{
    "numMessagesInTopic": 4, 
    "nextInTime": 6654, 
    "senderId": "bdyf8VtWCuysfvzVOgs_jhuvW3gpdO05ChyWR6ztRaMDa6YBThRcobRHHL_0_HkUlz3rizsqetX9KyNg0Mnc2waDnjcVyoQC_jA5Yd2W6ZAobefC6PI79YqrDENdTuqii1-MXSLVUNvd6gAZxhY", 
    "systemMessage": false, 
    "subject": "Re: Unit testing plugins", 
    "from": "&quot;J. B. Rainsberger &lt;jbr@...&gt;&quot; &lt;jbr@...&gt;", 
    "authorName": "J. B. Rainsberger &lt;jbr@diasparsoftware.c", 
    "msgSnippet": "Unit testing code that runs in a framework is not difficult, but it can be annoying. This really merits an article, but here are the bullet points. 1. Identify", 
    "msgId": 6653, 
    "rawEmail": "Return-Path: &lt;jbr@...&gt;\r\nX-Sender: jbr@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (EGP: mail-8_2_3_0); 14 Jan 2003 17:14:42 -0000\r\nReceived: (qmail 78589 invoked from network); 14 Jan 2003 17:14:42 -0000\r\nReceived: from unknown (66.218.66.218)\n  by m8.grp.scd.yahoo.com with QMQP; 14 Jan 2003 17:14:42 -0000\r\nReceived: from unknown (HELO n6.grp.scd.yahoo.com) (66.218.66.90)\n  by mta3.grp.scd.yahoo.com with SMTP; 14 Jan 2003 17:14:41 -0000\r\nReceived: from [66.218.67.144] by n6.grp.scd.yahoo.com with NNFMP; 14 Jan 2003 17:14:41 -0000\r\nDate: Tue, 14 Jan 2003 17:14:38 -0000\r\nTo: junit@yahoogroups.com\r\nSubject: Re: Unit testing plugins\r\nMessage-ID: &lt;b01ghu+rge9@...&gt;\r\nIn-Reply-To: &lt;b009v2+5hro@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Length: 3555\r\nX-Mailer: Yahoo Groups Message Poster\r\nFrom: &quot;J. B. Rainsberger &lt;jbr@...&gt;&quot; &lt;jbr@...&gt;\r\nX-Yahoo-Group-Post: member; u=89240252\r\nX-Yahoo-Profile: nails762\r\n\r\nUnit testing code that runs in a framework is not difficult, but it \ncan be annoying. This really merits an article, but here are the \nbullet points.\n\n1. Identify the extension points where you write your code.\n2. In the extension points, identify the objects that you or the \nframework use when executing your code.\n3. Change your code to accept those objects as parameters, either to \na constructor or its methods.\n4. Test the new code and either trust that the &quot;glue code&quot; will work \nor refactor the glue code so that it is written only once. (Then you \ncan test it once.)\n\nFor example, in Struts, you code an Action class by \noverriding &quot;execute()&quot;. Your code accesses your model and decides \nwhich page to return as a response. Action.execute() takes \nparameters to represent the Action list, an input form, the servlet \nrequest and the servlet response. Typically, you will grab data from \nthe input form, set attributes on the request and specify the page \nto forward to by name (a String).\n\nTherefore, I write a method like this:\n\nString doExecute(final MyModel model, final MyForm form, final Map \nattributes) throws Exception {\n    // grab form parameters from &#39;form&#39;\n    // talk to the model\n    // add attributes to &#39;attributes&#39;\n    // return the name of the page to forward to (the &quot;forward name&quot;)\n}\n\nI can easily create or mock MyModel and MyForm as well as the Map of \nattributes. I can easily check that the resulting forward name is \ncorrect. I unit test this method as much as possible. Then I write:\n\nActionForward execute(final ActionMapping actionMapping, final \nActionForm form, final HttpServletRequest request, final \nHttpServletResponse response) throws Exception {\n    final MyForm myForm = (MyForm) form;\n    final MyModel model = new MyModel();    // or retrieve from some \nfactory or creation method\n    final Map attributes = new HashMap();\n    \n    final String forwardName = doExecute(myForm, model, attributes);\n    setRequestAttributes(request, attributes);\n    return actionMapping.findForward(forwardName);\n}\n\nThe method setRequestAttributes simply iterates over the map entries \nand calls request.setAttribute for each one.\n\nNotice that the glue code is quite boilerplate in nature. I could \neven generate it or write it using funky reflection. This is a great \nway to remove duplication.\n\nIf I find that I need more stuff in my doExecute() method, like \nanother part of the request, I can create a narrow \ninterface &quot;RequestProperties&quot; and pass that in to &#39;doExecute&#39;. In \nthe test code, I fake out the RequestProperties; in the production \ncode, I wrap the Request in another object that implements \nRequestProperties. The goal is to improve substitutability of \nimplementation to maximize ease of testing.\n\nWhat do you think?\n\n--JBR.\n\n--- In junit@yahoogroups.com, &quot;kazugt_2000 &lt;pgeorge@a...&gt;&quot; \n&lt;pgeorge@a...&gt; wrote:\n&gt; Hi all,\n&gt; \n&gt; I am relatively new to Junit. I have successfully used it when \nunit \n&gt; testing standalone applications. Suffice to say I am hooked ;-).\n&gt; \n&gt; However now my situation is a bit different. There is an \napplication \n&gt; developed by a third party. I have to develop plugins for the \nsame. I \n&gt; want to be able to unit test my plugins, and develop a test suite. \n&gt; \n&gt; The problem is however I can&#39;t execute my plugin as a stand-alone \n&gt; app. The code only gets executed in the context of the app that \nuses \n&gt; it. Hence I cant create unit tests that I can execute with \nJunit .I \n&gt; would be most grateful if someone could provide me with \nsuggestions \n&gt; on how I could go about the same.\n\n\n\n", 
    "profile": "nails762", 
    "topicId": 6652, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 89240252, 
    "prevInTime": 6652, 
    "contentTrasformed": false, 
    "postDate": "1042564478", 
    "canDelete": false, 
    "nextInTopic": 6657, 
    "prevInTopic": 6652, 
    "headers": {
        "inReplyToHeader": "PGIwMDl2Mis1aHJvQGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PGIwMWdodStyZ2U5QGVHcm91cHMuY29tPg=="
    }
}