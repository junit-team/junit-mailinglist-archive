{
    "numMessagesInTopic": 8, 
    "nextInTime": 11235, 
    "senderId": "0j1Cc4gLd3l1ojFKGVyjiLY61vub7MYOiOdiT5uO7BpDOOQXFqIeZhvLJsbi3yPe7y0Rlzmi7a8myrNvFayEK1J2PKEe8ebMKg", 
    "systemMessage": false, 
    "subject": "Re: JUnit tests and common resources", 
    "from": "&quot;youlian&quot; &lt;julian@...&gt;", 
    "authorName": "youlian", 
    "msgSnippet": "... depends ... develop ... correctly. ... is ... invokes ... say, ... a ... subclass ... something ... do ... that ... connection. ... representing ... test", 
    "msgId": 11234, 
    "profile": "youlian", 
    "topicId": 11214, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 147836653, 
    "messageBody": "<div id=\"ygrps-yiv-100462604\">--- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>, &quot;J. B. Rainsberger&quot; &lt;jbrains@r...&gt; <br/>\nwrote:<br/>\n<blockquote><span title=\"ireply\"> &gt; youlian wrote:<br/>\n&gt; <br/>\n&gt; &gt; Hi,<br/>\n&gt; &gt; <br/>\n&gt; &gt; I hope this has a simple answer...<br/>\n&gt; &gt; <br/>\n&gt; &gt; My issue is when I write test cases that exercise code that <br/>\n </span></blockquote>depends<br/>\n<blockquote><span title=\"ireply\"> &gt; &gt; on a common resource. There is couple of things, but the simplest<br/>\n&gt; &gt; case is a serial port.<br/>\n&gt; &gt; <br/>\n&gt; &gt; Lets say that I have a class that implements a protocol with a<br/>\n&gt; &gt; hardware device over serial port connection. I would like to <br/>\n </span></blockquote>develop<br/>\n<blockquote><span title=\"ireply\"> &gt; &gt; a test to verify that the class implements the protocol <br/>\n </span></blockquote>correctly.<br/>\n<blockquote><span title=\"ireply\"> &gt; &gt; This means, that I will have to have the device connected and<br/>\n&gt; &gt; operational when running the test, and that is o.k.<br/>\n&gt; &gt; <br/>\n&gt; &gt; I could mock the serial connection - I understand this, but this <br/>\n </span></blockquote>is<br/>\n<blockquote><span title=\"ireply\"> &gt; &gt; not my intention. I see little value in this for many reasons. I<br/>\n&gt; &gt; want to test the real thing.<br/>\n&gt; &gt; <br/>\n&gt; &gt; So, I write a simple test suite and test case. The test case <br/>\n </span></blockquote>invokes<br/>\n<blockquote><span title=\"ireply\"> &gt; &gt; different methods - lets say total of three. To simplify, lets <br/>\n </span></blockquote>say,<br/>\n<blockquote><span title=\"ireply\"> &gt; &gt; that those methods each send different command to the device. In<br/>\n&gt; &gt; order to do that each test method will open the comm port, write <br/>\n </span></blockquote>a<br/>\n<blockquote><span title=\"ireply\"> &gt; &gt; string and close it.<br/>\n&gt; &gt; <br/>\n&gt; &gt; Sounds simple enough. However, when using JUnit, all these tests<br/>\n&gt; &gt; execute in parallel and since the resource is shared, all but one<br/>\n&gt; &gt; fail with SerialPortInUseException.<br/>\n&gt; &gt; <br/>\n&gt; <br/>\n&gt; <br/>\n&gt; &gt; I have read the JUnit Cookbook and undesrstand the reason - JUnit<br/>\n&gt; &gt; via reflection generates dynamically child classes. <br/>\n&gt; <br/>\n&gt; Not quite. Instead, it instantiates the test case class, invokes <br/>\n&gt; setUp(), a test method, then tearDown(). There is no need to <br/>\n </span></blockquote>subclass <br/>\n<blockquote><span title=\"ireply\"> &gt; anonymously since JUnit 2.0 first appeared.<br/>\n&gt; <br/>\n&gt;  &gt; For each test<br/>\n&gt; &gt; method setUp and tearDown is invoked. The log would look <br/>\n </span></blockquote>something<br/>\n<blockquote><span title=\"ireply\"> &gt; &gt; like this:<br/>\n&gt; &gt; <br/>\n&gt; &gt; setUp()<br/>\n&gt; &gt; setUp()<br/>\n&gt; &gt; setUp()<br/>\n&gt; &gt; ...<br/>\n&gt; &gt; test1()<br/>\n&gt; &gt; test2()<br/>\n&gt; &gt; testx()<br/>\n&gt; &gt; ...<br/>\n&gt; &gt; tearDown()<br/>\n&gt; &gt; tearDown()<br/>\n&gt; &gt; tearDown()<br/>\n&gt; <br/>\n&gt; No.<br/>\n&gt; <br/>\n&gt; setUp(), test1(), tearDown();<br/>\n&gt; setUp(), test2(), tearDown();<br/>\n&gt; ...<br/>\n&gt; <br/>\n&gt; &gt; If I use setUp() or even testX() to open the connection, I always<br/>\n&gt; &gt; end up in conflict.<br/>\n&gt; <br/>\n&gt; You want to open the connection /once/. The easiest thing you can <br/>\n </span></blockquote>do <br/>\n<blockquote><span title=\"ireply\"> &gt; (for now) is create a Singleton that contains a global connection <br/>\n </span></blockquote>that <br/>\n<blockquote><span title=\"ireply\"> &gt; only allows itself to be opened once. Let your tests use that <br/>\n </span></blockquote>connection.<br/>\n<blockquote><span title=\"ireply\"> &gt; <br/>\n&gt; Ultimately, what you&#39;d /like/ to do is Extract an Interface <br/>\n </span></blockquote>representing <br/>\n<blockquote><span title=\"ireply\"> &gt; the API for your resource, then use a mock objects approach to <br/>\n </span></blockquote>test how <br/>\n<blockquote><span title=\"ireply\"> &gt; well your code interacts with that API. The majority of your tests <br/>\n </span></blockquote>will <br/>\n<blockquote><span title=\"ireply\"> &gt; be like this. Eventually, you will have a small number of tests <br/>\n </span></blockquote>that <br/>\n<blockquote><span title=\"ireply\"> &gt; actually verify that the /production/ implementation of your new <br/>\n&gt; interface uses the serial port API correctly. This does not make <br/>\n </span></blockquote>your <br/>\n<blockquote><span title=\"ireply\"> &gt; problem go away, but it lessens the problem&#39;s impact, isolating it <br/>\n </span></blockquote>to a <br/>\n<blockquote><span title=\"ireply\"> &gt; single class (a well-known part of the code). This is the point of <br/>\n </span></blockquote>OOP.<br/>\n<blockquote><span title=\"ireply\"> &gt; <br/>\n&gt; &gt; My questions are:<br/>\n&gt; &gt; Is there a way to explicitly control the order of execution of <br/>\n </span></blockquote>test<br/>\n<blockquote><span title=\"ireply\"> &gt; &gt; methods within a test case, so to control the access to commonly<br/>\n&gt; &gt; used resources and account for their state? (system ports, JDBC<br/>\n&gt; &gt; connections, etc.)<br/>\n&gt; &gt; <br/>\n&gt; &gt; Is JUnit the tool for such a job?<br/>\n&gt; <br/>\n&gt; No, it isn&#39;t. Still, whenenver I want to do something in my design <br/>\n </span></blockquote>that <br/>\n<blockquote><span title=\"ireply\"> &gt; JUnit makes difficult, it is /usually/ a sign that my design needs <br/>\n&gt; improvement.<br/>\n&gt; -- <br/>\n&gt; J. B. Rainsberger,<br/>\n&gt; Diaspar Software Services<br/>\n&gt; <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.diasparsoftware.com\">http://www.diasparsoftware.com</a> :: +1 416 791-8603<br/>\n&gt; Let&#39;s write software that people understand<br/>\n<br/>\n </span></blockquote>I will try to answer couple of replies in a single message:<br/>\n<br/>\n1. I do have an interface defined and more. It is the low-level host <br/>\nprotocol I need to test. The difficulty is that the device on the <br/>\nother end is often experimental and I cannot rely on perfect <br/>\noperation and documentation. I could try to take the high road and <br/>\nexpect perfection from the manufacturer, but that is not how things <br/>\nwork in my world :). What I am writing is a set of software drivers <br/>\ncontrolling devices from different manufacturers. I am trying to <br/>\nprovide consistent interface to a class of hardware modules, all <br/>\nwith a twist and all of them with vastly different protocols. <br/>\nMocking the hardware will not help me much. It will be a waste of <br/>\ntime trying to duplicate (and some times guess) all aspects of the <br/>\nbehavior, when I can simply plug it in. In effect I am testing more <br/>\nthe host protocol and the device then the business logic on my end. <br/>\nAgain, I am developing a driver, not the business logic that will <br/>\nuse that driver.<br/>\n<br/>\n2. Yes, after some thinking I have decided that I really need to <br/>\nopen the connection only once. I did that by following the example <br/>\nof custom initialization for my suite taken directly from the JUnit <br/>\nCookbook. It worked fine. The setUp and tearDown methods of the <br/>\nsuite are invoked only once. Then the setUp and tearDown methods for <br/>\nthe tests are called. Since the instance of my driver is in effect <br/>\ndefined in the suite, it is being initialized only once. I am free <br/>\nto use the tests to define the detailed operations, etc. Test suites <br/>\ncan be nested and that works fine for me in this case.<br/>\n<br/>\n3. It crossed my mind to put everything into one test method and <br/>\ncall the individual test methods from there, but I do not like this <br/>\napproach. It invalidates in my opinion many of the benefits of <br/>\nJUnit. <br/>\n<br/>\n4. I also had the idea of creating a Singleton, or simply a static <br/>\nreference to the driver within the test case. However, that would <br/>\nrequire creating yet another class just for that purpose. It can be <br/>\ndone of course, but feels a bit awkward. #2 proved to be much more <br/>\nelegant solution. No static fields, no extra classes. <br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; No, it isn&#39;t. Still, whenever I want to do something in my design <br/>\n </span></blockquote>that <br/>\n<blockquote><span title=\"ireply\"> &gt; JUnit makes difficult, it is /usually/ a sign that my design needs <br/>\n&gt; Improvement.<br/>\n<br/>\n </span></blockquote>5. I do not agree entirely with the above. My concern was related to <br/>\nthe fact that I see no way to control the flow in JUnit and it has <br/>\nvery little to do with the design of the system being tested Â– good <br/>\nor bad. As far as I understand test framework should perform well <br/>\neven if the code it works with is bad (I hope this is not the case <br/>\nwith mine J). I still consider this ability (flow control) <br/>\ncompletely missing in JUnit.  I think it would be very useful if I <br/>\ncould have explicit control over what tests execute when and even <br/>\nbranch the logic based on a condition. Perhaps jump from one test to <br/>\nanother, etc. On the other hand I do not like the underlying <br/>\nsuggestion that one should be dependent on the specific capabilities <br/>\nof any one testing framework. In a way, to design for JUnit. Test <br/>\ntools come and go and the merits of the design should be judged not <br/>\nby how easy is to use with JUnit, but how it performs.<br/>\n<br/>\nThe bottom line is that I found a solution that works. Thanks for <br/>\nall the good suggestions.</div>", 
    "prevInTime": 11233, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1087716281", 
    "canDelete": false, 
    "nextInTopic": 11240, 
    "prevInTopic": 11232, 
    "headers": {
        "inReplyToHeader": "PDQwRDRBMzFFLjIwMTA2MDhAcm9nZXJzLmNvbT4=", 
        "messageIdInHeader": "PGNiM2UzcCtqdmN1QGVHcm91cHMuY29tPg=="
    }
}