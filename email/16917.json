{
    "numMessagesInTopic": 9, 
    "nextInTime": 16918, 
    "senderId": "HRCPgPqcQk5eswJfAoXDd1AsDYs9jLIbPS4QET9oZwleTa73E5nTCn2fKS0RXr7cYcnHavFWhdL-dt_tdRorQe7ZHCvSZVHKAr03Iu7z", 
    "systemMessage": false, 
    "subject": "Re: Deep Equals of two JavaBeans", 
    "from": "&quot;wheelerpoker&quot; &lt;wheelerpoker@...&gt;", 
    "authorName": "wheelerpoker", 
    "msgSnippet": "Thanks Joe. I think it s wise to implement the equals method properly if that s what you re saying, but I am interested in externalizing a deep comparison to", 
    "msgId": 16917, 
    "profile": "wheelerpoker", 
    "topicId": 16890, 
    "spamInfo": {
        "reason": "6", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 229401621, 
    "messageBody": "<div id=\"ygrps-yiv-631722503\">Thanks Joe. I think it&#39;s wise to implement the equals method properly<br/>\nif that&#39;s what you&#39;re saying, but I am interested in externalizing a<br/>\ndeep comparison to relieve myself of having to do property-by-property<br/>\ncomparisons in unit tests--so far, mainly DbUnit tests. I&#39;m happy with<br/>\nwhat I&#39;ve got for the most part, I&#39;m just not completely satisfied<br/>\nwith the error messages it generates on failure.<br/>\n<br/>\n&lt;code&gt;<br/>\nimport java.util.Collection;<br/>\nimport java.util.Date;<br/>\nimport java.util.HashSet;<br/>\nimport java.util.Iterator;<br/>\nimport java.util.Map;<br/>\nimport java.util.Set;<br/>\nimport java.util.SortedSet;<br/>\n<br/>\nimport junit.framework.Assert;<br/>\n<br/>\nimport org.apache.commons.beanutils.PropertyUtils;<br/>\nimport org.apache.commons.collections.CollectionUtils;<br/>\nimport org.apache.commons.collections.Predicate;<br/>\nimport org.apache.commons.logging.Log;<br/>\nimport org.apache.commons.logging.LogFactory;<br/>\n<br/>\n/**<br/>\n * Utility class for performing a deep comparison of two POJOs&#39;<br/>\nproperties. <br/>\n * &lt;p&gt;<br/>\n * Properties can fall into one of three categories:<br/>\n * &lt;p&gt;<br/>\n * <br/>\n * &lt;b&gt;1. Value Types&lt;/b&gt; The following value types and the primitives<br/>\nthey wrap<br/>\n * (where applicable) are compared by value.<br/>\n * &lt;ul&gt; <br/>\n *  &lt;li&gt;&lt;code&gt;java.lang.Boolean&lt;/code&gt;&lt;/li&gt;<br/>\n *  &lt;li&gt;&lt;code&gt;java.lang.Character&lt;/code&gt;&lt;/li&gt;<br/>\n *  &lt;li&gt;&lt;code&gt;java.lang.CharSequence&lt;/code&gt;&lt;/li&gt;<br/>\n *  &lt;li&gt;&lt;code&gt;java.lang.Number&lt;/code&gt;&lt;/li&gt;<br/>\n *  &lt;li&gt;&lt;code&gt;java.util.Date&lt;/code&gt;&lt;/li&gt;<br/>\n * &lt;/ul&gt;<br/>\n * This means other value types you use outside this list (e.g. types <br/>\n * that represent money) are treated like POJO&#39;s--they are deep compared<br/>\n * property-for-property. If you do not want that, you should use<br/>\n * &lt;code&gt;assertDeepEquals(Object, Object, Class[])&lt;/code&gt;, and pass in a <br/>\n * &lt;code&gt;Class&lt;/code&gt; array of classes you want compared by value. <br/>\n * &lt;p&gt;<br/>\n * <br/>\n * &lt;b&gt;2. POJOs&lt;/b&gt; POJOs are deep compared property-for-property.<br/>\n * &lt;p&gt;<br/>\n * <br/>\n * &lt;b&gt;3. Collections&lt;/b&gt; Collections are deep-compared<br/>\nelement-for-element. Any <br/>\n * properties they define are completely disregarded.<br/>\n * &lt;p&gt;<br/>\n * The methods of this class are safe to use with object graphs<br/>\ncontaining <br/>\n * cylic references.<br/>\n * &lt;p&gt;<br/>\n * &lt;b&gt;Note that this class is not thread-safe.&lt;/b&gt;<br/>\n */<br/>\npublic final class POJOAssert {<br/>\n<br/>\n    private static final Log logger = LogFactory.getLog(POJOAssert.class);<br/>\n    /** for detecting cycles and preventing an infinite recursive loop */<br/>\n    private static final Set lookedAt = new HashSet();<br/>\n    private static final Class[] defaultValueTypes;<br/>\n    private static Class[] userSpecifiedValueTypes = new Class[0];<br/>\n    <br/>\n    static {<br/>\n        defaultValueTypes = new Class[] {                <br/>\n            Date.class,<br/>\n            Number.class,<br/>\n            Character.class,<br/>\n            CharSequence.class,<br/>\n            Boolean.class<br/>\n        };<br/>\n    }<br/>\n    <br/>\n    private POJOAssert() {<br/>\n        throw new UnsupportedOperationException(&quot;do not use&quot;);<br/>\n    }<br/>\n        <br/>\n    public static void assertDeepEquals(Object expected, Object actual) {<br/>\n        doAssertDeepEquals(&quot;&quot;, expected, actual);<br/>\n        lookedAt.clear();<br/>\n    }<br/>\n    <br/>\n    public static void assertDeepEquals(Object expected, Object actual, <br/>\n            Class[] userSpecifiedValueTypes) {<br/>\n        if (userSpecifiedValueTypes == null)<br/>\n            throw new NullPointerException(&quot;null userSpecfiedValueTypes&quot;);<br/>\n        <br/>\n        POJOAssert.userSpecifiedValueTypes = userSpecifiedValueTypes;<br/>\n        <br/>\n        assertDeepEquals(expected, actual);<br/>\n        POJOAssert.userSpecifiedValueTypes = new Class[0];        <br/>\n    }<br/>\n    <br/>\n    private static void doAssertDeepEquals(String fieldName, Object<br/>\nexpected, Object actual) {<br/>\n        if (lookedAt(expected)) {<br/>\n            logger.debug(&quot;cycle detected on &quot; + expected);<br/>\n            return;<br/>\n        }<br/>\n        <br/>\n        if (expected == null) {<br/>\n            Assert.assertNull(&quot;expected &quot; + fieldName + &quot; null, actual<br/>\nnot null&quot;, actual);<br/>\n        } else {<br/>\n            Assert.assertNotNull(&quot;expected &quot; + fieldName + &quot; not null,<br/>\nactual null&quot;, actual);<br/>\n            <br/>\n            if (isValueProperty(expected)) {            <br/>\n                evaluateValueTypes(fieldName, expected, actual);<br/>\n            } else { <br/>\n                lookedAt.add(expected);<br/>\n                <br/>\n                if (isArrayProperty(expected)) {                <br/>\n                    evaluateArrays(fieldName, (Object[])expected,<br/>\n(Object[])actual);                    <br/>\n                } else if (isCollectionProperty(expected)) {            <br/>\n                    evaluateCollections(fieldName,<br/>\n(Collection)expected, (Collection)actual);            <br/>\n                } else if (isMapProperty(expected)) {            <br/>\n                    evaluateMaps(fieldName, (Map)expected,<br/>\n(Map)actual);            <br/>\n                } else {<br/>\n                    evaluateComplexTypes(fieldName, expected, actual);<br/>\n           <br/>\n                }                <br/>\n            }            <br/>\n        }        <br/>\n    }<br/>\n    <br/>\n    // ------------- Methods that check a property&#39;s type -------------<br/>\n    <br/>\n    private static boolean isValueProperty(Object o) {<br/>\n        for (int i = 0; i &lt; defaultValueTypes.length; i++) {<br/>\n            if (defaultValueTypes[i].isInstance(o))<br/>\n                return true;<br/>\n        }<br/>\n        <br/>\n        for (int i = 0; i &lt; userSpecifiedValueTypes.length; i++) {<br/>\n            if (userSpecifiedValueTypes[i].isInstance(o))<br/>\n                return true;<br/>\n        }        <br/>\n        <br/>\n        return false;<br/>\n    }<br/>\n        <br/>\n    private static boolean isArrayProperty(Object o) {<br/>\n        return o.getClass().isArray();<br/>\n    }<br/>\n    <br/>\n    private static boolean isCollectionProperty(Object o) {<br/>\n        return (o instanceof Collection);<br/>\n    }<br/>\n    <br/>\n    private static boolean isMapProperty(Object o) {<br/>\n        return (o instanceof Map);<br/>\n    }    <br/>\n    <br/>\n    // ------------- Methods that evaluate two properties (depending<br/>\non type) -------------    <br/>\n        <br/>\n    private static void evaluateValueTypes(String fieldName, Object<br/>\nexpected, Object actual) {<br/>\n        logger.debug(fieldName + &quot; [expected = &quot; + expected + &quot;,<br/>\nactual = &quot; + actual + &quot;]&quot;);<br/>\n        Assert.assertEquals(fieldName + &quot; not equal&quot;, expected,<br/>\nactual);        <br/>\n    }<br/>\n        <br/>\n    private static void evaluateArrays(String fieldName, Object[]<br/>\nexpected, Object[] actual) {        <br/>\n        if (expected.length != actual.length) {<br/>\n            Assert.fail(fieldName + &quot; lengths don&#39;t match&quot;);<br/>\n        }<br/>\n        <br/>\n        for (int i=0; i&lt;expected.length; i++) {<br/>\n            doAssertDeepEquals(fieldName + &quot; [&quot; + i + &quot;]&quot;,<br/>\nexpected[i], actual[i]);<br/>\n        }<br/>\n    }<br/>\n    <br/>\n    private static void evaluateCollections(String fieldName,<br/>\nCollection expected, Collection actual) {<br/>\n        if ((!(expected instanceof SortedSet)) && expected instanceof<br/>\nSet) {<br/>\n            evaluateSets(fieldName, (Set)expected, (Set)actual);<br/>\n        } else {<br/>\n            evaluateArrays(fieldName, expected.toArray(),<br/>\nactual.toArray());<br/>\n        }<br/>\n    }    <br/>\n    <br/>\n    private static void evaluateSets(String fieldName, Set expected,<br/>\nSet actual) {<br/>\n        if (expected.size() != actual.size()) {<br/>\n            Assert.fail(fieldName + &quot; lengths don&#39;t match&quot;);<br/>\n        }<br/>\n        <br/>\n        int idx = 0;<br/>\n        for (Iterator i = expected.iterator(); i.hasNext();) {<br/>\n            Object expectedElem = i.next();<br/>\n            Object actualElem = CollectionUtils.find(actual, new<br/>\nEqualPredicate(expectedElem));<br/>\n            if (actualElem == null) {<br/>\n                Assert.fail(fieldName + &quot; not equal&quot;);<br/>\n            }<br/>\n            doAssertDeepEquals(fieldName + &quot; [&quot; + (idx++) + &quot;]&quot;,<br/>\nexpectedElem, actualElem);<br/>\n        }        <br/>\n    }<br/>\n    <br/>\n    private static void evaluateMaps(String fieldName, Map expected,<br/>\nMap actual) {<br/>\n        Set keys = expected.keySet();<br/>\n        evaluateSets(fieldName, keys, actual.keySet());<br/>\n        <br/>\n        for (Iterator i=keys.iterator(); i.hasNext();) {<br/>\n            Object key = i.next();<br/>\n            doAssertDeepEquals(key.toString(), expected.get(key),<br/>\nactual.get(key));<br/>\n        }<br/>\n    }<br/>\n    <br/>\n    private static void evaluateComplexTypes(String fieldName, Object<br/>\nexpected, Object actual) {<br/>\n        Map expectedProps = null, actualProps = null;<br/>\n        try {<br/>\n            expectedProps = PropertyUtils.describe(expected);<br/>\n            actualProps = PropertyUtils.describe(actual);<br/>\n            // prevent infinite loop on Class.getClass(). don&#39;t have<br/>\nto worry about &#39;class&#39;<br/>\n            // properties on POJO&#39;s being skipped because<br/>\nObject.getClass() can&#39;t be overriden.<br/>\n            expectedProps.remove(&quot;class&quot;);<br/>\n            actualProps.remove(&quot;class&quot;);<br/>\n        } catch (Exception ex) {<br/>\n            logger.error(ex);<br/>\n            throw new RuntimeException(ex);<br/>\n        }<br/>\n        <br/>\n        evaluateMaps(fieldName, expectedProps, actualProps);        <br/>\n    }            <br/>\n    <br/>\n    private static boolean lookedAt(Object o) {<br/>\n        Object elem = CollectionUtils.find(lookedAt, new<br/>\nIdentityPredicate(o));<br/>\n        return elem != null;<br/>\n    }<br/>\n    <br/>\n    // ------------- Static inner classes -------------<br/>\n    <br/>\n    private static final class EqualPredicate implements Predicate {<br/>\n        private Object object;<br/>\n        <br/>\n        public EqualPredicate(Object o) {<br/>\n            object = o;<br/>\n        }<br/>\n        <br/>\n        public boolean evaluate(Object fromList) {<br/>\n            return object.equals(fromList);<br/>\n        }        <br/>\n    }<br/>\n    <br/>\n    private static final class IdentityPredicate implements Predicate {<br/>\n        private Object object;<br/>\n        <br/>\n        public IdentityPredicate(Object o) {<br/>\n            object = o;<br/>\n        }<br/>\n        <br/>\n        public boolean evaluate(Object fromList) {<br/>\n            return object == fromList;<br/>\n        }<br/>\n    }    <br/>\n}<br/>\n&lt;/code&gt;</div>", 
    "prevInTime": 16916, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1150224626", 
    "canDelete": false, 
    "nextInTopic": 16940, 
    "prevInTopic": 16908, 
    "headers": {
        "inReplyToHeader": "PDQ0OERDQTQxLjMwODAyMDFAcm9nZXJzLmNvbT4=", 
        "messageIdInHeader": "PGU2bjFkaSs4YTkzQGVHcm91cHMuY29tPg=="
    }
}