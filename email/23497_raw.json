{
    "numMessagesInTopic": 24, 
    "nextInTime": 23498, 
    "senderId": "w4fyukO6io5NqtJfGwS2uwloBrNE-pHmoFLwY11X5h_DlfnGi8RzGeBZZALy-y7iQ7Gup52_9KiEwsyBImd-z6Kk3e19", 
    "systemMessage": false, 
    "subject": "Re: [junit] Not knowing the tests in advance when providing a test runner", 
    "from": "Bill Venners &lt;bill@...&gt;", 
    "authorName": "Bill Venners", 
    "msgSnippet": "Hi Charlie, Thanks for explaining the theory behind theories. I think my own theory that this concept is like a property in Scala-land still holds, though. Let", 
    "msgId": 23497, 
    "rawEmail": "Return-Path: &lt;bill@...&gt;\r\nX-Sender: bill@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nX-Received: (qmail 85827 invoked from network); 29 Jun 2011 01:18:13 -0000\r\nX-Received: from unknown (66.196.94.105)\n  by m14.grp.re1.yahoo.com with QMQP; 29 Jun 2011 01:18:13 -0000\r\nX-Received: from unknown (HELO mail-gx0-f173.google.com) (209.85.161.173)\n  by mta1.grp.re1.yahoo.com with SMTP; 29 Jun 2011 01:18:12 -0000\r\nX-Received: by gxk26 with SMTP id 26so423128gxk.18\n        for &lt;junit@yahoogroups.com&gt;; Tue, 28 Jun 2011 18:18:12 -0700 (PDT)\r\nMIME-Version: 1.0\r\nX-Received: by 10.101.178.21 with SMTP id f21mr156604anp.32.1309310292349; Tue,\n 28 Jun 2011 18:18:12 -0700 (PDT)\r\nX-Received: by 10.100.132.10 with HTTP; Tue, 28 Jun 2011 18:18:12 -0700 (PDT)\r\nIn-Reply-To: &lt;BANLkTiku3zL7Gfp6jeQHBFvonFJn9tPg_A@...&gt;\r\nReferences: &lt;itfi5a+u52c@...&gt;\n\t&lt;4E0214D4.2040504@...&gt;\n\t&lt;BANLkTimabmOKRvC6jPN7DbPS27fKzeVJTg@...&gt;\n\t&lt;4E02F44A.6020508@...&gt;\n\t&lt;BANLkTimDSabTfcFwzgKo5a4VzxfvYkX-hA@...&gt;\n\t&lt;BANLkTi=2mL3EVtKhvndRFPh2tiK7tL7OiQ@...&gt;\n\t&lt;BANLkTi=vvHu_ZJ0DMpaevVo_KWmeSO-Wfg@...&gt;\n\t&lt;BANLkTikj0Eqx8PfeNk=OxdR8nJ3N_wnw1w@...&gt;\n\t&lt;BANLkTi=QH8mrrnKJ03BXQS2hFk0dSnDsWw@...&gt;\n\t&lt;BANLkTimtS4dBjA0r-ySC_Zp-gDR-aWVt1g@...&gt;\n\t&lt;BANLkTiku3zL7Gfp6jeQHBFvonFJn9tPg_A@...&gt;\r\nDate: Tue, 28 Jun 2011 18:18:12 -0700\r\nMessage-ID: &lt;BANLkTikHKZwdadP51A+CwAGB46BApp1JuQ@...&gt;\r\nTo: junit@yahoogroups.com\r\nFrom: Bill Venners &lt;bill@...&gt;\r\nSubject: Re: [junit] Not knowing the tests in advance when providing a test runner\r\nX-Yahoo-Group-Post: member; u=416990097; y=cgMSHSndou0EBETBy_A1Cmx6d1VZ3Vf7ttSmDhExQk1r_UGHL8Q\r\nX-Yahoo-Profile: billvenners\r\nContent-Type: text/plain; charset=UTF-8\r\nContent-Transfer-Encoding: quoted-printable\r\n\r\nHi Charlie,\n\nThanks for explaining the theory behind theories. I think my o=\r\nwn theory that\nthis concept is like a property in Scala-land still holds, t=\r\nhough. Let me\nrun this past you and see if you agree.\n\nBasically a &quot;propert=\r\ny&quot; is a statement about something that should be true\nfor all values meetin=\r\ng a certain criteria. The way that is expressed is as a\nfunction. The input=\r\ns to the function provide one set of values (I.e., to\ncheck 100 data points=\r\n, you&#39;d call the function 100 times, passing in a\ndifferent data point each=\r\n time.) If the function returns normally, the\nproperty evaluation &quot;passes&quot;.=\r\n If it throws an exception, it &quot;fails.&quot; So\ngiven a Fraction class, you coul=\r\nd have a property like:\n\n(n: Int, d: Int) =3D&gt; { // n and d are inputs to t=\r\nhe &quot;property&quot; function\n\n  whenever (d !=3D 0 && d !=3D Integer.MIN_VALUE\n  =\r\n    && n !=3D Integer.MIN_VALUE) {\n\n    val f =3D new Fraction(n, d)\n\n    i=\r\nf (n &lt; 0 && d &lt; 0 || n &gt; 0 && d &gt; 0)\n      f.numer should be &gt; 0\n    else i=\r\nf (n !=3D 0)\n      f.numer should be &lt; 0\n    else\n      f.numer should be =\r\n=3D=3D=3D 0\n\n    f.denom should be &gt; 0\n  }\n}\n\nSo whenever the n and d input=\r\ns are valid numerators and denominators for the\nFraction constructor, the a=\r\nssertions made here (like f.denom should be &gt; 0)\nshould hold. That sounds e=\r\nxactly what you mean by theory, is that correct?\nAnd if so, that&#39;s called a=\r\n property in Scala-land, probably because it was\ncalled a property in Quick=\r\nCheck in Haskell, which inspired ScalaCheck in\nScala. The idea is you&#39;re de=\r\nfining a &quot;property of the Fraction class&quot; that\nyou&#39;re testing.\n\nSo then the=\r\n question becomes how do you check it. One way is to use the\ntables approac=\r\nh that I showed earlier. You define some tables with data\npoints in them, a=\r\nnd give both the table and the property to forAll:\n\nforAll (examples) { (n:=\r\n Int, d: Int) =3D&gt; ...\n\nThis says that for all the example numerator/denomi=\r\nnator pairs given in the\ntable, the property should hold.\n\nBut you also jus=\r\nt say this:\n\nforAll { (n: Int, d: Int) =3D&gt; ...\n\nThat says for all integers=\r\n, n and d, the property should hold. In that case\nyou&#39;ll be using ScalaChec=\r\nk generators to get the data. So instead of you\nproviding a table of datapo=\r\nints, the generators will provide them for you,\nand ScalaCheck provides gen=\r\nerators for common data points such as integers.\nYou can create your own ge=\r\nnerators for your own data types, or to make\ngenerators for numerators and =\r\ndenominators that only generate valid values.\n\nSo I think the difference ma=\r\ny be more that theories are methods in J/NUnit\nand properties are functions=\r\n in ScalaTest and ScalaCheck. There may be\nanother difference in how theori=\r\nes are mapped to tests in results. Does one\n&quot;theory check&quot; of 100 data poin=\r\nts show up as one test that succeeds or\nfails, or as 100 tests that succeed=\r\ned or failed?\n\nTo see both table- and generator-driven property checks, loo=\r\nk at the\nexamples on this page:\n\nhttp://www.scalatest.org/scaladoc-1.6.1/#o=\r\nrg.scalatest.prop.PropertyChecks\n\nBill\n\nOn Tue, Jun 28, 2011 at 5:44 PM, Ch=\r\narlie Poole &lt;charliepoole@...&gt;wrote:\n\n&gt; **\n&gt;\n&gt;\n&gt; Hi Bill,\n&gt;\n&gt; The con=\r\ncept of a Theory is quite different from a normal (example) test\n&gt; and even=\r\n from a set of examples. That said the implementation, in J/NUnit\n&gt; lags th=\r\ne concept a bit and J/N-users don&#39;t generally seem to grok it (yet).\n&gt;\n&gt; Th=\r\ne general idea is that a Theory makes a statement that is true for all\n&gt; va=\r\nlues meeting a set of criteria. It invites the framework to supply any\n&gt; va=\r\nlues that meet those criteria - without any special intervention on the\n&gt; p=\r\nart of the user. The individual test cases are not relevant except in the\n&gt;=\r\n case of a failure, since the user should be viewing the Theory as a single=\r\n\n&gt; test. Of course, the syntactic similarity to data-driven tests tends to\n=\r\n&gt; hide\n&gt; the fact that this is a completely different way of looking at a t=\r\nest.\n&gt;\n&gt; IME, Theories work best when I start out with a theory in mind. St=\r\nandard\n&gt; tests work best when I only have a collection of examples.\n&gt;\n&gt; The=\r\n J/NUnit implementation, where the &#39;givens&#39; are provided within the\n&gt; tests=\r\n themselves through Assume.That, is not necessarily the only way\n&gt; to do it=\r\n. We could construct some sort of DSL that instructed the framework\n&gt; about=\r\n what our assumptions are and allowed the data to be generated. In\n&gt; .NET t=\r\nhat&#39;s quite difficult because of the limitations of attribute syntax\n&gt; and\n=\r\n&gt; I suspect it&#39;s also true for Java.\n&gt;\n&gt; Charlie\n&gt;\n&gt; On Tue, Jun 28, 2011 a=\r\nt 4:08 PM, Bill Venners &lt;bill@...&gt; wrote:\n&gt;\n&gt; &gt; **\n&gt;\n&gt; &gt;\n&gt; &gt;\n&gt; &gt; Hi =\r\nAll,\n&gt; &gt;\n&gt; &gt; This is all very interesting. One difference I see from ScalaT=\r\nest is\n&gt; &gt; that a &quot;theory&quot; is not treated as a special kind of test. J/NUni=\r\nt\n&gt; &gt; &quot;theories&quot; map to ScalaTest &quot;properties.&quot; J/NUnit &quot;assumptions&quot; (when=\r\n\n&gt; &gt; used with theories) map to ScalaTest &quot;conditions.&quot; And J/NUnit &quot;data\n&gt;=\r\n &gt; points&quot; map to a ScalaTest &quot;table.&quot;\n&gt; &gt;\n&gt; &gt; So for this example from the=\r\n JUNit 4.4 release notes:\n&gt; &gt;\n&gt; &gt; @RunWith(Theories.class)\n&gt; &gt; public class=\r\n UserTest {\n&gt; &gt; @DataPoint public static String GOOD_USERNAME =3D &quot;optimus&quot;=\r\n;\n&gt; &gt; @DataPoint public static String USERNAME_WITH_SLASH =3D &quot;optimus/prim=\r\ne&quot;;\n&gt; &gt;\n&gt; &gt; @Theory public void filenameIncludesUsername(String username) {=\r\n\n&gt; &gt; assumeThat(username, not(containsString(&quot;/&quot;)));\n&gt; &gt; assertThat(new Use=\r\nr(username).configFileName(),\n&gt; containsString(username));\n&gt; &gt; }\n&gt; &gt; }\n&gt; &gt;\n=\r\n&gt; &gt; You might do this in ScalaTest:\n&gt; &gt;\n&gt; &gt; public class UserSuite extends =\r\nFunSuite {\n&gt; &gt;\n&gt; &gt; test(&quot;filename includes username&quot;) {\n&gt; &gt;\n&gt; &gt; val example=\r\ns =3D\n&gt; &gt; Table(\n&gt; &gt; &quot;username&quot;,\n&gt; &gt; &quot;optimus&quot;,\n&gt; &gt; &quot;optimus/prime&quot;\n&gt; &gt; )\n&gt;=\r\n &gt;\n&gt; &gt; forAll (examples) { username =3D&gt;\n&gt; &gt; whenever(!username.contains(&quot;/=\r\n&quot;)) {\n&gt; &gt; (new User(username).configFileName) should include (username)\n&gt; &gt;=\r\n }\n&gt; &gt; }\n&gt; &gt; }\n&gt; &gt; }\n&gt; &gt;\n&gt; &gt; A false &quot;whenever&quot; expression is a failed &quot;con=\r\ndition,&quot; that causes a\n&gt; &gt; &quot;property evaluation&quot; to be &quot;discarded.&quot; But the=\r\n test encompasses all\n&gt; &gt; property evaluations. Here there&#39;s just two prope=\r\nrty evaluations, one\n&gt; &gt; of which gets discarded, but usually there would b=\r\ne a table of many\n&gt; &gt; example usernames, otherwise it isn&#39;t worth using a t=\r\nable.\n&gt; &gt;\n&gt; &gt; So what&#39;s missing from ScalaTest at this point is some way to=\r\n do\n&gt; &gt; something like this, also taken from the JUnit 4.4 release notes:\n&gt;=\r\n &gt;\n&gt; &gt; @Test public void filenameIncludesUsername() {\n&gt; &gt; assumeThat(File.s=\r\neparatorChar, is(&#39;/&#39;));\n&gt; &gt; assertThat(new User(&quot;optimus&quot;).configFileName()=\r\n,\n&gt; &gt; is(&quot;configfiles/optimus.cfg&quot;));\n&gt; &gt; }\n&gt; &gt;\n&gt; &gt; That&#39;s actually a use o=\r\nf an assumption disconnected with a theory, and\n&gt; &gt; it seems useful. I have=\r\nn&#39;t put anything like that into ScalaTest\n&gt; &gt; because no one has asked for =\r\nit, and I wanted to make sure that if I\n&gt; &gt; put something in it is based on=\r\n real requirements. It seems to me that\n&gt; &gt; TestNG&#39;s dependencies are a sim=\r\nilar concept, except instead of an\n&gt; &gt; assumption expression (like File.sep=\r\naratorChar is (&#39;/&#39;) here) deciding\n&gt; &gt; whether a test is &quot;skipped&quot;, it is t=\r\nhe failure of a dependent test.\n&gt; &gt;\n&gt; &gt; So one thing I&#39;d like to hear about=\r\n from JUnit, NUnit, and TestNG\n&gt; &gt; users are use cases. How have theoryless=\r\n assumptions actually been\n&gt; &gt; used in practice? What are they good for in =\r\nreality?\n&gt; &gt;\n&gt; &gt; The other thing is the naming. To Esko I&#39;d say that I thin=\r\nk &quot;skipped&quot;\n&gt; &gt; sounds to me most like the generic term that would encompas=\r\ns all of\n&gt; &gt; these concepts, so maybe that would not be a good term for me =\r\nto use\n&gt; &gt; in ScalaTest if I end up adding this feature. I hadn&#39;t thought o=\r\nf\n&gt; &gt; &quot;canceled&quot; until Charlie mentioned it, but that sounds like a clear\n&gt;=\r\n &gt; way to describe a test that for this run is being skipped because of\n&gt; &gt;=\r\n some unmet &quot;assumption.&quot; Another word you could consider for your\n&gt; &gt; runn=\r\ner, Esko, is &quot;discarded,&quot; which is what I use for properties\n&gt; &gt; thrown out=\r\n during a property check in ScalaTest.\n&gt; &gt;\n&gt; &gt; In case you&#39;re curious, the =\r\ndetails on table-driven property checks in\n&gt; &gt; ScalaTest is here:\n&gt; &gt;\n&gt; &gt;\n&gt;=\r\n &gt;\n&gt; http://www.scalatest.org/scaladoc-1.6.1/#org.scalatest.prop.TableDrive=\r\nnPropertyChecks\n&gt; &gt;\n&gt; &gt; Bill\n&gt; &gt;\n&gt; &gt;\n&gt; &gt; On Tue, Jun 28, 2011 at 11:58 AM, =\r\nCharlie Poole &lt;charliepoole@...&gt;\n&gt; &gt; wrote:\n&gt; &gt; &gt;\n&gt; &gt; &gt;\n&gt; &gt; &gt;\n&gt; &gt; &gt; H=\r\ni David,\n&gt; &gt; &gt;\n&gt; &gt; &gt; The devil is of course in the details... see inline...=\r\n\n&gt; &gt; &gt;\n&gt; &gt; &gt; On Tue, Jun 28, 2011 at 10:37 AM, David Saff &lt;david@...&gt; =\r\nwrote:\n&gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; Just to make it clear, the statuses =\r\ntranslate as:\n&gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; 1) Passed: We know it works\n&gt; &gt; &gt;\n&gt; &gt; &gt; Yes\n&gt;=\r\n &gt; &gt;\n&gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; 2) Failed: We know it doesn&#39;t work.\n&gt; &gt; &gt;\n&gt; &gt; &gt; Yes, b=\r\nut we don&#39;t know why without further info. For example, an\n&gt; &gt; &gt; assertion =\r\nmay have\n&gt; &gt; &gt; failed or an unexpected exception may have been thrown. I cu=\r\nrrently\n&gt; &gt; recognize\n&gt; &gt; &gt; &#39;Failed&#39;, &#39;Failed:Error&#39; and &#39;Failed:Cancelled&#39;=\r\n. The last one could\n&gt; &gt; equally well\n&gt; &gt; &gt; be treated as a sub-category of=\r\n Inconclusive but I made it a failure\n&gt; &gt; because\n&gt; &gt; &gt; the cancellation is=\r\n not something the test can control.\n&gt; &gt; &gt;\n&gt; &gt; &gt; &gt; 3) Skipped: We _could_ k=\r\nnow if it works, but have asked not to be\n&gt; told\n&gt; &gt; &gt; &gt; (because the infor=\r\nmation is redundant, or to save time, for example)\n&gt; &gt; &gt;\n&gt; &gt; &gt; No... The te=\r\nst never ran... OR we are treating it as if it never ran\n&gt; &gt; &gt; (since tests=\r\n can\n&gt; &gt; &gt; be ignored dynamically in their setup. This is the most interest=\r\ning\n&gt; &gt; &gt; category with\n&gt; &gt; &gt; options &#39;Skipped&#39;, &#39;Skipped:Ignored&#39; and &#39;Ski=\r\npped:Invalid&#39; showing up\n&gt; in\n&gt; &gt; the Gui\n&gt; &gt; &gt; as grey, yellow and red res=\r\npectively. I&#39;m considering adding a\n&gt; &gt; &gt; &#39;Severity&#39; field to\n&gt; &gt; &gt; the res=\r\nult so that this coloring (or other text display) is automatic.\n&gt; &gt; &gt;\n&gt; &gt; &gt;=\r\n &gt; 4) Inconclusive: We _can&#39;t_ know if it works\n&gt; &gt; &gt;\n&gt; &gt; &gt; Yes. This is th=\r\ne one we use in Theories. My intent is that\n&gt; &gt; &gt; Inconclusive should have\n=\r\n&gt; &gt; &gt; no effect on the success of a theory _unless_ all results are\n&gt; &gt; &gt; I=\r\nnconclusive. I can&#39;t\n&gt; &gt; &gt; make up my mind what it should mean in a normal =\r\ntest. :-)\n&gt; &gt; &gt;\n&gt; &gt; &gt; &gt; Is that right? I can dig that.\n&gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; I&#39;m =\r\nin favor of a categorization that we believe will serve without\n&gt; &gt; &gt; &gt; alt=\r\neration for five years or so: there&#39;s too many runners to say &quot;Oh,\n&gt; &gt; &gt; &gt; =\r\nyeah, we thought of a fifth status!&quot; and expect them all to catch up.\n&gt; &gt; &gt;=\r\n &gt;\n&gt; &gt; &gt; &gt; David Saff\n&gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; On Mon, Jun 27, 2011 at 8:42 PM, Char=\r\nlie Poole &lt;\n&gt; charliepoole@...&gt;\n&gt; &gt; wrote:\n&gt; &gt; &gt; &gt; &gt; For NUnit 3.0, I=\r\n took a page from the Gallo project and defined\n&gt; four\n&gt; &gt; &gt; &gt; &gt; fundamenta=\r\nl test\n&gt; &gt; &gt; &gt; &gt; statuses: Passed, Failed, Skipped and Inconclusive. These =\r\ncan be\n&gt; &gt; extended\n&gt; &gt; &gt; &gt; &gt; by use\n&gt; &gt; &gt; &gt; &gt; of an arbitrary text field, =\r\ne.g.: Skipped:Ignored.\n&gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt; This allows a test runner/report=\r\ner to at least give some basic info\n&gt; &gt; without\n&gt; &gt; &gt; &gt; &gt; being extended.\n&gt;=\r\n &gt; &gt; &gt; &gt; Extended runners could recognize specific test outcomes and report=\r\n\n&gt; &gt; them\n&gt; &gt; &gt; &gt; &gt; separately.\n&gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt; Note that in this desig=\r\nn, Skipped and Inconclusive carry no notion\n&gt; of\n&gt; &gt; being\n&gt; &gt; &gt; &gt; &gt; a Good=\r\nThing,\n&gt; &gt; &gt; &gt; &gt; a BadThing or just neutral. In practice, for example, we m=\r\night\n&gt; color\n&gt; &gt; the\n&gt; &gt; &gt; &gt; &gt; testing bar yellow for\n&gt; &gt; &gt; &gt; &gt; Skipped.Ign=\r\nored but just plain Skipped doesn&#39;t have any effect on\n&gt; the\n&gt; &gt; test\n&gt; &gt; &gt;=\r\n &gt; &gt; outcome.\n&gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt; Charlie\n&gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt; 2011/6/27 C=\r\n=C3=A9dric Beust =E2=99=94 &lt;cedric@...&gt;\n&gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt;&gt; **\n&gt; &gt; &gt;=\r\n &gt; &gt;&gt;\n&gt; &gt; &gt; &gt; &gt;&gt;\n&gt; &gt; &gt; &gt; &gt;&gt; On Fri, Jun 24, 2011 at 2:36 PM, Bill Venners &lt;=\r\nbill@...&gt;\n&gt; &gt; wrote:\n&gt; &gt; &gt; &gt; &gt;&gt;\n&gt; &gt; &gt; &gt; &gt;&gt; &gt; The skipped concept sho=\r\nws up in JUnit as assumptions, and in\n&gt; &gt; TestNG as\n&gt; &gt; &gt; &gt; &gt;&gt; &gt; dependent =\r\ntests, I think.\n&gt; &gt; &gt; &gt; &gt;&gt; &gt;\n&gt; &gt; &gt; &gt; &gt;&gt;\n&gt; &gt; &gt; &gt; &gt;&gt; I think that JUnit marks=\r\n tests that fail their assumption as\n&gt; &gt; &quot;Failed&quot;,\n&gt; &gt; &gt; &gt; &gt;&gt; while\n&gt; &gt; &gt; &gt;=\r\n &gt;&gt; TestNG marks them as &quot;Skipped&quot; (a status which doesn&#39;t exist in\n&gt; &gt; JUn=\r\nit\n&gt; &gt; &gt; &gt; &gt;&gt; AFAIK).\n&gt; &gt; &gt; &gt; &gt;&gt;\n&gt; &gt; &gt; &gt; &gt;&gt; --\n&gt; &gt; &gt; &gt; &gt;&gt; C=C3=A9dric\n&gt; &gt; &gt;=\r\n &gt; &gt;&gt;\n&gt; &gt; &gt; &gt; &gt;&gt; [Non-text portions of this message have been removed]\n&gt; &gt; =\r\n&gt; &gt; &gt;&gt;\n&gt; &gt; &gt; &gt; &gt;&gt;\n&gt; &gt; &gt; &gt; &gt;&gt;\n&gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt; [Non-text portio=\r\nns of this message have been removed]\n&gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt;=\r\n &gt; ------------------------------------\n&gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt; Yahoo! Groups L=\r\ninks\n&gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt;\n&gt; &gt; &gt;\n&gt; &gt;\n&gt; &gt; --\n&gt; &gt; B=\r\nill Venners\n&gt; &gt; Artima, Inc.\n&gt; &gt; http://www.artima.com\n&gt; &gt;\n&gt; &gt;\n&gt;\n&gt; [Non-tex=\r\nt portions of this message have been removed]\n&gt;\n&gt;  \n&gt;\n\n\n\n-- \nBill Venners\nA=\r\nrtima, Inc.\nhttp://www.artima.com\n\n\n[Non-text portions of this message have=\r\n been removed]\n\n\n", 
    "profile": "billvenners", 
    "topicId": 23466, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 416990097, 
    "prevInTime": 23496, 
    "contentTrasformed": false, 
    "postDate": "1309310292", 
    "canDelete": false, 
    "nextInTopic": 23498, 
    "prevInTopic": 23496, 
    "headers": {
        "inReplyToHeader": "PEJBTkxrVGlrdTN6TDdHZnA2amVRSEJGdm9uRkpuOXRQZ19BQG1haWwuZ21haWwuY29tPg==", 
        "messageIdInHeader": "PEJBTkxrVGlrSEtad2RhZFA1MUErQ3dBR0I0NkJBcHAxSnVRQG1haWwuZ21haWwuY29tPg==", 
        "referencesHeader": "PGl0Zmk1YSt1NTJjQGVHcm91cHMuY29tPgk8NEUwMjE0RDQuMjA0MDUwNEBnbWFpbC5jb20+CTxCQU5Ma1RpbWFibU9LUnZDNmpQTjdEYlBTMjdmS3plVkpUZ0BtYWlsLmdtYWlsLmNvbT4JPDRFMDJGNDRBLjYwMjA1MDhAZ21haWwuY29tPgk8QkFOTGtUaW1EU2FiVGZjRnd6Z0tvNWE0Vnp4ZnZZa1gtaEFAbWFpbC5nbWFpbC5jb20+CTxCQU5Ma1RpPTJtTDNFVnRLaHZuZFJGUGgydGlLN3RMN09pUUBtYWlsLmdtYWlsLmNvbT4JPEJBTkxrVGk9dnZIdV9aSjBETXBhZXZWb19LV21lU08tV2ZnQG1haWwuZ21haWwuY29tPgk8QkFOTGtUaWtqMEVxeDhQZmVOaz1PeGRSOG5KM05fd253MXdAbWFpbC5nbWFpbC5jb20+CTxCQU5Ma1RpPVFIOG1ycm5LSjAzQlhRUzJoRmswZFNuRHNXd0BtYWlsLmdtYWlsLmNvbT4JPEJBTkxrVGltdFM0ZEJqQTByLXlTQ19acC1nRFItYVdWdDFnQG1haWwuZ21haWwuY29tPgk8QkFOTGtUaWt1M3pMN0dmcDZqZVFIQkZ2b25GSm45dFBnX0FAbWFpbC5nbWFpbC5jb20+"
    }
}