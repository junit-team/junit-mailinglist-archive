{
    "numMessagesInTopic": 8, 
    "nextInTime": 2665, 
    "senderId": "i_9K_xC9-FQvzKJOlxQikDBHH0LS6K6zLo0pC9-cA1_GGxt1chP4poQMJUNzx1lIjzTMELutM5xPGeMY9j-wyIWVER8HAyhnW8LWOs0", 
    "systemMessage": false, 
    "subject": "Re: SwingUI and AWTUI don&#39;t work with PROJECTX?", 
    "from": "&quot;Kirby Angell&quot; &lt;kirbyangell@...&gt;", 
    "authorName": "Kirby Angell", 
    "msgSnippet": "In just a cursory examination, I think the reason that modifying the excluded.properties works for swinguirunner and not when using Ant is that I can t find", 
    "msgId": 2664, 
    "topicId": 2000, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 0, 
    "messageBody": "<div id=\"ygrps-yiv-892019920\">In just a cursory examination, I think the reason that modifying the <br/>\nexcluded.properties works for swinguirunner and not when using Ant is <br/>\nthat I can&#39;t find any code in JUnitTestRunner (the class Ant uses to <br/>\nexecute test cases), or any other Ant module, that looks at <br/>\nexcluded.properties.<br/>\n<br/>\nI would expect that this is a bug in Ant (or an oversite shall we <br/>\nsay) and not in JUnit.<br/>\n<br/>\nI&#39;m looking at the code now to see if I can patch it to get it to <br/>\nwork.<br/>\n<br/>\n<blockquote><span title=\"qreply\"> --- In junit@y..., tooleojim@y... wrote:<br/>\n&gt; Hello,<br/>\n&gt; <br/>\n&gt; I&#39;ve been following the various threads to do with the JUnit<br/>\n&gt; TestCaseClassLoader on the JUnit mailing list because I&#39;ve<br/>\n&gt; been having a similar sort of problem.<br/>\n&gt; <br/>\n&gt; I&#39;m using Ant 1.3 to run JUnit 3.7 tests for an application<br/>\n&gt; that uses Xerces 1.4.1 and Xalan 2.1. However, my tests fail on <br/>\ntrying<br/>\n&gt; to parse a DOM document because of a problem with a class loader <br/>\n(I&#39;m not sure which loader).<br/>\n&gt; <br/>\n&gt; java.lang.LinkageError<br/>\n&gt; &quot;loader constraints violated when linking org/xml/sax/InputSource <br/>\nclass&quot;<br/>\n&gt; <br/>\n&gt; I&#39;ve had the same problem when running the same tests on the same <br/>\napplication using the Swing or AWT JUnit test runner (and NOT using <br/>\nAnt). I managed to fix  this problem thanks to a suggestion on the <br/>\nJUnit mailing list from Scott Stirling. He suggests a change to the <br/>\nexclude.properties file in the JUnit jar. This file tells the JUnit <br/>\nTestCaseClassLoader which classes it should not try to load. Instead <br/>\nthese classes should be left to the JVM class loader. His suggestion <br/>\nwas to supplement the list of excluded classes to exclude all<br/>\n&gt; org.w3c.dom.* and or.xml.sax.* classes.<br/>\n&gt; <br/>\n&gt; However, this workaround does not fix the problem of running JUnit <br/>\ntests from Ant where the tests (or the application being tested) <br/>\ninvolve org.xml.sax.* classes. <br/>\n&gt; <br/>\n&gt; Has anyone else experienced this problem? Does anyone know of any <br/>\nother fix that could solve this problem? Perhaps, it&#39;s a flaw in the <br/>\nAntClassLoader but as I don&#39;t know much about class loading matters I <br/>\nneed some assistance in pin pointing the problem. Does anyone have <br/>\nany  suggestions?<br/>\n&gt; <br/>\n&gt; Incidentally, I tried removing the JAXP jars (jaxp.jar and <br/>\nparser.jar) that come with Ant and replacing them with the Xalan and <br/>\nXerces jars that my application uses. Ant continues to work fine but <br/>\nthe tests still won&#39;t run. The reason I made this change was that I <br/>\nwas under the impression (from reading the Java Spec <br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://java.sun.com/docs/books/vmspec/2nd-\">http://java.sun.com/docs/books/vmspec/2nd-</a><br/>\nedition/html/ConstantPool.doc.html) that there would be no problem <br/>\nhaving two class loaders loading the same class.<br/>\n&gt; <br/>\n&gt; I also tried adding org.* to the excluded.properties file (so that <br/>\njunit wouldn&#39;t try loading Ant/Xerces/Xalan/etc classes!) but <br/>\nalthough Ant continues to work, the JUnit tests still won&#39;t.<br/>\n&gt; <br/>\n&gt; Thanks,<br/>\n&gt; Jim.<br/>\n&gt; <br/>\n&gt; P.S. This is what Scott Stirling had to say about the matter:<br/>\n&gt; <br/>\n&gt; The JUnit TestCaseClassLoader (the reloadable one) has a <br/>\nfundamental problem that results in frequent LinkageErrors under the <br/>\nfollowing conditions:<br/>\n&gt; <br/>\n&gt; 1.  You use the JUnit Swing UI.<br/>\n&gt; 2.  You use JAXP in your test cases or any classes referenced in <br/>\nyour test cases, or even any &quot;instanceof&quot; expressions that reference <br/>\nJAXP classes. (By JAXP I mean the whole set of javax.* classes plus <br/>\nthe org.w3c.dom.* and org.xml.sax.* classes)<br/>\n&gt; <br/>\n&gt; I can go into this in depth, but the bottom line problems are that <br/>\nJUnit loads classes from the same place as the JVM&#39;s system loader; <br/>\nthe classpath. This necessitates the use of an exclusion list to <br/>\nfilter out certain class names that either must be loaded by the <br/>\nsystem loader, or you would like to have loaded by the system <br/>\nloader.  The JUnit loader does not always delegate to the system <br/>\nloader when it should, particularly in the case of JAXP, which is a <br/>\nweird mix of classes whose names begin with the filtered &quot;javax.*&quot; and<br/>\n&gt; the unfiltered &quot;org.w3c.*&quot; and org.xml.*&quot;.<br/>\n&gt; <br/>\n&gt; JAXP is a special case because it is based on a set of javax.* <br/>\nclasses.  All javax.* classes are excluded from the JUnit loader by <br/>\ndefault (in the default excluded.properties file) in junit.jar.  But <br/>\nJAXP, as shipped from Sun, comes with a bunch of other classes in <br/>\norg.w3c.* and org.xml.*.  The interesting thing is a direct <br/>\ndependency between javax.* classes and some other classes not in the <br/>\nusual exclusion list of com.sun.*, javax.*, etc.<br/>\n&gt; <br/>\n&gt; So what can happen, and frequently does when using the JUnit Swing <br/>\nUI with test cases or other classes, such as Log4J, that use JAXP, is <br/>\nthat the JUnit class loader (properly) delegates javax.xml.* classes <br/>\nit &quot;sees&quot; to the system loader.  But then the system loader loads up <br/>\na bunch of org.w3c.dom and/or org.xml.sax classes as the result of <br/>\ninitializing and loading that JAXP class.  Later, if the JUnit loader <br/>\ncomes across some org.w3c/xml class that it&#39;s never seen before, it <br/>\ntries to load it because the classname doesn&#39;t match one of the <br/>\npatterns in the exclude list.<br/>\n&gt; <br/>\n&gt; But it&#39;s already been loaded through the &quot;backdoor&quot; as the result <br/>\nof some other class loaded by the system loader (remember, the JVM <br/>\nkeeps classes in their own namespace by identifying them by their <br/>\nfully qualified name plus the instance of their _defining_ (not <br/>\ninitiating) loader, AND, the JVM will attempt to assign all unloaded <br/>\nclasses referenced by a defined class to that defining class&#39;s <br/>\nloader).  The JVM&#39;s classresolver routine keeps track of all these <br/>\nclass loading events and &quot;sees&quot; that the JUnit loader is attempting <br/>\nto define a class that has already been defined by the system <br/>\nloader.  That&#39;s wrong because according to the rules of loader <br/>\nconstraints, JUnit should delegate this load to the system loader.<br/>\n&gt; <br/>\n&gt; You can hack around this (I did) by catching the LinkageError in<br/>\n&gt; TestCaseClassLoader&#39;s loadClass() method and then making a recovery <br/>\ncall to findSystemClass() -- thereby delegating to the system loader <br/>\nafter the fact (which is OK).  This hack only works some of the time, <br/>\nthough, because now you can have the reverse problem where the JUnit <br/>\nloader loads a host of org.*.* classes, and then the system loader <br/>\nviolates the loader constraints at some point when it tries to do <br/>\nexactly what I described above with JAXP because it doesn&#39;t ever <br/>\ndelegate to its child (the JUnit loader). Inevitably, if your test <br/>\ncases use many JAXP and related XML classes, one or the other <br/>\nClassLoader will end violating the constraints whatever you do.<br/>\n&gt; <br/>\n&gt; So the solution in the existing JUnit is to definitely add <br/>\norg.w3c.dom.* and org.xml.sax.* to your excluded.properties if you&#39;re <br/>\nusing any JAXP stuff.<br/>\n&gt; <br/>\n&gt; What can we learn from this?  Well, one thing is that it&#39;s a good <br/>\nidea to have your custom class loaders load classes from repositories <br/>\nother than the system classpath.  Note that the JVM&#39;s built-in <br/>\nclassloaders work that way (one for the jre/ext dirs, another for the <br/>\njava.class.path).<br/>\n&gt; <br/>\n&gt; Anyway, the excluded.properties fix is just a matter of time before <br/>\nit<br/>\n&gt; becomes standard in JUnit, since JAXP will be a standard part of <br/>\nthe 1.4 JDK.  It&#39;ll be just like having org.omg.* excluded. </span></blockquote></div>", 
    "prevInTime": 2663, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1000504321", 
    "canDelete": false, 
    "nextInTopic": 2665, 
    "prevInTopic": 2215, 
    "headers": {
        "inReplyToHeader": "PDlrNmdtMys5MmJmQGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PDludHU2MStmdnRzQGVHcm91cHMuY29tPg=="
    }
}