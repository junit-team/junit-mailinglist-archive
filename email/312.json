{
    "numMessagesInTopic": 23, 
    "nextInTime": 313, 
    "senderId": "hwN8Kbfs1dXWbHxNhkpZJbLc3lLRGUxiunr1YSZC3ogO0n7We5Jpb7cpLkqkcrOLpMD53q2yqA", 
    "systemMessage": false, 
    "subject": "Re: Programming By Contract", 
    "from": "jakob@...", 
    "authorName": "jakob@jenkov.com", 
    "msgSnippet": "Hi Tony. I think some of the other guys already told you NOT to catch AssertionFailedErrors in your production code. One reason being that it s part of JUnit s", 
    "msgId": 312, 
    "topicId": 292, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 0, 
    "messageBody": "<div id=\"ygrps-yiv-2059411613\">Hi Tony.<br/>\n<br/>\nI think some of the other guys already told you NOT to catch <br/>\nAssertionFailedErrors in your production code. One reason <br/>\nbeing that it&#39;s part of JUnit&#39;s framework, and to keep test code <br/>\nand production code separate, you shouldn&#39;t use the JUnit <br/>\nclasses in your production code. The fact that you keep <br/>\ninsisting on using the Assert class make me suspicious that<br/>\nyou might have misunderstood the use of the Assert class <br/>\n(not meant as an offence!). <br/>\n<br/>\nYou want to throw an exception when the INPUT of some method is<br/>\nwrong, but AssertionFailedException should be thrown <br/>\n(in a test case) when the CODE HANDLING THE INPUT is wrong, <br/>\nnot the input data itself!!! An AssertionFailedError should be<br/>\nthrown in a test case when a tested method, provided with some input<br/>\ndoesn&#39;t behaved like you expected it to. For instance, didn&#39;t<br/>\nwrite a line to the file when the string input was &quot;simple text&quot;<br/>\n(an error in your code), or didn&#39;t throw an exception as expected<br/>\nwhen supplied with a null parameter. So, your exception signal that<br/>\nsomething in your system, either input is invalid or some other <br/>\nsystem <br/>\n(fx. a database) doesn&#39;t work. AssertionFailedError signals that your<br/>\ncode code doesn&#39;t work! Your code is then wrong and should be fixed! <br/>\n<br/>\n<br/>\n&quot;Well, how do I catch the errors then, If I can&#39;t use Assert?&quot; <br/>\n<br/>\n<br/>\nI assume that what you are using the Assert class for is as a <br/>\nguard in a method, like below:<br/>\n<br/>\npublic void someMethod(String someParameter){<br/>\n<br/>\n    Assert.assertNotNull(someParameter);<br/>\n<br/>\n}<br/>\n<br/>\nThis way you will have an AssertionFailedError thrown if <br/>\nsomeParameter is null. BUT! This is a wrong way to use the<br/>\nAssert class!!! You should NEVER use the Assert class to<br/>\ncheck if some parameter is wrong or the like. Write your<br/>\nown methods to check that, and throw a meaningful Exception<br/>\ninstead if the parameters are wrong. That&#39;ll look like<br/>\nthis:<br/>\n<br/>\npublic void someMethod(String someParameter) throws someException{<br/>\n<br/>\n    if(someParameter == null) throw new someException(<br/>\n                    &quot;someParameter is not allowed to be null!!&quot;);<br/>\n<br/>\n}<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n&quot;What&#39;s the difference?&quot;<br/>\n<br/>\nWell, when you test your code, your put in Assert.assertXXX<br/>\nmethods in your test cases. When NONE of these asserts in<br/>\nyour test cases fail any more, it means that your code works<br/>\nin respect to the asserts in the test case. In other words,<br/>\nyou don&#39;t need the assert statements anymore, since you<br/>\nhave already tested that your code can handle any correct as<br/>\nwell as incorrect parameters etc. (Of course you keep the<br/>\nasserts in the test cases in case you have to change something <br/>\nin code you test, so you need to run the test cases again).<br/>\nIn other, other words again, this means that the errors that<br/>\nyour asserts are checking for, cannot occur in the tested <br/>\ncode, otherwise the test would have failed. If you still <br/>\nthink the errors that your assert is checking for could<br/>\noccur in the code, your test cases aren&#39;t thorough enough. <br/>\nWrite some additional test cases that tests that these errors<br/>\ncannot occur (that your code is able to handle it).<br/>\n<br/>\n<br/>\n<br/>\nAlright, it&#39;s example time:<br/>\n<br/>\n<br/>\nA method myProductionMethod looks like this:<br/>\n<br/>\n<br/>\npublic void doProductionAction(String paramString, int paramInt){<br/>\n<br/>\n    doSubAction1(paramString);<br/>\n    doSubAction2(paramInt);<br/>\n}<br/>\n<br/>\n<br/>\nNow you find out that your whole system will become unstable if the<br/>\nmethod doSubAction1(paramString) is called with paramString being<br/>\nnull. What you have done (I think) is to use the Assert class<br/>\nto make sure that the paramString is not null when calling <br/>\ndoSubAction1,<br/>\nlike this:<br/>\n<br/>\n<br/>\npublic void doProductionAction(String paramString, int paramInt){<br/>\n<br/>\n    Assert.assertNotNull(paramString);<br/>\n    doSubAction1(paramString);<br/>\n    doSubAction2(paramInt);<br/>\n}<br/>\n<br/>\nAnd that&#39;s what&#39;s wrong! Don&#39;t use the Assert class here. Use a simple<br/>\nif-statement instead, or create method call <br/>\n<br/>\n  checkForNull(Object) throws NullPointerException<br/>\n<br/>\nto do the job instead. Otherwise you will end up with code that <br/>\ncatches<br/>\nonly AssertionFailedError&#39;s <br/>\n<br/>\nAn if-statement could look like below:<br/>\n<br/>\npublic void doProductionAction(String paramString, int paramInt) <br/>\n                                        throws <br/>\nNullParamStringException{<br/>\n<br/>\n    if(paramString == null) throw new <br/>\n        NullParamStringException(&quot;paramString is not allowed to be <br/>\nnull&quot;);<br/>\n<br/>\n    doSubAction1(paramString);<br/>\n    doSubAction2(paramInt);<br/>\n}<br/>\n<br/>\n<br/>\n&quot;Well, what IS the difference then?&quot;. <br/>\n<br/>\n<br/>\nGood question. The difference is mostly conceptual, (Don&#39;t mix <br/>\n&quot;buggy code&quot; signals with &quot;invalid input&quot; signals) and should become <br/>\nmore obvious when we start writing a test case for the above method:<br/>\n<br/>\n<br/>\npublic void testDoProductionAction() throws Exception{<br/>\n    MyProductionObject prodObj = new MyProductionObject();<br/>\n<br/>\n    prodObj.doProductionAction(&quot;validText&quot;, 3);<br/>\n<br/>\n}<br/>\n<br/>\n<br/>\nNow, if the doProductionAction method call fails on the given input <br/>\nabove,<br/>\na MyProductionException will be thrown, and it will be caught be the <br/>\nJUnit framework and displayed as a failure. Let&#39;s assume for now, that<br/>\ngiven the String &quot;validText&quot;, and the integer 3, the method will work <br/>\nfine.<br/>\nNow, how do you know if the doProductionAction method will behave <br/>\ncorrectly<br/>\nin case paramString is null? You add a test for it, as below:<br/>\n<br/>\n<br/>\npublic void testDoProductionAction() throws Exception{<br/>\n    MyProductionObject prodObj = new MyProductionObject();<br/>\n<br/>\n    prodObj.doProductionAction(&quot;validText&quot;, 3);<br/>\n<br/>\n    try{<br/>\n        prodObject.doProductionAction(null, 3);<br/>\n        <br/>\n        //it did NOT behave correctly, an Exception was NOT thrown<br/>\n        Assert.assert(&quot;doProductionAction should have thrown a &quot; + <br/>\n                      &quot;NullParamStringException, but didn&#39;t&quot;,   <br/>\nfalse);<br/>\n<br/>\n    }catch(NullParamStringException e){<br/>\n        //it behaved correctly, an Exception was thrown!<br/>\n    }<br/>\n<br/>\n}<br/>\n<br/>\n<br/>\nNow you have a test that proves that you doProductionAction method can<br/>\nhandle a null in paramString (if the test case succeeds!). This means,<br/>\nthat had you had a assertNotNull call in your production code, for <br/>\ninstance<br/>\nafter the if-statement, IT IS NOW NOT NECESSARY ANYMORE, since the <br/>\ntest<br/>\nhas proved that a null will NEVER pass the if-statement. Perfect! And,<br/>\nthe Assert class is used for what it is really intended for, namely <br/>\nsignalling to JUnit that a test case has failed, because your code <br/>\njust <br/>\ncouldn&#39;t handle the input!<br/>\n<br/>\n&quot;But I&#39;d think it was great to get exceptions thrown in my production<br/>\ncode that shows that my code is buggy! Self checking code, lovely!!!&quot;<br/>\n<br/>\nNo you don&#39;t. Think of all the extra catch(AssertionFailedErrors e) <br/>\nclauses you would have spread out through the production code? And how<br/>\ncan you be sure that an AssertionFailedError is thrown because the<br/>\ncode has a bug? It might as well be that it was the user that typed<br/>\nsomething wrong (e.g. that input data was invalid), right? <br/>\nWhich eventually means that you have no way<br/>\nof knowing if the AssertionFailedError was thrown because of invalid <br/>\ninput or because of a bug UNTIL you get to see the users input. Once<br/>\nyou have that, hurry up writing a test case with exactly that input<br/>\nwith some Assert.assertXXX method calls in it to check that your code<br/>\ndid actually behave correctly. If not, fix the code. DON&#39;T USE<br/>\nAssert.assertXXX IN PRODUCTION CODE! It signals a bug in your code<br/>\nbut you can&#39;t be sure it really is a bug.<br/>\n<br/>\n<br/>\n<br/>\n*** Conclusion: *********************<br/>\n<br/>\nExceptions thrown by any production method:  <br/>\n-------------------------------------------<br/>\nInput was wrong, method handled it correctly (possibly) by throwing <br/>\nan exception.<br/>\nThis exception could be caught, and the user redirected to an error <br/>\npage.<br/>\n<br/>\nOf course, this may also be a sign that your code is buggy, if the<br/>\ninput given was correct/valid, and an exception was still thrown. Add <br/>\na<br/>\ntest case to test that situation if you are in doubt.<br/>\n<br/>\n<br/>\nAssertionFailedError: <br/>\n-------------------------------------------<br/>\nYour code is buggy, and should be fixed!<br/>\n<br/>\n<br/>\n*************************************<br/>\n<br/>\n<br/>\nI&#39;ll continue the example for the sake of clarity. If you&#39;ve already<br/>\ngrasped it, skip it.<br/>\n<br/>\n<br/>\n-------------------------------------------------------------<br/>\n<br/>\nNow, let&#39;s assume that the doSubAction2 will fail terribly if called <br/>\nwith negative values... You need to add a check to the <br/>\ndoProductionAction <br/>\nmethod to make sure that negative values are rejected:<br/>\n<br/>\n<br/>\n<br/>\npublic void doProductionAction(String paramString, int paramInt) <br/>\n              throws NullParamStringException, <br/>\n                     NegativeParamIntException{<br/>\n<br/>\n    if(paramString == null) throw new <br/>\n        NullParamStringException(&quot;paramString is not allowed to be <br/>\nnull&quot;);<br/>\n<br/>\n    if(paramInt &lt; 0) throw new<br/>\n        NegativeParamIntException(&quot;paramInt is not allowed to be <br/>\nnegative&quot; + <br/>\n                        &quot;paramInt was &quot; + paramInt);<br/>\n        <br/>\n<br/>\n    doSubAction1(paramString);<br/>\n    doSubAction2(paramInt);<br/>\n}<br/>\n<br/>\n<br/>\nIn your test case you&#39;d have to test it like this (last in the test <br/>\nmethod):<br/>\n<br/>\npublic void testDoProductionAction() throws Exception{<br/>\n <br/>\n   MyProductionObject prodObj = new MyProductionObject();<br/>\n<br/>\n    prodObj.doProductionAction(&quot;validText&quot;, 3);<br/>\n<br/>\n    try{<br/>\n        prodObject.doProductionAction(null, 3);<br/>\n        <br/>\n        //it did NOT behave correctly, an Exception was NOT thrown<br/>\n        Assert.assert(&quot;doProductionAction should have thrown a &quot; + <br/>\n                      &quot;NullParamStringException, but didn&#39;t&quot;,   <br/>\nfalse);<br/>\n<br/>\n    }catch(NullParamStringException e){<br/>\n        //it behaved correctly, an Exception was thrown!<br/>\n    }<br/>\n<br/>\n<br/>\n    //TEST FOR NEGATIVE paramInt VALUES !!!<br/>\n<br/>\n<br/>\n    try{<br/>\n        prodObj.doProductionAction(&quot;validText&quot;, -5);<br/>\n<br/>\n        //it did NOT behave correctly, an Exception was NOT thrown<br/>\n        Assert.assert(&quot;doProductionAction should have thrown a &quot; + <br/>\n                      &quot;NegativeParamIntException, but didn&#39;t&quot;,   <br/>\nfalse);<br/>\n<br/>\n<br/>\n    }catch(NegativeParamIntException e){<br/>\n        //Correct behaviour, exception thrown<br/>\n    }<br/>\n<br/>\n<br/>\n<br/>\n... and then you can catch and handle these exceptions in your <br/>\nproduction code like this:<br/>\n<br/>\n<br/>\n<br/>\n    try{<br/>\n<br/>\n        prodObject.doProductionMethod(someParamString, someParamInt);<br/>\n<br/>\n    }catch(NullParamStringException e){<br/>\n<br/>\n        //redirect user to error page, saying that paramString should <br/>\nbe filled out.<br/>\n<br/>\n    }catch(NegativeParamIntException e)7<br/>\n        //redirect user to error page, saying that paramInt cannot be <br/>\nnegative.<br/>\n    }<br/>\n<br/>\n}<br/>\n----------------------------------------------------------------------<br/>\n----------------------<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n...PHEEEEEW !!!!<br/>\n<br/>\n<br/>\nI hope this helped you out, otherwise I just wasted an hour typing <br/>\nnonsense ;-)<br/>\n<br/>\n<br/>\nGood Luck,<br/>\n<br/>\nJakob Jenkov</div>", 
    "prevInTime": 311, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "980364125", 
    "canDelete": false, 
    "nextInTopic": 317, 
    "prevInTopic": 311, 
    "headers": {
        "inReplyToHeader": "PDk0bW1tdit1YTh0QGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PDk0bmEwdCtoc3ZiQGVHcm91cHMuY29tPg=="
    }
}