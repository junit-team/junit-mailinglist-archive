{
    "numMessagesInTopic": 33, 
    "nextInTime": 7569, 
    "senderId": "BAjaJJJnBq_FqYXYVCGCYLfG6B_4IxsRDOAAHzlR4xmUoXc0HKQsBCm1FWGWBAY4xwgY7JajnjQo-tg6lVCBJ81NmHtyOKY", 
    "systemMessage": false, 
    "subject": "Re: About the value of JUnit", 
    "from": "&quot;javainsel&quot; &lt;javainsel@...&gt;", 
    "authorName": "javainsel", 
    "msgSnippet": "... allows ... to be ... find ... per ... the ... Same can be said about the process of writing a contract (Design by Contract) and then the code which obeys", 
    "msgId": 7568, 
    "profile": "javainsel", 
    "topicId": 7504, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 137093095, 
    "messageBody": "<div id=\"ygrps-yiv-2142426126\"><blockquote><span title=\"ireply\">&gt; I have used JTest as well as a host of similar tools and I do not  <br/>\n&gt; consider it a substitute. Using JTest is in the same category as  <br/>\n&gt; turning up the warning level on your compiler all the way. It <br/>\n </span></blockquote>allows  <br/>\n<blockquote><span title=\"ireply\"> &gt; you to flag &quot;unsafe&quot; constructs and finds things which are likely <br/>\n </span></blockquote>to be  <br/>\n<blockquote><span title=\"ireply\"> &gt; errors, but no automated tool can judge intention, so they cannot <br/>\n </span></blockquote>find  <br/>\n<blockquote><span title=\"ireply\"> &gt; real design errors. Unit Testing does not find these errors either <br/>\n </span></blockquote>per  <br/>\n<blockquote><span title=\"ireply\"> &gt; se, but the *process* of Unit Testing and TDD uncovers them. Take <br/>\n </span></blockquote>the  <br/>\n<blockquote><span title=\"ireply\"> &gt; following piece of (pseudo) code:<br/>\n&gt; <br/>\n<br/>\n </span></blockquote>Same can be said about the process of writing a contract (Design by<br/>\nContract) and then the code which obeys that contract. Its a cyclic<br/>\nprocess like TDD but much more natural.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; /**<br/>\n&gt;   * @post return =  x * i<br/>\n&gt;   */<br/>\n&gt; public int f(int x, int i)<br/>\n&gt; {<br/>\n&gt;      return x * i;<br/>\n&gt; }<br/>\n&gt; <br/>\n&gt; Is this code right? Who knows? What is it *supposed* to do? No  <br/>\n<br/>\n </span></blockquote>Just add a comment like &quot;sums up quantity and weeks&quot; and you&#39;re done.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; automated tool can tell you that the return value should actually  <br/>\n&gt; contain the *sum* of x and i. The only way to figure that out is <br/>\n </span></blockquote>to try  <br/>\n<blockquote><span title=\"ireply\"> &gt; to use the code in a unit test and realize you cannot connect the  <br/>\n&gt; pieces you wish to connect or that you are getting the wrong <br/>\n </span></blockquote>answer.<br/>\n<blockquote><span title=\"ireply\"> &gt; <br/>\n&gt; A tool can generate &quot;automated&quot; test cases for the above, and <br/>\n </span></blockquote>those  <br/>\n<blockquote><span title=\"ireply\"> &gt; tools will generate data to test the post-condition. Of course <br/>\n </span></blockquote>both the  <br/>\n<blockquote><span title=\"ireply\"> &gt; code *and* the postcondition are wrong. They often will be because <br/>\n </span></blockquote>they  <br/>\n<blockquote><span title=\"ireply\"> &gt; are cut and pasted from the code. In many cases, the <br/>\n </span></blockquote>postcondition  <br/>\n<blockquote><span title=\"ireply\"> &gt; cannot be expressed any more succinctly than the code itself.<br/>\n&gt; <br/>\n<br/>\n </span></blockquote>How likely is it for programers who use JUnit to not use properly <br/>\nTDD?<br/>\nMuch more likely than using cut and paste postconditions.<br/>\n<br/>\nCut and paste are unlikely to happen. And if it happens as in your <br/>\nexample, then the method is unlikely to break and wouldn&#39;t be tested <br/>\nwith <br/>\nJUnit.<br/>\n<br/>\nConsider the examples at the JUnit site:<br/>\n<br/>\n    Collection collection = new ArrayList();<br/>\n    collection.add(&quot;itemA&quot;);<br/>\n    assertEquals(1, collection.size());<br/>\n    collection.add(&quot;itemB&quot;);<br/>\n    assertEquals(2, collection.size());<br/>\n    <br/>\nAs a postcondition it would maybe look like &quot;AFTER:size() == <br/>\nBEFORE:size()++&quot; (pseudo code). This is very readable, natural and <br/>\nof <br/>\nmuch greater use for testing and documenting than JUnit/TDD.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; A tool cannot automate testing because a tool does not have access <br/>\n </span></blockquote>to  <br/>\n<blockquote><span title=\"ireply\"> &gt; the human context in which the code makes sense (or fails to). <br/>\n </span></blockquote>Unit  <br/>\n<blockquote><span title=\"ireply\"> &gt; testing tends to uncover these errors in profusion. Often it is <br/>\n </span></blockquote>not  <br/>\n<blockquote><span title=\"ireply\"> &gt; even that test cases fail but that the errors are noticed when the <br/>\n </span></blockquote>test  <br/>\n<blockquote><span title=\"ireply\"> &gt; cases are being written and a serious mistake is uncovered. Test-<br/>\n </span></blockquote>First  <br/>\n<blockquote><span title=\"ireply\"> &gt; Design makes this process more efficient by preventing the faulty <br/>\n </span></blockquote>code  <br/>\n<blockquote><span title=\"ireply\"> &gt; from being written in the first place.<br/>\n&gt; <br/>\n<br/>\n </span></blockquote>DbC with design time checking has no problem with beeing better at <br/>\nthis.<br/>\nIt is similiar like TDD, lets call it &quot;Contract based <br/>\nDevelopment&quot;. ;)<br/>\nThe contract is created first. Then the method is implemented. Same <br/>\nprocedure as TDD. Same benefits like JUnit/TDD plus many more.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; One of the largest advantages of TDD, therefore, is the switch in  <br/>\n&gt; focus, from inside to outside. Writing the test cases forces one <br/>\n </span></blockquote>to  <br/>\n<blockquote><span title=\"ireply\"> &gt; look at the code being written from the point of view of the <br/>\n </span></blockquote>caller and  <br/>\n<blockquote><span title=\"ireply\"> &gt; notice errors which are not apparent from the narrow context of <br/>\n </span></blockquote>the  <br/>\n<blockquote><span title=\"ireply\"> &gt; code itself. Automated tools do not facilitate this thought <br/>\n </span></blockquote>because  <br/>\n<blockquote><span title=\"ireply\"> &gt; their stated purpose is to remove the need to think about the <br/>\n </span></blockquote>issues.  <br/>\n<blockquote><span title=\"ireply\"> &gt; Their only context is internal. And so, the issues are not <br/>\n </span></blockquote>thought  <br/>\n<blockquote><span title=\"ireply\"> &gt; about and the coding happily continues right off a cliff.<br/>\n&gt; <br/>\n<br/>\n </span></blockquote>Writing a contract for a method is to switch the focus to outside.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Automated tools are useful, but they do not replace discipline <br/>\n </span></blockquote>and  <br/>\n<blockquote><span title=\"ireply\"> &gt; process.<br/>\n<br/>\n </span></blockquote>Yes. But it is much easier to keep discipline when using Design by <br/>\nContract. I mean DbC checking at runtime and at compile time, either<br/>\nby using a special compiler or by creating automatically JUnit tests.</div>", 
    "prevInTime": 7567, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1049484525", 
    "canDelete": false, 
    "nextInTopic": 7572, 
    "prevInTopic": 7567, 
    "headers": {
        "inReplyToHeader": "PDY3Nzc2MTRELTY2QzEtMTFENy05QUIxLTAwMDM5M0MzMEVDRUBxbHVlLmNvbT4=", 
        "messageIdInHeader": "PGI2a21kZStwbjloQGVHcm91cHMuY29tPg=="
    }
}