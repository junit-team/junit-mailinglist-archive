{
    "numMessagesInTopic": 16, 
    "nextInTime": 8376, 
    "senderId": "qJTZl9ZSv05EXrg3iWVqyjio3ZEyXG2ekPMzB-xEG6TWNDEnLvnCLZaoy1ZRVOJtG9VyfwHhT34vuIB_Jnp5mok0JTAhDg87EGO0JNgucw", 
    "systemMessage": false, 
    "subject": "RE: [junit] Re: Fork each test method?", 
    "from": "&quot;Robert DiFalco&quot; &lt;rdifalco@...&gt;", 
    "authorName": "Robert DiFalco", 
    "msgSnippet": "... No, not really. I don t expect to be able to convince you but if you have caches, or thread pools, or whatever that are scoped to the runtime instance", 
    "msgId": 8375, 
    "profile": "robert_difalco", 
    "topicId": 8358, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 35850082, 
    "messageBody": "<div id=\"ygrps-yiv-1944245792\"><blockquote><span title=\"ireply\">&gt;&gt; I would think that the easiest way to zero out all the<br/>\n&gt;&gt; caches is to create new cache objects. <br/>\n<br/>\n </span></blockquote>No, not really. I don&#39;t expect to be able to convince you but if you<br/>\nhave caches, or thread pools, or whatever that &quot;are scoped to the<br/>\nruntime instance they were created in&quot;, the easiest and in fact the most<br/>\ncorrect way to reinitialize them is to create a new runtime instance.<br/>\nThe saddest thing is that there is no reason in production to &quot;zero out<br/>\nall caches&quot;. Even having such a method indicates (to me) a design flaw.<br/>\nAfter all, I don&#39;t expect the value of an immutable object (say an<br/>\nInteger) to suddenly change during the life of that object. <br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt; If a class uses a cache, then that class should either<br/>\n&gt;&gt; accept the cache from the outside world or be unaware<br/>\n&gt;&gt; that it&#39;s using a cache at all.<br/>\n<br/>\n </span></blockquote>You are working too hard at this. Things seem simpler to me. For<br/>\nexample, from what you say I am going to assume that you never use<br/>\nstring constants in your code. There isn&#39;t that much of a difference. I<br/>\nsuppose you use a decorator that caches strings and then you make a call<br/>\non each access of the string (possibly looking in a map?) instead of<br/>\nsimply caching the constant string reference as a static final? Really,<br/>\nthere is no difference between that and this:<br/>\n<br/>\n class Something<br/>\n {<br/>\n     private static final Identity FOO_CLASS_ID =<br/>\nClassRegistry.identify( Foo.class );<br/>\n<br/>\n     ...<br/>\n }<br/>\n<br/>\nFOO_CLASS_ID is scoped to the runtime instance it was created in. It is<br/>\nimmutable for the life of the runtime. These may be generated by a<br/>\ndatabase, created by a synchronized static int, GUID generator or<br/>\nwhatever. It doesn&#39;t really matter. The contract is that they are good<br/>\nfor the life of the Runtime. So it makes sense to hide them just as you<br/>\nwould any other immutable constant -- say a string. The only reason to<br/>\nimpose a hash look up on every access is, well, I dunno. For testing?<br/>\n<br/>\nNow, if you suddenly invalidate those identities or flush the<br/>\nClassRegistry, you are in deep trouble. What is the simplest solution?<br/>\n&quot;Don&#39;t do that.&quot; What is the most complicated solution? &quot;Create a bunch<br/>\nof rigging that has no value save for unit tests that are unable to<br/>\ncreate new runtime instances on each run.&quot; Think about it. Details and<br/>\nAbstraction are one thing, this is another. For me, there is nothing<br/>\nworse than seeing designs that are overly complicated (obfuscated in<br/>\nfact) for no other reason than to serve a principle. Liskov<br/>\nSubstitution, Law of Demeter, Coupling and Cohesion, Shunts, Mock<br/>\nObjects, Decorators....these are all good and wonderful things.  All<br/>\nimportant tools. However, they are capable of improving code or making<br/>\ncode horribly obfuscated and ugly. At this point in its evolution,<br/>\nprogramming is much more like music than science. You can kill the feel<br/>\nof the code by being too pedantic.<br/>\n<br/>\nGoogle &quot;Simplicity&quot;.<br/>\n<br/>\nRobert<br/>\n<br/>\n-----Original Message-----<br/>\nFrom: J. B. Rainsberger [mailto:<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:jbrains@...\">jbrains@...</a>] <br/>\nSent: Tuesday, June 17, 2003 3:30 PM<br/>\nTo: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a><br/>\nSubject: Re: [junit] Re: Fork each test method?<br/>\n<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;So said robert_difalco on 2003-06-16 -------------------- Sure, loosely<br/>\n<br/>\n&gt;coupled systems are great, definitely a goal. However, sometimes <br/>\n&gt;certain things just are coupled, like a subclass to it&#39;s superclass. <br/>\n&gt;The class data for the superclass should exist before the subclass, <br/>\n&gt;etc.<br/>\n<br/>\n </span></blockquote>Why should the class have its own data?<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;Also, sometimes the more loosely coupled something is, the HARDER it<br/>\n&gt;is to reset it&#39;s cached data (across all interactions). And I guess <br/>\n&gt;this is really the problem. I want to zero out all cached data <br/>\n&gt;without having to know about the couplings that were created <br/>\n&gt;dynamically.<br/>\n<br/>\n </span></blockquote>I would think that the easiest way to zero out all the caches is to<br/>\ncreate new cache objects. That&#39;s the point of a loosely-coupled system.<br/>\nIf a class uses a cache, then that class should either accept the cache<br/>\nfrom the outside world or be unaware that it&#39;s using a cache at all.<br/>\n<br/>\nCaching is more of an extra service that should be implemented as a<br/>\nDecorator. The application should decide to add caching when it strings<br/>\nobjects together to form the application. Either that or components<br/>\nshould make caching configurable.<br/>\n<br/>\nGoogle &quot;Abstraction and detail&quot;.<br/>\n<br/>\nTake care.<br/>\n<br/>\n<br/>\nJ. B. Rainsberger,<br/>\nPresident, Diaspar Software Services<br/>\nLet&#39;s write software that people understand.<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.diasparsoftware.com/\">http://www.diasparsoftware.com/</a><br/>\ntelephone: +1 416 791-8603<br/>\n<br/>\n<br/>\n<br/>\nTo unsubscribe from this group, send an email to:<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit-unsubscribe@yahoogroups.com\">junit-unsubscribe@yahoogroups.com</a><br/>\n <br/>\n<br/>\nYour use of Yahoo! Groups is subject to<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://docs.yahoo.com/info/terms/\">http://docs.yahoo.com/info/terms/</a></div>", 
    "prevInTime": 8374, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1055890734", 
    "canDelete": false, 
    "nextInTopic": 8376, 
    "prevInTopic": 8374, 
    "headers": {
        "messageIdInHeader": "PENGRERFQjNCODcwRUUzNDZCQjU4M0QyQjA0MjBGNUFDM0I5NDkxQHNlYWJhc3MudHJpcHdpcmUuY29tPg=="
    }
}