{
    "numMessagesInTopic": 8, 
    "nextInTime": 10423, 
    "senderId": "a4GXq0oDxb35KJgCbFO53_1NrpG_Cg7j63iHp0MzMXg7Bp-I7DeUFOXmA4LUY_dE-N80gfRFWHCi8lEt0MqHazgmL-DpiWjM-5QPJs1AKg", 
    "systemMessage": false, 
    "subject": "Re: [junit] JUnit & Reflection -  test method doesn&#39;t fail cleanly", 
    "from": "&quot;J. B. Rainsberger&quot; &lt;jbrains@...&gt;", 
    "authorName": "J. B. Rainsberger", 
    "msgSnippet": "... Doesn t this only work when invoking a class-level (static) method? I assume your test*() methods are not class-level. When you invoke an instance-level", 
    "msgId": 10422, 
    "profile": "nails762", 
    "topicId": 10412, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 127224993, 
    "messageBody": "<div id=\"ygrps-yiv-864375329\">Oisin Kim wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Hi All,<br/>\n&gt; I&#39;ve searched the archives (& Google) for something like this but<br/>\n&gt; didn&#39;t find anything so here goes:<br/>\n&gt; <br/>\n&gt; a test method will run fine if ran by itself in a plain class which<br/>\n&gt; extends TestCase, it includes a section like this:<br/>\n&gt; String expectedExceptionMessage = &quot;someException&quot;;<br/>\n&gt; String actualExceptionMessage = null;<br/>\n&gt; try {<br/>\n&gt;   SomeClass.someStaticMethod();<br/>\n&gt;   AssetFail(&quot;Never Should have got here&quot;);<br/>\n&gt; } catch (Throwable t) {<br/>\n&gt;   actualExceptionMessage = t.getMessage();<br/>\n&gt; }<br/>\n&gt; assertEquals(expectedExceptionMessage, actualExceptionMessage);<br/>\n&gt; <br/>\n&gt; what happens is that if this snippet is run from a regular test case,<br/>\n&gt; everything is fine, but if run via reflection like (shown below) it<br/>\n&gt; gives me something like:<br/>\n&gt; <br/>\n&gt; [junit] Testcase: testName took 8.407 sec<br/>\n&gt; [junit]     Caused an ERROR<br/>\n&gt; [junit] null<br/>\n&gt; [junit] java.lang.reflect.InvocationTargetException<br/>\n&gt; <br/>\n&gt; The test method is called as follows :<br/>\n&gt; <br/>\n&gt; final Method[] methods = this.getClass().getDeclaredMethods();<br/>\n&gt;   final int size = methods.length;<br/>\n&gt;   for (int i = 0; i &lt; size; i++) {<br/>\n&gt;     method = methods[i];<br/>\n&gt;     if (method.getName().startsWith(&quot;test&quot;)<br/>\n&gt;       && method.getParameterTypes().length == 0) {<br/>\n&gt;       this.setUp();<br/>\n&gt;       try {<br/>\n<br/>\n&gt;         method.invoke(RunResourcesTest.class, null);<br/>\n<br/>\n </span></blockquote>Doesn&#39;t this only work when invoking a class-level (static) method? I <br/>\nassume your test*() methods are not class-level.<br/>\n<br/>\nWhen you invoke an instance-level method, you need an instance of the <br/>\nunderlying class somewhere, and I don&#39;t see that.<br/>\n<br/>\nFinally, why are you duplicating code in JUnit&#39;s test runner?<br/>\n-- <br/>\nJ. B. Rainsberger,<br/>\nDiaspar Software Services<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.diasparsoftware.com\">http://www.diasparsoftware.com</a> :: +1 416 791-8603<br/>\nLet&#39;s write software that people understand</div>", 
    "prevInTime": 10421, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1076009618", 
    "canDelete": false, 
    "nextInTopic": 10431, 
    "prevInTopic": 10412, 
    "headers": {
        "inReplyToHeader": "PGJ2dGZ1NSt1cTJjQGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PDQwMjI5QTkyLjUwMDA0MDdAcm9nZXJzLmNvbT4=", 
        "referencesHeader": "PGJ2dGZ1NSt1cTJjQGVHcm91cHMuY29tPg=="
    }
}