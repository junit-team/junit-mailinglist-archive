{
    "numMessagesInTopic": 67, 
    "nextInTime": 5304, 
    "senderId": "s6ksW-frRdxABHlCc9USaLI6uYZNi2UP9xF61BZvRBE-nvenxI6XOqk8cvcmue37_41EekVYs4EpRqf7a8ZHpADg8_HVTO1iRr5Py742", 
    "systemMessage": false, 
    "subject": "RE: [junit] Re: distinguishing between failures and errors", 
    "from": "Mark Meyers &lt;markm@...&gt;", 
    "authorName": "Mark Meyers", 
    "msgSnippet": "... should be assertTrue( ... , true), sorry. ... That is correct, I think if you are concerned about illegal input generating exceptions, you should handle", 
    "msgId": 5303, 
    "topicId": 5186, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 61568997, 
    "messageBody": "<div id=\"ygrps-yiv-1535196357\"><blockquote><span title=\"ireply\">&gt; -----Original Message-----<br/>\n&gt; From: Daniel Barclay <br/>\n&gt; <br/>\n&gt; &gt; From: Mark Meyers <br/>\n&gt; &gt; <br/>\n&gt; &gt; <br/>\n&gt; &gt; &gt; From: Daniel Barclay  <br/>\n&gt; &gt; ...<br/>\n&gt; &gt; &gt; (How can a test show that the caller is responsible for not <br/>\n&gt; &gt; &gt; passing in a null pointer?<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; <br/>\n&gt; &gt; I disagree, how about:<br/>\n&gt; &gt; \ttry{<br/>\n&gt; &gt; \t    instance.someMethod(null);<br/>\n&gt; &gt; \t    fail(&quot;someMethod should not accept null&quot;);<br/>\n&gt; &gt; \t}catch(IllegalArgumentException e){<br/>\n&gt; &gt; \t    assertTrue(&quot;Client code should check for null arguments&quot;);<br/>\n&gt; &gt; \t}<br/>\n&gt; <br/>\n&gt; (Is that code correct?  Is there an assertTrue(String) method?)<br/>\n&gt; <br/>\n<br/>\n </span></blockquote>should be assertTrue(&quot;...&quot;, true), sorry.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Your call to fail(...) says that the method must throw an <br/>\n&gt; IllegalArgumentException when passed a null pointer.  <br/>\n&gt; <br/>\n&gt; That is _not_ the same as saying that the caller must not pass in<br/>\n&gt; null.<br/>\n&gt; <br/>\n<br/>\n </span></blockquote>That is correct, I think if you are concerned about illegal input generating<br/>\nexceptions,<br/>\nyou should handle them. The problem is that the argument is illegal, not<br/>\nthat the current implementation <br/>\ncan&#39;t cope with it. What I was trying to say is that the concern you try to<br/>\nput in a test, is really a <br/>\nconcern you want to put in the implementation.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; <br/>\n&gt; In your case, a caller is allowed to use the method to detect null <br/>\n&gt; pointers.  <br/>\n&gt; <br/>\n<br/>\n </span></blockquote>No. In either case, the behavior is not documented, except in the Tests.<br/>\nNullPointerException and IllegalArgumentException are both unchecked. I just<br/>\nthink IllegalArgumentException is a better <br/>\ndescription of what goes wrong.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; In my case, a caller cannot expect any particular behavior.  <br/>\n&gt; (Maybe the <br/>\n&gt; method throws IllegalArgumentException.  Maybe it returns a <br/>\n&gt; bogus result.<br/>\n&gt; Maybe it gets stuck in an endless loop.  Maybe it makes something else<br/>\n&gt; fail 10000 calls later in another method.  Maybe it crashes <br/>\n&gt; the VM (via <br/>\n&gt; JNI).)<br/>\n&gt; <br/>\n&gt; <br/>\n<br/>\n </span></blockquote>So, check the input parameter before The Apocalypse...<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; <br/>\n&gt; &gt; &gt; You can&#39;t test for any particular behavior from the callee<br/>\n&gt; &gt; &gt; if the callee&#39;s behavior in the face of a null pointer is <br/>\n&gt; &gt; &gt; intentially left undefined (e.g., for flexibility in <br/>\n&gt; &gt; &gt; implementing an interface).)<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; <br/>\n&gt; &gt; The callee is the class being tested, the specifics for different<br/>\n&gt; &gt; implementations could be implemented<br/>\n&gt; &gt; in specific TestCases, <br/>\n&gt; <br/>\n&gt; Why test for behavior that is (intentionally) undefined?<br/>\n&gt; <br/>\n&gt; Consider a method that is defined to return &quot;an instance of some <br/>\n&gt; class implementing interface I.&quot;  In that specification, the<br/>\n&gt; particular class is undefined.<br/>\n&gt; <br/>\n&gt; If your implementation currently uses a class C, why test that <br/>\n&gt; the returned instance is of class C?  Why constrain yourself from<br/>\n&gt; returning an instance of class D, as long as you still return<br/>\n&gt; &quot;an instance of some class implementing interface I&quot;?<br/>\n&gt; <br/>\n<br/>\n </span></blockquote>Well, you would have tests for class C and D ? (Concrete implementations for<br/>\nI).<br/>\nThen you probably would have an abstract super class TestI for TestC and<br/>\nTestD.<br/>\nWhat I meant is if you want to make sure an implementation of I never calls<br/>\ncallee&#39;s someMethod(...) with a null argument, this is really a condition<br/>\nfor<br/>\nthe caller, and must be tested in TestC or TestD. Which is somewhat awkward.<br/>\nSo, throwing an IllegalArgumentException is more elegant and much simpler.<br/>\n(You don&#39;t need to know about callers being implemented)<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; If you test for class C and treat tests as documentation, then <br/>\n&gt; that implies that a caller is allowed to depend on the fact that <br/>\n&gt; you return class C.  That is usually _not_ at all what you want.<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; <br/>\n&gt; &gt; &gt; (How can a test show that a caller is responsible for not<br/>\n&gt; &gt; &gt; depending on certain current behavior of an implementation<br/>\n&gt; &gt; &gt; that is not part of the interface contract?)<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; <br/>\n&gt; &gt; It can&#39;t, the caller&#39;s TestCase should do that. And possibly <br/>\n&gt; <br/>\n&gt; What caller?  That is, no caller necessarily even exists yet. <br/>\n&gt; So no, the caller&#39;s test case cannot do that.  <br/>\n&gt; <br/>\n<br/>\n </span></blockquote>That is the point. It is the responsibility of the caller(s) not to depend<br/>\non internal implementation.<br/>\nAnd if you have a concern about the possibility, and think it&#39;s dangerous to<br/>\nallow such dependencies, your problem as an implementor of the callee, is to<br/>\nmake your code sufficiently robust to prevent that happening.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; (And how could a test case for a caller detect whether that <br/>\n&gt; caller passes a null pointer to the called method?)<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; &gt; the callee&#39;s<br/>\n&gt; &gt; documentation.<br/>\n&gt; <br/>\n&gt; EXACTLY--documentation, not just tests!!!<br/>\n&gt; <br/>\n<br/>\n </span></blockquote>I agree you need documentation (javadoc, How-To, specs, whatever) when<br/>\n&quot;publishing&quot; code as an API or framework.<br/>\nBut dependencies on paper copies of programmer intent _inside_ a project is<br/>\ndangerous. Tests are safer.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; <br/>\n&gt; <br/>\n&gt; &gt; &gt; Because tests, being code, can&#39;t relate code to external <br/>\n&gt; concepts.  <br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; (A specification can say that a function f returns the <br/>\n&gt; mathematical<br/>\n&gt; &gt; &gt; sum of two given integers subject to the limitations of 32-bit<br/>\n&gt; &gt; &gt; signed binary arithmetic.  How can a test say something <br/>\n&gt; like that?)<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; <br/>\n&gt; &gt; \ttry{<br/>\n&gt; &gt; \t    int result = instance.f(Integer.MAX_VALUE, <br/>\n&gt; &gt; Integer.MAX_VALUE);<br/>\n&gt; &gt; \t    fail(&quot;f should throw Exception when integer limits <br/>\n&gt; &gt; are met&quot;);<br/>\n&gt; &gt; \t}catch(IllegalStateException e){<br/>\n&gt; &gt; \t    assertTrue(&quot;function f returns the mathematical sum <br/>\n&gt; &gt; of two given<br/>\n&gt; &gt; integers subject to the limitations of 32-bit&quot;);<br/>\n<br/>\n </span></blockquote>(sorry again, assertTrue(&quot;...&quot;, true)...)<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; <br/>\n&gt; Hmm.  I thought you were talking about having the test logic/behavior<br/>\n&gt; define the method behavior.<br/>\n&gt; <br/>\n&gt; You can stick documentation text in the test case code, but I don&#39;t<br/>\n&gt; think that changes the fact that it&#39;s human-parsed documentation.<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; I do grant that your example shows that documentation doesn&#39;t have to <br/>\n&gt; be in some place separate from the tests. <br/>\n&gt; <br/>\n&gt; Hey--I have an idea.  You know how Javadoc 1.4 can provide links to <br/>\n&gt; the source?  Maybe (ideally, fantasy-land, etc.) it could <br/>\n&gt; provide links <br/>\n&gt; to the test case source too.<br/>\n&gt; <br/>\n&gt; <br/>\n<br/>\n </span></blockquote>No, I didn&#39;t know that. Would be nice in a project.<br/>\nNext we can google search through our code ;-)<br/>\nWell, I like this discussion a lot. Makes me think about<br/>\ncode/test in another way, Thanks;<br/>\n<br/>\n<blockquote><span title=\"qreply\"> &gt; <br/>\n&gt; Daniel<br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 5302, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1025697270", 
    "canDelete": false, 
    "nextInTopic": 5304, 
    "prevInTopic": 5300, 
    "headers": {
        "messageIdInHeader": "PEM0NTBEOTY2NjRDQkQzMTE4MkI2MDBBMEM5NzY2OEIxNjQ4MENBQENBU0UwNTI+"
    }
}