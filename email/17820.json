{
    "numMessagesInTopic": 287, 
    "nextInTime": 17821, 
    "senderId": "buYQOmOCOS61L3E5fbO4wFBF1h99bUoBUWkH42EhlC5E6yCyIwt-76eSHjHhmCPudCGOIoDhkL7liaD9P9aPsqDXj9osA_nrM85Xb__sLd6cVQ", 
    "systemMessage": true, 
    "subject": "Re: Test-friendly, but not caller-friendly?", 
    "from": "&quot;Dean Wampler&quot; &lt;dean@...&gt;", 
    "authorName": "Dean Wampler", 
    "msgSnippet": "I m the author of Contract4J. Here s my perspective. To be quite honest, I use TDD far more than DbC these days. They overlap enough in terms of what they do", 
    "msgId": 17820, 
    "profile": "deanwampler", 
    "topicId": 17266, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 171044160, 
    "messageBody": "<div id=\"ygrps-yiv-1304521958\">I&#39;m the author of Contract4J. Here&#39;s my perspective.<br/>\n<br/>\nTo be quite honest, I use TDD far more than DbC these days. They<br/>\noverlap enough in terms of what they do and TDD has enough advantages<br/>\nthat I only use DbC when I&#39;m in a situation where testing, and<br/>\nimplicitly defining the contract with automated tests, is hard. The<br/>\nlast time this really happened was a few years ago while working on an<br/>\nEJB v2 application. Before TDD, I used DbC and was very successful<br/>\nwith it. One thing I particularly like about DbC is that it explicitly<br/>\nstates information that is more implicit, in unit tests, but which is<br/>\nno less essetially to clients.<br/>\n<br/>\nThat EJB project was before I wrote Contract4J, so why did I bother?<br/>\nWell, I know that many people still use DbC and AspectJ is a natural<br/>\nand powerful tool to implement it. (I may extend the framework for<br/>\nother &quot;metaprogramming-like&quot; purposes later....) <br/>\n<br/>\nBut, is the contract a &quot;cross-cutting concern&quot;? Doesn&#39;t it have to be<br/>\nto use AspectJ?? DbC is an interesting &quot;grey-area&quot; example. The<br/>\ncontract is most definitely an integral part of a component; how can<br/>\nyou use the component without understanding the requirements on inputs<br/>\nand expected outputs? However, you can argue (perhaps weakly ;^) that<br/>\nhow you *exploit* the contract is the crosscutting part. In the case<br/>\nof C4J, it&#39;s an *enforcement* tool. You could also imagine other tools<br/>\nthat use the contract for other purposes, e.g., an IDE that enhances<br/>\ncode completion with contract information. Okay, maybe this argument<br/>\nis splitting hairs, but I&#39;m more interested in practicalities than<br/>\ntheory anyway. So sue me. ;)<br/>\n<br/>\nHere&#39;s a funny thing about Cedric&#39;s comment about aspects only being<br/>\nuseful for reuse scenarios; the actual aspects in C4J are very<br/>\ngeneric; all the unique contract stuff is in the user annotations. <br/>\n<br/>\nAmong its many limitations, most reflect limitations of Java itself.<br/>\n(I prefer Ruby these days...) Cedric is correct about some of the<br/>\nlimitations; especially the fact that tests are written as strings and<br/>\naren&#39;t compiled until runtime interpretation. I made that choice so I<br/>\ncould use annotations and I chose annotations to (i) separate out the<br/>\ncontract code from the &quot;business logic&quot; and (ii) get the contract into<br/>\nthe method and class signatures that you would see in Javadoc output.<br/>\n<br/>\nBelieve me, it was a big design pain doing runtime interpretation and<br/>\nthe majority of the Contract4J unit tests (yes, it&#39;s tested with<br/>\njunit) have something or other to do with testing the expression<br/>\nevaluation.<br/>\n<br/>\nThe performance is also not great, as you might expect, but this is<br/>\nnot a serious issue most of the time, IMHO, as the contracts are<br/>\nusually only enabled during the testing process.<br/>\n<br/>\nFinally, if you really have a huge contract expression, I suspect you<br/>\nneed to refactor an overly-complicated class or method. If not, then<br/>\ngo ahead and write an &quot;isValid()&quot; method as regular Java and call it<br/>\nin the contract.<br/>\n<br/>\ndean<br/>\n <br/>\n<br/>\n<blockquote><span title=\"qreply\"> --- In junit@yahoogroups.com, &quot;CÃ©dric Beust â&quot; &quot; &lt;cbeust@...&gt; wrote:<br/>\n&gt;<br/>\n&gt; One more thought:  I don&#39;t think AOP is the right tool for this job.<br/>\n&gt; <br/>\n&gt; AOP helps you when the same concerns are crosscutting your code and<br/>\ncan be<br/>\n&gt; factored out.  In the case of pre/postconditions or invariants, each of<br/>\n&gt; these will be fairly unique to the method they apply to, so there is<br/>\nlittle<br/>\n&gt; reuse going on, and therefore, little point in capturing them in aspects<br/>\n&gt; (which this tool doesn&#39;t seem to do, by the way, since they are<br/>\ncaptured in<br/>\n&gt; a string).<br/>\n&gt; <br/>\n&gt; -- <br/>\n&gt; Cedric<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; On 9/4/06, CÃ©dric Beust â&quot; &lt;cbeust@...&gt; wrote:<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt; On 9/4/06, Ray V &lt;ttftestrayv@...&gt; wrote:<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; I wonder what you guys think of Contract4J:<br/>\n&gt; &gt; &gt;<br/>\nhttp://www.contract4j.org/contract4j&lt;http://www.google.com/url?sa=D&q=http%3A%2F%2Fwww.contract4j.org%2Fcontract4j&gt;<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; It combines an annotation based design by contract<br/>\n&gt; &gt; &gt; approach with the &quot;fail fast&quot; philosophy, and can be<br/>\n&gt; &gt; &gt; turned off (like assertions) when it&#39;s time to deploy.<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; It seems very complimentary to unit testing, and would<br/>\n&gt; &gt; &gt; help in doing less defensive programming.  I&#39;ve been<br/>\n&gt; &gt; &gt; curious about this tool for a while, but have yet to<br/>\n&gt; &gt; &gt; use it myself on a real project.<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt; Based on the example on the Web site, it seems to me it&#39;s the<br/>\nwrong way to<br/>\n&gt; &gt; solve the problem.<br/>\n&gt; &gt;<br/>\n&gt; &gt; The example is basically moving asserts inside the method into a<br/>\nstring<br/>\n&gt; &gt; inside an annotation.  By doing that, you lose type checking, you<br/>\nlose IDE<br/>\n&gt; &gt; assistance, you lose highlighting and you lose refactoring<br/>\ncapabilities.<br/>\n&gt; &gt;<br/>\n&gt; &gt; I also wonder how well it scales when your preconditions or<br/>\npostconditions<br/>\n&gt; &gt; need to span ten lines, or when you want to intersperse them<br/>\nin-between<br/>\n&gt; &gt; several lines inside your method.<br/>\n&gt; &gt;<br/>\n&gt; &gt; These reasons are exactly why I think Design by Contract simply<br/>\ndoesn&#39;t<br/>\n&gt; &gt; work:  either your DBC tests are small enough to fit in one-line<br/>\nassertions<br/>\n&gt; &gt; (which can be optimized away by the compiler) or they are fairly<br/>\ncomplex and<br/>\n&gt; &gt; better captured in tests.<br/>\n&gt; &gt;<br/>\n&gt; &gt; --<br/>\n&gt; &gt; CÃ©dric<br/>\n&gt; &gt;<br/>\nhttp://testng.org&lt;http://www.google.com/url?sa=D&q=http%3A%2F%2Ftestng.org&gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; -- <br/>\n&gt; CÃ©dric<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; [Non-text portions of this message have been removed]<br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 17819, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1157512312", 
    "canDelete": false, 
    "nextInTopic": 17821, 
    "prevInTopic": 17819, 
    "headers": {
        "inReplyToHeader": "PGI4NmI2YTljMDYwOTA0MTUxM3c1OGQyMTNiOGljNmZlYmFjNWNmMzE5ZDFAbWFpbC5nb29nbGUuY29tPg==", 
        "messageIdInHeader": "PGVkbGU5bytlZWlhQGVHcm91cHMuY29tPg=="
    }
}