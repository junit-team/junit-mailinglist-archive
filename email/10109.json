{
    "numMessagesInTopic": 5, 
    "nextInTime": 10110, 
    "senderId": "sbjK8OZmnrOxXgAO9Vg9uOLQviXCfSjuCRf5rJa7ao9-pgGMxM5qkLEudW2muEb7G0tW3TQG7xw-XXnJ37eZ0UFzGWFDhkJbG5MZb8udGg", 
    "systemMessage": false, 
    "subject": "Re: [junit] newbie - how to test clases persisting to DB, mock objects in .net", 
    "from": "&quot;J. B. Rainsberger&quot; &lt;jbrains@...&gt;", 
    "authorName": "J. B. Rainsberger", 
    "msgSnippet": "... I have had the greatest success with Interface Segregation. My business logic talks to Store objects using commands, and not a database. The Store objects", 
    "msgId": 10109, 
    "profile": "nails762", 
    "topicId": 10094, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 127224993, 
    "messageBody": "<div id=\"ygrps-yiv-141116620\">Kevin Klinemeier wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; I&#39;ve been using the mock object approach to testing with a good amount<br/>\n&gt; of success.  I&#39;ve used both the SQL mock objects from<br/>\n&gt; http://www.mockobjecst.com, and a mock implementation of our own<br/>\n&gt; persistence level. <br/>\n<br/>\n </span></blockquote>I have had the greatest success with Interface Segregation. My business <br/>\nlogic talks to Store objects using commands, and not a database. The <br/>\nStore objects could be hooked up to anything: files, RDBMS, OODBMS, it <br/>\ndoesn&#39;t matter. The command executer and Store objects go together: the <br/>\nJDBC version manages connections to the database as well as transaction <br/>\nboundaries. I suppose I could put an Abstract Factory around the whole <br/>\nthing, but I haven&#39;t bothered yet.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; The main criticism of this approach is that you&#39;re not really testing<br/>\n&gt; writing to the database.<br/>\n<br/>\n </span></blockquote>My response to those critics: it&#39;s not my job to test someone else&#39;s <br/>\nJDBC driver. I&#39;d rather test /my/ code.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Performance, configuration, db behavior, and<br/>\n&gt; select statement correctness is not tested.  <br/>\n<br/>\n </span></blockquote>My response to those critics: that&#39;s ridiculous. We test it by using the <br/>\napplication. Every day.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; I don&#39;t think that<br/>\n&gt; configuration and performance are things that are appropriate for<br/>\n&gt; testing in unit tests, so I ignore those points.  <br/>\n<br/>\n </span></blockquote>/Everything/ is appropriate for testing as an object test, but some <br/>\ntests provide more ROI than others. If you have persistent ongoing <br/>\nconfiguration problems, then build a Deployment Test Suite to verify <br/>\nyour configuration before you deploy. If you don&#39;t, then don&#39;t build it <br/>\nuntil you do.<br/>\n<br/>\n<blockquote><span title=\"ireply\">  &gt; To the database<br/>\n&gt; behavior question (aka &quot;actually writing to the database&quot;), I respond<br/>\n&gt; with, &quot;I didn&#39;t write the database layer, I don&#39;t need to test it.&quot;  <br/>\n<br/>\n </span></blockquote>Beautiful. Not my yob, mang.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; It<br/>\n&gt; is true that you can have unresolved bugs with problems in your SQL<br/>\n&gt; statement (or QBE examples, in my case).  That&#39;s an admitted weakness,<br/>\n&gt; and not a small one.  If there are suggestions on that front, they&#39;re<br/>\n&gt; welcome (see below).<br/>\n<br/>\n </span></blockquote>Test &#39;em manually. Type an SQL statement into a command line interactive <br/>\nSQL interface. Did it work? Great. Paste it into your code and make it <br/>\nthe Gold Master. If anyone changes that SQL statement (example: they <br/>\ngenerate it differently than they used to), then the tests tell you that <br/>\nthat happened and you can use your judgment: either the gold master <br/>\nneeds to be updated or the change to the SQL statement was wrong.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Just to clarify, (almost) all my tests run without actually accessing<br/>\n&gt; the database.  I think this approach has these key advantages:<br/>\n&gt; <br/>\n&gt; 1:  Test independence - I don&#39;t have to worry about stepping on other<br/>\n&gt; developers.  (If my non-mock test creates a value, then deletes it,<br/>\n&gt; what happens if someone else&#39;s test it re-creates it after I&#39;ve deleted<br/>\n&gt; it, but before I&#39;ve checked for it being missing?  Trouble and<br/>\n&gt; confusion).<br/>\n&gt; <br/>\n<br/>\n&gt; 2:  Test speed - This sounds minor, but its a bigger deal than you<br/>\n&gt; might think.  No database startup or connection times makes for much<br/>\n&gt; faster execution of unit tests.  This makes me much more likely to add<br/>\n&gt; a unit test, or to run old ones.<br/>\n<br/>\n </span></blockquote>In memory, these tests take 0.25 seconds less time each.<br/>\n<br/>\n1000 database tests times 0.25 seconds per test = 250 seconds &gt; 4 minutes.<br/>\n<br/>\nNow I can run my tests an extra 15-20 times per hour, if I want. That&#39;s <br/>\n120-160 times per day. How many more defects will that help you find? <br/>\nMany. Not to mention avoiding extra context switches by checking e-mail, <br/>\nbrowsing the web, grabbing a coffee.<br/>\n<br/>\nWhen the computer starts telling /you/ when to take a break, something <br/>\nis wrong.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; 3:  Test failure cases - This is a big one.  The mock object approach<br/>\n&gt; can test the way your code behaves when the database fails.  I can have<br/>\n&gt; my mock object accept the Person query, but when it asks for Salary, it<br/>\n&gt; throws an exception.  This can&#39;t be done with the database-connected<br/>\n&gt; approach.<br/>\n<br/>\n </span></blockquote>Tell me more about this. I don&#39;t understand it.<br/>\n<br/>\nI think you mean that the tests detect problems before your JDBC driver <br/>\ntries to execute an obviously erroneous query. Is that right?<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; 4:  Test completeness - This is more true of the SQL tools, but only<br/>\n&gt; because they&#39;ve taken the time to write all the things I needed.  I can<br/>\n&gt; tell the SQL tools to look for the following select statements, and if<br/>\n&gt; there is deviation, complain.  The not-so-obvious case that this caught<br/>\n&gt; for me was multiple queries.  I had a logic problem that was causing my<br/>\n&gt; code to ask ten times for a particular case that I only intended for it<br/>\n&gt; to ask once.<br/>\n<br/>\n </span></blockquote>EasyMock objects are great for this.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; 4:  Test completeness - I want to say this again with another example.<br/>\n&gt; If you have code that deletes things, you can be sure that it only<br/>\n&gt; deletes the things you expect.  With the database-connected approach,<br/>\n&gt; you&#39;re typically only testing that it deletes the things you expect to<br/>\n&gt; be gone, not whether there were things that existed before that are now<br/>\n&gt; also deleted by some side effect (like in another table you weren&#39;t<br/>\n&gt; expecting, for example).<br/>\n<br/>\n </span></blockquote>How often does it happen that data magically disappears from another <br/>\ntable? I suppose it happens when someone silently adds a new foreign key <br/>\nconstraint with &quot;cascade delete&quot;. Perhaps this shouldn&#39;t happen. Perhaps <br/>\nthat&#39;s a different problem.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; 5:  Test size unchanged - When I set out to use the mock objects, I<br/>\n&gt; expected this to increase the size of my test code vs the<br/>\n&gt; database-connected approach.  I was suprised to find that this wasn&#39;t<br/>\n&gt; the case.  Consider the following pseudocode:<br/>\n&gt; <br/>\n&gt; setupInitialState();<br/>\n&gt; executeMethodUnderTest();<br/>\n&gt; assertTrue(&quot;State not right&quot;,checkState());<br/>\n&gt; cleanupState();<br/>\n&gt; <br/>\n&gt; This is the same type of code whether your initial state is inserting<br/>\n&gt; records in the database, or if it is setting up mock objects.  The only<br/>\n&gt; place I had more code than before was in cases #3 and #4, where I was<br/>\n&gt; testing things I was previously unable to test.<br/>\n<br/>\n </span></blockquote>Disagree. More mock objects means more complex object construction (more <br/>\nparameters to constructors). This means your setUp() code is more <br/>\ncomplex. (I use EasyMock, so two lines of code per interface to mock.) <br/>\nWhat&#39;s neat, though, is that you spend more lines of code setting up <br/>\nobjects, but verifying them is a snap. The less cohesive your objects <br/>\n(common with a direct-to-database design), the more hoops to jump <br/>\nthrough to verify a particular condition.<br/>\n<br/>\nComplex object construction is much less brittle, in general, than <br/>\ncomplex assertions.<br/>\n<br/>\nThanks for your thoughts. I&#39;m glad I&#39;m not alone in this. :)<br/>\n-- <br/>\nJ. B. Rainsberger,<br/>\nDiaspar Software Services<br/>\nhttp://www.diasparsoftware.com :: +1 416 791-8603<br/>\nLet&#39;s write software that people understand</div>", 
    "prevInTime": 10108, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1071691304", 
    "canDelete": false, 
    "nextInTopic": 10112, 
    "prevInTopic": 10107, 
    "headers": {
        "inReplyToHeader": "PDIwMDMxMjE3MTkyOTE2Ljk1MTEucW1haWxAd2ViNjAzMDYubWFpbC55YWhvby5jb20+", 
        "messageIdInHeader": "PDNGRTBCNjI4LjUwMTA4QHJvZ2Vycy5jb20+", 
        "referencesHeader": "PDIwMDMxMjE3MTkyOTE2Ljk1MTEucW1haWxAd2ViNjAzMDYubWFpbC55YWhvby5jb20+"
    }
}