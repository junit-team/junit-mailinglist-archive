{
    "numMessagesInTopic": 10, 
    "nextInTime": 12556, 
    "senderId": "FXZZR2Rien5AFc-BG_DfyEa_j2uxyYRpOX5lc0OLv9ioookNH2DtLDjsUoarg9hZmvxO9b5B6ExQWKa-hP2Yd9sOODtcOA", 
    "systemMessage": false, 
    "subject": "Re: [junit] Multithreading: Testing scheduled method invocation?!", 
    "from": "Mike Clark &lt;mike@...&gt;", 
    "authorName": "Mike Clark", 
    "msgSnippet": "... So, you were able to write tests for Quartz with these fakes? -- Mike Clark Clarkware Consulting, Inc. http://clarkware.com", 
    "msgId": 12555, 
    "profile": "clarkware", 
    "topicId": 12519, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 33026788, 
    "messageBody": "<div id=\"ygrps-yiv-724308330\">On Dec 27, 2004, at 6:45 PM, Brett Neumeier wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;<br/>\n&gt; On Mon, 2004-12-27 at 10:07 -0700, Mike Clark wrote:<br/>\n&gt;&gt; I tried writing some learning tests for Quartz a couple months back.<br/>\n&gt;&gt; For what it&#39;s worth, I ran into the same timing issues.<br/>\n&gt;&gt;<br/>\n&gt;&gt; Before reaching for sleep(), I tried to refactor Quartz innards so <br/>\n&gt;&gt; that<br/>\n&gt;&gt; the internal clock could be programmatically advanced.  Unfortunately,<br/>\n&gt;&gt; a direct call to System.currentTimeMillis() was duplicated in many<br/>\n&gt;&gt; places and even after consolidating all those calls through an<br/>\n&gt;&gt; interface I was unable to mock the clock.<br/>\n&gt;<br/>\n&gt; I have done that as well.  My Clock interface encapsulates<br/>\n&gt; System.currentTimeMillis(), new Date(), Calendar.getInstance(), and<br/>\n&gt; Thread.sleep().  There may be other standard API mechanisms that <br/>\n&gt; operate<br/>\n&gt; on the current system time, but those were the only ones in use in the<br/>\n&gt; code I was refactoring.<br/>\n&gt;<br/>\n&gt; Most of those were no problem, but pause (the method that encapsulates<br/>\n&gt; Thread.sleep()) was very difficult to fake.  The problem is that when<br/>\n&gt; thread A calls pause, all other threads have to be given a chance to<br/>\n&gt; call pause before thread A is woken up.  This is tricky because thread<br/>\n&gt; scheduling in Java is inherently unpredictable, and in Java 1.4 and<br/>\n&gt; earlier there is no way to determine whether any given thread is<br/>\n&gt; runnable or not.  As a result the FakeClock is as reliable as most<br/>\n&gt; mechanisms for testing multi-threaded code: not perfectly.<br/>\n&gt;<br/>\n&gt; But the tests are an order of magnitude faster than they were when they<br/>\n&gt; just used Thread.sleep(), and they are as reliable as they were before,<br/>\n&gt; so that&#39;s good enough for me.<br/>\n<br/>\n </span></blockquote>So, you were able to write tests for Quartz with these fakes?<br/>\n<br/>\n--<br/>\nMike Clark<br/>\nClarkware Consulting, Inc.<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://clarkware.com\">http://clarkware.com</a></div>", 
    "prevInTime": 12554, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1104279578", 
    "canDelete": false, 
    "nextInTopic": 12556, 
    "prevInTopic": 12554, 
    "headers": {
        "inReplyToHeader": "PDExMDQxOTgzMzcuMTAzMDEuNDcuY2FtZWxAYW5vbWUucm5kLmN4Pg==", 
        "messageIdInHeader": "PDUzQ0EzODJBLTU5MkYtMTFEOS1BQ0Y4LTAwMEE5NUE1NDdCQ0BjbGFya3dhcmUuY29tPg==", 
        "referencesHeader": "PDIwMDQxMjIyMDEzMS4wNTYzOS5taWNoYWVsQHNjaHVlcmlnLmRlPiA8QkZGQ0M4ODEtNTgyOS0xMUQ5LTk4MzktMDAwQTk1QTU0N0JDQGNsYXJrd2FyZS5jb20+IDwxMTA0MTk4MzM3LjEwMzAxLjQ3LmNhbWVsQGFub21lLnJuZC5jeD4="
    }
}