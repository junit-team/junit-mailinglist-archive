{
    "numMessagesInTopic": 3, 
    "nextInTime": 13981, 
    "senderId": "6fgYRAilxlwm7psH0kFqSLUXCBUo9Yz5AEFsmPkrEMkLqyaoYeMnacJ0K5kUCebpO6R-aKNpboCUk0G4YDmZeqT9abII_-q5", 
    "systemMessage": true, 
    "subject": "JUnit 4 API layers for IDE support and test-flavor developers", 
    "from": "&quot;wesisberg&quot; &lt;wesisberg@...&gt;", 
    "authorName": "wesisberg", 
    "msgSnippet": "Hi all (and Kent in particular) - ... and ... a static ... imho, that s a problem: IDE s are trying to support JUnit tests directly.  As another design goal", 
    "msgId": 13980, 
    "profile": "wesisberg", 
    "topicId": 13980, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 108927556, 
    "messageBody": "<div id=\"ygrps-yiv-1414802565\">Hi all (and Kent in particular) -<br/>\n<br/>\nKent has said in the original JUnit 4 thread:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; The theme of JUnit 4 is to encourage more developers <br/>\n&gt; to write more tests by further simplifying JUnit.<br/>\n<br/>\n </span></blockquote>and <br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; AFAIK, IDEs look for subclasses of TestCase or classes implementing<br/>\n </span></blockquote>a static<br/>\n<blockquote><span title=\"ireply\"> &gt; suite() method to identify tests.<br/>\n<br/>\n </span></blockquote>imho, that&#39;s a problem: IDE&#39;s are trying to support JUnit tests<br/>\ndirectly.  As another design goal for JUnit 4, I&#39;d recommend making <br/>\nit easy for IDE support developers and test flavor developers as<br/>\nwell as for test developers.  That means getting IDE&#39;s out of the<br/>\nbusiness of running tests directly.<br/>\n<br/>\nIn nearly every job I encounter pressure to make tests runnable<br/>\nunder JUnit because of the pervasive IDE and build support <br/>\nJUnit enjoys.  Because of the assumptions about test classes and<br/>\ntests being methods, I&#39;ve even had to generate classes using <br/>\nbytecode toolkits to trick the harness into working.  And using<br/>\nany variant of test generation entails enforcing code standards <br/>\nabout what happens in static suite() methods.  <br/>\n<br/>\nI understand that you&#39;re really only concerned with making things<br/>\neasier for the test developer, but at this point with JUnit being<br/>\nthe de facto standard, making it easier for domain-specific test<br/>\nflavors to run as JUnit tests would probably increase the amount<br/>\nof testing that gets done.<br/>\n<br/>\nYou&#39;ve already asked for a concrete proposal for an API for<br/>\ndynamically generated tests (fair enough), but I wanted to check<br/>\nwhether you really did want to be in the business of creating<br/>\nAPI layers for IDE/test runner support and test-flavor developers.<br/>\nYou already have the layers, but they&#39;re not orthogonal because<br/>\nof shared assumptions about test identifiers, tests as methods, etc.<br/>\n<br/>\nIn process order:<br/>\n<br/>\n- {Harness}: to gather test specifications, direct and track testing<br/>\n  (IDE/Ant/... support developer, command-line test deployer)<br/>\n  Without this, IDE&#39;s assume a flavor of test, the JUnit one.<br/>\n<br/>\n- {TestGatherer}: to select and order tests <br/>\n  (test deployer as user, test flavor developer as provider)<br/>\n  Without this, harness has to make test-flavor-specific assumptions<br/>\n  about test attributes/metadata and suite composition.<br/>\n<br/>\n- TestRunner/Test: to create and run each test<br/>\n  (test developer as user, test flavor developer as provider)<br/>\n  Where different flavors of tests can be adapted.<br/>\n<br/>\n- Test/TestCase: for each flavor of test <br/>\n  (test developer)<br/>\n  Here&#39;s where the JUnit model (test == Method) is but one.<br/>\n<br/>\nOne harness I&#39;ve developed is in open source in the AspectJ tree.  It<br/>\nconcretizes some abstractions that might be relevant:<br/>\n<br/>\n- Test specification: this describes a test (for harness selection,<br/>\npreflight, and display), and can be used by a factory to create the<br/>\ntest.  Among other things, you can create data- or<br/>\nspecification-driven tests and need only create one test at a time,<br/>\nwhich makes it easier to have suites with thousands of generated<br/>\ntests.  <br/>\n<br/>\n- Test identifier: In the AspectJ tree, we use the test title as a<br/>\ntest identifier for identifying fixes (failed, now pass) or<br/>\nregressions (passed, now fail).  This would have to be a first-class<br/>\nabstraction to avoid knowing too much about test flavors.  (When<br/>\ngenerating tests I found it hard to map data-driven identifiers to<br/>\nmethod names in generated classes.  And assuming that all tests <br/>\nare always passing results in failing-test limbo: ignored<br/>\nby comment or annotation, rather than being visible and managed.)<br/>\n<br/>\n- A test run is a composite test composed of sub-runs.  The<br/>\ndistinction between &quot;suite&quot; and &quot;test&quot; is collapsed.  It makes it easy<br/>\nto write standard test flavors.  For the AspectJ domain, runs are<br/>\nthings like compile, weave, and run, and tests are composed of these<br/>\nsteps.  Put another way, it&#39;s tests all the way down (rather than<br/>\nsuite{, suite..}, test.., assert..).  This is also where<br/>\ndecorators can work, since a parent can act as around advice.<br/>\n<br/>\n- Messages are associated with each run, and are ways to pass signals<br/>\naround.  The default behavior can be like JUnit asserts (abort on fail<br/>\nmessage), but the more useful behavior is for the parent to interpret<br/>\nexpected and actual messages.  This makes it easier to reuse steps<br/>\n(e.g., database lookup - normal; database lookup (broken pipe)), and<br/>\nto have endemic logging.  (One critique I have of JUnit is that it<br/>\nassumes the developer is evaluating a test failure and can re-run the<br/>\ntest (or that the stack trace is sufficient); messages make it easy<br/>\nfor another developer or for build folks to identify things like setup<br/>\nfailures.)<br/>\n<br/>\n- keywords are simply text associated with a test (cf JavaTest). <br/>\nThese make it very easy to self-name and anoint tests, and to select<br/>\ntests based on unions, intersections, etc.  Annotations can be one<br/>\nsource for these. <br/>\n<br/>\n- Sandbox is a place for temporary junk, encoding good TDD practice.<br/>\n(In the AspectJ harness it also provides shared state, so, e.g., the<br/>\ncompiler can set the classpath used when running the class). <br/>\nHowever...)<br/>\n<br/>\n(This is by no means to say the AspectJ harness is a model for JUnit;<br/>\nit&#39;s feature-driven and not for general use.)<br/>\n<br/>\nTwo other things not in the harness:<br/>\n<br/>\n- World (in the weaver). For expressly-shared state.  <br/>\n<br/>\n- a thread&#39;s current messages, sandbox, test (i.e., chain of tests),<br/>\nand world might all be accessible via a threadlocal, so IDE/harnesses<br/>\ncan provide real-time or snapshot information.  Elsewhere I&#39;ve called<br/>\nvariants of this the test context.<br/>\n<br/>\nThis is  a more ambitious project than upgrading JUnit to simplify <br/>\nthe test developer&#39;s work using annotations and static imports, so<br/>\nI&#39;m assuming you&#39;re not interested in all of it, but might be <br/>\ninterested in concrete/code proposals for categories/keywords and<br/>\nfactories.  However, I figured now&#39;s the time to ask!<br/>\n<br/>\nWes</div>", 
    "prevInTime": 13979, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1119092413", 
    "canDelete": false, 
    "nextInTopic": 14776, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PGQ5MHVydCtpOTFyQGVHcm91cHMuY29tPg=="
    }
}