{
    "numMessagesInTopic": 3, 
    "nextInTime": 667, 
    "senderId": "ZZmwnEmc84G94DxOR8NiVgjPHReao3CksR2IgEIoXdhAFmnd4h-s9UOF8UsD3dmuKfNU4_B2IPROdbTelGbMaTh9ucnP", 
    "systemMessage": false, 
    "subject": "Re: [junit] todo tests in JUnit (think Perl)", 
    "from": "Sameer Ajmani &lt;ajmani@...&gt;", 
    "authorName": "Sameer Ajmani", 
    "msgSnippet": "Chas-- There s no reason you couldn t implement your suggestions yourself quite easily.  Try this: 1) define assertUnimplemented() method that throws a unique ", 
    "msgId": 666, 
    "topicId": 662, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 0, 
    "messageBody": "<div id=\"ygrps-yiv-611072471\">Chas--<br/>\n<br/>\nThere&#39;s no reason you couldn&#39;t implement your suggestions yourself quite<br/>\neasily.  Try this:<br/>\n<br/>\n1) define assertUnimplemented() method that throws a unique<br/>\nError type and call as appropriate.<br/>\n2) define an abort() method that throws a unique Error type.<br/>\n3) create your own TestCase superclass that all your test classes<br/>\ninherit from, and define setUp follows:<br/>\nfinal void setUp()<br/>\n{<br/>\n  try {<br/>\n    setUpImpl();<br/>\n  } catch (Throwable t) {<br/>\n\tabort(&quot;Error in setUp&quot;, t);<br/>\n  }<br/>\n}<br/>\nYour subclasses define setUpImpl. Handle tearDown similarly.<br/>\n<br/>\n4) Define a TestListener that defines addError() to record results in<br/>\nseparate buckets according to the Error thrown.  Include a method to<br/>\nsummarize the output.<br/>\n<br/>\n5) Hook the TestListener into a TestRunner, and you&#39;re done!<br/>\n<br/>\nI realize this seems a little nuts, but the point is there are enough<br/>\nhooks in JUnit as-is to implement this rather easily.  The main problem<br/>\nis that JUnit&#39;s TestRunners don&#39;t let you attach arbitrary<br/>\nTestListeners.  I have implemented my own ExtensibleTestRunner that does<br/>\ndo this and have also defined a TestRunListener interface that extends<br/>\nTestListener with startRun() and endRun() methods.  The result is an<br/>\nextremely flexible TestRunner that can be extended dynamically according<br/>\nto need.  I can pick and choose output styles according to what<br/>\nTestListener I use, and your rebucketing scheme would be simple to<br/>\nimplement.  Let mw know if you&#39;re interested in the source.<br/>\n<br/>\n<blockquote><span title=\"qreply\"> &gt; Perhaps it would be simpler to implement these statii as additional<br/>\n&gt; methods in framework.Assert class and add corresponding vectors and<br/>\n&gt; methods to framework.TestResult?  Something like<br/>\n&gt; Assert.assertUnimplemented() and assertUnimplemented(String).  It<br/>\n&gt; shouldn&#39;t be too hard to teach framework.TestResult to tally the<br/>\n&gt; buckets and amend the test summary report. </span></blockquote></div>", 
    "prevInTime": 665, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "984443730", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 665, 
    "headers": {
        "inReplyToHeader": "WW91ciBtZXNzYWdlIG9mICJNb24sIDEyIE1hciAyMDAxIDE2OjAzOjIzIFBTVC4iIDwwMDVkMDFjMGFiNTEkMDUzNzg4NDAkNjQ2NjY0MGFAemhhbnJhLmNvbT4g", 
        "messageIdInHeader": "PDIwMDEwMzEzMDAzNS5UQUEwNzQ5N0BjaG9yZC5sY3MubWl0LmVkdT4="
    }
}