{
    "numMessagesInTopic": 9, 
    "nextInTime": 11135, 
    "senderId": "Fldq13Yzxyt0YugWNxA9p7XjSbZYjbYUVniIYAgXlpMQGLweK3lt8uH1_pUNb_kkxSpIPYdqhMkARsiOudrvuPg-QOPRlCE6KgQQAUmLCA", 
    "systemMessage": false, 
    "subject": "Re: [junit] using JUnit with derived classes", 
    "from": "&quot;J. B. Rainsberger&quot; &lt;jbrains@...&gt;", 
    "authorName": "J. B. Rainsberger", 
    "msgSnippet": "... It s an interesting notion, and one I can t argue away very easily. I suppose I am a victim of my own preconceptions. (Could I really be a dinosaur", 
    "msgId": 11134, 
    "profile": "nails762", 
    "topicId": 11010, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 127224993, 
    "messageBody": "<div id=\"ygrps-yiv-181106998\">Curt Sampson wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; On Tue, 25 May 2004, J. B. Rainsberger wrote:<br/>\n&gt; <br/>\n&gt;  &gt; I don&#39;t like the built-in assumption that tests belong to production<br/>\n&gt;  &gt; code. A test is just another client of the production code....<br/>\n&gt; <br/>\n&gt; While the test code is generally not run in production systems, I think<br/>\n&gt; of the unit tests as an essential, integral part of any chunk of code.<br/>\n&gt; Leaving out unit tests would be like--well, leaving out large chunks of<br/>\n&gt; the code itself. Code without tests is only half-written code.<br/>\n&gt; <br/>\n&gt; So in that sense, to me, if you&#39;re going to be using files for storage<br/>\n&gt; of code units anyway, putting the tests in a separate file seems akin to<br/>\n&gt; just chopping the class randomly in half, and putting half in one file,<br/>\n&gt; and half in the other. After all, from a TDD programmer&#39;s point of view,<br/>\n&gt; the tests and code are an inseparable chunk.<br/>\n<br/>\n </span></blockquote>It&#39;s an interesting notion, and one I can&#39;t argue away very easily. I <br/>\nsuppose I am a victim of my own preconceptions. (Could I really be a <br/>\ndinosaur already?!) To me, tests are clients of production code, and <br/>\ntests are separate classes from production code, and in Java separate <br/>\nclasses go into separate files, therefore... well, the conclusion is clear.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;  &gt; ...and clients do not belong to providers. The implied dependency is<br/>\n&gt;  &gt; in the wrong direction and generally that way lie dragons.<br/>\n&gt; <br/>\n&gt; In fact, as I&#39;ve been doing more and more acceptance testing, I am<br/>\n&gt; seeing more and more cases where the code is merely a subservient<br/>\n&gt; dependency on the test.<br/>\n<br/>\n </span></blockquote>I think we are using different definitions of &quot;dependency.&quot;<br/>\n<br/>\nTo reword your statement, we programmers are merely code generators, <br/>\nusing the test cases as source and producing production code that passes <br/>\nthe test cases. The &quot;dependency&quot; is there: the production code we write <br/>\nmust pass the tests. There is a certain logical link, then, from the <br/>\ntests to the production code; however, production code does not depend <br/>\non the tests, meaning that production classes do not hardcode <br/>\ndependencies on test classes. At worst, production classes depend on <br/>\ninterfaces that Testing Objects might implement, but even then, it&#39;s <br/>\nonly a test that wires the production object and Testing Object together.<br/>\n<br/>\nJust because we write production code in response to test code doesn&#39;t <br/>\nmean that the production code /depends on/ (in the Java sense) the test <br/>\ncode.<br/>\n<br/>\n<blockquote><span title=\"ireply\">  &gt; The tests are, after all, where we specified<br/>\n&gt; just what the code is to do, and where most of hard work (design and<br/>\n&gt; specification) was done. If you remove all the code, it can relatively<br/>\n&gt; easily be recreated, so long as you have those tests. If you delete the<br/>\n&gt; tests, you now have a pile of code with no specification of what it<br/>\n&gt; should do, only some behaviour that you can&#39;t safely modify. Losing the<br/>\n&gt; tests and keeping the code is akin in this case to losing your source<br/>\n&gt; code and being left only with compiled binaries.<br/>\n<br/>\n </span></blockquote>Exactly: binaries do not depend on source code in the same way that test <br/>\ncode does not depend on production code. Instead, we generate one from <br/>\nthe other.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;  &gt; &gt; I don&#39;t see what the problem with [including tests in production<br/>\n&gt;  &gt; &gt; code] is. It might cause a bit of code bloat, but that&#39;s often not a<br/>\n&gt;  &gt; &gt; problem in many projects.<br/>\n&gt;  &gt;<br/>\n&gt;  &gt; I disagree with the notion that code bloat is not a common problem.<br/>\n&gt;  &gt; Refactoring exists in part because of code bloat.<br/>\n&gt; <br/>\n&gt; Actually, &quot;code bloat&quot; was possibly the wrong term to use here. I<br/>\n&gt; was refering to things like your distribution files getting larger.<br/>\n&gt; For example, the JAR files I roll out into production often include<br/>\n&gt; compiled versions of all of the unit tests, even though that code is not<br/>\n&gt; necessary in production. That may make my JAR file twice the size it<br/>\n&gt; would be otherwise, but in most circumstances I don&#39;t really care enough<br/>\n&gt; to do the work to try to remove the test code.<br/>\n<br/>\n </span></blockquote>I see what you mean. I suppose it&#39;s a question of taste, and maybe it&#39;s <br/>\na good sign. We have /encouraged/ projects to deliver their tests with <br/>\ntheir production code, so I suppose I should be happy. Still, we don&#39;t <br/>\nwant to introduce unnecessary dependencies (production -&gt; tests) and so <br/>\nit&#39;s a worthwhile exercise to /be able to/ package the production code <br/>\nentirely without tests.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;  &gt; &gt;  &gt; This brings up something I am struggling with: in C#/NUnit, we can<br/>\n&gt;  &gt; &gt;  &gt; declare a test without extending TestCase (even if we frequently <br/>\n&gt; extend<br/>\n&gt;  &gt; &gt;  &gt; Assert, anyway). Is there some great benefit to this over the <br/>\n&gt; way we do<br/>\n&gt;  &gt; &gt;  &gt; it in JUnit, SUnit, RubyUnit, PyUnit, ...?<br/>\n&gt;  &gt;...<br/>\n&gt;  &gt; I know it&#39;s possible, but I don&#39;t know why it&#39;s valuable. Can someone<br/>\n&gt;  &gt; with experience doing both make a comparison? Weblog? Anything?<br/>\n&gt; <br/>\n&gt; I think it&#39;s valuable because it gives you a lot more leway to play with<br/>\n&gt; the design of your testing framework within a particular application. I<br/>\n&gt; know that I often feel that certain refactoring directions I&#39;d like to<br/>\n&gt; try are closed to me because of the fairly strict structure of the JUnit<br/>\n&gt; testing framework.<br/>\n<br/>\n </span></blockquote>Do you have a specific example? Given that the structure (hierarchy) of <br/>\ntest classes does not need to reflect the structure of production <br/>\nclasses, what kinds of refactorings are difficult in JUnit but easy in <br/>\nNUnit? This is the kind of thing I need to explore, because my JUnit <br/>\npreconceptions hold me back when thinking in NUnit. You could jump-start <br/>\nme. :)<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; A &quot;pain&quot; that I&#39;ve been feeling over the last few years has been the<br/>\n&gt; tension between code that is in an external library, and code that is<br/>\n&gt; in &quot;my&quot; source repository. For some things, the pain is bad enough, and<br/>\n&gt; my need for flexability strong enough, that I just import the source<br/>\n&gt; code for the external package and effectively start maintaining it<br/>\n&gt; myself. This introduces a maintenance load, however, if I&#39;m also going<br/>\n&gt; to track the changes from the external package. I think that being<br/>\n&gt; given more flexability in how one interfaces with an external chunk of<br/>\n&gt; code lessens this tension. That&#39;s one thing that has, over the past few<br/>\n&gt; years, started driving me away from the very static and declarative Java<br/>\n&gt; model (&quot;this interaface is declared as such, and may only be used in<br/>\n&gt; this way&quot;) more towards the Smalltalk model, where an interface can be<br/>\n&gt; thought of as any group of messages that one object sends to another.<br/>\n<br/>\n </span></blockquote>I want to know more of what&#39;s in here. When you have the time, energy <br/>\nand patience, pick a concrete example then write an article. Please. I <br/>\nwant to read it!<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; I&#39;m sure that this message is not terribly clear; my thoughts on this<br/>\n&gt; topic are actually not terribly well formed at this time. But perhaps it<br/>\n&gt; gives you an inkling of what I&#39;m grasping towards here.<br/>\n<br/>\n </span></blockquote>An inkling, but now that you&#39;ve whet my appetite, I want more....<br/>\n-- <br/>\nJ. B. Rainsberger,<br/>\nDiaspar Software Services<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.diasparsoftware.com\">http://www.diasparsoftware.com</a> :: +1 416 791-8603<br/>\nLet&#39;s write software that people understand</div>", 
    "prevInTime": 11133, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1086606379", 
    "canDelete": false, 
    "nextInTopic": 11143, 
    "prevInTopic": 11132, 
    "headers": {
        "inReplyToHeader": "PFBpbmUuTkVCLjQuNTguMDQwNjA3MTIxNzA1MC40NDhAYW5nZWxpYy12dGZ3LmN2cG4uY3luaWMubmV0Pg==", 
        "messageIdInHeader": "PDQwQzQ0QzJCLjIwNTAzMDlAcm9nZXJzLmNvbT4=", 
        "referencesHeader": "PGM3dHN1MytmY3NiQGVHcm91cHMuY29tPiA8NDBBMkFDRjcuOTAzMDcwNEByb2dlcnMuY29tPiA8UGluZS5ORUIuNC41OC4wNDA1MjUxMzA5NTQwLjkyMzNAYW5nZWxpYy12dGZ3LmN2cG4uY3luaWMubmV0PiA8NDBCMzgyOUEuMjA0MDYwM0Byb2dlcnMuY29tPiA8UGluZS5ORUIuNC41OC4wNDA2MDcxMjE3MDUwLjQ0OEBhbmdlbGljLXZ0ZncuY3Zwbi5jeW5pYy5uZXQ+"
    }
}