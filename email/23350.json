{
    "numMessagesInTopic": 7, 
    "nextInTime": 23351, 
    "senderId": "4eoOydTpV6dmfuZLRMlyatpuwbCr1PbEzpqnvKgvBVW5bP69xE9zVroqEfWiGJnKOu6ygVEC8BWideZucPEHwZYe", 
    "systemMessage": true, 
    "subject": "Re: Unit Testing best practices", 
    "from": "&quot;hkaipe&quot; &lt;hkaipe@...&gt;", 
    "authorName": "hkaipe", 
    "msgSnippet": "Hi Daniel I think you are right on track when you recognize that validations on the input parameters, providing defaults if the parameters are not valid will", 
    "msgId": 23350, 
    "profile": "hkaipe", 
    "topicId": 23330, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 478409128, 
    "messageBody": "<div id=\"ygrps-yiv-1617360621\">Hi Daniel<br/>\n<br/>\nI think you are right on track when you recognize that &quot;validations on the input parameters, providing defaults if the parameters are not valid&quot; will make &quot;the number of testing methods&quot; skyrocket quickly when you want to &quot;test all variations of invalid input on all three constructors&quot;.<br/>\n<br/>\nDuring the past ten years I have spent some time thinking over similar problems myself and the fruit is a JUnit-extension for parameterized tests - CallbackParams <a rel=\"nofollow\" target=\"_blank\" href=\"http://callbackparams.org\">http://callbackparams.org</a> - that I released as open-source a couple of months ago. When using CallbackParams for your Account example - a &quot;best practice&quot; could be ...<br/>\n ... one test-class per constructor (similar to David&#39;s suggestion)<br/>\n ... one enum(!) per constructor parameter (e.g. enum AccountId / enum OwnerName / enum Balance)<br/>\n ... one enum-constant for each value you would like to test<br/>\n<br/>\nTo demonstrate this I have made the class &quot;TestAccount&quot;, which is committed to the svn-repo:<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://callbackparams.svn.sourceforge.net/viewvc/callbackparams/trunk/junit4-tests/src/test/java/org/callbackparams/demo/TestAccount.java?revision=18&view=markup\">http://callbackparams.svn.sourceforge.net/viewvc/callbackparams/trunk/junit4-tests/src/test/java/org/callbackparams/demo/TestAccount.java?revision=18&view=markup</a><br/>\n<br/>\nThe test uses BddRunner (one of two JUnit-runner offered by CallbackParams) and has this general structure:<br/>\n<br/>\n@RunWith(Suite.class)<br/>\n@...({<br/>\n \tTestAccount.Constructor_1.class,<br/>\n \tTestAccount.Constructor_2.class,<br/>\n \tTestAccount.Constructor_3.class})<br/>\npublic class TestAccount {<br/>\n<br/>\n    @Retention(RetentionPolicy.RUNTIME)<br/>\n    @interface ValidationFailure {String value();}<br/>\n<br/>\n<br/>\n    @RunWith(BddRunner.class)<br/>\n    @CombineConfig(strategy=CombineCompletely.class)<br/>\n    public static class Constructor_1 {<br/>\n        Account account;<br/>\n        String accountIdConstructorArg;<br/>\n        ...<br/>\n        @When void createAccount() {<br/>\n            account = new Account(accountIdConstructorArg);<br/>\n        }<br/>\n<br/>\n\t@Then void verifyDefaults() {...}<br/>\n<br/>\n        enum AccountId {<br/>\n            @ValidationFailure(...) ACCOUNT_ID_NULL(null),<br/>\n            @ValidationFailure(...) ACCOUNT_ID_EMPTY(&quot;&quot;),<br/>\n            ACCOUNT_ID_VALID(&quot;123456789-0&quot;),<br/>\n            @ValidationFailure(...) ACCOUNT_ID_INVALID(&quot;HM?&quot;);<br/>\n            ...<br/>\n            @Given void setupAccountIdConstructorArg(Constructor_1 test) {...}<br/>\n            @Then void verifyAccountId(Account account) {...}<br/>\n        }<br/>\n    }<br/>\n<br/>\n<br/>\n    public static class Constructor_2 extends Constructor_1 {<br/>\n        String ownerNameConstructorArg;<br/>\n<br/>\n        @When @Override void createAccount() {<br/>\n            account = new Account(accountIdConstructorArg, ownerNameConstructorArg);<br/>\n        }<br/>\n<br/>\n        @Then @Override void verifyDefaults() {...}<br/>\n<br/>\n        enum OwnerName {<br/>\n            ...<br/>\n            @Given void setupOwnerNameConstructorArg(Constructor_2 test) {...}<br/>\n            @Then void verifyOwnerName(Account account) {...}<br/>\n        }<br/>\n    }<br/>\n<br/>\n<br/>\n    public static class Constructor_3 extends Constructor_2 {<br/>\n        Double balanceConstructorArg;<br/>\n        ...<br/>\n        enum Balance {<br/>\n            ...<br/>\n        }<br/>\n    }<br/>\n}<br/>\n<br/>\nUnlike traditional parameterized tests the parameter values are not primitive - instead they are enum constants, which each has one @Given-method - for setting up the constructor argument that the enum class concerns - and one @Then-method - for verifying the resulting account. (There is no test-method that calls these methods - that is taken care of under-the-hood by BddRunner.) Please note that it is possible for individual enum-constants to override methods and this is what the constants OWNER_NULL and BALANCE_NULL do in order to verify that the null-argument results in the proper default value.<br/>\n<br/>\nMy test-example has four constants per enum, i.e. there are four different values tested for each constructor parameter. Each test will pick exactly one enum-constant from each of its nested enum-classes. This means that Constructor_1 will produce four tests - one for each AccountId-constant. Constructor_2 produces 16 tests - one for each combination of OwnerName and AccountId, where the enum AccountId will be available since it is nested by the super-class! Thereafter Constructor_3 will produce one test for each possible combination of AccountId, OwnerName and Balance etc ... This will result in a total of 84 tests, which will be named like this:<br/>\n<br/>\nTest-class TestAccount$Constructor_1$BDD$ (4 tests)<br/>\n  test[ACCOUNT_ID_NULL]<br/>\n  test[ACCOUNT_ID_EMPTY]<br/>\n  test[ACCOUNT_ID_VALID]<br/>\n  test[ACCOUNT_ID_INVALID]<br/>\n<br/>\nTest-class TestAccount$Constructor_2$BDD$ (16 tests)<br/>\n  test[ACCOUNT_ID_NULL, OWNER_DEFAULT]<br/>\n  test[ACCOUNT_ID_NULL, OWNER_NULL]<br/>\n  test[ACCOUNT_ID_NULL, OWNER_VALID]<br/>\n  test[ACCOUNT_ID_NULL, OWNER_NAME_INVALID]<br/>\n  test[ACCOUNT_ID_EMPTY, OWNER_DEFAULT]<br/>\n  ...<br/>\n  test[ACCOUNT_ID_INVALID, OWNER_NAME_INVALID]<br/>\n<br/>\nTest-class TestAccount$Constructor_3$BDD$ - (64 tests)<br/>\n  test[ACCOUNT_ID_NULL, OWNER_DEFAULT, BALANCE_DEFAULT]<br/>\n  test[ACCOUNT_ID_NULL, OWNER_DEFAULT, BALANCE_NULL]<br/>\n  test[ACCOUNT_ID_NULL, OWNER_DEFAULT, BALANCE_10000]<br/>\n  test[ACCOUNT_ID_NULL, OWNER_DEFAULT, BALANCE_NEGATIVE]<br/>\n  test[ACCOUNT_ID_NULL, OWNER_NULL, BALANCE_DEFAULT]<br/>\n  ...<br/>\n  test[ACCOUNT_ID_INVALID, OWNER_NAME_INVALID, BALANCE_NEGATIVE]<br/>\n<br/>\nSo instead of having &quot;one single thing in each unit test&quot; we now have ~one single thing in each enum-constant~ and no test-method. For the &quot;all variations of invalid input on all three constructors&quot;-thing - CallbackParams handles it by combining the enum-constants.<br/>\n<br/>\nI may be somewhat biased :-) but from how you describe your intentions I think CallbackParams is what fits your needs.<br/>\n<br/>\nFor more information on BddRunner: <a rel=\"nofollow\" target=\"_blank\" href=\"http://callbackparams.org/part1-maintain.html#bdd\">http://callbackparams.org/part1-maintain.html#bdd</a><br/>\n<br/>\nThe annotation @ValidationFailure is used to annotate each enum-constant that is expected to cause an exception. It is part of a Rule-based pattern that is further described here:<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://callbackparams.org/part2-validate.html\">http://callbackparams.org/part2-validate.html</a><br/>\n<br/>\nGreetings<br/>\n/Henrik Kaipe<br/>\n<br/>\n<blockquote><span title=\"qreply\"> --- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>, &quot;Daniel&quot; &lt;dtoffe@...&gt; wrote:<br/>\n&gt;<br/>\n&gt; Hi all,<br/>\n&gt; <br/>\n&gt;     I&#39;m rather new to unit testing and after reading about best practices on the net and some attempts on my own, I still have doubts, hope this is a right place to ask.<br/>\n&gt;     Let&#39;s say I have an Account class with three fields, accountId, ownerName and balance. This class has three constructors:<br/>\n&gt; <br/>\n&gt; Account(String accountId)<br/>\n&gt; Account(String accountId, String ownerName)<br/>\n&gt; Account(String accountId, String ownerName, Double balance)<br/>\n&gt; <br/>\n&gt;     and these constructors have to do some validations on the input parameters, providing defaults if the parameters are not valid.<br/>\n&gt;     Now, let&#39;s say I want to test all variations of invalid input on all three constructors, for example:<br/>\n&gt; <br/>\n&gt; Account(null)<br/>\n&gt; Account(&quot;&quot;, null, 1575.0)<br/>\n&gt; <br/>\n&gt;     I&#39;ve learned that a best practice is to test one single thing in each unit test. If I write my test as.<br/>\n&gt; <br/>\n&gt; testConstructor1AccountIdNull<br/>\n&gt; testConstructor1AccountIdEmpty<br/>\n&gt; testConstructor1AccountIdExampleValue<br/>\n&gt; etc,<br/>\n&gt; <br/>\n&gt;     the number of testing methods skyrockets quickly.<br/>\n&gt;     So my question is, am I doing it wrong, is there any other simpler best practice to test all variations of input values ?<br/>\n&gt;     I&#39;ve seen the @Parameter annotation in JUnit 4.x, can I use it with multiple constructors and data sets in one unit testing class, or must I spread it into one class for each constructor and data array definition ?<br/>\n&gt; <br/>\n&gt; Thanks in advance,<br/>\n&gt; <br/>\n&gt; Daniel<br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 23349, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1301242426", 
    "canDelete": false, 
    "nextInTopic": 23363, 
    "prevInTopic": 23344, 
    "headers": {
        "inReplyToHeader": "PGlscjZuais0YnJtQGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PGltbm5ucSttaXU1QGVHcm91cHMuY29tPg=="
    }
}