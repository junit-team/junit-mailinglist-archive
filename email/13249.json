{
    "numMessagesInTopic": 32, 
    "nextInTime": 13250, 
    "senderId": "3AMrIVhWXrQX19YR3csQTggo7vbrv8MmStnI3W2LQvndr_3IqYaOwOLd0GWlNtNT6vybE_7zNWbGx98OgNh9bS9k", 
    "systemMessage": false, 
    "subject": "Re: [junit] How does Unit test in a heirarchy works...", 
    "from": "Arun J &lt;mail.jak@...&gt;", 
    "authorName": "Arun J", 
    "msgSnippet": "Thanks for taking time..find my response inline. ... JAK: as I have mentioned this heirarchy is just a sample...in reality it could be even deeper.  Let us not", 
    "msgId": 13249, 
    "profile": "jayarunkumar", 
    "topicId": 13233, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 190187075, 
    "messageBody": "<div id=\"ygrps-yiv-2073921438\">Thanks for taking time..find my response inline.<br/>\n<br/>\n<blockquote><span title=\"qreply\"> On Apr 8, 2005 12:22 PM, Ilja Preuss &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:preuss@...\">preuss@...</a>&gt; wrote:<br/>\n&gt;  Arun J wrote:<br/>\n&gt;  <br/>\n&gt;  &gt; Though this is not my usecase. Do not get carried away by<br/>\n&gt;  &gt; this example..I am trying to sample a similar one.. Assume<br/>\n&gt;  &gt; the following heirarchy structure..<br/>\n&gt;  &gt; BizDoc = Performs versions/history relation functions.<br/>\n&gt;  &gt; OrderDoc -&gt; BizDoc = Performs Order related functions.<br/>\n&gt;  &gt; RequestDoc -&gt; BizDoc = Performs Request related functions.<br/>\n&gt;  &gt; PurchaseOrder -&gt;OrderDoc = Performs PO specific functions.<br/>\n&gt;  &gt; Invoice -&gt; OrderDoc = Performs Invoice specific functions.<br/>\n&gt;  &gt; Shipment -&gt; Orderdoc = Performs Shipment specific functions.<br/>\n&gt;  &gt; Auction -&gt; RequestDoc = Performs auctions specific functions.<br/>\n&gt;  &gt; PurchaseRequest -&gt; RequestDoc = Performs PR specific functions.<br/>\n&gt;  <br/>\n&gt;  With all due respect, this hierarchy looks a little big to me. I would<br/>\n&gt; think<br/>\n&gt;  about using composition in some of those places. (Or aren&#39;t you actually<br/>\n&gt;  talking about inheritance here?)<br/>\n<br/>\nJAK: as I have mentioned this heirarchy is just a sample...in reality<br/>\nit could be even deeper.  Let us not question the design for testing..<br/>\n<br/>\n&gt;  &gt; I would prefer to organize my tests with a similar hierarchy<br/>\n&gt;  &gt; structure<br/>\n&gt;  <br/>\n&gt;  Why?<br/>\n&gt;  <br/>\n&gt;  &gt; Also I would like to initialise the objects needed in the<br/>\n&gt;  &gt; appropriate level for the childs to make use of them without doing<br/>\n&gt;  &gt; them again. <br/>\n&gt;  <br/>\n&gt;  I&#39;m not sure I understand this. Care to elaborate?<br/>\nhmm. There won&#39;t a limit to explain the situation.  I assume you<br/>\nunderstand the scenario i&#39;m trying to explain.  At different levels it<br/>\nlooks up and initializes the composite objects for that level. <br/>\nDerivatives uses them sometimes or overrides depending on their needs.<br/>\n<br/>\n&gt;  &gt; 1. Have a single parent without testXXX methods do the on<br/>\n&gt;  &gt; demand initialisation at the top level and all Uts inherit<br/>\n&gt;  &gt; from this single parent. And have Uts in a single level. In<br/>\n&gt;  &gt; the above case BizDocUt & PurchaseRequestUt will be in the<br/>\n&gt;  &gt; same level.  BizDocUt initialises some objects in the helpers<br/>\n&gt;  &gt; and make available for all Uts.  Or if PurchaseRequestUt is<br/>\n&gt;  &gt; run first it initialises first all Bizdoc objects so that<br/>\n&gt;  &gt; BizdocUt can run w/o initializing them again.<br/>\n&gt;  <br/>\n&gt;  So are you saying the Bizdoc objects are global to the tests? What does it<br/>\n&gt;  mean to &quot;initialize&quot; them? Where are the hold?<br/>\n&gt;  <br/>\nBizDoc is the System object and BizDocUt is Unit test class which<br/>\ntests the BizDoc operations/API. Here Parent(s) can have any name<br/>\nwhich extends TestCase and BizDocUt and other tests would inherit and<br/>\nuse them as just parents .  These parent(s) will not have testXXX<br/>\nmethods.<br/>\n&gt;  &gt; 2. Maintain the heirarchy of Ut and use the Test suite in all<br/>\n&gt;  &gt; Ut classes to add the child tests only.<br/>\n&gt;  <br/>\n&gt;  Sounds like unecessary work to me.<br/>\nThis is an alternative to override the default behavior of the jUnit<br/>\nwhich adds parents test also.  I agree this is painful but it is<br/>\nnecessary.<br/>\n&gt;  &gt; Guys - don&#39;t you feel this is a very common need for any OO<br/>\n&gt;  &gt; application.<br/>\n&gt;  <br/>\n&gt;  Frankly, no, I don&#39;t feel it is. It rather looks to me as if your design is<br/>\n&gt;  suboptimal, and that your testing problems are just a symptom of that. I<br/>\n&gt;  don&#39;t know enough to be sure, though.<br/>\n&gt;  <br/>\nSystem design is for meeting the requirement not meeting the testing<br/>\nrequirement.<br/>\nWhen we are writing test cases at the lower level (API testing) we<br/>\ncan&#39;t expect a seperate set of API for testing purpose only.<br/>\n<br/>\n&gt;  &gt; I am surprised JUnit doesn&#39;t provided this<br/>\n&gt;  &gt; flexibility directly.<br/>\n&gt;  <br/>\n&gt;  That&#39;s because the inventors of Junit, and many of it users, don&#39;t just<br/>\n&gt;  write unit tests to tests the system, but use writing tests as a *design*<br/>\n&gt;  technique. If they encounter a problem when trying to write Junit tests for<br/>\n&gt;  their system, they first think about what the system needed to look like to<br/>\n&gt;  not have those problems, and often find that refactoring it to that<br/>\n&gt;  direction improves the overall decoupling and flexibility.<br/>\n&gt;  <br/>\n&gt;  &gt; I have posted my requirement for<br/>\n&gt;  &gt; Logical flow of tests which is also good to have.  JUnit has these<br/>\n&gt;  &gt; missing.<br/>\n&gt;  <br/>\n&gt;  It can be added to Junit without a problem, it is flexible enough to allow<br/>\n&gt;  that. It&#39;s not at the core of Junit because many of its users actually<br/>\n&gt; think<br/>\n&gt;  that needing a &quot;Logical flow of tests&quot; is a thing that should be avoided.<br/>\n&gt;  <br/>\n&gt;  &gt; I can hack(override) into jUnit to support these but I do<br/>\n&gt;  &gt; not want to maintain this for every release.<br/>\n&gt;  <br/>\n&gt;  If you want, you can write a TestSuite implementation that uses reflection<br/>\n&gt;  to only call the test methods declared directly in a class (that is, not<br/>\n&gt; the<br/>\n&gt;  inherited ones). I think it would take me less than an hour to do so. In<br/>\n&gt;  years of using Junit, I never felt the need to do that, though.<br/>\n&gt;  <br/>\nI understand you have not encountered this before and that is the<br/>\nreason why I have explained a scenario which needs this.  It is not<br/>\nabout writing some code to override the behaviour, it is about<br/>\nmaintaining them..<br/>\n<br/>\n&gt;  &gt; JUnit folks..are you hearing...?<br/>\n&gt;  <br/>\n&gt;  Certainly. Are you, too? ;)<br/>\n<br/>\nThanks..I mean jUnit inventors in your language..:-)<br/>\n<br/>\n~JAK </span></blockquote></div>", 
    "prevInTime": 13248, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1112951016", 
    "canDelete": false, 
    "nextInTopic": 13250, 
    "prevInTopic": 13248, 
    "headers": {
        "inReplyToHeader": "PDAwNGUwMWM1M2MwNyQ3YjgyYmI1MCQ3MDY0YThjMEBkaXN5Lm5ldD4=", 
        "messageIdInHeader": "PGU3MTczMzBlMDUwNDA4MDIwMzZjNWU2MDJAbWFpbC5nbWFpbC5jb20+", 
        "referencesHeader": "PGU3MTczMzBlMDUwNDA3MjI0MzNlZDAyZGRkQG1haWwuZ21haWwuY29tPgkgPDAwNGUwMWM1M2MwNyQ3YjgyYmI1MCQ3MDY0YThjMEBkaXN5Lm5ldD4="
    }
}