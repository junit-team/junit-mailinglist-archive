{
    "numMessagesInTopic": 9, 
    "nextInTime": 18129, 
    "senderId": "gWFprZRTl1TFKi6k65OLCXNKtIm0NQtIaAB_MpOHCVlPYLD5EQkTOve1b_RW9UqIV9CFqi_jGFZE_3l5y5YBVq4ReOLPMbGFf-J1D0dwaL1jMwI8vhaLEcoAsQ", 
    "systemMessage": false, 
    "subject": "Re: @Ignore with date", 
    "from": "=?iso-8859-1?B?SWxqYSBQcmV13w==?= &lt;it@...&gt;", 
    "authorName": "Ilja Preu√ü", 
    "msgSnippet": "Mhh, no interest? Is there a low intrusive way I can implement this without having to patch JUnit with every new version? BTW, there also started some", 
    "msgId": 18128, 
    "profile": "ipreussde", 
    "topicId": 17834, 
    "spamInfo": {
        "reason": "6", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 182451331, 
    "messageBody": "<div id=\"ygrps-yiv-1879922765\">Mhh, no interest?<br/>\n<br/>\nIs there a low intrusive way I can implement this without having to<br/>\npatch JUnit with every new version?<br/>\n<br/>\nBTW, there also started some discussion of this feature at<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://saloon.javaranch.com/cgi-bin/ubb/ultimatebb.cgi?ubb=get_topic&f=68&t=001369\">http://saloon.javaranch.com/cgi-bin/ubb/ultimatebb.cgi?ubb=get_topic&f=68&t=001369</a><br/>\n<br/>\n<blockquote><span title=\"qreply\"> --- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>, it@... wrote:<br/>\n&gt;<br/>\n&gt; Hello,<br/>\n&gt; <br/>\n&gt; from time to time, we feel the need to temporarily ignore a test<br/>\ncase. In Junit 3.x, our team introduced a failAfter(Date) method to<br/>\nremind us from time to time that there was a testcase ignored.<br/>\n&gt; <br/>\n&gt; Now that we are switching to JUnit 4, we&#39;d like to use the Ignore<br/>\nannotation, so I patched it to allow an additional until-Parameter.<br/>\nBelow are the additional unit tests for the TestMethodTest:<br/>\n&gt; <br/>\n&gt; \tstatic public class IgnoredUntilTest {<br/>\n&gt; \t\t@Ignore(until=&quot;1/1/3000&quot;) @Test public void withUntilLater() {}<br/>\n&gt; \t}<br/>\n&gt; \t<br/>\n&gt; \t@Test public void ignoreRunnerUntil() {<br/>\n&gt; \t\tJUnitCore runner= new JUnitCore();<br/>\n&gt; \t\tResult result= runner.run(IgnoredUntilTest.class);<br/>\n&gt; \t\tassertEquals(1, result.getIgnoreCount());<br/>\n&gt; \t}<br/>\n&gt; \t<br/>\n&gt; \tstatic public class IgnoredUntilWithTimeTest {<br/>\n&gt; \t\t@Ignore(until=&quot;1/1/3000 1:00 PM&quot;) @Test public void<br/>\nwithUntilLater() {}<br/>\n&gt; \t}<br/>\n&gt; \t<br/>\n&gt; \t@Test public void ignoreRunnerUntilWithTime() {<br/>\n&gt; \t\tJUnitCore runner= new JUnitCore();<br/>\n&gt; \t\tResult result= runner.run(IgnoredUntilWithTimeTest.class);<br/>\n&gt; \t\tassertEquals(1, result.getIgnoreCount());<br/>\n&gt; \t}<br/>\n&gt; \t<br/>\n&gt; \tstatic public class IgnoredUntilBeforeTest {<br/>\n&gt; \t\t@Ignore(until=&quot;1/1/1900&quot;) @Test public void withUntilBefore() {}<br/>\n&gt; \t}<br/>\n&gt; \t<br/>\n&gt; \t@Test public void doNotIgnoreUntilBefore() {<br/>\n&gt; \t\tJUnitCore runner= new JUnitCore();<br/>\n&gt; \t\tResult result= runner.run(IgnoredUntilBeforeTest.class);<br/>\n&gt; \t\tassertEquals(0, result.getIgnoreCount());<br/>\n&gt; \t}<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; The Ignore annotation needs the additional method:<br/>\n&gt; <br/>\n&gt; public @interface Ignore {<br/>\n&gt; \tString value() default &quot;&quot;; <br/>\n&gt; \tString until() default &quot;&quot;;<br/>\n&gt; }<br/>\n&gt; <br/>\n&gt; And the implementation of the behaviour is in TestIntrospector:<br/>\n&gt; <br/>\n&gt; \tpublic boolean isIgnored(Method eachMethod) {<br/>\n&gt; \t\tIgnore ignoredAnnotation= eachMethod.getAnnotation(Ignore.class);<br/>\n&gt; \t\tif (ignoredAnnotation == null) {<br/>\n&gt; \t\t\treturn false;<br/>\n&gt; \t\t}<br/>\n&gt; \t\tString until= ignoredAnnotation.until();<br/>\n&gt; \t\tif (until.length() == 0) {<br/>\n&gt; \t\t\treturn true;<br/>\n&gt; \t\t}<br/>\n&gt; \t\ttry {<br/>\n&gt; \t\t\treturn DateFormat.getDateTimeInstance(DateFormat.SHORT,<br/>\n&gt; \t\t\t\t\tDateFormat.SHORT, Locale.ENGLISH).parse(until).after(<br/>\n&gt; \t\t\t\t\tnew Date());<br/>\n&gt; \t\t} catch (ParseException e) {<br/>\n&gt; \t\t\ttry {<br/>\n&gt; \t\t\t\treturn DateFormat.getDateInstance(DateFormat.SHORT,<br/>\n&gt; \t\t\t\t\t\tLocale.ENGLISH).parse(until).after(new Date());<br/>\n&gt; \t\t\t} catch (ParseException e2) {<br/>\n&gt; \t\t\t\treturn false;<br/>\n&gt; \t\t\t}<br/>\n&gt; \t\t}<br/>\n&gt; \t}<br/>\n&gt; <br/>\n&gt; (I guess this could be in need of a little refactoring, sorry... :o )<br/>\n&gt; <br/>\n&gt; If you think it&#39;s a good idea, don&#39;t hesitate to add it to JUnit<br/>\n4.2... :)<br/>\n&gt; <br/>\n&gt; Any other comments would be welcome, too, of course.<br/>\n&gt; <br/>\n&gt; Cheers, Ilja<br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 18127, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1160659099", 
    "canDelete": false, 
    "nextInTopic": 18130, 
    "prevInTopic": 17834, 
    "headers": {
        "inReplyToHeader": "PDQ1Mzc2NzkuODkxMTExNTc1NTMzNzkzOTAuSmF2YU1haWwuc2VydmxldEBrdW5kZW5zZXJ2ZXI+", 
        "messageIdInHeader": "PGVnbGZhcis3cGw3QGVHcm91cHMuY29tPg=="
    }
}