{
    "numMessagesInTopic": 1, 
    "nextInTime": 18260, 
    "senderId": "pow61tTXYd14m8rJ3NsYYyIzj7I56l4VBWD7ACfoVfbcb6o--w28a8Un2wfHnY00o2m8WcU_1Ifh0cJIgYUWdgFflIQxxray5oj-QS_4CVg", 
    "systemMessage": true, 
    "subject": "XPath asserts against a generated XSLT stylesheet", 
    "from": "&quot;cliftonccraig&quot; &lt;cliftonccraig@...&gt;", 
    "authorName": "cliftonccraig", 
    "msgSnippet": "Help! I m trying to perform XPath asserts against a generated XSLT stylesheet. That is a stylesheet that I generate using a stylesheet. I m using a combination", 
    "msgId": 18259, 
    "profile": "cliftonccraig", 
    "topicId": 18259, 
    "spamInfo": {
        "reason": "4", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 190580959, 
    "messageBody": "<div id=\"ygrps-yiv-1937937203\">Help!<br/>\n<br/>\nI&#39;m trying to perform XPath asserts against a generated XSLT stylesheet.<br/>\nThat is a stylesheet that I generate using a stylesheet. I&#39;m using a<br/>\ncombination of XMLUnit, Juxy, and some custom XMLUnit extensions in<br/>\nvarious test and in one test I am trying to reduce the fluff of<br/>\ncomparing an entire resulting XSLT document with an inlined string so I<br/>\nlooked at using the XMLUnit Xpath assert stuff and it started to look<br/>\nlike it was working. So now I&#39;ve broken off and wrote my own XPath<br/>\nassertions in my custom test case extension and I get the same<br/>\nbehaviour. I believe it&#39;s related to the absence of a namespace<br/>\nassociation but I can&#39;t figure out how to make it work. Here&#39;s what I<br/>\ngot so far. Below is a test method that tests my custom XML test case:<br/>\n<br/>\n     public void testAssertXPathExists() throws Exception<br/>\n     {<br/>\n         Document doc = customXMLTestCase.toDocumentNode(<br/>\n                 &quot;&lt;xsl:stylesheet<br/>\nxmlns:xsl=&#92;&quot;<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.w3.org/1999/XSL/Transform&#92;&quot;\">http://www.w3.org/1999/XSL/Transform&#92;&quot;</a>&gt;&quot; +<br/>\n                         &quot;&lt;xsl:template name=&#92;&quot;foo&#92;&quot;&gt;&quot; +<br/>\n                         &quot;&lt;xsl:call-template name=&#92;&quot;foo&#92;&quot;&gt;&quot; +<br/>\n                         &quot;&lt;/xsl:call-template&gt;&quot; +<br/>\n                         &quot;&lt;/xsl:template&gt;&quot; +<br/>\n                         &quot;&lt;/xsl:stylesheet&gt;&quot;);<br/>\n         try<br/>\n         {<br/>\n             String nonExistantPath = &quot;/xsl:stylesheet/xsl:template[@name<br/>\n= &#39;foo&#39;]/xsl:call-template[@name = &#39;foo&#39;]&quot;;<br/>\n             customXMLTestCase.assertXpathExists(nonExistantPath, doc);<br/>\n             fail(&quot;Path &quot; + nonExistantPath + &quot; should not exist in the<br/>\ninputXml&quot;);<br/>\n         }<br/>\n         catch(AssertionFailedError e)<br/>\n         {<br/>\n             String convertedXmlString = customXMLTestCase.asString(doc);<br/>\n             assertTrue(&quot;Error should include inputXml. Message text: &quot; +<br/>\ne, e.getMessage().indexOf(convertedXmlString) &gt;= 0);<br/>\n             throw e;<br/>\n         }<br/>\n     }<br/>\n<br/>\nIt reports the following (running in the Idea test runner):<br/>\njava.lang.RuntimeException: Xpath /xsl:stylesheet/xsl:template[@name =<br/>\n&#39;foo&#39;]/xsl:call-template[@name = &#39;foo&#39;] could not be evaluated against<br/>\ndocument<br/>\n     at<br/>\ncom.custom.junit.ext.CustomXMLTestCase.evaluateXpath(CustomXMLTestCase.j&#92;<br/>\nava:179)<br/>\n     at<br/>\ncom.custom.junit.ext.CustomXMLTestCase.xpathExists(CustomXMLTestCase.jav&#92;<br/>\na:166)<br/>\n     at<br/>\ncom.custom.junit.ext.CustomXMLTestCase.assertXpathExists(CustomXMLTestCa&#92;<br/>\nse.java:161)<br/>\n     at<br/>\ncom.custom.junit.ext.CustomXMLTestCaseTest.testAssertXPathExists(CustomX&#92;<br/>\nMLTestCaseTest.java:33)<br/>\n     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br/>\n     at<br/>\nsun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.jav&#92;<br/>\na:39)<br/>\n     at<br/>\nsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessor&#92;<br/>\nImpl.java:25)<br/>\n     at<br/>\ncom.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:40)<br/>\n     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br/>\n     at<br/>\nsun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.jav&#92;<br/>\na:39)<br/>\n     at<br/>\nsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessor&#92;<br/>\nImpl.java:25)<br/>\n     at<br/>\ncom.intellij.rt.execution.application.AppMain.main(AppMain.java:90)<br/>\nCaused by: javax.xml.xpath.XPathExpressionException<br/>\n     at<br/>\ncom.sun.org.apache.xpath.internal.jaxp.XPathImpl.evaluate(XPathImpl.java&#92;<br/>\n:289)<br/>\n     at<br/>\ncom.custom.junit.ext.CustomXMLTestCase.evaluateXpath(CustomXMLTestCase.j&#92;<br/>\nava:174)<br/>\n     ... 24 more<br/>\nCaused by: javax.xml.transform.TransformerException: Unknown error in<br/>\nXPath.<br/>\n     at com.sun.org.apache.xpath.internal.XPath.execute(XPath.java:296)<br/>\n     at<br/>\ncom.sun.org.apache.xpath.internal.jaxp.XPathImpl.eval(XPathImpl.java:213&#92;<br/>\n)<br/>\n     at<br/>\ncom.sun.org.apache.xpath.internal.jaxp.XPathImpl.evaluate(XPathImpl.java&#92;<br/>\n:275)<br/>\n     ... 25 more<br/>\nCaused by: java.lang.NullPointerException<br/>\n     at<br/>\ncom.sun.org.apache.xpath.internal.axes.AxesWalker.setRoot(AxesWalker.jav&#92;<br/>\na:218)<br/>\n     at<br/>\ncom.sun.org.apache.xpath.internal.axes.WalkingIterator.setRoot(WalkingIt&#92;<br/>\nerator.java:153)<br/>\n     at<br/>\ncom.sun.org.apache.xpath.internal.axes.NodeSequence.setRoot(NodeSequence&#92;<br/>\n.java:212)<br/>\n     at<br/>\ncom.sun.org.apache.xpath.internal.axes.LocPathIterator.execute(LocPathIt&#92;<br/>\nerator.java:211)<br/>\n     at com.sun.org.apache.xpath.internal.XPath.execute(XPath.java:268)<br/>\n     ... 27 more<br/>\n<br/>\nBelow is the code in my custom class:<br/>\n     public Document toDocumentNode(String xml) throws SAXException,<br/>\nIOException, ParserConfigurationException{<br/>\n         return delegate.toDocumentNode(xml);<br/>\n     }<br/>\n<br/>\n     public String asString(Document document) throws Exception<br/>\n     {<br/>\n         return new JuxyTestCase(){}.asString(document);<br/>\n     }<br/>\n<br/>\n     @Override<br/>\n     public void assertXpathNotExists(String string, Document document)<br/>\nthrows TransformerException<br/>\n     {<br/>\n         try{ super.assertXpathNotExists(string, document); }<br/>\n         catch(AssertionFailedError e) {<br/>\nrethrowAssertionFailedErrorWithDocumentText(e, document); }<br/>\n     }<br/>\n<br/>\n     @Override<br/>\n     public void assertXpathExists(String xpath, Document document)<br/>\nthrows TransformerException, AssertionFailedError<br/>\n     {<br/>\n         assertTrue(&quot;Expected to find xpath &quot; + xpath, xpathExists(xpath,<br/>\ndocument));<br/>\n     }<br/>\n<br/>\n     private boolean xpathExists(String xpath, Document document)<br/>\n     {<br/>\n         return evaluateXpath(xpath, document).getLength() &gt; 0;<br/>\n     }<br/>\n<br/>\n     public NodeList evaluateXpath(String xpath, Document document)<br/>\n     {<br/>\n         NodeList nodeset;<br/>\n         try<br/>\n         {<br/>\n             nodeset = (NodeList) XPathFactory.newInstance().newXPath()<br/>\n                     .evaluate(xpath, new DOMSource(document),<br/>\nXPathConstants.NODESET);<br/>\n         }<br/>\n         catch(XPathExpressionException e)<br/>\n         {<br/>\n             throw new RuntimeException(&quot;Xpath &quot; + xpath + &quot; could not be<br/>\nevaluated against document&quot;, e);<br/>\n         }<br/>\n         return nodeset;<br/>\n     }<br/>\n<br/>\n     private void<br/>\nrethrowAssertionFailedErrorWithDocumentText(AssertionFailedError e,<br/>\nDocument document)<br/>\n     {<br/>\n         try<br/>\n         {<br/>\n             throw new AssertionFailedError(e.getMessage() + &quot;&#92;n&quot; +<br/>\nasString(document));<br/>\n         }<br/>\n         catch(Exception e1)<br/>\n         {<br/>\n             throw new RuntimeException(&quot;Assertion failed and an error<br/>\nwas thrown while converting the input &quot; +<br/>\n                     &quot;Document object to a string. AssertionFailure: &quot; +<br/>\ne);<br/>\n         }<br/>\n     }<br/>\n<br/>\nYou&#39;ll note my change in direction where one assert method<br/>\n(assertXpathExists) delegates to the XMLUnit counterpart and the other<br/>\n(assertXpathExists) reimplements the idea using the JDK5 XPath API. I<br/>\ntried the idea both ways and it doesn&#39;t seem to work. It may be due to<br/>\nmy lack of understanding of both the XMLUnit and JDK Xpath APIs. I&#39;m<br/>\nsure the XPath is valid as I have confirmed it with the Idea XPath<br/>\nplugin. (In this scenario I copied the xml to a dummy XML file and<br/>\ncopied the XPath string directly from the test case and into the XPath<br/>\nplugin dialog which points me to the single matching node in question.)<br/>\nI also noticed that some of my other test cases that use the XMLUnit<br/>\nxpath asserts throw errors while yielding a green bar. The errors I get<br/>\nare below:<br/>\nSystemId Unknown; Line #1; Column #404; Prefix must resolve to a<br/>\nnamespace: xslt<br/>\nSystemId Unknown; Line #1; Column #404; A location step was expected<br/>\nfollowing the &#39;/&#39; or &#39;//&#39; token.<br/>\nSystemId Unknown; Line #1; Column #404; Extra illegal tokens: &#39;[&#39;, &#39;@&#39;,<br/>\n&#39;name&#39;, &#39;=&#39;, &#39;&#39;main&#39;&#39;, &#39;]&#39;, &#39;/&#39;, &#39;descendant&#39;, &#39;::&#39;, &#39;[&#39;, &#39;@&#39;, &#39;name&#39;,<br/>\n&#39;=&#39;, &#39;&#39;align-right&#39;&#39;, &#39;]&#39;<br/>\n<br/>\nAny ideas? Is there another forum or list where my question may be more<br/>\nappropriate?</div>", 
    "prevInTime": 18258, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1161799075", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PGVobzhqMytyOXVlQGVHcm91cHMuY29tPg=="
    }
}