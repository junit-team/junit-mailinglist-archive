{
    "numMessagesInTopic": 56, 
    "nextInTime": 6287, 
    "senderId": "l_FhgCQsIVxvmXegj7nuGIlbfA4t5OD7Z2E09qI6LTiqWv8M1u_APOKgZh9e03DqOMkvIr8qJLeD-GAGn4jvG82oOZcBdbHL9T6dEcFIADifn-x2InpfxgW6", 
    "systemMessage": false, 
    "subject": "Re: [junit] Looking for some &quot;Best Practices&quot;", 
    "from": "=?ISO-8859-1?Q?Bill_de_h=D3ra?= &lt;dehora@...&gt;", 
    "authorName": "Bill de hÓra", 
    "msgSnippet": "... Glad you asked. Normally I d say yes - you don t want cycles in an object graph. In this case I m not so sure it s a problem, because it might just be my", 
    "msgId": 6286, 
    "profile": "bdehora", 
    "topicId": 6227, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 94742758, 
    "messageBody": "<div id=\"ygrps-yiv-414139404\">Steven Taschuk wrote:<br/>\n<blockquote><span title=\"ireply\"> &gt; Quoth Bill de hÓra:<br/>\n&gt;   [...]<br/>\n&gt; <br/>\n&gt;&gt;One think I don&#39;t like about the way Junit does test suites, aside <br/>\n&gt;&gt;from the effort of remembering to add a test to a suite, is that it <br/>\n&gt;&gt;drives the dependencies downward. AllTests at the top of the tree <br/>\n&gt;&gt;has to know about all the tests or testsuites below it.<br/>\n&gt;&gt;[...] This seems to introduce cycles in Java packages [...]<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; Is there a problem with having such cycles?<br/>\n<br/>\n </span></blockquote>Glad you asked. Normally I&#39;d say yes - you don&#39;t want cycles in an <br/>\nobject graph. In this case I&#39;m not so sure it&#39;s a problem, because <br/>\nit might just be my own private definition of what clean code looks <br/>\nlike and Java seems more forgiving than C++ wrt cycles. And I&#39;m <br/>\npretty sure Gamma and Beck and the legion of developers that use and <br/>\nextend JUnit know about dependency cycles. All of which are why I&#39;m <br/>\nafter opinions - I don&#39;t get what&#39;s special about JUnit that would <br/>\nabsolve it of this matter.<br/>\n<br/>\nThe solution for me was to stop using suites, invent a marker <br/>\ninterface and have a treewalker load classes that met the interface, <br/>\nbut that&#39;s inefficient. Another option is to follow a naming <br/>\nconvention and collate the tests that way - this does stop you <br/>\nloading up classes twice, but has the disadvantage of being a <br/>\nconvention as opposed to being something actually enforceable in the <br/>\nlanguage (imo it&#39;s not much better than an ide depending on magic <br/>\ncomments).<br/>\n<br/>\nBob Martin has a section in his new book on this subject, which is <br/>\nwhy I&#39;ve thinking about it again. Cycles are to be avoided, and one <br/>\nanswer he proposes is to apply a dependency inversion to the code. <br/>\nIn Junit I think you could make this happen in Junit by allowing <br/>\nTestCases to be visted by TestSuites. That would keep the <br/>\ndependencies unidirectional with the bonus of not having constantly <br/>\ngo to back the suite and add the test cases to it, which seems to be <br/>\nthe main reason people write a test collecting treewalker - this way <br/>\nyou&#39;d just add the suite to the test instead which is where you <br/>\nhappen to be in the code.<br/>\n<br/>\nBill de hÓra</div>", 
    "prevInTime": 6285, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1038229912", 
    "canDelete": false, 
    "nextInTopic": 6287, 
    "prevInTopic": 6285, 
    "headers": {
        "messageIdInHeader": "PDNERTIyMTk4LjEwMzA4MDNAZWlyY29tLm5ldD4=", 
        "referencesHeader": "PDIwMDIxMTI0MDEzNjI0LjM2NzQzLnFtYWlsQHdlYjgyMDMubWFpbC5pbi55YWhvby5jb20+IDwzREUwRkFFMS44MDQwOTA2QGVpcmNvbS5uZXQ+IDwyMDAyMTEyNDIwNDMwMS5BMjUwNjBAdGliaWEuYW1vdGxwYWEuYm9ndXM+"
    }
}