{
    "numMessagesInTopic": 1, 
    "nextInTime": 1486, 
    "senderId": "AC7e7_1L1F_aJWca3HwM3kQBjtehjpKIYp-Ur3r-L9vaoAdqh8CBZgrg0PFxapTNwHat2sCzqiHGT1PgYBQTsULiMkw", 
    "systemMessage": false, 
    "subject": "RE: Best Practice for Tests", 
    "from": "Keith Ray &lt;keith.ray@...&gt;", 
    "authorName": "Keith Ray", 
    "msgSnippet": "[I m quoting many people here... please don t flame the lack of attributions.] ... You seem to be advocating black box testing. The XP approach is test", 
    "msgId": 1485, 
    "topicId": 1485, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 0, 
    "messageBody": "<div id=\"ygrps-yiv-181508923\">\n<html>\n<head>\n \n \n<title>RE: Best Practice for Tests </title>\n</head>\n \n\n<p><font SIZE=\"2\">[I&#39;m quoting many people here... please don&#39;t flame the lack of attributions.]</font>\n</p>\n\n<p><font SIZE=\"2\">&gt;I guess I disagree here.&nbsp; I am not convinced that package-potected methods</font>\n<br><font SIZE=\"2\">&gt;are part of a public interface.&nbsp; If they are used that way I would question</font>\n<br><font SIZE=\"2\">&gt;whether some refactoring needed to take place.&nbsp; But that&#39;s just my opinion.</font>\n<br><font SIZE=\"2\">&gt;I don&#39;t want to seem like I am picking on your design decisions.</font>\n</p>\n\n<p><font SIZE=\"2\">You seem to be advocating &quot;black box&quot; testing. </font>\n</p>\n\n<p><font SIZE=\"2\">The XP approach is &quot;test everything that could possibly break&quot;. My approach *includes* testing classes by subclassing and by calling protected methods. If a &quot;private&quot; method needs to be tested, I make it &#39;package-protected&#39;.</font></p>\n\n<p><font SIZE=\"2\">Other XPers say that if there are several &quot;private&quot; methods that need to be tested, they refactor them into another class - where they become public, and that class is used as a private member of the original class.</font></p>\n\n<p><font SIZE=\"2\">Package-protected is the Java equivalent of C++ &quot;friend&quot;, and yes I know that &quot;friend&quot;ship can be a sign of &quot;bad design&quot;, but on rare occasions, it is the best design.</font></p>\n\n<p><font SIZE=\"2\">--</font>\n</p>\n\n<p><font SIZE=\"2\">&gt;A perspective that has worked well for me is that protected methods are</font>\n<br><font SIZE=\"2\">&gt;private to the framework but not within it. So you set a method as protected</font>\n<br><font SIZE=\"2\">&gt;if it is not part of the public interface that the framework provides but it</font>\n<br><font SIZE=\"2\">&gt;does provide services to other classes within the framework or to extensions</font>\n<br><font SIZE=\"2\">&gt;to the framework (i.e. subclasses).</font>\n<br><font SIZE=\"2\">&gt;</font>\n<br><font SIZE=\"2\">&gt;So if you are testing a framework as a &#39;black box&#39; service provider, you</font>\n<br><font SIZE=\"2\">&gt;don&#39;t necessarily need to test protected methods, but if you are testing a</font>\n<br><font SIZE=\"2\">&gt;framework at a deeper level, then you might find yourself doing just that.</font>\n</p>\n\n<p><font SIZE=\"2\">Agree. </font>\n</p>\n\n<p><font SIZE=\"2\">&quot;Black Box&quot; testing is appropriate for XP Acceptance tests. Unit testing is &quot;White Box&quot; testing.</font>\n</p>\n\n<p><font SIZE=\"2\">&gt;The real issue of this sub-thread is in where to locate tests and why.&nbsp; The</font>\n<br><font SIZE=\"2\">&gt;original quote (paraphrased) was that &quot;we put tests in the same package as</font>\n<br><font SIZE=\"2\">&gt;production code to make it easier to test protected interfaces of our</font>\n<br><font SIZE=\"2\">&gt;objects.&quot;&nbsp; I don&#39;t see where this fits in to good design or good testing</font>\n<br><font SIZE=\"2\">&gt;practices.&nbsp; The virtue of public/protected/private/default is not what I was</font>\n<br><font SIZE=\"2\">&gt;questioning.&nbsp; I wanted to point out the potential flaws of design and</font>\n<br><font SIZE=\"2\">&gt;testing that could otherwise be missed when you put tests in the same</font>\n<br><font SIZE=\"2\">&gt;package as production code.&nbsp; The production code should be tested in the</font>\n<br><font SIZE=\"2\">&gt;same fashion it would be used by a client.&nbsp; A test is a client in some</font>\n<br><font SIZE=\"2\">&gt;degree.&nbsp; In most cases clients exist outside of the package.</font>\n</p>\n\n<p><font SIZE=\"2\">That would be &quot;black box testing&quot;. XP unit testing is &quot;white box&quot;. I am my own client, most classes in my application are in the same package, so most tests should also be in the same package.</font></p>\n\n<p><font SIZE=\"2\">&gt; but this is turning into a thread on Java design issues, maybe we should</font>\n<br><font SIZE=\"2\">&gt; take it elsewhere.</font>\n</p>\n\n<p><font SIZE=\"2\">Test-first-programming enabled by JUnit is a design technique. Do a google search on &quot;test-first-design&quot;.</font>\n</p>\n\n<p><font SIZE=\"2\">The XP mailing list could use some on-topic postings...</font>\n</p>\n\n<p><font SIZE=\"2\">--</font>\n</p>\n\n<p><font SIZE=\"2\">&gt;1. Code coverage analysis should be your guide in making decisions about</font>\n<br><font SIZE=\"2\">&gt;whether testing through public APIs provide thorough enough test coverage</font>\n<br><font SIZE=\"2\">&gt;(80%? 95%?, depending on the quality you&#39;re shooting for and (relevant to</font>\n<br><font SIZE=\"2\">&gt;that) the industry you&#39;re in).&nbsp; Naturally, coverage analysis will inform</font>\n<br><font SIZE=\"2\">&gt;your testing decisions, which in turn will likely inform your design</font>\n<br><font SIZE=\"2\">&gt;decisions.</font>\n</p>\n\n<p><font SIZE=\"2\">Agree</font>\n</p>\n\n<p><font SIZE=\"2\">&gt;2. In the &quot;real world&quot; of non-ideal engineering situations, a QA team or</font>\n<br><font SIZE=\"2\">&gt;engineer may well be tasked with, among other things, unit testing code or</font>\n<br><font SIZE=\"2\">&gt;working with a team of engineers who do not do unit testing and cannot be</font>\n<br><font SIZE=\"2\">&gt;convinced to do so.&nbsp; In this case, the powerful benefit of the coding-unit</font>\n<br><font SIZE=\"2\">&gt;testing feedback loop is mostly lost and severely diluted, but the QA team</font>\n<br><font SIZE=\"2\">&gt;must do its best to test whatever craziness comes its way.&nbsp; The values of</font>\n<br><font SIZE=\"2\">&gt;unit testing are diminished, but by no means entirely, even if only the QA</font>\n<br><font SIZE=\"2\">&gt;team does it. Ditto for testing legacy systems over which one had no design</font>\n<br><font SIZE=\"2\">&gt;control for historical reasons.</font>\n<br><font SIZE=\"2\">&gt;</font>\n<br><font SIZE=\"2\">&gt;Scott Stirling</font>\n<br><font SIZE=\"2\">&gt;JRun QA</font>\n<br><font SIZE=\"2\">&gt;Macromedia</font>\n</p>\n\n<p><font SIZE=\"2\">Agree. (Is Macromedia hiring, BTW?)</font>\n</p>\n\n<p><font SIZE=\"2\">--</font>\n</p>\n\n<p><font SIZE=\"2\">&gt;If you test classes, you write unit tests.</font>\n<br><font SIZE=\"2\">&gt;If you test subsystems, you write black-box or white-box tests (or </font>\n<br><font SIZE=\"2\">&gt;integration tests).</font>\n<br><font SIZE=\"2\">&gt;</font>\n<br><font SIZE=\"2\">The main goal of JUnit is to write unit tests.&nbsp; Although JUnit can be </font>\n<br><font SIZE=\"2\">&gt;used to write integration tests, it is not its main goal.&nbsp; With JUnit, </font>\n<br><font SIZE=\"2\">&gt;you have problems if you want to test the user interaction or really </font>\n<br><font SIZE=\"2\">&gt;complex systems (-&gt; use of mock objects).</font>\n</p>\n\n<p><font SIZE=\"2\">Agree</font>\n</p>\n\n<p><font SIZE=\"2\">--</font>\n</p>\n\n<p><font SIZE=\"2\">&gt;Lurker here, but I thought I&#39;d chime in to agree with</font>\n<br><font SIZE=\"2\">&gt;Vladimir on this.&nbsp; In an ideal world, test cases might</font>\n<br><font SIZE=\"2\">&gt;stay separate, but the first hurdle is often just</font>\n<br><font SIZE=\"2\">&gt;getting developers to write them, and that&#39;s a lot</font>\n<br><font SIZE=\"2\">&gt;easier to manage when the test case lives in the same</font>\n<br><font SIZE=\"2\">&gt;package as their code.</font>\n<br><font SIZE=\"2\">&gt;</font>\n<br><font SIZE=\"2\">&gt;Co-mingling increases the chances that they&#39;ll use the</font>\n<br><font SIZE=\"2\">&gt;test case for all of their incremental testing</font>\n<br><font SIZE=\"2\">&gt;(instead of writing little mini-clients or main()</font>\n<br><font SIZE=\"2\">&gt;methods to test/debug), and helps make unit testing</font>\n<br><font SIZE=\"2\">&gt;seem like part of the development process instead of a</font>\n<br><font SIZE=\"2\">&gt;post-coding chore.&nbsp; </font>\n<br><font SIZE=\"2\">&gt;</font>\n<br><font SIZE=\"2\">&gt;We can always auto-repackage stuff later, but in my</font>\n<br><font SIZE=\"2\">&gt;experience, it&#39;s not always easy to get people to go</font>\n<br><font SIZE=\"2\">&gt;back and write test cases when there&#39;s more</font>\n<br><font SIZE=\"2\">&gt;interesting work to be done.</font>\n</p>\n\n<p><font SIZE=\"2\">I agree. People have my company have done things both ways. I think we get MORE unit tests and more testing in general when the unit test source files are in the same directory as the code-under-test-source-files. Looking a directory, it is easy to see which classes are not tested.</font></p>\n\n<p><font SIZE=\"2\">class-under-test file name == class-under-test-name + &quot;.java&quot;</font>\n<br><font SIZE=\"2\">Test source file name == class-under-test-name + &quot;Test.java&quot;</font>\n</p>\n\n<p><font SIZE=\"2\">In Metrowerks CodeWarrior, it is VERY EASY to make a &#39;testing&#39; target and a &#39;release&#39; target, and to leave the all of test sources out of the release target. Each target produces a different jar file, and you can flip between targets with one mouse-click, and run the app or the tests with one more mouse-click.</font></p>\n\n<p><font SIZE=\"2\">[referring to &quot;mingling...helps make unit testing...part of the... process]</font>\n<br><font SIZE=\"2\">&gt;Why do you say that?&nbsp; I think this is pure speculation, but if you have some</font>\n<br><font SIZE=\"2\">&gt;actual metrics I would be interested in seeing them.</font>\n</p>\n\n<p><font SIZE=\"2\">&quot;Metrics, we don&#39;t need no stinking metrics!&quot;&nbsp; Why do you assume this is speculation? In my case, it is observation. It may be observation by the original poster, too.</font></p>\n\n<p><font SIZE=\"2\">&gt;Again, I am baffled at your logic, but if you have actual results please</font>\n<br><font SIZE=\"2\">&gt;share them.</font>\n</p>\n\n<p><font SIZE=\"2\">I have shared MY results... but I&#39;m not going to get in an accountant in to &quot;certify&quot; them. This isn&#39;t the academy awards or a scientific study...</font></p>\n\n<p><font SIZE=\"2\">[referring to &quot;auto-repackage later...&quot;]</font>\n<br><font SIZE=\"2\">&gt;This is a burden on the process.&nbsp; </font>\n</p>\n\n<p><font SIZE=\"2\">No it isn&#39;t! (This is the argument office, right? :-) see above.)</font>\n</p>\n\n<p><font SIZE=\"2\">&gt;Also, depending on</font>\n<br><font SIZE=\"2\">&gt;your source control system, this could be somewhat detrimental to your</font>\n<br><font SIZE=\"2\">&gt;company&#39;s history markers and metrics.&nbsp; Moving a class out of one package to</font>\n<br><font SIZE=\"2\">&gt;another (which we must do from time to time) will cause another root to be</font>\n<br><font SIZE=\"2\">&gt;formed in the new package and an orphaned leaf in the old.&nbsp; You could lose</font>\n<br><font SIZE=\"2\">&gt;valuable history.&nbsp; Not to mention that in distributed team environments</font>\n<br><font SIZE=\"2\">&gt;others may be expecting for your class(es) to be &quot;in the same ol&#39; place&quot; and</font>\n<br><font SIZE=\"2\">&gt;if you move them, you cause some degree of hassle.&nbsp; Sometimes this is</font>\n<br><font SIZE=\"2\">&gt;unavoidable, but I think it is a bad practice to get into.</font>\n</p>\n\n<p><font SIZE=\"2\">This refactoring/moving argument applies equally to keeping the tests in the same directory as well as to keeping the tests in a separate directory. By keeping the tests in a different directory, it is slightly more likely to get left behind and forgotten, when someone moves a class but not its test-class.</font></p>\n\n<p><font SIZE=\"2\">I have moved class + test around without ill effects.</font>\n</p>\n\n<p><font SIZE=\"2\">&gt;That is a fault of not doing test-first which you will face no matter where</font>\n<br><font SIZE=\"2\">&gt;the test cases live.&nbsp; The thought in my mind is that tests are an integral</font>\n<br><font SIZE=\"2\">&gt;part of the system, they drive the design for us (in XP).&nbsp; They are not some</font>\n<br><font SIZE=\"2\">&gt;special case group of bastardized objects that can be taken or not.&nbsp; They</font>\n<br><font SIZE=\"2\">&gt;are essential.</font>\n</p>\n\n<p><font SIZE=\"2\">Agree.</font>\n</p>\n\n<p><font SIZE=\"2\">&gt;Don Wells once said (I believe it was Don, if anyone knows</font>\n<br><font SIZE=\"2\">&gt;differently please correct me), &quot;Throw away my code, but never throw away my</font>\n<br><font SIZE=\"2\">&gt;tests.&quot;&nbsp; Point being that he would be able to rebuild the system again from</font>\n<br><font SIZE=\"2\">&gt;scratch if he had the tests.&nbsp; If you threw away the tests and gave him the</font>\n<br><font SIZE=\"2\">&gt;production code, he would be floundering in agony to reproduce all of those</font>\n<br><font SIZE=\"2\">&gt;tests.</font>\n<br><font SIZE=\"2\">&gt;</font>\n<br><font SIZE=\"2\">&gt;Tests are not simply obilgatory objects that satisfy some requirements from</font>\n<br><font SIZE=\"2\">&gt;management... they are the life-sustaining power of the code, in my opinion!</font>\n</p>\n\n<p><font SIZE=\"2\">Agree.</font>\n</p>\n\n<p><font SIZE=\"2\">&gt;Again, why?&nbsp; No one has yet given me one concrete answer as to why this</font>\n<br><font SIZE=\"2\">&gt;should be.&nbsp; It&#39;s all been ambiguous speculation.</font>\n</p>\n\n<p><font SIZE=\"2\">Answer these questions: is this base-class robust enough for me and anyone else to subclass? Do the protected methods that are called by the subclasses/other-classes-in-this-package work? Is making this function private going to cause hard-ship to the subclasser, unit-test-class, or other-classes-in-this-package? Is this un-tested legacy code really doing what it is supposed to be doing? (What the heck IS this un-tested legacy code doing?)</font></p>\n\n<p><font SIZE=\"2\">Finding the answers to these questions is why I sometimes test protected/&quot;private&quot; methods.</font>\n</p>\n\n<p><font SIZE=\"2\">&gt;After testing the model, I like to do integration tests for model, control</font>\n<br><font SIZE=\"2\">&gt;and view. I do this by checking the view. But as the view is used by users</font>\n<br><font SIZE=\"2\">&gt;only, there is no need to know state, at least for programm components other</font>\n<br><font SIZE=\"2\">&gt;than the tests. This approach is (Did I get you right now?) not favorable in</font>\n<br><font SIZE=\"2\">&gt;your eyes? Which would be your favorable approach?</font>\n</p>\n\n<p><font SIZE=\"2\">You can test the view without testing the model by using a mock object in place of the model.</font>\n</p>\n\n<p><font SIZE=\"2\">I sometimes test a view class by directly calling the methods that would normally be indirectly called by buttons, etc., and then seeing that the model has the correct state. I don&#39;t &quot;simulate&quot; AWT/Swing events, I just call functions of the class. I don&#39;t call the anonymous-class-methods that are listening for events because those are one-line methods that call an easily-tested method in the view class.</font></p>\n\n<p><font SIZE=\"2\">For &quot;view&quot;, see the design pattern &quot;mediator&quot;.</font>\n</p>\n\n<p><font SIZE=\"2\">&gt;MVC can be difficult.&nbsp; If it is done improperly it offers many traps!!&nbsp; But</font>\n<br><font SIZE=\"2\">&gt;done rightly, it&#39;s a wonderful tool.&nbsp; Testing is easier, refactoring is</font>\n<br><font SIZE=\"2\">&gt;easier, etc.</font>\n</p>\n\n<p><font SIZE=\"2\">Agree.</font>\n</p>\n\n<p><font SIZE=\"2\">&gt;From the QA perspective, the methods within the public API are the </font>\n<br><font SIZE=\"2\">&gt;functional methods and these methods require a</font>\n<br><font SIZE=\"2\">&gt;functional test written by the QA team.&nbsp; This means that there is </font>\n<br><font SIZE=\"2\">&gt;double coverage on testing the methods in the public</font>\n<br><font SIZE=\"2\">&gt;API and developers are not simply checking themselves.</font>\n</p>\n\n<p><font SIZE=\"2\">Agree.</font>\n</p>\n\n<p><font SIZE=\"2\">&gt;We have gotten a lot of mileage out of validation through looking at</font>\n<br><font SIZE=\"2\">&gt;internal state.&nbsp; Primarily this boils down to listening to listener</font>\n<br><font SIZE=\"2\">&gt;interfaces, and saying that the test passes if the right listeners are</font>\n<br><font SIZE=\"2\">&gt;called.</font>\n</p>\n\n<p><font SIZE=\"2\">Good separate of GUI class testing from the model testing...</font>\n</p>\n\n \n</html></div>", 
    "prevInTime": 1484, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "992374765", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PEQ5RjZCOURBQkE0Q0FFNEI5Mjg1MDI1MkM1MjM4M0FCMDEwMUY2RTdAZXgtZW5nLWNvcnA+"
    }
}