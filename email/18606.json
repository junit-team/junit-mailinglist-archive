{
    "numMessagesInTopic": 32, 
    "nextInTime": 18607, 
    "senderId": "lUToa-32BbOmuVgnA9Zwh-_c7wpB8CuBtSJBgVG3gpG6IQDH0qDkIW0-i6ubh_fomyZ57BM-RC2g8_lzzh4abTq33CeT6w", 
    "systemMessage": true, 
    "subject": "Re: [junit] Re: Thinking of improving the auto generation of test cases", 
    "from": "Ole Ersoy &lt;ole_ersoy@...&gt;", 
    "authorName": "Ole Ersoy", 
    "msgSnippet": "Sounds like a really cool idea. Another thought on that subject: We ve said earlier that Unit testing is really about good design. A good design is easy to", 
    "msgId": 18606, 
    "profile": "ole_ersoy", 
    "topicId": 18582, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 98908154, 
    "messageBody": "<div id=\"ygrps-yiv-1157047004\">Sounds like a really cool idea.<br/>\n<br/>\nAnother thought on that subject:<br/>\n<br/>\nWe&#39;ve said earlier that Unit testing is really about<br/>\ngood design.<br/>\n<br/>\nA good design is easy to unit test.  It breaks<br/>\neverything into simple little steps that are easily<br/>\nverified.<br/>\n<br/>\nThis give us reassurance that what we are running<br/>\nconsists of several easy to align dominoes that we<br/>\nknow will fall when the right pressure is applied and<br/>\nthat they won&#39;t fall when the pressure if off.<br/>\n<br/>\nThis is as opposed to a whole bunch of dominoes<br/>\nbunched up where it&#39;s tricky to find the one domino<br/>\nthat&#39;s no cooperating.<br/>\n<br/>\nAlso, it makes it easy to switch out one domino or a<br/>\ngroup of dominoes, to verify that the sequence still<br/>\nworks.<br/>\n<br/>\nSo a good design is simple, easy to validate, and easy<br/>\nto improve.<br/>\n<br/>\nHowever once a domino (Class) has been verified /<br/>\ntested in the context that it&#39;s contract describes per<br/>\nthe expectations around what it is to deliver, we can<br/>\nuse that domino and put it in sequences and should<br/>\nexclude retesting things we know have been tested<br/>\nalready.<br/>\n<br/>\nSo how do we know what&#39;s been tested already?<br/>\n<br/>\nSomething that helped isolate issues, using existing<br/>\ntest data, would be really cool.<br/>\n<br/>\nUsing reflection that possibilities of what could go<br/>\nwrong can be automagically found, then existing test<br/>\nassertions could be used to narrow the set of<br/>\npossibilities.<br/>\n<br/>\nOnce this is done, a report would be generated and<br/>\nwould suggest additional constraints (Possibly using<br/>\naspects) to put on the methods that are &quot;At risk&quot; of<br/>\nthrowing things off.<br/>\n<br/>\nSo, there would be 2 steps:<br/>\n<br/>\n1) Map a set of method input ranges to a set of<br/>\npossible outputs.  This means we know in advance what<br/>\nthe exhaustive set of inputs the method takes as<br/>\nparameters.  Aspect Preconditions on method parameters<br/>\ncould be to constrain the set so that respects this<br/>\nthe parameter rules.<br/>\n<br/>\n2) Map the input ranges to a set of possible output<br/>\nranges.  When doing this type of mapping, break the<br/>\nmap into little steps where it&#39;s easy to verify the<br/>\ninput range and output range.  Possibly have a test<br/>\nfor each range.  Break the range down if necessary and<br/>\ntest range subsets...until the test is exhaustive.<br/>\n<br/>\nSo from a practical point of view what does that mean:<br/>\n<br/>\nThis is really simple, and I probably don&#39;t have to<br/>\nlist it but what the heck: <br/>\n<br/>\nSuppose you have a method that takes to strings and<br/>\nappends them.<br/>\n<br/>\npublic String append(String 1, String2)<br/>\n{<br/>\n  return (String1 + String2)<br/>\n}<br/>\n<br/>\nThe risk here is that String1 and String2 may deviate<br/>\nfrom the values that they are allowed to have per the<br/>\ndesign context.<br/>\n<br/>\nSo we would have to put constraints on them to ensure<br/>\nthat they are correct.<br/>\n<br/>\nSuppose this is the first method, then there are<br/>\nseveral methods that occur after that method returns<br/>\nit&#39;s computed String.<br/>\n<br/>\nIf we know the exhaustive set of input strings (Say be<br/>\ncreating an Enum of them), then we know the set that<br/>\nthe method can return.<br/>\n<br/>\nSuppose there was another method that gets strings<br/>\nfrom this method.<br/>\n<br/>\nIt also has constraint on the method that describes<br/>\nthe strings allowed.<br/>\n<br/>\nSuppose that method dissallows one of the strings<br/>\nreturned by the first method.  Then that constraint<br/>\nshould be put on the first method so that the second<br/>\nmethod in the call sequence does not have to worry<br/>\nabout doing the constraint checking, since if we did<br/>\nit at every step in the call sequence it would be<br/>\ncostly.<br/>\n<br/>\nOr, it could be that we would not want to move the<br/>\nconstraint back to that call because that method also<br/>\nservices other objects, and they need that value.<br/>\n<br/>\nBut now we know to check that one possibility on the<br/>\nnext method, rather than all the possibilities.<br/>\n<br/>\nCheers,<br/>\n- Ole<br/>\n<br/>\n<br/>\n--- Bob Runstein &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:rrunstein@...\">rrunstein@...</a>&gt; wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; &gt; On 12/27/06, junitheadache<br/>\n&gt; &gt; &lt;bohs01@...&gt; wrote:<br/>\n&gt; &gt; Hi all,<br/>\n&gt; &gt; <br/>\n&gt; &gt; I am currently working on auto generation of test<br/>\n&gt; &gt; cases for TDD for<br/>\n&gt; &gt; my honors year project. And was considering<br/>\n&gt; &gt; modifying JUnit such<br/>\n&gt; &gt; that it will auto generate some test cases based<br/>\n&gt; &gt; values flagged by<br/>\n&gt; &gt; users.<br/>\n&gt; <br/>\n&gt; How about considering a project where you generate<br/>\n&gt; the unit tests by <br/>\n&gt; hand and then auto generate the production code from<br/>\n&gt; them? Now that <br/>\n&gt; would be something!<br/>\n&gt; <br/>\n&gt; Bob<br/>\n&gt; <br/>\n&gt; <br/>\n<br/>\n<br/>\n </span></blockquote>__________________________________________________<br/>\nDo You Yahoo!?<br/>\nTired of spam?  Yahoo! Mail has the best spam protection around <br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://mail.yahoo.com\">http://mail.yahoo.com</a></div>", 
    "prevInTime": 18605, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1167585571", 
    "canDelete": false, 
    "nextInTopic": 18607, 
    "prevInTopic": 18604, 
    "headers": {
        "inReplyToHeader": "PGVuNDMzMSsyZ2d1QGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PDU1NjEzLjc5NDEwLnFtQHdlYjYwNzIwLm1haWwueWFob28uY29tPg=="
    }
}