{
    "numMessagesInTopic": 10, 
    "nextInTime": 2772, 
    "senderId": "Q_rdmyrNmZhHz1HO0ioVIQA4JLqHfx0XWpXZRYkqk3iS0icaXmqRxdJgLEIwBOjFC-f2mFeDnJwzgPh-NVKvgFXz-FbO", 
    "systemMessage": false, 
    "subject": "Re: [junit] Re: Multithreaded code", 
    "from": "Eric Vought &lt;evought@...&gt;", 
    "authorName": "Eric Vought", 
    "msgSnippet": "... Ahh.., I had thought of that, but didn t want to make the example too much more complicated so that the technique was clear. Probably the easiest way to do", 
    "msgId": 2771, 
    "topicId": 2726, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 0, 
    "messageBody": "<div id=\"ygrps-yiv-734242759\">On Wed, 26 Sep 2001, Emily Bache wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Thanks Eric for an enlightening reply! The code example you have given is<br/>\n&gt; clearly more robust than what I came up with. I&#39;ve added it to my test<br/>\n&gt; suite, and (after minor modification to remove typos) it runs and passes,<br/>\n&gt; which is great.<br/>\n&gt;<br/>\n&gt; There is just one thing I&#39;m unsure of - this test proves that while one<br/>\n&gt; thread holds the lock on the record, the other thread can find out that it<br/>\n&gt; is locked by calling isRecordLocked(). However, the second thread never<br/>\n&gt; requests the lock, so it&#39;s not testing that the second thread blocks in the<br/>\n&gt; obtainLock() call until the lock becomes available. That was the requirement<br/>\n&gt; I was trying to test :-)<br/>\n<br/>\n </span></blockquote>Ahh.., I had thought of that, but didn&#39;t want to make the example too much<br/>\nmore complicated so that the technique was clear. Probably the easiest way<br/>\nto do this would be to obtain the lock in the parent thread before the<br/>\nchild starts. It&#39;s tricky to prove that something blocked, much easier to<br/>\nprove that it did not. The reason is that it&#39;s hard to tell whether a<br/>\nthread really blocked or just wasn&#39;t scheduled to run. You have to make<br/>\nsure that the thread really would have run otherwise. JDK 1.4 (beta) has a<br/>\nholdsLock() or somesuch method which allows you to tell whether a<br/>\nparticular thread has a particular lock or not, which allows you to<br/>\nsidestep this issue sometimes.<br/>\n<br/>\nIf you are running in a green threads environment, then a simple yield()<br/>\ncall is enough to cause the next equal priority thread to be<br/>\nselected in a round-robin fashion. In native thread environments, threads<br/>\nare supposed to be scheduled &quot;fairly&quot;, but there is no particular way to<br/>\nguarantee that a particular thread (of equal priority) will be scheduled<br/>\nat a particular time. Even so, yield() is usually sufficient. That is, if<br/>\nthe parent thread yields, and the child thread has not run, then you can<br/>\nassume it won&#39;t. In multiprocessing native thread environments, however,<br/>\nprocessor affinity might cause things to become rather weird.<br/>\n<br/>\nThe safest way to force the child to (try to) run then, is to make sure<br/>\nits priority is higher than that of the parent thread<br/>\nthread.setPriority(). In a green threads environment, a higher priority<br/>\nthread shall immediately pre-empt the parent. In a native threads<br/>\nenvironment, you&#39;ve done the best you can.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; You picked up on several points I was unsure of how to tackle, though, such<br/>\n&gt; as how to make my test code run in a predictable manner by avoiding timing<br/>\n&gt; issues, and making the test run as fast as possible by avoiding sleep()<br/>\n&gt; statements. I intend to refactor my other tests to use these approaches as<br/>\n&gt; far as possible.<br/>\n&gt;<br/>\n&gt; The other problem I can see is that the test code is far more complicated<br/>\n&gt; than the code being tested! (the implementations for obtainLock() and<br/>\n&gt; releaseLock() are about 5 lines each) Is that true in general for threaded<br/>\n&gt; code? Does there come a point when it is no longer worth testing that it&#39;s<br/>\n&gt; correct, and trying instead to in some way prove that it works by inspection<br/>\n&gt; and review?<br/>\n<br/>\n </span></blockquote>This is actually typical in my experience. Testing thread code is<br/>\nfairly costly. It becomes more so when you realize that you really should<br/>\nrun the tests on a broad selection of platforms if you care about<br/>\nportability. This is not only an issue of what platforms your customers<br/>\nuse or that you want to support today. Even if, for instance, you will<br/>\nonly run your code in an EJB server on Solaris (ever), you have to contend<br/>\nwith the fact that OS and VM versions will come and go and may choose a<br/>\ndifferent mechanism from the large number of permutations the spec allows.<br/>\nRunning on multiple platforms helps you ferret out bad assumptions early.<br/>\n<br/>\nWe maintain a local portability lab with over thirty platform/VM<br/>\ncombinations for just this reason. We don&#39;t run tests on all platforms<br/>\nevery time, but do choose different subsets. We have different<br/>\narchitectures (e.g.: x86, SPARC32, SPARC64, PA/RISC, PowerPC, etc),<br/>\ndifferent numbers of processors (1,2, more than 2), different OSs, and<br/>\ndifferent VMs.<br/>\n<br/>\nWe also try to cut the need for this kind of testing whenever we need to.<br/>\nWe often find we can bury most of the thread coordination for even a<br/>\ncomplex package in just one class. Often, we can get away with using<br/>\nbuiltin classes (e.g. the pipe classes in java.io) to avoid writing our<br/>\nown thread control code. Where we have to, we try to make the thread<br/>\nclasses general utilities so we can get as much as we can out of the high<br/>\ncost.<br/>\n<br/>\nIn many cases, you can get away with good, visual inspection. We seldom<br/>\nwrite unit tests to verify synchronized methods, for instance. We will<br/>\nspot check parallel access using soak/stress testing, but will not test<br/>\nanywhere near exaustively. We tend to find that exception safety is more<br/>\nerror prone and focus effort there first. Save the complex test code for<br/>\nthread coordination and control (like a job queue or the example you<br/>\nstarted with). In our logging API, for instance, we have a single<br/>\nEntryQueue class which handles queueing entries for processing, controls<br/>\nconcurrent access, synchronous/asynchronous processing, and throttling.<br/>\nThis is what we test. The rest of the code we inspect carefully but more<br/>\nor less ignore its threading aspects in regression.<br/>\n<br/>\n-- <br/>\nEric Vought<br/>\nChief Technical Officer - QLUE Consulting, Inc.<br/>\n<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:evought@...\">evought@...</a> toll-free: 888-771-3538  RTP area: 919-816-9901</div>", 
    "prevInTime": 2770, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1001602358", 
    "canDelete": false, 
    "nextInTopic": 2787, 
    "prevInTopic": 2761, 
    "headers": {
        "inReplyToHeader": "PDcwMEVBMTdBMTQyQUQzMTE4QTFFMDAwOEM3MjRCQ0I0RUI3QTBEQGFnYmdudHMwMy5hZ2JnLmludHJhbmV0Pg==", 
        "messageIdInHeader": "PFBpbmUuTE5YLjQuMzAuMDEwOTI2MTMzMzQxMC4yMjMwNS0xMDAwMDBAYnJhaW4ucWx1ZS1sYW4+"
    }
}