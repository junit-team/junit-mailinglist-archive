{
    "numMessagesInTopic": 7, 
    "nextInTime": 18520, 
    "senderId": "1csIpEr7HTYVF6fNfbaesmI-mmvxbxmxeA297vOAkFJKpVT10N--tF-ZNGtTRos1ogcFoIh-aCWq20bKJvU82Ob2p79tdfEsm5l-Sn_Mrcb3z70EIA", 
    "systemMessage": false, 
    "subject": "RE: [junit] Philosophical question--Multiple assertions in one test case", 
    "from": "&quot;David Jackman&quot; &lt;david.jackman@...&gt;", 
    "authorName": "David Jackman", 
    "msgSnippet": "I do this as well.  I always assert early on whatever assumptions my test code is making about its environment, with error messages that instruct the user what", 
    "msgId": 18519, 
    "profile": "djackmanq", 
    "topicId": 18509, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 207066460, 
    "messageBody": "<div id=\"ygrps-yiv-1045946301\">I do this as well.  I always assert early on whatever assumptions my<br/>\ntest code is making about its environment, with error messages that<br/>\ninstruct the user what they need to do to fix the situation (or at least<br/>\nwhat&#39;s missing).  It&#39;s a whole lot better to see one of those error<br/>\nmessages than some other exception that occurred because an assumption<br/>\nwasn&#39;t valid.  So, in your case, I would even say that every test should<br/>\n(in the setUp method if possible) verify that everything is in place<br/>\nwith the DAO (if such verification is possible without actually changing<br/>\nthe state).  And any time a test does change the state of the system, it<br/>\nought to verify that the state is as expected.  It&#39;s basically the &quot;fail<br/>\nfast&quot; philosophy.  As you say, it&#39;s good to limit the amount of state<br/>\nchanges occurring in a single test, but sometimes it is necessary.<br/>\n <br/>\n..David..<br/>\n<br/>\n________________________________<br/>\n<br/>\nFrom: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a> [mailto:<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>] On Behalf Of<br/>\nshefehs<br/>\nSent: Wednesday, December 06, 2006 1:52 PM<br/>\nTo: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a><br/>\nSubject: [junit] Philosophical question--Multiple assertions in one test<br/>\ncase<br/>\n<br/>\n<br/>\n<br/>\nI&#39;ve read all over the place that it&#39;s a bad idea to include multiple<br/>\nassertions in one test case, but it seems to me that sometimes it&#39;s<br/>\nvery useful. For example, I have a fairly straightforward DAO and I<br/>\nwant to test the create method. But to really test it, I need to<br/>\nretrieve it afterwards and make sure it was successfully created. And<br/>\nI need to clean it up afterwards (or the test will fail next time I<br/>\nrun it and try to create a duplicate), so I call my delete method. <br/>\nThere I&#39;ve exercised 3 methods of my DAO, not just one. So it feels<br/>\nlike it would save time to assert that each step of the process<br/>\nsucceeded. <br/>\n<br/>\nExample:<br/>\npublic void testEmployeeCRUD()<br/>\nthrows Exception<br/>\n{<br/>\nint sizeBeforeAdding = em.listEmployees().size();<br/>\n_employeeId = em.createEmployee(_fname, _lname, _jobtitle);<br/>\n<br/>\nint sizeAfterAdding = em.listEmployees().size();<br/>\nlog.debug(&quot;Created employee &quot; + _employeeId);<br/>\n//Make sure that the new list is longer than the old list<br/>\nassertTrue(&quot;Create employee failed&quot;, sizeAfterAdding&gt;sizeBeforeAdding);<br/>\n<br/>\nEmployee emp = em.getEmployee(_employeeId);<br/>\nassertEquals(&quot;getEmployee failed&quot;, emp.getLName(), _lname);<br/>\nlog.debug(&quot;Retrieved employee &quot; + emp.getLName());<br/>\n<br/>\nem.deleteEmployee(emp);<br/>\n<br/>\nint sizeAfterDelete = em.listEmployees().size();<br/>\n<br/>\n//Make sure that the length of the list after delete <br/>\n//is the same as it was before we added<br/>\nassertEquals(&quot;Delete employee failed&quot;, sizeAfterDelete,<br/>\nsizeBeforeAdding);<br/>\nlog.debug(&quot;Deleted employee&quot;);<br/>\n}<br/>\n<br/>\nThe preceding code works just fine. If the test fails, I&#39;d look in<br/>\nthe failure message to see which part of it failed, and it seems like<br/>\nthat&#39;s not too difficult. I know it&#39;s not following best practices<br/>\nbecause it calls 4 separate methods, but when I tried writing a test<br/>\nfor each of those methods, I ended up either calling the other ones in<br/>\nthe setup/teardown or by essentially recreating them in a sample data<br/>\nloading operation. I&#39;m trying to do good TDD and to convince a<br/>\ncolleague who resists unit tests at all, so I don&#39;t want to do things<br/>\n&quot;wrong&quot; but I also don&#39;t want to make life tremendously more difficult<br/>\nwithout understanding the real reason behind the recommendations.<br/>\n<br/>\nDoes anyone have any thoughts on this principle? I appreciate the<br/>\nintelligent exchanges I&#39;ve seen on the list in the past so I hope to<br/>\nget a thoughtful discussion going.<br/>\n<br/>\nThanks very much!<br/>\nJulie<br/>\n<br/>\n<br/>\n<br/>\n <br/>\n<br/>\n<br/>\n[Non-text portions of this message have been removed]</div>", 
    "prevInTime": 18518, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1165597982", 
    "canDelete": false, 
    "nextInTopic": 18520, 
    "prevInTopic": 18511, 
    "headers": {
        "inReplyToHeader": "PGVsN2FncCtkaTJwQGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PDBFMEU5QUVDNjJEMUZDNDA4QjUwMjRCQ0ZEQTg4NkVBQUVGMkMxQHNsY2VzMDEuYWQuZmFzdC5ubz4="
    }
}