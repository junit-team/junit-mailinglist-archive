{
    "numMessagesInTopic": 8, 
    "nextInTime": 22935, 
    "senderId": "x9d5dsMRKmckrKSLZmGBhIwvw2iKo7l26vaRDGCLlUFajxNPOin0VLhPExqKxMbj0oey9RyYif4uCnBK11kHIy2F", 
    "systemMessage": false, 
    "subject": "Re: [junit] Common Test Runner for JVM", 
    "from": "David Saff &lt;david@...&gt;", 
    "authorName": "David Saff", 
    "msgSnippet": "Esko, This is a lot to absorb all at once.  I d love to go down the list and see what makes sense outside JUnit vs. inside JUnit.  I notice that a number of", 
    "msgId": 22934, 
    "profile": "dsaff", 
    "topicId": 22933, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 341876227, 
    "messageBody": "<div id=\"ygrps-yiv-535885026\">Esko,<br/>\n<br/>\nThis is a lot to absorb all at once.  I&#39;d love to go down the list and<br/>\nsee what makes sense outside JUnit vs. inside JUnit.  I notice that a<br/>\nnumber of the issues you&#39;re tackling are mostly about IDE<br/>\nintegration--I wonder if thinking about the interface you wish IDEs<br/>\nwould talk to, and then getting at least one IDE to agree to it, would<br/>\nbe a good approach.  I&#39;ve tackled a few of your questions below--going<br/>\ndeep on one of them, of your choice, might be the most productive way<br/>\nforward, rather than trying to hit all of them at once.<br/>\n<br/>\n   David Saff<br/>\n<br/>\n<blockquote><span title=\"qreply\"> On Sat, Sep 11, 2010 at 6:08 PM, Esko Luontola &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:esko.luontola@...\">esko.luontola@...</a>&gt; wrote:<br/>\n&gt; I&#39;ll soon start writing a new test runner - a common test runner for the<br/>\n&gt; JVM, codename CTR4J. It will provide a superset of JUnit&#39;s test runner&#39;s<br/>\n&gt; features, while at the same time overcoming some of JUnit&#39;s limitations<br/>\n&gt; and helping integration with development tools. I would like to hear<br/>\n&gt; your opinions on this project.<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;        MOTIVATION<br/>\n&gt;<br/>\n&gt; JUnit&#39;s test runner - especially the org.junit.runner.RunWith annotation<br/>\n&gt; - has been very successful in providing a common interface for running<br/>\n&gt; tests from multiple testing frameworks. If a testing framework provides<br/>\n&gt; a org.junit.runner.Runner implementation, every Java build tool and IDE<br/>\n&gt; will automatically support the framework.<br/>\n&gt;<br/>\n&gt; However with the rise of Scala testing frameworks (Specs, ScalaTest,<br/>\n&gt; Specsy - the last one being written by me), some limitations of JUnit&#39;s<br/>\n&gt; test runner are coming to the fore:<br/>\n&gt;<br/>\n&gt; - JUnit makes an implicit assumption that all tests are known before any<br/>\n&gt; test code is executed. For example IntelliJ IDEA calls<br/>\n&gt; Runner.getDescription() before calling Runner.run() and has problems if<br/>\n&gt; the descriptions change during test execution. But in the Scala testing<br/>\n&gt; frameworks, in order to achieve a concise syntax, test declarations are<br/>\n&gt; implemented as method calls in the class constructor, which means that<br/>\n&gt; at least some of the test code must be executed before it is known that<br/>\n&gt; what tests there are.<br/>\n<br/>\nThere are advantages to the &quot;declare everything before running<br/>\nanything&quot; requirement from JUnit, but I agree that it also makes some<br/>\nthings very difficult.  I&#39;d love to see a standard way to address this<br/>\nwithin JUnit.<br/>\n<br/>\n&gt; - JUnit doesn&#39;t know the concept of nested tests. It knows the concept<br/>\n&gt; of suites containing suites, but not &quot;test methods&quot; which contain other<br/>\n&gt; &quot;test methods&quot;. But at least Specs and Specsy allow organizing tests<br/>\n&gt; into unlimitedly nested closures. For them this limitation means that<br/>\n&gt; IDEs are not able to show the right mental model of what is really<br/>\n&gt; happening during test execution, which makes understanding test output<br/>\n&gt; harder.<br/>\n<br/>\nIn terms of IDE integration, JUnit just reports a tree of<br/>\nDescriptions, and results against them.  Runners are free to structure<br/>\nthese trees however they wish.  Have you run into IDE limitations for<br/>\ndisplaying/interacting with these trees?<br/>\n<br/>\n&gt; - There is an implicit assumption that test names are the same as method<br/>\n&gt; names, and that the tests are implemented as methods. For example in<br/>\n&gt; IntelliJ IDEA it&#39;s possible to navigate from the test results into test<br/>\n&gt; methods. But with the Scala frameworks this is not possible, because the<br/>\n&gt; test names to not correspond any method declaration (and a string search<br/>\n&gt; is not 100% reliable because the test name could be generated<br/>\n&gt; dynamically or there could be multiple tests with the same name; at<br/>\n&gt; least Specsy allows duplicate names).<br/>\n<br/>\nThat assumption is in the IDE&#39;s.  It&#39;s a useful one, but it&#39;s neither<br/>\nrequired nor assumed by JUnit itself.<br/>\n<br/>\n&gt; There are also some other limitations which affect all Java testing<br/>\n&gt; frameworks:<br/>\n&gt;<br/>\n&gt; - When a test prints something, IntelliJ IDEA collects what is printed<br/>\n&gt; to stdout and stderr, so that when you select a test in the test<br/>\n&gt; results, it will show only what that test printed. This is very useful<br/>\n&gt; for debugging with println-statements. But because there is no<br/>\n&gt; synchronization between the test runner and the IDE which reads the<br/>\n&gt; stdout/err, IDEA doesn&#39;t always associate what a test printed with the<br/>\n&gt; correct test, especially when the tests are very fast.<br/>\n<br/>\n<br/>\n&gt; - No built-in support for executing the tests in parallel. Third-party<br/>\n&gt; tools are needed for it.<br/>\n<br/>\nWe&#39;ve taken several stabs at this.  The biggest hurdle is how to<br/>\nextend the test-definition language: while many tests can be<br/>\nparallelized without cost, and test writers should not depend on<br/>\norder, they currently might depend on only test being written at the<br/>\ntime.<br/>\n<br/>\n&gt; Possibly because of being faced with the above limitations, at least<br/>\n&gt; Specs, ScalaTest and TestNG have implemented their own test runners.<br/>\n&gt; This in turn means that the IDEs need to support each test runner<br/>\n&gt; individually, which results in varying levels of quality and features<br/>\n&gt; between the integration with different test runners. For example, at<br/>\n&gt; least some time ago, IDEA&#39;s Scala plugin did not support automatically<br/>\n&gt; finding all Specs tests in the project and executing them.<br/>\n<br/>\nTest discovery seems to be yet another feature of a common IDE interface.<br/>\n<br/>\n&gt; There is also code duplication inside and between all IDEs, build tools<br/>\n&gt; and CI servers because they have had to write code to keep track of the<br/>\n&gt; test execution state, and that needs to be repeated for each test runner.<br/>\n<br/>\n<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;        THE PROJECT<br/>\n&gt;<br/>\n&gt; I&#39;ll soon start writing a test runner to solve the above mentioned<br/>\n&gt; limitations and to ease the integration with build tools, IDEs, CI<br/>\n&gt; servers etc. The license will be Apache License 2.0. I&#39;m also thinking<br/>\n&gt; of making this not only open source, but also &quot;open development&quot;, by<br/>\n&gt; screencasting similar to <a rel=\"nofollow\" target=\"_blank\" href=\"http://jamesshore.com/Blog/Lets-Play/\">http://jamesshore.com/Blog/Lets-Play/</a><br/>\n&gt;<br/>\n&gt; What the test runner will provide to testing frameworks, is a superset<br/>\n&gt; of the features provided by these JUnit classes: RunWith, Runner,<br/>\n&gt; Description, RunNotifier. The API will be a bit more generic and with<br/>\n&gt; new abstractions, in order to support for example nested tests.<br/>\n&gt;<br/>\n&gt; What the test runner will provide to IDEs, build tools and CI servers,<br/>\n&gt; is a library for launching the tests in a new VM instance, monitoring<br/>\n&gt; the test execution status, collecting the test results and what was<br/>\n&gt; printed to stdout/err etc. The tools just need to configure the<br/>\n&gt; classpath and choose which tests to run (e.g. using file name patters).<br/>\n&gt; I will also provide a reference implementation of an UI for running the<br/>\n&gt; tests, because running tests as part of the TDD cycle is too important a<br/>\n&gt; feature for its usability to be left in the hands of programmers without<br/>\n&gt; interaction design skills.<br/>\n&gt;<br/>\n&gt; What the test runner will provide to users, is running tests from all<br/>\n&gt; testing frameworks (which support this runner or JUnit&#39;s test runner) in<br/>\n&gt; one suite, running them in parallel on multiple CPU cores (I&#39;ll tackle<br/>\n&gt; parallelization over multiple machines as a separate project, probably<br/>\n&gt; as a commercial tool), integration with every development tool on the<br/>\n&gt; JVM (I intend to contact all tool vendors and gather requirements from<br/>\n&gt; them to ease the integration) and reliability (backwards compatiblity is<br/>\n&gt; very important to me, and I plan on making it possible for each tool<br/>\n&gt; vendor to write integration tests, which will be run as part of the test<br/>\n&gt; runner&#39;s development builds, to detect any breaking changes).<br/>\n&gt;<br/>\n&gt; So, I would like to ask for your opinion on this project. Here are some<br/>\n&gt; questions:<br/>\n&gt;<br/>\n&gt; - Do you find this useful?<br/>\n&gt;<br/>\n&gt; - If you had the possibility to rewrite JUnit&#39;s test runner, without<br/>\n&gt; having to think about backwards compatibility, what would you do<br/>\n&gt; differently? @RunWith&#39;s javadoc says: &quot;We added this feature late in<br/>\n&gt; development. While it seems powerful we expect the runner API to change<br/>\n&gt; as we learn how people really use it. Some of the classes that are<br/>\n&gt; currently internal will likely be refined and become public.&quot;<br/>\n&gt;<br/>\n&gt; - What do you think would be a good name for the project? One suggestion<br/>\n&gt; is CTR4J (actually named similar to SLF4J) which is googleable, but<br/>\n&gt; perhaps not very pronounceable or memorable.<br/>\n&gt;<br/>\n&gt; - What would be a good name for the annotation which corresponds<br/>\n&gt; @RunWith? Its name needs to be different to be googleable and to make it<br/>\n&gt; easy to annotate a class with both JUnit&#39;s and this test runner&#39;s<br/>\n&gt; annotation.<br/>\n&gt;<br/>\n&gt; - Any other thoughts?<br/>\n&gt;<br/>\n&gt; --<br/>\n&gt; Esko Luontola<br/>\n&gt; www.orfjackal.net<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; ------------------------------------<br/>\n&gt;<br/>\n&gt; Yahoo! Groups Links<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 22933, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1284386948", 
    "canDelete": false, 
    "nextInTopic": 22935, 
    "prevInTopic": 22933, 
    "headers": {
        "inReplyToHeader": "PDRDOEJGREU3LjMwMTA2MDNAZ21haWwuY29tPg==", 
        "messageIdInHeader": "PEFBTkxrVGluNEFYazhCR2NiWEdmbTY4S1FGekxxYlZ6ayttMjJDcmNVZ1J0MUBtYWlsLmdtYWlsLmNvbT4=", 
        "referencesHeader": "PDRDOEJGREU3LjMwMTA2MDNAZ21haWwuY29tPg=="
    }
}