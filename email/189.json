{
    "numMessagesInTopic": 5, 
    "nextInTime": 190, 
    "senderId": "POTaWpSHKF1uqH01Qjw2sC2jUcCnweqZLDd0V1UUX3dsMu0f44_0gOTN9AVWqiFJ1q3yVwOwsSvoaKOrIcW8XmZtgd8z8edQ8Vg", 
    "systemMessage": false, 
    "subject": "Re: [junit] Digest Number 43", 
    "from": "&quot;Scott Eade&quot; &lt;seade@...&gt;", 
    "authorName": "Scott Eade", 
    "msgSnippet": "... that is being tested.  I am actually writing several hundred test cases for code written by someone else - working this way it makes much more sense to", 
    "msgId": 189, 
    "topicId": 188, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 0, 
    "messageBody": "<div id=\"ygrps-yiv-1636570011\"><blockquote><span title=\"ireply\">&gt; &gt; The motivation for this extension is that most test cases contain a whole bunch of assertions following the code<br/>\n </span></blockquote>that is being tested.  I am actually writing several hundred test cases for code written by someone else - working this<br/>\nway it makes much more sense to test a feature to death in a single test case rather than writing a separate test case<br/>\nfor each aspect of a feature.  I have test cases that include 100 assertions with up to like 80 failures (I currently<br/>\nhave to comment out lines containing failures in order to continue processing).  Writing 100 separate test cases would<br/>\nnot be practical and would actually make the test results harder to interpret.<br/>\n<blockquote><span title=\"ireply\"> &gt;<br/>\n&gt; Are the 100 separate test cases really impractical? Can you refactor your test code to make new tests easy to write?<br/>\n </span></blockquote>Perhaps writing several test classes to cover different aspects of the target code? The test-per-method makes things<br/>\nvery obvious, gives you somewhere to put a name for the test and can be easier to manage as your code evolves.<br/>\n<br/>\nI do have many smaller test cases but there quite a few that do include a lot of assertions (say 150 out of 400 test<br/>\ncases).  The fact that so many assertions fail is symptomatic of the fact that the testing code is being written<br/>\nseparately from the application code and that the application is the initial prototype of something that is unlikely to<br/>\nbecome a product for quite a while yet.<br/>\n<br/>\nWhile I could cut the test into a number of pieces there are a some good reasons as to why I have not done so:<br/>\n1. A single application method invocation often has multiple effects that need several assertions to test - no matter<br/>\nwhich assertions fail, the same piece of functionality (or chunk of application code) needs to be fixed.  I imagine this<br/>\nis a fairly common scenario but that it doesn&#39;t normally generate too many assertions.<br/>\n2. In this particular instance I have to deal with application methods whose arguments are encoded in String objects - a<br/>\nsingle method may have a varying number of encoded arguments of different types but as far as Java is concerned they<br/>\ntake a single String argument.  Now no matter which form of the encoded arguments is being used a single piece of<br/>\nfunctionality (application code) is involved.  I think it makes sense to test all combinations of the encoded arguments<br/>\nin a single test case - the developer should keep running the test case and fixing their code until it runs all the way<br/>\nthrough.<br/>\n3. Often we have a bunch of related methods that each take the same variations of encoded arguments - there is a high<br/>\nprobability that these are all going to behave in the same way, i.e. if one works they will all work but if one fails...<br/>\nIt makes sense to me to group these into a single test case - why have several test cases fail that all point to the<br/>\nsame problem.<br/>\n4. Often we have a set of methods whose effect on a common set of data values is closely coupled.  It seems to me that<br/>\nthese methods should work in complete harmony or not at all and thus I have grouped the testing of these methods<br/>\ntogether in the same test case.<br/>\n<br/>\nI agree that as a rule you should attempt to make your test cases as small and specific as possible but I think in this<br/>\nparticular instance I have some good reasons for writing larger test cases that include large numbers of assertions.<br/>\n<br/>\nThe desire to have JUnit continue running a method after an assertion failure is simply to get a metric of test success<br/>\nto use across testing runs.  A developer may fix some aspect of a method but the test case will continue to fail - if<br/>\nhowever they could see that the number of failures in the test case had decreased then they would have some idea that<br/>\nthey were making progress.<br/>\n<br/>\nScott</div>", 
    "prevInTime": 188, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "978655056", 
    "canDelete": false, 
    "nextInTopic": 190, 
    "prevInTopic": 188, 
    "headers": {
        "messageIdInHeader": "PDAxODcwMWMwNzZhZiRiNDM2MzY2MCQwMTAwYThjMEBzY29vYnkwMD4=", 
        "referencesHeader": "PDk3ODYzMzI4Mi40Mjk3QGVncm91cHMuY29tPiA8MDA2MzAxYzA3NmEwJDE3NWJhMWUwJDAxODBhNGMwQGdhdGV3YXk+"
    }
}