{
    "numMessagesInTopic": 47, 
    "nextInTime": 15127, 
    "senderId": "AiFJhwsx6eEUE49-VPuoRIUREbdzeglJ8OGcebSDxHpZC8lIpIPuSBhDB2bJIJgbjl_-UYtZ0Kp72Y6JPwthGARr3Mo", 
    "systemMessage": false, 
    "subject": "Re: [junit] Proposed parameterized test syntax for JUnit 4", 
    "from": "Eugene Kuleshov &lt;eu@...&gt;", 
    "authorName": "Eugene Kuleshov", 
    "msgSnippet": "... Let me give an example. Imagine you have a statefull facade under test with has 5 methods: first one take no params, second - one param, third - two", 
    "msgId": 15126, 
    "rawEmail": "Return-Path: &lt;eu@...&gt;\r\nX-Sender: eu@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (qmail 96806 invoked from network); 13 Oct 2005 04:06:39 -0000\r\nReceived: from unknown (66.218.66.216)\n  by m8.grp.scd.yahoo.com with QMQP; 13 Oct 2005 04:06:39 -0000\r\nReceived: from unknown (HELO god.md.pp.ru) (64.56.237.27)\n  by mta1.grp.scd.yahoo.com with SMTP; 13 Oct 2005 04:06:38 -0000\r\nReceived: from d141-208-169.home.cgocable.net ([24.141.208.169] helo=[192.168.1.101])\n\tby god.md.pp.ru with esmtpsa (TLSv1:AES256-SHA:256)\n\t (Exim 4.50 #1)\n\tid 1EPuLz-0004AW-PJ\n\tfor junit@yahoogroups.com; Thu, 13 Oct 2005 00:06:27 -0400\r\nMessage-ID: &lt;434DDD20.10706@...&gt;\r\nDate: Thu, 13 Oct 2005 00:05:52 -0400\r\nUser-Agent: Mozilla Thunderbird 1.0+ (Windows/20050531)\r\nMIME-Version: 1.0\r\nTo: junit@yahoogroups.com\r\nReferences: &lt;E1ENGSY-0004ww-AA@...&gt; &lt;4344461D.3050703@...&gt; &lt;4344644B.404@...&gt; &lt;43453771.9070509@...&gt; &lt;434D355E.7060402@...&gt; &lt;434DD3D0.1050901@...&gt;\r\nIn-Reply-To: &lt;434DD3D0.1050901@...&gt;\r\nContent-Type: text/plain; charset=UTF-8; format=flowed\r\nContent-Transfer-Encoding: 7bit\r\nX-Spam-Score: -2.9 (--)\r\nX-eGroups-Msg-Info: 1:12:0:0\r\nFrom: Eugene Kuleshov &lt;eu@...&gt;\r\nSubject: Re: [junit] Proposed parameterized test syntax for JUnit 4\r\nX-Yahoo-Group-Post: member; u=150395705; y=nMmtvJ2MnE40vUQR9Qt7k02tXcKOPdxb8xpO3WfVR3G0tENL\r\nX-Yahoo-Profile: ekuleshov\r\n\r\nJ. B. Rainsberger wrote:\n\n&gt;&gt;   For instance, if you look at typical facade pattern, it is quite\n&gt;&gt;often that it would change different parts of the internal state but\n&gt;&gt;we still need to test it as a single entity. I am pretty sure that\n&gt;&gt;facade is not only case for this.\n&gt; \n&gt; I have to admit that I can&#39;t make the connection between this paragraph \n&gt; and the subject of this thread.\n\n   Let me give an example. Imagine you have a statefull facade under \ntest with has 5 methods: first one take no params, second - one param, \nthird - two params, etc.\n\n   Should we follow your rules and break this facade into 5 classes? \nShould we then write separate unit test class for each of those new classes?\n\n   The way I see it: there should be single test class with several \nparameterized test cases (so several parm generators) and test case \nwould test a single test. In order to keep such construction compact you \ncan move most of the code into the declarative test definition, like how \ninput should look like and what to assert on the output, then test code \nitself could just iterate trough the rules for each given test case \n(before and then after test). Unfortunately this leads to soft-typed \ndynamic bindings and evaluation and as a result practically usable only \nin completely generated tests.\n\n&gt; My point is pretty straightforward: we have these refactoring rules we \n&gt; often follow and we usually say that we should refactor tests like we \n&gt; refactor production code, so why wouldn&#39;t we apply these refactoring \n&gt; rules to tests?\n\n   I don&#39;t quite agree with this. Tests should be simple enough to \nrequire no refactorings at all. Applying OOP patters to the tests may \nlead to fragile test code that will require too much maintenance, \nespecially if code under test is being structurally changed.\n\n&gt;&gt; &gt; Why wouldn&#39;t we follow those rules with JUnit test case classes? The\n&gt;&gt; &gt; first rule extracts common setup code into setUp() and fixture objects.\n&gt;&gt; &gt; The second splits test case classes that have multiple fixtures into\n&gt;&gt; &gt; separate test case classes. This leads to test case classes organized\n&gt;&gt; &gt; around fixtures.\n&gt;&gt; &gt;\n&gt;&gt; &gt; As for one test case per model class, that&#39;s a natural place to start,\n&gt;&gt; &gt; because it&#39;s simple, but once that test case class becomes complex,\n&gt;&gt; &gt; refactor as usual.\n&gt;&gt;\n&gt;&gt;   That usually would lead to confusion and will require special tools\n&gt;&gt;to track down all the test cases for given class.\n&gt; \n&gt; I have /never/, /ever/ wanted to track down all the tests for a given \n&gt; class. I /have/ wanted to track down all the tests for a given /method/, \n&gt; which is dirt simple in any decent IDE. (In Eclipse, I hit Ctrl+Shift+G.)\n\n   Can you then run ALL tests you found in a search view?\n   Can these results guarantee that changed method under test didn&#39;t \naffected other methods and you don&#39;t have to run all tests for them too?\n\n&gt;&gt; &gt; To say that JUnit supports or doesn&#39;t support this way of organizing\n&gt;&gt; &gt; tests sounds odd to me. I don&#39;t organize my tests a certain way; I\n&gt;&gt; &gt; refactor the tests, and that&#39;s where they tend to end up.\n&gt;&gt;\n&gt;&gt;   By the way, I believe that such freely-organized test cases will be\n&gt;&gt;affected a lot when doing massive code refactorings and/or moving\n&gt;&gt;things around classses. So, I&#39;d say it is always a tread off and has\n&gt;&gt;to be considered in a case by case base.\n&gt; \n&gt; You /believe/ this? or it&#39;s your experience? In my /experience/ it just \n&gt; isn&#39;t that much of an issue.\n\n   It could be not an issue for unit testing of the isolated classes, \nbut it is quite different if those classes have more or less complex \ndependencies (e.g. those that may be injected by IoC container in real \napp, but mocked or stubbed in a test time). That perhaps problem with \nthe toolset because such testing usually introduces lot of dynamic \ndependencies only resolved or even generated in the runtime.\n\n   regards,\n   Eugene\n\n\n", 
    "profile": "ekuleshov", 
    "topicId": 14820, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 150395705, 
    "prevInTime": 15125, 
    "contentTrasformed": false, 
    "postDate": "1129176352", 
    "canDelete": false, 
    "nextInTopic": 15128, 
    "prevInTopic": 15124, 
    "headers": {
        "inReplyToHeader": "PDQzNEREM0QwLjEwNTA5MDFAcm9nZXJzLmNvbT4=", 
        "messageIdInHeader": "PDQzNERERDIwLjEwNzA2QG1kLnBwLnJ1Pg==", 
        "referencesHeader": "PEUxRU5HU1ktMDAwNHd3LUFBQHNtdHBhdXRoMDUubWFpbC5hdGwuZWFydGhsaW5rLm5ldD4gPDQzNDQ0NjFELjMwNTA3MDNAbWQucHAucnU+IDw0MzQ0NjQ0Qi40MDRAbWV0YWxhYi51bmMuZWR1PiA8NDM0NTM3NzEuOTA3MDUwOUByb2dlcnMuY29tPiA8NDM0RDM1NUUuNzA2MDQwMkBtZC5wcC5ydT4gPDQzNEREM0QwLjEwNTA5MDFAcm9nZXJzLmNvbT4="
    }
}