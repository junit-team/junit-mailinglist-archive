{
    "numMessagesInTopic": 13, 
    "nextInTime": 23644, 
    "senderId": "WztwGrmnRfX57U2scNk0shzwzEskuKDRXFJyCtCh_XQ33k8CwZ0RkWHO5aV7KI5brF_PAFPw_IIa6q8eirJdDI6mlZUH1EgfTD3tDwL-Cw9RyAC8Yvq4HqI", 
    "systemMessage": false, 
    "subject": "Re: Feature request: @Assumes", 
    "from": "Stephen Connolly &lt;stephen.alan.connolly@...&gt;", 
    "authorName": "Stephen Connolly", 
    "msgSnippet": "https://github.com/junit-team/junit.contrib/pull/5 ... [Non-text portions of this message have been removed]", 
    "msgId": 23643, 
    "rawEmail": "Return-Path: &lt;stephen.alan.connolly@...&gt;\r\nReceived: (qmail 9232 invoked by uid 7800); 15 Sep 2011 11:50:17 -0000\r\nX-Sender: stephen.alan.connolly@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nX-Received: (qmail 13979 invoked from network); 15 Sep 2011 11:44:48 -0000\r\nX-Received: from unknown (98.137.34.45)\n  by m6.grp.sp2.yahoo.com with QMQP; 15 Sep 2011 11:44:48 -0000\r\nX-Received: from unknown (HELO mail-ww0-f44.google.com) (74.125.82.44)\n  by mta2.grp.sp2.yahoo.com with SMTP; 15 Sep 2011 11:44:48 -0000\r\nX-Received: by wwf22 with SMTP id 22so3563550wwf.1\n        for &lt;junit@yahoogroups.com&gt;; Thu, 15 Sep 2011 04:44:23 -0700 (PDT)\r\nMIME-Version: 1.0\r\nX-Received: by 10.227.157.149 with SMTP id b21mr1001136wbx.95.1316087062858;\n Thu, 15 Sep 2011 04:44:22 -0700 (PDT)\r\nX-Received: by 10.227.129.18 with HTTP; Thu, 15 Sep 2011 04:44:22 -0700 (PDT)\r\nIn-Reply-To: &lt;CA+nPnMxRzpX1Ych3YhM_H4xz9pCy0DODDjnxM7LLPXTvnrbt6g@...&gt;\r\nReferences: &lt;CA+nPnMwbfNvxbhqjWVyXW7UDt2VM5TzwWzwAiRJaHkKrnHzmxQ@...&gt;\n\t&lt;CA+nPnMyQPw_hmB5PZjY5tO7LdhSvXJkb7Nn9JFZreB1Vy5P8ow@...&gt;\n\t&lt;CACj8BuOn5eFmNfSxP-RzV3rM331VeD0EHS_fOzwEmPbnjTuU6A@...&gt;\n\t&lt;CA+nPnMxRzpX1Ych3YhM_H4xz9pCy0DODDjnxM7LLPXTvnrbt6g@...&gt;\r\nDate: Thu, 15 Sep 2011 12:44:22 +0100\r\nMessage-ID: &lt;CA+nPnMzmbGepQorCpyhOrJy=Y2FXkeUhfd1PzFfCmbrMdb9cKQ@...&gt;\r\nTo: &quot;junit@yahoogroups.com&quot; &lt;junit@yahoogroups.com&gt;\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: Stephen Connolly &lt;stephen.alan.connolly@...&gt;\r\nSubject: Re: Feature request: @Assumes\r\nX-Yahoo-Group-Post: member; u=458231986; y=akqFO-Lm6s3XwdpA3dwHFSg1QsUIaNjoUUAkdVtdIzx6epUMt7fQIUc2JxaMbw\r\nX-Yahoo-Profile: stephenalanconnolly\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\nX-eGroups-Approved-By: mark_l_salter &lt;marksalter@...&gt; via email; 15 Sep 2011 11:50:17 -0000\r\n\r\nhttps://github.com/junit-team/junit.contrib/pull/5\n\nOn Wednesday, 14 September 2011, Stephen Connolly wrote:\n\n&gt; On Wednesday, 14 September 2011, David Saff wrote:\n&gt;\n&gt;&gt; Stephen,\n&gt;&gt;\n&gt;&gt; I can see how this could be useful.  It shouldn&#39;t be too hard to try\n&gt;&gt; it out as a custom runner:\n&gt;&gt; - subclass BlockJUnit4ClassRunner\n&gt;&gt; - override computeTestMethods to order the methods based on assumptions\n&gt;&gt; - override methodBlock to notice when tests fail, and use that to mark\n&gt;&gt; assumption failures on later tests.\n&gt;&gt;\n&gt;&gt; Would you be interested in contributing something like this to\n&gt;&gt; junit.contrib?\n&gt;&gt;\n&gt;&gt;\n&gt; As a proof of concept, implementing as a custom runner is fine, but\n&gt; ultimately it would need some hooks that can feed back to Request.sort(...)\n&gt; as, IIUC, that applies after the Runner&#39;s sorting and this would really be\n&gt; enforcing restrictions on the final order.\n&gt;\n&gt; Where do I git clone and send the pull request for junit.contrib or is that\n&gt; just a package space in the standard junit git repo?\n&gt;\n&gt; -Stephen\n&gt;\n&gt;\n&gt;&gt;   David Saff\n&gt;&gt;\n&gt;&gt; On Wed, Sep 14, 2011 at 6:02 AM, Stephen Connolly\n&gt;&gt; &lt;stephen.alan.connolly@...&gt; wrote:\n&gt;&gt; &gt; Note: I have also posted this to junit-devel@... but\n&gt;&gt; &gt; I think that wider input could be beneficial\n&gt;&gt; &gt;\n&gt;&gt; &gt; Consider the case where you are testing a List class...\n&gt;&gt; &gt;\n&gt;&gt; &gt; we have\n&gt;&gt; &gt;\n&gt;&gt; &gt; public class ListTest {\n&gt;&gt; &gt;\n&gt;&gt; &gt;  @Test\n&gt;&gt; &gt;  public void newListIsEmpty() {\n&gt;&gt; &gt;    assertThat(new List().isEmpty(), is(true);\n&gt;&gt; &gt;  }\n&gt;&gt; &gt;\n&gt;&gt; &gt;  @Test\n&gt;&gt; &gt;  public void newListHasSizeZero() {\n&gt;&gt; &gt;    assertThat(new List().size(), is(0));\n&gt;&gt; &gt;  }\n&gt;&gt; &gt;\n&gt;&gt; &gt;  @Test\n&gt;&gt; &gt;  public void addPutsAnElementIntoAnEmptyList() {\n&gt;&gt; &gt;    List l = new List();\n&gt;&gt; &gt;    l.add(new Object());\n&gt;&gt; &gt;    assertThat(l.isEmpty(), is(false));\n&gt;&gt; &gt;  }\n&gt;&gt; &gt;\n&gt;&gt; &gt;  @Test\n&gt;&gt; &gt;  public void addIncreasesSizeOfPopulatedListByOne() {\n&gt;&gt; &gt;    List l = new List();\n&gt;&gt; &gt;    l.add(new Object());\n&gt;&gt; &gt;    int s = l.size();\n&gt;&gt; &gt;    l.add(new Object());\n&gt;&gt; &gt;    assertThat(l.size(), is(s + 1));\n&gt;&gt; &gt;  }\n&gt;&gt; &gt;\n&gt;&gt; &gt; }\n&gt;&gt; &gt;\n&gt;&gt; &gt; We now want to add some tests of the delete functionality... but the\n&gt;&gt; &gt; reality is that until/unless some of the preceding tests are passing,\n&gt;&gt; &gt; the tests for delete are meaningless. We could have a perfectly\n&gt;&gt; &gt; functional List.delete() method but until such time as the above tests\n&gt;&gt; &gt; are passing, there is no way to tell that the method does not work.\n&gt;&gt; &gt;\n&gt;&gt; &gt; Now I could code my tests like such\n&gt;&gt; &gt;\n&gt;&gt; &gt;  @Test\n&gt;&gt; &gt;  public void deleteIsANoOpOnEmptyList() {\n&gt;&gt; &gt;    List l = new List();\n&gt;&gt; &gt;    assumeThat(l.isEmpty(), is(true));\n&gt;&gt; &gt;    l.delete(new Object());\n&gt;&gt; &gt;  }\n&gt;&gt; &gt;\n&gt;&gt; &gt; But all that I am doing is repeating code from the preceding tests,\n&gt;&gt; &gt; having changed all those tests&#39; assertThat(...)s into assumeThat(...)s\n&gt;&gt; &gt;\n&gt;&gt; &gt; That does not seem agile to me, copy & paste & search & replace... ban\n&gt;&gt; &gt; code smell there\n&gt;&gt; &gt;\n&gt;&gt; &gt; I would much rather be able to annotate the tests with an @Assumes\n&gt;&gt; &gt; annotation that indicates that the test assumes that the specified\n&gt;&gt; &gt; tests are passing, e.g.\n&gt;&gt; &gt;\n&gt;&gt; &gt;  @Test\n&gt;&gt; &gt;  @Assumes(&quot;newListIsEmpty&quot;)\n&gt;&gt; &gt;  public void deleteIsANoOpOnEmptyList() {\n&gt;&gt; &gt;    List l = new List();\n&gt;&gt; &gt;    l.delete(new Object());\n&gt;&gt; &gt;  }\n&gt;&gt; &gt;\n&gt;&gt; &gt;  @Test\n&gt;&gt; &gt;  @Assumes({&quot;newListIsEmpty&quot;,&quot;addPutsAnElementIntoAnEmptyList&quot;)\n&gt;&gt; &gt;  public void deleteRemovesAnElement() {\n&gt;&gt; &gt;    List l = new List();\n&gt;&gt; &gt;    Object o = new Object();\n&gt;&gt; &gt;    l.add(o);\n&gt;&gt; &gt;    l.delete(o);\n&gt;&gt; &gt;    assertThat(l.isEmpty(), is(true));\n&gt;&gt; &gt;  }\n&gt;&gt; &gt;\n&gt;&gt; &gt; In fact in my initial example of tests, there are some additional\n&gt;&gt; &gt; assumptions that I didn&#39;t make explicit\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt;  @Test\n&gt;&gt; &gt;  @Assumes(&quot;newListIsEmpty&quot;)\n&gt;&gt; &gt;  public void addPutsAnElementIntoAnEmptyList() {\n&gt;&gt; &gt;    ...\n&gt;&gt; &gt;  }\n&gt;&gt; &gt;\n&gt;&gt; &gt; and\n&gt;&gt; &gt;\n&gt;&gt; &gt;  @Test\n&gt;&gt; &gt;  @Assumes({&quot;newListIsEmpty&quot;,&quot;addPutsAnElementIntoAnEmptyList&quot;)\n&gt;&gt; &gt;  public void addIncreasesSizeOfPopulatedListByOne() {\n&gt;&gt; &gt;    ...\n&gt;&gt; &gt;  }\n&gt;&gt; &gt;\n&gt;&gt; &gt; Now you could get some of this functionality via a TestRule...\n&gt;&gt; &gt;\n&gt;&gt; &gt; You could watch tests to see if they pass, and skip tests annotated\n&gt;&gt; &gt; with the annotation if assumed functionality is failing, but that\n&gt;&gt; &gt; would result in sporadic failures of, e.g. deleteRemovesAnElement\n&gt;&gt; &gt; because of the failing newListIsEmpty being executed _after_\n&gt;&gt; &gt; deleteRemovesAnElement rather than before.\n&gt;&gt; &gt;\n&gt;&gt; &gt; The simple point is that the test result of deleteRemovesAnElement is\n&gt;&gt; &gt; meaningless until its assumptions are true, and while I could code the\n&gt;&gt; &gt; assumptions with assumeThat(..)s C&P&S&R is even worse than C&P.\n&gt;&gt; &gt;\n&gt;&gt; &gt; Another alternative to @Assumes would be to invoke the assumed\n&gt;&gt; &gt; method(s) at the start of the test, e.g.\n&gt;&gt; &gt;\n&gt;&gt; &gt;  @Test\n&gt;&gt; &gt;  public void deleteRemovesAnElement() {\n&gt;&gt; &gt;    newListIsEmpty(); // verify assumed functionality\n&gt;&gt; &gt;    addPutsAnElementIntoAnEmptyList();  // verify assumed functionality\n&gt;&gt; &gt;  &gt; ------------------------------------\n&gt;&gt; &gt;\n&gt;&gt; &gt; Yahoo! Groups Links\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt;\n&gt;&gt;\n&gt;&gt; ------------------------------------\n&gt;&gt;\n&gt;&gt; Yahoo! Groups Links\n&gt;&gt;\n&gt;&gt;\n&gt;&gt;\n&gt;&gt;\n\n\n[Non-text portions of this message have been removed]\n\n\n", 
    "profile": "stephenalanconnolly", 
    "topicId": 23636, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 458231986, 
    "prevInTime": 23642, 
    "contentTrasformed": false, 
    "postDate": "1316087062", 
    "canDelete": false, 
    "nextInTopic": 23646, 
    "prevInTopic": 23642, 
    "headers": {
        "inReplyToHeader": "PENBK25Qbk14UnpwWDFZY2gzWWhNX0g0eHo5cEN5MERPRERqbnhNN0xMUFhUdm5yYnQ2Z0BtYWlsLmdtYWlsLmNvbT4=", 
        "messageIdInHeader": "PENBK25Qbk16bWJHZXBRb3JDcHloT3JKeT1ZMkZYa2VVaGZkMVB6RmZDbWJyTWRiOWNLUUBtYWlsLmdtYWlsLmNvbT4=", 
        "referencesHeader": "PENBK25Qbk13YmZOdnhiaHFqV1Z5WFc3VUR0MlZNNVR6d1d6d0FpUkphSGtLcm5Iem14UUBtYWlsLmdtYWlsLmNvbT4JPENBK25Qbk15UVB3X2htQjVQWmpZNXRPN0xkaFN2WEprYjdObjlKRlpyZUIxVnk1UDhvd0BtYWlsLmdtYWlsLmNvbT4JPENBQ2o4QnVPbjVlRm1OZlN4UC1SelYzck0zMzFWZUQwRUhTX2ZPendFbVBibmpUdVU2QUBtYWlsLmdtYWlsLmNvbT4JPENBK25Qbk14UnpwWDFZY2gzWWhNX0g0eHo5cEN5MERPRERqbnhNN0xMUFhUdm5yYnQ2Z0BtYWlsLmdtYWlsLmNvbT4="
    }
}