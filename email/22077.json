{
    "numMessagesInTopic": 16, 
    "nextInTime": 22078, 
    "senderId": "7gdKLAJmpaiuFGai3qlIh4iqmb90phNbA8ODUCmgViI788LmysIVd-vqZCRueanpn3uqMNqSuGRRFw80Py5ZyAfev9RP1uBHcnm915qbt1g", 
    "systemMessage": false, 
    "subject": "Re: An &quot;after all tests&quot; event", 
    "from": "&quot;yme0987654321&quot; &lt;yme0987654321@...&gt;", 
    "authorName": "yme0987654321", 
    "msgSnippet": "Stolsvik, What you want (annotate some random class somewhere) isn t currently supported by JUnit (as far as I know). But what you can do is make a suite. So", 
    "msgId": 22077, 
    "profile": "yme0987654321", 
    "topicId": 22067, 
    "spamInfo": {
        "reason": "6", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 386557907, 
    "messageBody": "<div id=\"ygrps-yiv-1852455125\">Stolsvik,<br/>\n<br/>\nWhat you want (annotate some random class somewhere) isn&#39;t currently supported by JUnit (as far as I know).<br/>\n<br/>\nBut what you can do is make a suite. So you pick some random class somewhere and you annotated it with the @RunWith(Suite.class), add the class to the suite with @... annotation, and then on that class define a @BeforeClass and an @AfterClass method. Those @BeforeClass and @AfterClass methods will get run before and after all the other tests in the suite, respectively.<br/>\n<br/>\nWhat you don&#39;t get from using this method is the nice convenient use of your IDE to just run all the tests. You have to put them together yourself. Right now in JUnit literally by specifying them, although David has promised some idea for allowing the Suite classes to be generated programatically.<br/>\n<br/>\nIn the mean time if you need something generated programatically, you can make a custom runner that extends Suite and pass an array of the classes that you construct programatically to the Suite constructor.<br/>\n<br/>\nEven with this solution, you lose the ability to have your IDE just find all tests in the project, but since I need those tests run during the build anyway, that was not a loss for me.<br/>\n<br/>\n<blockquote><span title=\"qreply\"> --- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>, &quot;stolsvik&quot; &lt;online@...&gt; wrote:<br/>\n&gt;<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; <br/>\n&gt; Folks, thanks for your answers.<br/>\n&gt; <br/>\n&gt; --- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>, David Saff &lt;david@&gt; wrote:<br/>\n&gt; &gt;<br/>\n&gt; &gt; Stolsvik,<br/>\n&gt; &gt; <br/>\n&gt; &gt; You can use @BeforeClass and @AfterClass on a suite to get this<br/>\n&gt; &gt; behavior, in many circumstances.<br/>\n&gt; <br/>\n&gt; Could you tell me directly, or point to some resource, of how I set that up? Your sentence didn&#39;t immediately ring understanding with me.<br/>\n&gt; <br/>\n&gt; Basically, what I am requesting, is that I&#39;d like to annotate some random method on some random class anywhere in the project with some annotation like @AfterTestRun - so that when I run either one single test class, or a package, or the entire project, with the Eclipse runner, this specific method would be invoked after the requested test(s) are run.<br/>\n&gt; <br/>\n&gt; So: How do I accomplish that with &quot;@AfterClass on a suite&quot;?<br/>\n&gt; <br/>\n&gt; Do I have to annotate all my test classes with some specific Suite-annotation? That would be doable. However, it would be just as awkward as I do with my logging init: Having to do some boilerplate bs on every single test class - only that forgetting to do this would not give me any immediate indication, as with the logging init; For the logging init, I immediately see if I have forgotten those three boilerplate lines (&quot;static { TestHelper.setupLogging() }&quot;), because log4j spews out some noise on Std.err if any part of the system starts to log on an uninitialized logging system.<br/>\n&gt; <br/>\n&gt; &gt; <br/>\n&gt; &gt;    David Saff<br/>\n&gt; &gt; <br/>\n&gt; &gt; On Thu, Nov 19, 2009 at 7:09 AM, stolsvik &lt;online@&gt; wrote:<br/>\n&gt; &gt; &gt; I need some way to run a certain test after all other tests.<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; I run my tests in Eclipse, and do not yet have a build system outside of it. I understand that had I done this programmatically, I could have attached a RunListener, implementing the testRunFinished(Result) method.<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; Is there any way to achieve a similar effect within the JUnit runner in Eclipse?<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; Rationale: I have actual unit tests, then bigger tests, then full-fledged &quot;integration tests&quot; or whatever one call them, where I take up my entire application-local server thingy and process a bunch of items, letting JUnit check after the dust settles whether the items was processed correctly. However, the internals are multi threaded, and also, this being a Swing app, lots of Runnables are sent over to the EDT. This is all good.<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; However, I&#39;ve sometimes seen that a thread crashes (uncaught exception), without this being noticed by any of the tests running (I&#39;ve e.g. seen a ConcurrentModificationException take down the EDT, without having a clue as to why I got that - and the next event posted just brings up a new EDT, so I get a green bar, but with an uncaught error). What I&#39;d want to achieve, is to install an uncaught exception handler, and then, as a final step to ALL permutations of tests (e.g. both for a single unit test, and also for the project-wide test run), run a test that checks whether any thread-killing exception was caught by the handler, and if so, fails the run. (I&#39;d throw the exception that was caught, and in any case also log-dump any and all such exceptions).<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; (As a very similar question, I&#39;d also like to have a &quot;before any tests&quot; thing, like the RunListener.testRunStarted(Description) method, where I could set up logging. Now I do that by letting ALL tests have a static block that calls a specific static method which has a static boolean that tells whether the log system already is set up. This also works just nicely, but is a hassle nevertheless. However, it is not possible, as I see it, to solve the above question in the same manner.)<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; ------------------------------------<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; Yahoo! Groups Links<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 22076, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1258733929", 
    "canDelete": false, 
    "nextInTopic": 22106, 
    "prevInTopic": 22076, 
    "headers": {
        "inReplyToHeader": "PGhlNjR1aCt0NWVtQGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PGhlNmZoOStqMmw1QGVHcm91cHMuY29tPg=="
    }
}