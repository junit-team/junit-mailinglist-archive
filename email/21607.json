{
    "numMessagesInTopic": 7, 
    "nextInTime": 21608, 
    "senderId": "hs5LufcMLMKZilOQc03C_QMBxPdOml8ULlrjzwPlSi4NUzI2VbmzqOlwskStr-XkfcSQ_vMUIv-cgBYJULHnFCAu", 
    "systemMessage": false, 
    "subject": "Re: [junit] Re: Non-static inner classes of test classes using \tenclosing fixtures?", 
    "from": "David Saff &lt;david@...&gt;", 
    "authorName": "David Saff", 
    "msgSnippet": "... Glad to hear that. ... I think there were two different directions going on here.  It sounds like you want JUnit, when given the outer class, to", 
    "msgId": 21607, 
    "profile": "dsaff", 
    "topicId": 21578, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 341876227, 
    "messageBody": "<div id=\"ygrps-yiv-305199131\">On Wed, May 13, 2009 at 4:25 PM, Paul Holser &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:pholser@...\">pholser@...</a>&gt; wrote:<br/>\n<blockquote><span title=\"ireply\"> &gt; Hi JUnit,<br/>\n&gt;<br/>\n&gt; Regarding my previous post, about the desire to have non-static inner<br/>\n&gt; test classes of a test class instantiated and run with an enclosing<br/>\n&gt; instance: I found a solution that seems workable. I used JUnit 4.5. It<br/>\n&gt; involves the following:<br/>\n&gt; [snip]<br/>\n&gt; So, I was able to leverage existing JUnit extension points to accomplish<br/>\n&gt; my goal.<br/>\n<br/>\n </span></blockquote>Glad to hear that.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; I wonder if this would be useful functionality for JUnit to<br/>\n&gt; have in general: when a test class is detected, and that test class has<br/>\n&gt; non-static inner classes which may themselves be test classes, when<br/>\n&gt; building up tests for the enclosing class, also instantiate the inner<br/>\n&gt; test classes and attach to the (an?) enclosing test class instance. I<br/>\n&gt; saw some previous discussion about such fixtures in JDave.<br/>\n<br/>\n </span></blockquote>I think there were two different directions going on here.  It sounds<br/>\nlike you want JUnit, when given the outer class, to automatically<br/>\ninstantiate the inner classes.  It sounded like JDave wanted JUnit,<br/>\nwhen given the inner class, to automatically consult the outer class<br/>\nwhen instantiating.<br/>\n<br/>\nAm I getting both requests right?  If not, then we&#39;re getting close to<br/>\na Rule of Three threshold for reuse.  If I am, then I see the same<br/>\nJava idiom having two different &quot;obvious&quot; interpretations to two<br/>\ndifferent classes of user.<br/>\n<br/>\n   David Saff<br/>\n<br/>\n<blockquote><span title=\"qreply\"> &gt;<br/>\n&gt; What do you think? Some code from my solution is below.<br/>\n&gt;<br/>\n&gt; Thanks,<br/>\n&gt; Paul Holser<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; ======<br/>\n&gt;<br/>\n&gt; public abstract class UnmodifiableCollectionTestSupport&lt;T&gt; {<br/>\n&gt;     protected Collection&lt;T&gt; items;<br/>\n&gt;     private T containedItem;<br/>\n&gt;<br/>\n&gt;     @Before<br/>\n&gt;     public final void initializeHarness() {<br/>\n&gt;         this.items = newCollection();<br/>\n&gt;         this.containedItem = containedItem();<br/>\n&gt;         // ...<br/>\n&gt;     }<br/>\n&gt;<br/>\n&gt;     @Test(expected = UnsupportedOperationException.class) {<br/>\n&gt;     public final void<br/>\n&gt; shouldPreventOperationThatWouldModifyTheCollection() {<br/>\n&gt;         // ...<br/>\n&gt;     }<br/>\n&gt;<br/>\n&gt;     // tests...<br/>\n&gt;<br/>\n&gt;     protected abstract Collection&lt;T&gt; newCollection();<br/>\n&gt;<br/>\n&gt;     protected abstract T newItem();<br/>\n&gt;<br/>\n&gt;     protected abstract T containedItem();<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; public abstract class UnmodifiableListTestSupport&lt;T&gt; extends<br/>\n&gt; UnmodifiableCollectionTestSupport&lt;T&gt; {<br/>\n&gt;     // ...<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; @RunWith(AllTests.class)<br/>\n&gt; public abstract class UnmodifiableMapTestSupport&lt;K, V&gt; {<br/>\n&gt;     private Map&lt;K, V&gt; entries;<br/>\n&gt;     private K containedKey;<br/>\n&gt;     private V containedValue;<br/>\n&gt;<br/>\n&gt;     @Before<br/>\n&gt;     public final void initializeHarness() {<br/>\n&gt;         this.entries = newMap();<br/>\n&gt;         this.containedKey = containedKey();<br/>\n&gt;         this.containedValue = containedValue();<br/>\n&gt;         // ...<br/>\n&gt;     }<br/>\n&gt;<br/>\n&gt;     @Test(expected = UnsupportedOperationException.class) {<br/>\n&gt;     public final void shouldPreventOperationThatWouldModifyTheMap() {<br/>\n&gt;         // ...<br/>\n&gt;     }<br/>\n&gt;<br/>\n&gt;     // tests...<br/>\n&gt;<br/>\n&gt;     protected abstract Map&lt;K, V&gt; newMap();<br/>\n&gt;<br/>\n&gt;     protected abstract K newKey();<br/>\n&gt;<br/>\n&gt;     protected abstract K containedKey();<br/>\n&gt;<br/>\n&gt;     protected abstract V containedValue();<br/>\n&gt;<br/>\n&gt;     protected static junit.framework.Test<br/>\n&gt; buildUnmodifiableMapSuite(UnmodifiableMapTestSupport&lt;?, ?&gt; test) {<br/>\n&gt;         TestSuite suite = new TestSuite();<br/>\n&gt;         suite.addTest(new JUnit4TestInstanceAdapter(test));<br/>\n&gt;         suite.addTest(new JUnit4TestInstanceAdapter(test.new<br/>\n&gt; KeySetTest()));<br/>\n&gt;         suite.addTest(new JUnit4TestInstanceAdapter(test.new<br/>\n&gt; ValuesTest()));<br/>\n&gt;         suite.addTest(new JUnit4TestInstanceAdapter(test.new<br/>\n&gt; EntriesTest()));<br/>\n&gt;         return suite;<br/>\n&gt;     }<br/>\n&gt;<br/>\n&gt;     class KeySetTest extends UnmodifiableCollectionTestSupport&lt;K&gt; {<br/>\n&gt;         @Override protected K containedItem() {<br/>\n&gt;             return containedKey;<br/>\n&gt;         }<br/>\n&gt;<br/>\n&gt;         @Override protected Collection&lt;K&gt; newCollection() {<br/>\n&gt;             return entries.keySet();<br/>\n&gt;         }<br/>\n&gt;<br/>\n&gt;         @Override protected K newItem() {<br/>\n&gt;             return newKey();<br/>\n&gt;         }<br/>\n&gt;     }<br/>\n&gt;<br/>\n&gt;     class ValuesTest extends UnmodifiableCollectionTestSupport&lt;V&gt; {<br/>\n&gt;         @Override protected V containedItem() {<br/>\n&gt;             return containedValue;<br/>\n&gt;         }<br/>\n&gt;<br/>\n&gt;         @Override protected Collection&lt;V&gt; newCollection() {<br/>\n&gt;             return entries.values();<br/>\n&gt;         }<br/>\n&gt;<br/>\n&gt;         @Override protected V newItem() {<br/>\n&gt;             return null;<br/>\n&gt;         }<br/>\n&gt;     }<br/>\n&gt;<br/>\n&gt;     class EntriesTest extends<br/>\n&gt; UnmodifiableCollectionTestSupport&lt;Map.Entry&lt;K, V&gt;&gt; {<br/>\n&gt;         @Override protected Entry&lt;K, V&gt; containedItem() {<br/>\n&gt;             return /* new Map.Entry impl whose key is containedKey and<br/>\n&gt; whose value is containedValue */;<br/>\n&gt;         }<br/>\n&gt;<br/>\n&gt;         @Override protected Collection&lt;Entry&lt;K, V&gt;&gt; newCollection() {<br/>\n&gt;             return entries.entrySet();<br/>\n&gt;         }<br/>\n&gt;<br/>\n&gt;         @Override protected Entry&lt;K, V&gt; newItem() {<br/>\n&gt;             return null;<br/>\n&gt;         }<br/>\n&gt;     }<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; // sample implementor<br/>\n&gt; public class UnmodifiableMapTest extends<br/>\n&gt; UnmodifiableMapTestSupport&lt;String, String&gt; {<br/>\n&gt;     public static junit.framework.Test suite() {<br/>\n&gt;         return UnmodifiableMapTestSupport.buildUnmodifiableMapSuite(new<br/>\n&gt; UnmodifiableMapTest());<br/>\n&gt;     }<br/>\n&gt;<br/>\n&gt;     @Override protected String containedKey() {<br/>\n&gt;         return &quot;foo&quot;;<br/>\n&gt;     }<br/>\n&gt;<br/>\n&gt;     @Override protected String containedValue() {<br/>\n&gt;         return &quot;value&quot;;<br/>\n&gt;     }<br/>\n&gt;<br/>\n&gt;     @Override protected String newKey() {<br/>\n&gt;         return &quot;bar&quot;;<br/>\n&gt;     }<br/>\n&gt;<br/>\n&gt;     @Override protected Map&lt;String, String&gt; newMap() {<br/>\n&gt;         return<br/>\n&gt; Collections.unmodifiableMap(Collections.singletonMap(&quot;foo&quot;, &quot;value&quot;));<br/>\n&gt;     }<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; --- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>, David Saff &lt;david@...&gt; wrote:<br/>\n&gt;&gt;<br/>\n&gt;&gt; Paul,<br/>\n&gt;&gt;<br/>\n&gt;&gt; Have you looked at Theory support in JUnit &gt; 4.4?  It may not give you<br/>\n&gt;&gt; everything you want, but I&#39;d be curious to know how close it gets.<br/>\n&gt;&gt; Thanks,<br/>\n&gt;&gt;<br/>\n&gt;&gt;    David<br/>\n&gt;&gt;<br/>\n&gt;&gt; On Sat, May 9, 2009 at 1:37 PM, Paul Holser pholser@... wrote:<br/>\n&gt;&gt; &gt; Hello JUnit,<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt; I have some abstract classes that enable a caller to check that<br/>\n&gt; classes which expose collection fields via accessor methods do so via<br/>\n&gt; the java.util.Collections#unmodifiable___() facilities.  Here are some<br/>\n&gt; snippets:<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt; public abstract class UnmodifiableCollectionTestSupport&lt;T&gt; {<br/>\n&gt;&gt; &gt;    protected Collection&lt;T&gt; items;<br/>\n&gt;&gt; &gt;    private T containedItem;<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;    @Before<br/>\n&gt;&gt; &gt;    public final void initializeHarness() {<br/>\n&gt;&gt; &gt;        this.items = newCollection();<br/>\n&gt;&gt; &gt;        this.containedItem = containedItem();<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;        assertFalse(&quot;need a non-empty collection&quot;, items.isEmpty());<br/>\n&gt;&gt; &gt;        assertTrue(&quot;need an item that is in the collection&quot;,<br/>\n&gt; items.contains(containedItem));<br/>\n&gt;&gt; &gt;    }<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;    @Test(expected = UnsupportedOperationException.class)<br/>\n&gt;&gt; &gt;    public final void shouldPreventAdd() {<br/>\n&gt;&gt; &gt;        // ...<br/>\n&gt;&gt; &gt;    }<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;    // etc...<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;    protected abstract Collection&lt;T&gt; newCollection();<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;    protected abstract T newItem();<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;    protected abstract T containedItem();<br/>\n&gt;&gt; &gt; }<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt; public abstract class UnmodifiableListTestSupport&lt;T&gt; extends<br/>\n&gt; UnmodifiableCollectionTestSupport&lt;T&gt; {<br/>\n&gt;&gt; &gt;    @Test(expected = UnsupportedOperationException.class)<br/>\n&gt;&gt; &gt;    public final void shouldPreventAddAtIndex() {<br/>\n&gt;&gt; &gt;        // ...<br/>\n&gt;&gt; &gt;    }<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;    // etc...<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;    protected final Collection&lt;T&gt; newCollection() {<br/>\n&gt;&gt; &gt;        return newList();<br/>\n&gt;&gt; &gt;    }<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;    protected abstract List&lt;T&gt; newList();<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;    private List&lt;T&gt; list() {<br/>\n&gt;&gt; &gt;        return (List&lt;T&gt;) items;<br/>\n&gt;&gt; &gt;    }<br/>\n&gt;&gt; &gt; }<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt; public class UnmodifiableListTest extends<br/>\n&gt; UnmodifiableListTestSupport&lt;String&gt; {<br/>\n&gt;&gt; &gt;    @Override<br/>\n&gt;&gt; &gt;    protected List&lt;String&gt; newList() {<br/>\n&gt;&gt; &gt;        return unmodifiableList(asList(&quot;foo&quot;));<br/>\n&gt;&gt; &gt;    }<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;    protected String newItem() {<br/>\n&gt;&gt; &gt;        return &quot;bar&quot;;<br/>\n&gt;&gt; &gt;    }<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;    protected String containedItem() {<br/>\n&gt;&gt; &gt;        return &quot;foo&quot;;<br/>\n&gt;&gt; &gt;    }<br/>\n&gt;&gt; &gt; }<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt; I am imagining an UnmodifiableMapTestSupport abstract class to do<br/>\n&gt; similar tests for unmodifiable maps:<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt; public abstract class UnmodifiableMapTestSupport&lt;K, V&gt; {<br/>\n&gt;&gt; &gt;    private Map&lt;K, V&gt; entries;<br/>\n&gt;&gt; &gt;    private K containedKey;<br/>\n&gt;&gt; &gt;    private V containedValue;<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;    @Before<br/>\n&gt;&gt; &gt;    public final void initializeHarness() {<br/>\n&gt;&gt; &gt;        this.entries = newMap();<br/>\n&gt;&gt; &gt;        this.containedKey = containedKey();<br/>\n&gt;&gt; &gt;        this.containedValue = containedValue();<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;        assertFalse(&quot;need a non-empty map&quot;, entries.isEmpty());<br/>\n&gt;&gt; &gt;        assertTrue(&quot;need a key that is in the map&quot;,<br/>\n&gt; entries.containsKey(containedKey));<br/>\n&gt;&gt; &gt;        assertTrue(&quot;need a value that is in the map&quot;,<br/>\n&gt; entries.containsValue(containedValue));<br/>\n&gt;&gt; &gt;    }<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;    @Test(expected = UnsupportedOperationException.class)<br/>\n&gt;&gt; &gt;    public final void shouldPreventPut() {<br/>\n&gt;&gt; &gt;        // ...<br/>\n&gt;&gt; &gt;    }<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;    protected abstract Map&lt;K, V&gt; newMap();<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;    protected abstract K newKey();<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;    protected abstract K containedKey();<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;    protected abstract V containedValue();<br/>\n&gt;&gt; &gt; }<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt; Not just would I like to test that a map cannot be modified via its<br/>\n&gt; Map methods, but also I would like to test that the map cannot be<br/>\n&gt; mutated via the keySet(), values(), and entrySet() views.  It would be<br/>\n&gt; really nice if, when someone subclasses UnmodifiableMapTestSupport, they<br/>\n&gt; could get an Un modifiableCollectionTestSupport&lt;K&gt;,<br/>\n&gt; UnmodifiableCollectionTestSupport&lt;V&gt;, and an<br/>\n&gt; UnmodifiableCollectionTestSupport&lt;Map.Entry&lt;K, V&gt;&gt; instantiated, run,<br/>\n&gt; and result reported on for the keySet(), values(), and entrySet() views<br/>\n&gt; of the newMap() result.  Otherwise, they would have to hand-roll three<br/>\n&gt; more concretes of UnmodifiableCollectionTestSupport for testing the<br/>\n&gt; keySet(), values(), and entrySet() views of a given map.<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; ------------------------------------<br/>\n&gt;<br/>\n&gt; Yahoo! Groups Links<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 21606, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1242309018", 
    "canDelete": false, 
    "nextInTopic": 21611, 
    "prevInTopic": 21600, 
    "headers": {
        "inReplyToHeader": "PGd1ZmFjOSthYnQxQGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PDRmN2RhNmI5MDkwNTE0MDY1MG8zNGRkNjhkZG0yYzIzM2NmYjU1NmZjZTZjQG1haWwuZ21haWwuY29tPg==", 
        "referencesHeader": "PDRmN2RhNmI5MDkwNTExMDgwNnExNGM4ODFlM3ZiN2UxZGVmZWE4Y2MwYzYyQG1haWwuZ21haWwuY29tPgkgPGd1ZmFjOSthYnQxQGVHcm91cHMuY29tPg=="
    }
}