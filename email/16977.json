{
    "numMessagesInTopic": 31, 
    "nextInTime": 16978, 
    "senderId": "zfvVFA0dynDzpn2pjAd1vKpr7r82qL3MhX1_SxvNfjeTBQgRz9iiBvOH5Zjdk99HtKJRqyDaSBx_999Utm7sTnPhGhCFTf1wxjgwSw_LGATV", 
    "systemMessage": true, 
    "subject": "Re: [junit] Multiple assertions per test", 
    "from": "&quot;Brett L. Schuchert&quot; &lt;schuchert@...&gt;", 
    "authorName": "Brett L. Schuchert", 
    "msgSnippet": "Cédric, ... Not really. My thinking was something like this... If you write multiple asserts, some of which you expect to fail (as in the original example), I", 
    "msgId": 16977, 
    "profile": "schuchert", 
    "topicId": 16876, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 162568887, 
    "messageBody": "<div id=\"ygrps-yiv-1257236288\">Cédric, <br/>\n<blockquote><span title=\"ireply\"> &gt;&gt; need a person to process those results rather than the computer. It goes<br/>\n&gt;&gt; counter to AUTOMATION and moves towards more human intervention.<br/>\n<br/>\n&gt;I&#39;m not sure why wanting multiple results leads to needing human<br/>\n&gt;intervention. .. Can you expand on that?<br/>\n<br/>\n </span></blockquote>Not really. My thinking was something like this... If you write multiple asserts, some of which you expect to fail (as in the original example), I was thinking that you were expecting failures and wanted to know each of them ... thus human intervention. However, if you write the tests and expect them to pass, then having multiple assertions failing only requires human intervention for evaluation of failures, which is no different. So I was on crack.<br/>\n <br/>\n<blockquote><span title=\"ireply\"> &gt; The problem with this approach is not just that it leads to an explosion of<br/>\n&gt; test methods, it&#39;s that it decouples code that you obviously want to keep<br/>\n&gt; ..<br/>\n&gt; other methods to modify them too.<br/>\n <br/>\n </span></blockquote>I suppose. Though running the tests will find them, so they will eventually get fixed.<br/>\n <br/>\nBy the way, I think it is normal to have multiple asserts in a test method. I understand some people would disagree, but often I want to test something bigger than a unit. Here&#39;s an actual example: I want to perform data validation on a composite object. I set up one test for each individual field. There will be some dependent validations. I need to set up tests for those. It is likely that when I have dependent validations I might have multiple things I need to verify were shown to be in error, thus multiple asserts.<br/>\n <br/>\nIf I use an external resource (e.g. a DAO, even a mocked one), if I expect a non-null result but get a null result, I&#39;ll have a failure with a null pointer exception. I&#39;d rather put an assert with a message so I know right away what&#39;s going on.<br/>\n <br/>\nSo having multiple asserts in a test method, at least for me, is par for the course.<br/>\n <br/>\n<blockquote><span title=\"ireply\"> &gt;Sure, but you can get the same result with strings, which are even more<br/>\n&gt; readable:<br/>\n <br/>\n </span></blockquote>For this trivial example, I agree the strings would work well, but I&#39;d still have different test methods for the second reason I mention below:<br/>\n <br/>\nFor the majority of examples there will be some amount of setup. Using multiple methods along with the setUp/tearDown (@Before/@After) feature of JUnit allows for test isolation. In this trivial example, it is not necessary.<br/>\n <br/>\nHowever, there is the issue of equivalence sets. In the original examples, the person was validating different logical test scenarios and I would argue those should be in different test methods. I would also argue that the last two examples were in the same equivalence set (is that the right term?) and so the third test was useless. So from the original example, there should have been 2 tests, one for a successful use and one for a failed use. Furthermore, the failed example should have been written to assertFalse instead of true to move the overall example to more of a automated one. This last point is overkill for the example provided, so in this case I&#39;d probably build one unit test.<br/>\n <br/>\nFinally, <br/>\nTutorials and Articles<br/>\n     http://schuchert.wikispaces.com/<br/>\n<br/>\n<br/>\n<br/>\n----- Original Message ----<br/>\nFrom: Cédric Beust ♔ &lt;cbeust@...&gt;<br/>\nTo: junit@yahoogroups.com<br/>\nSent: Sunday, June 18, 2006 8:38:15 PM<br/>\nSubject: Re: [junit] Multiple assertions per test<br/>\n<br/>\n<br/>\n<blockquote><span title=\"qreply\"> On 6/18/06, Brett L. Schuchert &lt;schuchert@yahoo. com&gt; wrote:<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; A unit test should test one thing. Let&#39;s say you WANT to get multiple<br/>\n&gt; results. What&#39;s the UI for that? And besides the UI, what&#39;s even the point?<br/>\n&gt; We&#39;re trying to write tests in a way that requires nearly 0 human<br/>\n&gt; interaction. If you can get multiple results from a test, it seems you&#39;d<br/>\n&gt; need a person to process those results rather than the computer. It goes<br/>\n&gt; counter to AUTOMATION and moves towards more human intervention.<br/>\n<br/>\nI&#39;m not sure why wanting multiple results leads to needing human<br/>\nintervention. .. Can you expand on that?<br/>\n<br/>\nThe original example was later answered well by someone else. Make<br/>\n&gt; testOrder() three tests instead of one. You get the results you want, though<br/>\n&gt; you do have to write a few more lines of code.<br/>\n<br/>\nThe problem with this approach is not just that it leads to an explosion of<br/>\ntest methods, it&#39;s that it decouples code that you obviously want to keep<br/>\ntogether. First you break these three tests in three different methods and<br/>\nnext thing you know, these three methods become scattered in the class and<br/>\nyou completely forget they are testing things that are closely related. And<br/>\nmost likely, if you change one of these methods, you need to hunt down these<br/>\nother methods to modify them too.<br/>\n<br/>\nI&#39;m not saying that it&#39;s a bad thing to do, just that sometimes, there are<br/>\ngood reasons for wanting these multiple asserts together in the same method.<br/>\n<br/>\n&gt; // Note, in the original test this assert would have failed. It should<br/>\n&gt; have been written<br/>\n&gt; // in a way that would not fail but still assert what should happen<br/>\n&gt; public void testFailure_ DoesNotMatch( ) {<br/>\n&gt; assertNotEqual( 44, Largest.largest( new int[] {8,9,7}));<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; And so on... The name of the test states the intent of the test. I don&#39;t<br/>\n&gt; have to read the code to figure out the intention of what is being tested.<br/>\n<br/>\nSure, but you can get the same result with strings, which are even more<br/>\nreadable:<br/>\n<br/>\nassert 44 != Larget.largest( new int[] { 8, 9, 7}) : &quot;The largest item should<br/>\nnot be 44&quot;.<br/>\n<br/>\n&lt;snip&gt;<br/>\n<br/>\nAgree with the rest of your message.<br/>\n<br/>\n-- <br/>\nCédric<br/>\nhttp://testng. org<br/>\n<br/>\n[Non-text portions of this message have been removed]<br/>\n<br/>\n<br/>\n <br/>\n<br/>\n[Non-text portions of this message have been removed] </span></blockquote></div>", 
    "prevInTime": 16976, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1150775706", 
    "canDelete": false, 
    "nextInTopic": 16978, 
    "prevInTopic": 16975, 
    "headers": {
        "inReplyToHeader": "PGI4NmI2YTljMDYwNjE4MTgzOGozZDgzMTIwMnFhOTQwYWYzMTc3YzFmYmU4QG1haWwuZ29vZ2xlLmNvbT4=", 
        "messageIdInHeader": "PDIwMDYwNjIwMDM1NTA2LjIzOTkwLnFtYWlsQHdlYjU0MTA1Lm1haWwueWFob28uY29tPg=="
    }
}