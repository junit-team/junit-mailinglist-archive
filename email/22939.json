{
    "numMessagesInTopic": 8, 
    "nextInTime": 22940, 
    "senderId": "-hwHJPYL140MoqiktEPR-y1SxEVIGJaS1wGgNCP79EXgZxe8-MSYmRO0ln3Fs_Ufo4hir-l5NA2GeRrAegz7VBZ4eBsT8vC7sD4", 
    "systemMessage": false, 
    "subject": "Re: [junit] Common Test Runner for JVM", 
    "from": "Mike Forsberg &lt;bigmike.f@...&gt;", 
    "authorName": "Mike Forsberg", 
    "msgSnippet": "I may be wrong, but it sounds like this project will be a JUnit engine geared specifically for IntelliJ. Is there any chance that the core functionality", 
    "msgId": 22939, 
    "profile": "bigmike_f", 
    "topicId": 22933, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 421392598, 
    "messageBody": "<div id=\"ygrps-yiv-1834467161\">I may be wrong, but it sounds like this project will be a JUnit<br/>\n&quot;engine&quot; geared specifically for IntelliJ.<br/>\n<br/>\nIs there any chance that the core functionality could be written in a<br/>\nway that other tools could leverage it&#39;s design.  It would be great if<br/>\nthe project would be broken into a core with modules per IDE.  I think<br/>\nthis paradigm would benifit the project in the following ways:<br/>\n-- Adoption may slow if every developer were forced into a specific<br/>\nIDE to gain access to this tool.<br/>\n-- Integration with common tools like Ant, Maven, and other CI tools<br/>\nmight be harder if too much design is IntelliJ specific.<br/>\n-- I want to use it, but prefer eclipse for no other reason then, &quot;I&#39;m lazy&quot;.<br/>\n<br/>\nSound like a great project, a refactoring of the @RunWith would be a<br/>\nnice-ity.  If you head the eclipse route, I&#39;d be willing to give it a<br/>\ntry and supply feed back.<br/>\n<br/>\nBig Mike<br/>\n<br/>\n<br/>\n<blockquote><span title=\"qreply\"> On Mon, Sep 13, 2010 at 2:18 PM, Esko Luontola &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:esko.luontola@...\">esko.luontola@...</a>&gt; wrote:<br/>\n&gt;&gt;  &gt; I notice that a<br/>\n&gt;&gt;  &gt; number of the issues you&#39;re tackling are mostly about IDE<br/>\n&gt;&gt;  &gt; integration<br/>\n&gt;<br/>\n&gt; Yes. In addition to programming I do also interaction design, and<br/>\n&gt; usability is very important to me. My development process is to first<br/>\n&gt; design the UI and after that think about what is needed to implement it.<br/>\n&gt; Quite many times a good user interface affects all levels of the<br/>\n&gt; implementation.<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;&gt;  &gt; I wonder if thinking about the interface you wish IDEs<br/>\n&gt;&gt;  &gt; would talk to, and then getting at least one IDE to agree to it, would<br/>\n&gt;&gt;  &gt; be a good approach.<br/>\n&gt;<br/>\n&gt; Yes, that&#39;s what I&#39;m planning. As Linus Torvalds says, &quot;Talk is cheap.<br/>\n&gt; Show me the code.&quot;<br/>\n&gt;<br/>\n&gt; My current plan is to implement a minimal set of features, create a UI<br/>\n&gt; and integrate it with IntelliJ IDEA. Then people can better see what<br/>\n&gt; this is all about, and can better decide whether it&#39;s something that<br/>\n&gt; they like. I will setup a dedicated mailing list and contact the major<br/>\n&gt; tool vendors after I have something working to show (right now I&#39;m only<br/>\n&gt; gauging some interest on JUnit, scala-tools and simple-build-tool<br/>\n&gt; mailing lists).<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;&gt; I think the main advantage to being able to count the tests before<br/>\n&gt;&gt; you run<br/>\n&gt;&gt; them is that is that you can make a progress bar that gives feedback to the<br/>\n&gt;&gt; user as the tests run. That&#39;s a really nice feature in GUI test runners that<br/>\n&gt;&gt; is lost if you can&#39;t count tests in advance. It would be possible to make<br/>\n&gt;&gt; the advance test count an optional feature, but then when tests can&#39;t be<br/>\n&gt;&gt; counted, you couldn&#39;t show a progress bar. And I think that would be a<br/>\n&gt;&gt; pretty big loss.<br/>\n&gt;<br/>\n&gt; I&#39;ve thought about that. It&#39;s possible to measure progress at least on<br/>\n&gt; the class level. And within a class, the completion of a class can be<br/>\n&gt; approximated as more tests are discovered.<br/>\n&gt;<br/>\n&gt; I&#39;m also planning on making the tool remember statistics from previous<br/>\n&gt; test runs (and do some classloader caching of external libraries, to<br/>\n&gt; speed up the test runs), so after the first test run the tool will know<br/>\n&gt; quite accurately that how many tests there are and how long each of them<br/>\n&gt; takes to execute.<br/>\n&gt;<br/>\n&gt; I&#39;ve also thought about some ways to detect which classes are covered by<br/>\n&gt; a test, which information can be used to run first the tests for the<br/>\n&gt; recently modified classes. So there might be some features similar to<br/>\n&gt; JUnit Max (I haven&#39;t used Max because it&#39;s not available on IntelliJ IDEA).<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;&gt;  &gt; In terms of IDE integration, JUnit just reports a tree of<br/>\n&gt;&gt;  &gt; Descriptions, and results against them. Runners are free to structure<br/>\n&gt;&gt;  &gt; these trees however they wish. Have you run into IDE limitations for<br/>\n&gt;&gt;  &gt; displaying/interacting with these trees?<br/>\n&gt;&gt;  &gt;<br/>\n&gt;&gt; I would question the need for nesting tests. I can easily see the benefit<br/>\n&gt;&gt; of nesting closures in test code. Several traits in ScalaTest do that, but<br/>\n&gt;&gt; the model I use in ScalaTest is that each leaf node is one test. The<br/>\n&gt;&gt; closures surrounding the leaf nodes are descriptions, not tests themselves.<br/>\n&gt;&gt; I would think you and Eric could adopt that approach in Specs and Specsy<br/>\n&gt;&gt; without much trouble.<br/>\n&gt;<br/>\n&gt; It would be possible for me to detect the leaf nodes after the tests<br/>\n&gt; have been run, but I prefer the UI to show the correct mental model of<br/>\n&gt; what is happening during test runs.<br/>\n&gt;<br/>\n&gt; To illustrate, here is a partial version of one of Specsy&#39;s example<br/>\n&gt; specs with some println() debug statements.<br/>\n&gt;<br/>\n&gt; @RunWith(classOf[Specsy])<br/>\n&gt; class StackSpec extends Spec {<br/>\n&gt;   val stack = new scala.collection.mutable.Stack[String]<br/>\n&gt;   println(stack)<br/>\n&gt;<br/>\n&gt;   &quot;When objects have been pushed onto a stack&quot; &gt;&gt; {<br/>\n&gt;     stack.push(&quot;pushed first&quot;)<br/>\n&gt;     stack.push(&quot;pushed last&quot;)<br/>\n&gt;     println(stack)<br/>\n&gt;<br/>\n&gt;     &quot;the object pushed last is popped first&quot; &gt;&gt; {<br/>\n&gt;       val poppedFirst = stack.pop()<br/>\n&gt;       assertThat(poppedFirst, is(&quot;pushed last&quot;))<br/>\n&gt;       println(stack)<br/>\n&gt;     }<br/>\n&gt;     &quot;the object pushed first is popped last&quot; &gt;&gt; {<br/>\n&gt;       stack.pop()<br/>\n&gt;       val poppedLast = stack.pop()<br/>\n&gt;       assertThat(poppedLast, is(&quot;pushed first&quot;))<br/>\n&gt;       println(stack)<br/>\n&gt;     }<br/>\n&gt;   }<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; To execute that, Specsy needs to instantiate and run the class two<br/>\n&gt; times. The first test run will print:<br/>\n&gt;<br/>\n&gt; Stack()<br/>\n&gt; Stack(pushed last, pushed first)<br/>\n&gt; Stack(pushed first)<br/>\n&gt;<br/>\n&gt; The second test run will print:<br/>\n&gt;<br/>\n&gt; Stack()<br/>\n&gt; Stack(pushed last, pushed first)<br/>\n&gt; Stack()<br/>\n&gt;<br/>\n&gt; My vision is that the UI would visualize where one test ends and another<br/>\n&gt; begins. It would provide the same information as the following examples<br/>\n&gt; (but better visualized ;).<br/>\n&gt;<br/>\n&gt; Test run 1:<br/>\n&gt;<br/>\n&gt; -- &lt;net.orfjackal.specsy.examples.StackSpec&gt;<br/>\n&gt; Stack()<br/>\n&gt; --     &lt;When objects have been pushed onto a stack&gt;<br/>\n&gt; Stack(pushed last, pushed first)<br/>\n&gt; --         &lt;the object pushed last is popped first&gt;<br/>\n&gt; Stack(pushed first)<br/>\n&gt; --         &lt;/the object pushed last is popped first&gt;<br/>\n&gt; --     &lt;/When objects have been pushed onto a stack&gt;<br/>\n&gt; -- &lt;/net.orfjackal.specsy.examples.StackSpec&gt;<br/>\n&gt;<br/>\n&gt; Test run 2:<br/>\n&gt;<br/>\n&gt; -- &lt;net.orfjackal.specsy.examples.StackSpec&gt;<br/>\n&gt; Stack()<br/>\n&gt; --     &lt;When objects have been pushed onto a stack&gt;<br/>\n&gt; Stack(pushed last, pushed first)<br/>\n&gt; --         &lt;the object pushed first is popped last&gt;<br/>\n&gt; Stack()<br/>\n&gt; --         &lt;/the object pushed first is popped last&gt;<br/>\n&gt; --     &lt;/When objects have been pushed onto a stack&gt;<br/>\n&gt; -- &lt;/net.orfjackal.specsy.examples.StackSpec&gt;<br/>\n&gt;<br/>\n&gt; Then when I select &quot;StackSpec&quot; or &quot;When objects have been pushed onto a<br/>\n&gt; stack&quot; in the tree of tests shown by the UI, it would show both of those<br/>\n&gt; test runs, because those tests were included in both of them. But if I<br/>\n&gt; select &quot;the object pushed last is popped first&quot; then it will show only<br/>\n&gt; test run 1, and if I select &quot;the object pushed first is popped last&quot; it<br/>\n&gt; will show only test run 2.<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;&gt;  &gt; That assumption is in the IDE&#39;s. It&#39;s a useful one, but it&#39;s neither<br/>\n&gt;&gt;  &gt; required nor assumed by JUnit itself.<br/>\n&gt;<br/>\n&gt; True. I would like to make that concept explicit, so that the testing<br/>\n&gt; framework could help the IDE with code navigation.<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;&gt;  &gt; We&#39;ve taken several stabs at this. The biggest hurdle is how to<br/>\n&gt;&gt;  &gt; extend the test-definition language: while many tests can be<br/>\n&gt;&gt;  &gt; parallelized without cost, and test writers should not depend on<br/>\n&gt;&gt;  &gt; order, they currently might depend on only test being written at the<br/>\n&gt;&gt;  &gt; time.<br/>\n&gt;<br/>\n&gt; I&#39;ve been thinking whether to make parallelization enabled by default.<br/>\n&gt;  From a usability point of view, I would prefer to &quot;design for one user&quot;<br/>\n&gt; (as advocated for example by Alan Cooper) and as such I&#39;m tempted to<br/>\n&gt; write the test runner for programmers who write tests which don&#39;t depend<br/>\n&gt; on any global state (i.e. I would design it for myself :).<br/>\n&gt;<br/>\n&gt; For tests which cannot be executed safely in parallel, my plan is to<br/>\n&gt; make it possible to annotate the class with @LocallySequential or<br/>\n&gt; @GloballySequential. The first annotation would still allow running<br/>\n&gt; tests from other classes in parallel, but the second annotation would<br/>\n&gt; execute this one test class all alone.<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;&gt;  &gt; Test discovery seems to be yet another feature of a common IDE interface.<br/>\n&gt;<br/>\n&gt; And build tools.<br/>\n&gt;<br/>\n&gt; One thing that I&#39;m also trying to solve, is minor differences between<br/>\n&gt; running tests in the IDE vs. running them through a build tool. For<br/>\n&gt; example IntelliJ IDEA executes all tests in the project using the same<br/>\n&gt; classpath, but Maven uses the classpath of the module which contains the<br/>\n&gt; tests. If two modules use different versions of a library (I have one<br/>\n&gt; such project), then this difference might be important.<br/>\n&gt;<br/>\n&gt; Also I want to get rid of bugs such as<br/>\n&gt; <a rel=\"nofollow\" target=\"_blank\" href=\"http://youtrack.jetbrains.net/issue/IDEA-57696\">http://youtrack.jetbrains.net/issue/IDEA-57696</a> &quot;IDEA&#39;s JUnit test runner<br/>\n&gt; does not run Scala classes which are annotated with<br/>\n&gt; org.junit.runner.RunWith&quot;. Running tests is such an important feature,<br/>\n&gt; that I don&#39;t want it to have any bugs.<br/>\n&gt;<br/>\n&gt; --<br/>\n&gt; Esko Luontola<br/>\n&gt; www.orfjackal.net<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; ------------------------------------<br/>\n&gt;<br/>\n&gt; Yahoo! Groups Links<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 22938, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1284406748", 
    "canDelete": false, 
    "nextInTopic": 22940, 
    "prevInTopic": 22938, 
    "headers": {
        "inReplyToHeader": "PDRDOEU3OTFELjUwNDA3MDRAZ21haWwuY29tPg==", 
        "messageIdInHeader": "PEFBTkxrVGlrX2haQW5XRmplZE4zTj1qS1cxa3dqZTF0clliQT1DYVAzMW5LVkBtYWlsLmdtYWlsLmNvbT4=", 
        "referencesHeader": "PDRDOEJGREU3LjMwMTA2MDNAZ21haWwuY29tPgk8QUFOTGtUaW40QVhrOEJHY2JYR2ZtNjhLUUZ6THFiVnprK20yMkNyY1VnUnQxQG1haWwuZ21haWwuY29tPgk8QUFOTGtUaW0xMU9STzY4aXJGaEhyVkNCdnFIOHZLOUJRRzI2d2lVeFdkOVpkQG1haWwuZ21haWwuY29tPgk8NEM4RTc5MUQuNTA0MDcwNEBnbWFpbC5jb20+"
    }
}