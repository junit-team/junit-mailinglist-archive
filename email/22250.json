{
    "numMessagesInTopic": 38, 
    "nextInTime": 22251, 
    "senderId": "6STY79HtHXaRMajqTXNCX3CVXqmg10NmgXLkjZT6GkPEMHqeGxYiHSvx9sgqLsEnG9CeHXnDgSOovgvMtUZtVGMdcxeKyA", 
    "systemMessage": false, 
    "subject": "Re: [junit] Order of execution for tests", 
    "from": "Kent Beck &lt;kentb@...&gt;", 
    "authorName": "Kent Beck", 
    "msgSnippet": "From this it looks like you could partially order tests based on what SUT code they cover. In this case, Test A is less than Test B. You might want to run", 
    "msgId": 22250, 
    "profile": "kentlbeck", 
    "topicId": 22219, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 173198504, 
    "messageBody": "<div id=\"ygrps-yiv-1575575467\">From this it looks like you could partially order tests based on what SUT code they cover. In this case, Test A is &quot;less than&quot; Test B. You might want to run Test B first as a result.<br/>\n<br/>\nI&#39;ve seen two reasons for test ordering:<br/>\n  * Optimization--getting the whole suite to run more quickly by not running tests that are guaranteed to fail<br/>\n  * Precise feedback--getting the most specific test failure possible and not be overwhelmed by the failure of a whole bunch of dependent tests<br/>\n<br/>\nI assume that only a few tests will fail on any given run (I&#39;ve measured that failure counts follow a power law distribution). Because of this I prefer the JUnit Max-style optimization through test ordering and ignore the precision problem.<br/>\n<br/>\nRegards,<br/>\n<br/>\nKent<br/>\n<br/>\n<blockquote><span title=\"qreply\"> On Dec 30, 2009, at 12:11 PM, Charlie Poole wrote:<br/>\n<br/>\n&gt; Hi Kent, <br/>\n&gt; <br/>\n&gt; &gt; It seems to me that a coverage tool like Clover could <br/>\n&gt; &gt; discover this information dynamically with[out] the user having to <br/>\n&gt; &gt; specify more meta-information about tests that could be wrong <br/>\n&gt; &gt; and would need maintenance. Isn&#39;t removing tedium why we have <br/>\n&gt; &gt; computers in the first place?<br/>\n&gt; <br/>\n&gt; As far as I know, coverage tools deal well with direct dependencies<br/>\n&gt; but not with logical (interpretive) dependency.<br/>\n&gt; <br/>\n&gt; For example, if we have<br/>\n&gt; <br/>\n&gt; Test A --&gt; SUT A --&gt; SUT B<br/>\n&gt; Test B --&gt; SUT B<br/>\n&gt; <br/>\n&gt; Even in this simple case, coverage analysis won&#39;t tell us anything <br/>\n&gt; about the relationship between A and B, although we could make some<br/>\n&gt; deductions by examining the results.<br/>\n&gt; <br/>\n&gt; If there were some way to tell the framework &quot;Test A depends<br/>\n&gt; on functionality, which is tested directly by B&quot; then I can<br/>\n&gt; imagine several good outcomes:<br/>\n&gt; <br/>\n&gt; 1) The test result output could be made much clearer - by<br/>\n&gt; emphasizing the B result when both tests had failed. Some<br/>\n&gt; approaches I can think include subordinating the A result <br/>\n&gt; to that of B, highlighting B, not showing A at all and<br/>\n&gt; marking A as inconclusive.<br/>\n&gt; <br/>\n&gt; 2) Users would be discouraged from seeking annotations that<br/>\n&gt; provide for direct ordering of tests or the actual &quot;hard&quot;<br/>\n&gt; dependencies.<br/>\n&gt; <br/>\n&gt; 3) Less important, but as an optimization, the framework<br/>\n&gt; could suppress running of A if B had already failed.<br/>\n&gt; <br/>\n&gt; Charlie<br/>\n&gt; <br/>\n&gt; &gt; Kent<br/>\n&gt; &gt; <br/>\n&gt; &gt; On Dec 29, 2009, at 2:28 PM, Pigneri, Rocco wrote:<br/>\n&gt; &gt; <br/>\n&gt; &gt; &gt; Charlie,<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; &gt;As a framework author, I can see that allowing the user to specify <br/>\n&gt; &gt; &gt; &gt;ordering is a simpler implementation. But I think it&#39;s more <br/>\n&gt; &gt; &gt; &gt;interesting to imagine the user specifying the nature of the <br/>\n&gt; &gt; &gt; &gt;dependencies and allowing the framework to figure out a strategy.<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; I am very much with you on this one. In my experience, <br/>\n&gt; &gt; there have been a lot of times when functions under test <br/>\n&gt; &gt; within the same class depend upon each other, and it would <br/>\n&gt; &gt; have been great to have the test harness know that <br/>\n&gt; &gt; information. When I was refactoring code for a new framework <br/>\n&gt; &gt; package, I would have loved to have the UI to display <br/>\n&gt; &gt; non-dependent tests first as it would have shown me very <br/>\n&gt; &gt; clearly the source of the problem.<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; Specifying only the relationships in code and leaving the <br/>\n&gt; &gt; display strategy to the test harness would allow more <br/>\n&gt; &gt; flexible display and execution of these tests based upon the <br/>\n&gt; &gt; user&#39;s goals rather than upon the dependencies themselves. I <br/>\n&gt; &gt; could imagine myself asking the UI only to display the least <br/>\n&gt; &gt; dependent functions&#39; errors and to hide all other errors for <br/>\n&gt; &gt; quick debugging on sweeping optimizations. I could also want <br/>\n&gt; &gt; to see the dependent tests in a tree in case I am changing a <br/>\n&gt; &gt; single class and want to understand the effects of what I am <br/>\n&gt; &gt; touching. I could also want to see all tests in a single list <br/>\n&gt; &gt; with the least dependent at the top and the most dependent on <br/>\n&gt; &gt; the bottom when running regression tests. As you can see, the <br/>\n&gt; &gt; chosen view depends more upon what I am doing than upon the <br/>\n&gt; &gt; test dependencies themselves.<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; Finally, being able to list dependencies between test <br/>\n&gt; &gt; classes in addition to test cases would also JUnit to report <br/>\n&gt; &gt; which components of the system depend upon each other. This <br/>\n&gt; &gt; simple extension would greatly increase the power of the <br/>\n&gt; &gt; dependency models for larger systems (particularly regression tests).<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; Thank you,<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; Rocco<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; From: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a> [mailto:<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>] <br/>\n&gt; &gt; On Behalf <br/>\n&gt; &gt; &gt; Of Charlie Poole<br/>\n&gt; &gt; &gt; Sent: Thursday, December 24, 2009 12:09 AM<br/>\n&gt; &gt; &gt; To: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a><br/>\n&gt; &gt; &gt; Subject: RE: [junit] Order of execution for tests<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; Hi C�dric,<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; &gt; &gt; On another list, I identified the same variations of dependency <br/>\n&gt; &gt; &gt; &gt; &gt; but with the variation that for case 1. We might run B <br/>\n&gt; &gt; anyway but <br/>\n&gt; &gt; &gt; &gt; &gt; could highlight the error in A in some way. That <br/>\n&gt; &gt; approach doesn&#39;t <br/>\n&gt; &gt; &gt; &gt; &gt; require ordering the tests in any particular way, which <br/>\n&gt; &gt; has some advantages.<br/>\n&gt; &gt; &gt; &gt; &gt; It still promotes developer efficiency while not worrying about <br/>\n&gt; &gt; &gt; &gt; &gt; execution efficiency.<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; Yes, we call these &quot;soft dependencies&quot;.<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; If &quot;b&quot; has a hard dependency on &quot;a&quot; and &quot;a&quot; fails, &quot;a&quot; will be <br/>\n&gt; &gt; &gt; &gt; marked &quot;FAILED&quot; and b &quot;SKIPPED&quot;.<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; If &quot;b&quot; has a soft dependency on &quot;a&quot;, &quot;b&quot; will still run <br/>\n&gt; &gt; even if &quot;a&quot; <br/>\n&gt; &gt; &gt; &gt; fails but a warning could be displayed in the log.<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; This is an implementation-based view of the tests: i.e. they will <br/>\n&gt; &gt; &gt; either be run or not run.<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; The distinction I was trying to make - and I think David as <br/>\n&gt; &gt; well - is <br/>\n&gt; &gt; &gt; based on the cause and nature of the dependency.<br/>\n&gt; &gt; &gt; For the sake of argument, I&#39;ll try to redefine what you&#39;re calling <br/>\n&gt; &gt; &gt; Hard and Soft along those lines.<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; Hard: Test A does something (sets state) upon which B depends.<br/>\n&gt; &gt; &gt; For example, A may write to a data store and B might try to <br/>\n&gt; &gt; read the <br/>\n&gt; &gt; &gt; information back. Or A might create a complex object and B <br/>\n&gt; &gt; might try <br/>\n&gt; &gt; &gt; to call a method on that object. If we allow this sort of <br/>\n&gt; &gt; thing, then <br/>\n&gt; &gt; &gt; there is no choice but to run A first and it makes sense to <br/>\n&gt; &gt; not run B <br/>\n&gt; &gt; &gt; at all if A fails. However, I would not want a unit test <br/>\n&gt; &gt; framework to <br/>\n&gt; &gt; &gt; allow it.<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; Soft: Test A tests some functionality upon which some other <br/>\n&gt; &gt; &gt; functionality, tested by B, depends. Therefore, if test A <br/>\n&gt; &gt; fails, Test <br/>\n&gt; &gt; &gt; B will either fail as well or be inconclusive, so nothing <br/>\n&gt; &gt; further can <br/>\n&gt; &gt; &gt; be learned from test B. In this case, a testing framework could <br/>\n&gt; &gt; &gt; respond in a number of ways to the dependency:<br/>\n&gt; &gt; &gt; 1) Run the tests in order, skipping B if A fails.<br/>\n&gt; &gt; &gt; 2) Run the tests in an arbitrary order, but skip B if A already ran <br/>\n&gt; &gt; &gt; and failed.<br/>\n&gt; &gt; &gt; 3) Run the tests in an arbitrary order, not skipping any of <br/>\n&gt; &gt; them but <br/>\n&gt; &gt; &gt; organize reporting in such a way that a failure of A takes <br/>\n&gt; &gt; precedence <br/>\n&gt; &gt; &gt; over a failure of B.<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; As a framework author, I can see that allowing the user to specify <br/>\n&gt; &gt; &gt; ordering is a simpler implementation. But I think it&#39;s more <br/>\n&gt; &gt; &gt; interesting to imagine the user specifying the nature of the <br/>\n&gt; &gt; &gt; dependencies and allowing the framework to figure out a strategy.<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; Charlie<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; &gt; Every time we have discussed this potential feature for <br/>\n&gt; &gt; TestNG, the <br/>\n&gt; &gt; &gt; &gt; discussion ended up being non conclusive on the real interest and <br/>\n&gt; &gt; &gt; &gt; the existing ability to mark certain methods as <br/>\n&gt; &gt; &quot;alwaysRun&quot; already <br/>\n&gt; &gt; &gt; &gt; fills a big part of this scenario, so I always ended up <br/>\n&gt; &gt; punting on <br/>\n&gt; &gt; &gt; &gt; it, but I&#39;d be happy to hear if someone can come up with <br/>\n&gt; &gt; a good use <br/>\n&gt; &gt; &gt; &gt; case for soft dependencies...<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; --<br/>\n&gt; &gt; &gt; &gt; ***C�dric<br/>\n&gt; &gt; &gt; &gt; *<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; [Non-text portions of this message have been removed]<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; ------------------------------------<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; Yahoo! Groups Links<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; [Non-text portions of this message have been removed]<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; <br/>\n&gt; &gt; <br/>\n&gt; &gt; <br/>\n&gt; &gt; [Non-text portions of this message have been removed]<br/>\n&gt; &gt; <br/>\n&gt; &gt; <br/>\n&gt; &gt; <br/>\n&gt; &gt; ------------------------------------<br/>\n&gt; &gt; <br/>\n&gt; &gt; Yahoo! Groups Links<br/>\n&gt; &gt; <br/>\n&gt; &gt; <br/>\n&gt; &gt; <br/>\n&gt; &gt; <br/>\n&gt; <br/>\n&gt; <br/>\n<br/>\n<br/>\n<br/>\n[Non-text portions of this message have been removed] </span></blockquote></div>", 
    "prevInTime": 22249, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1262630659", 
    "canDelete": false, 
    "nextInTopic": 22251, 
    "prevInTopic": 22249, 
    "headers": {
        "inReplyToHeader": "PDAwM2QwMWNhODk4YyQzOTFkOWZmMCQ3MjAxYThjMEBmZXJyYXJpPg==", 
        "messageIdInHeader": "PEMwQThEMTBELTJDQjktNDBBNC1BQ0M2LTQyN0RCNkE1RDY2MEBlYXJ0aGxpbmsubmV0Pg==", 
        "referencesHeader": "PDAwM2QwMWNhODk4YyQzOTFkOWZmMCQ3MjAxYThjMEBmZXJyYXJpPg=="
    }
}