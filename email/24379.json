{
    "numMessagesInTopic": 1, 
    "nextInTime": 24380, 
    "senderId": "dZpZAlsBENvDgVYzCyTCkIZYunKbWepM-8zCLUPYWl8FS5b1nD0E3KYYPYlq735OW7KiTTw4eyzG-QE6Hq_uzU2xEQT4oDDs6M6BTQ", 
    "systemMessage": false, 
    "subject": "Out of Mem when using @DataPoints with Iterator type, request lazy fetch", 
    "from": "&quot;willmcqueen&quot; &lt;willmcqueen@...&gt;", 
    "authorName": "willmcqueen", 
    "msgSnippet": "Hi, ... ...but just one problem -- the JUnit Iterable @DataPoints doesn t seem to get the data lazily... it looks like it slurps everything into memory before", 
    "msgId": 24379, 
    "profile": "willmcqueen", 
    "topicId": 24379, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 125879749, 
    "messageBody": "<div id=\"ygrps-yiv-113113446\">Hi,<br/>\n<br/>\nI see that in the current master branch of JUnit, the JUnit 4.12 release notes say:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; &quot;Pull request #658: Iterables can now be used as datapoints<br/>\n&gt; Previously when building sets of datapoints for Theory parameters<br/>\n&gt; the only valid multi-valued @DataPoints types were arrays. This has<br/>\n&gt; now been extended to also take parameters from iterable @DataPoints<br/>\n&gt; methods and fields.&quot;<br/>\n<br/>\n </span></blockquote>Fantastic. To me this means that we can now have something similar to TestNG&#39;s DataProvider that returns an &#39;Iterator&lt;Object[]&gt;&#39; (<a rel=\"nofollow\" target=\"_blank\" href=\"http://testng.org/doc/documentation-main.html)\">http://testng.org/doc/documentation-main.html)</a>:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; An Iterator&lt;Object[]&gt;. The only difference with Object[][] is that an Iterator<br/>\n&gt; lets you create your test data lazily. TestNG will invoke the iterator and then<br/>\n&gt; the test method with the parameters returned by this iterator one by one.<br/>\n&gt; This is particularly useful if you have a lot of parameter sets to pass to the<br/>\n&gt; method and you don&#39;t want to create all of them upfront.<br/>\n<br/>\n </span></blockquote>...but just one problem -- the JUnit Iterable @DataPoints doesn&#39;t seem to get the data lazily... it looks like it slurps everything into memory before passing it to the Theory test. I&#39;d like to request that we please change the implementation of this method so that the data is ingested lazily (one element at a time, or maybe in batches) to avoid OOME. As a quick test, what I&#39;d consider to be a desirable implementation would be one that passes a test that uses this infinite @DataPoints:<br/>\n<br/>\nimport com.google.common.collect.Iterables<br/>\n  @DataPoints<br/>\n  public static Iterable&lt;String&gt; infiniteDataStream() {<br/>\n      return Iterables.cycle(&quot;one&quot;, &quot;two&quot;);  //continuously alternate between 2 values<br/>\n  }<br/>\n<br/>\n[Ref: <a rel=\"nofollow\" target=\"_blank\" href=\"http://docs.guava-libraries.googlecode.com/git-history/v14.0.1/javadoc/com/google/common/collect/Iterables.html#cycle(\">http://docs.guava-libraries.googlecode.com/git-history/v14.0.1/javadoc/com/google/common/collect/Iterables.html#cycle(</a>T...)]<br/>\n<br/>\nAlternatively, here&#39;s a finite test that still results in OOME:<br/>\n<br/>\nimport com.google.common.collect.Iterables<br/>\nimport java.util.Arrays;<br/>\nimport java.util.Collections;<br/>\n  public static Iterable&lt;String&gt; finiteDataStream() {<br/>\n    //return 200 million copies of &quot;aaa&quot; and &quot;bbb&quot;<br/>\n    return Iterables.concat(Collections.nCopies(200000000, Arrays.asList(&quot;aaa&quot;, &quot;bbb&quot;)));<br/>\n  }<br/>\n<br/>\nHere&#39;s the OOME:<br/>\n<br/>\njava.lang.OutOfMemoryError: Java heap space<br/>\n\tat java.lang.AbstractStringBuilder.&lt;init&gt;(AbstractStringBuilder.java:45)<br/>\n\tat java.lang.StringBuilder.&lt;init&gt;(StringBuilder.java:68)<br/>\n\tat org.junit.experimental.theories.internal.AllMembersSupplier.addIterableValues(AllMembersSupplier.java:147)<br/>\n\tat org.junit.experimental.theories.internal.AllMembersSupplier.addDataPointsValues(AllMembersSupplier.java:128)<br/>\n\tat org.junit.experimental.theories.internal.AllMembersSupplier.addMultiPointMethods(AllMembersSupplier.java:83)<br/>\n\tat org.junit.experimental.theories.internal.AllMembersSupplier.getValueSources(AllMembersSupplier.java:71)<br/>\n\tat org.junit.experimental.theories.internal.Assignments.potentialsForNextUnassigned(Assignments.java:78)<br/>\n\tat org.junit.experimental.theories.Theories$TheoryAnchor.runWithIncompleteAssignment(Theories.java:162)<br/>\n\tat org.junit.experimental.theories.Theories$TheoryAnchor.runWithAssignment(Theories.java:153)<br/>\n\tat org.junit.experimental.theories.Theories$TheoryAnchor.evaluate(Theories.java:138)<br/>\n\tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)<br/>\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:72)<br/>\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:51)<br/>\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)<br/>\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)<br/>\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)<br/>\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)<br/>\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)<br/>\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)<br/>\n\tat org.junit.runner.JUnitCore.run(JUnitCore.java:160)<br/>\n\tat com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:77)<br/>\n\tat com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:195)<br/>\n\tat com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:63)<br/>\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br/>\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)<br/>\n\tat com.intellij.rt.execution.application.AppMain.main(AppMain.java:120)<br/>\n<br/>\n<br/>\nThank you for considering this request.<br/>\n<br/>\nCheers,<br/>\nWill</div>", 
    "prevInTime": 24378, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1367468635", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PGtsc3BvcitmMzloQGVHcm91cHMuY29tPg=="
    }
}