{
    "numMessagesInTopic": 48, 
    "nextInTime": 19632, 
    "senderId": "UBlZN8D-7KabzEUjIlYnPQXSFUdqIzTfZNSLVp465CUcNEsctkBRXInJmtb5zI0OxGawqr5pUsolAQM2o1txvtV28Anm7txoWqKoBQevjyFVh8T-bA", 
    "systemMessage": false, 
    "subject": "RE: Assurance/CPU cycle ratio [branching from Re: Test Grouping/Partitioning]", 
    "from": "&quot;David Jackman&quot; &lt;david.jackman@...&gt;", 
    "authorName": "David Jackman", 
    "msgSnippet": "This idea of an assurance/CPU cycle ratio is intriguing.  Thinking of a particular module where I spend most of my time, I have many hundreds of unit tests", 
    "msgId": 19631, 
    "profile": "djackmanq", 
    "topicId": 19521, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 207066460, 
    "messageBody": "<div id=\"ygrps-yiv-882107786\">This idea of an assurance/CPU cycle ratio is intriguing.  Thinking of a<br/>\nparticular module where I spend most of my time, I have many hundreds of<br/>\nunit tests that do run fairly fast (several seconds), but are slow<br/>\nenough that I find myself not running them sometimes so as not to break<br/>\nmy momentum.  The assurance/CPU cycle ratio concept would imply that it<br/>\nshould be possible to improve the ratio without decreasing the assurance<br/>\nI&#39;m getting from running the tests.  <br/>\n<br/>\n <br/>\n<br/>\nWhat formulas or patterns did they use for improving this ratio?  How<br/>\ndid they ensure that they weren&#39;t sacrificing assurance while improving<br/>\nperformance (i.e. open the code up for a potential bug in the future<br/>\nbecause a particular case is no longer being tested)?<br/>\n<br/>\n <br/>\n<br/>\n..David..<br/>\n<br/>\n <br/>\n<br/>\nFrom: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a> [mailto:<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>] On Behalf Of<br/>\nKent Beck<br/>\nSent: Thursday, July 26, 2007 4:38 PM<br/>\nTo: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a><br/>\nSubject: [junit] Re: Test Grouping/Partitioning<br/>\n<br/>\n <br/>\n<br/>\nAll,<br/>\n<br/>\nIt seems clear to me that some sort of test classification scheme is a<br/>\nreasonable thing to add to JUnit. However, rather than simply copy one<br/>\nof<br/>\nthe models out there we&#39;re going to go back to first principles and try<br/>\nto<br/>\nderive a model for classification that is concise, useful, flexible,<br/>\nand,<br/>\nabove all, easy to use.<br/>\n<br/>\nI&#39;ve heard two purposes for classification:<br/>\n* Performance<br/>\n* Assumptions<br/>\n<br/>\nPerformance<br/>\n<br/>\nIf you have tests that run for longer than your attention span (my<br/>\nlimits<br/>\nare 1 second for the inner loop of programming and 10 minutes for<br/>\nintegration), running a subset of the tests can give you some assurance<br/>\nthat<br/>\nthe software is working. Classification is one way to reduce test run<br/>\ntime--just this one test, all tests in this class, all tests in this<br/>\npackage, all tests labeled &quot;quick&quot;, etc.<br/>\n<br/>\nThere are other ways of reducing test run time. For example, you could<br/>\nhave<br/>\na runner that runs 1 second worth of the tests that have failed most<br/>\nrecently or a runner that runs half a second of recently failed tests<br/>\nplus<br/>\nhalf a second of randomly selected tests.<br/>\n<br/>\nIn the end I think the systemic solution to test run times is to improve<br/>\ndesign and testing techniques to dramatically increase the assurance/CPU<br/>\ncycle ratio. <br/>\n<br/>\nI remember a friend&#39;s story of an early project that used tests<br/>\nextensively.<br/>\nAfter three years they had a carefully tuned suite that took ten minutes<br/>\nto<br/>\nrun. When the test runtime increased beyond ten minutes, they would work<br/>\non<br/>\nthe design of the system and/or the design of the tests to improve the<br/>\nassurance/CPU cycle ratio and get the runtime back under ten minutes.<br/>\nThen<br/>\nmost of the original team left. <br/>\n<br/>\nA few years later my friend was shown the system. The programmer proudly<br/>\nexplained that the test suites now took 24 hours to run, even though the<br/>\nsystem had grown little in functionality. They had stopped paying<br/>\nattention<br/>\nto designing for testability. Every time they added a new axis of<br/>\nvariability they blindly ran the cross product of the existing tests<br/>\nwith<br/>\nall the alternatives for the new axis. Yes they had more tests, but A/C<br/>\nhad<br/>\ndropped by several orders of magnitude.<br/>\n<br/>\nIn short, I see using classification to reduce test runtime as a bandage<br/>\nmasking the real problem which is low A/C. Using classification to<br/>\nreduce<br/>\ntest runtime really is a hack and I hope people will continue working to<br/>\nimprove design for testability. We will still provide some<br/>\nclassification<br/>\nmechanism, but that doesn&#39;t make it not a hack.<br/>\n<br/>\nAssumptions<br/>\n<br/>\nThe second reason I&#39;ve heard for classification is to avoid a slew of<br/>\nmisleadingly failing tests. If my development machine doesn&#39;t have<br/>\naccess to<br/>\nthe database, then if I run the database tests I&#39;ll get a bunch of<br/>\nfailures<br/>\neven though the system is really working (or, to be more precise, I<br/>\ndon&#39;t<br/>\nhave any information about whether the system is really working or not).<br/>\n<br/>\nClassification is one way to express assumptions. When I say<br/>\n&quot;@Test(groups =<br/>\n{&quot;database&quot;})&quot; I have declared something about this test. However, this<br/>\nexpression seems limited and error-prone to me. I&#39;d prefer to have the<br/>\npower<br/>\nof a programming language to express my assumptions.<br/>\n<br/>\nIn the JUnit 4.4 you can use assumeThat() to express assumptions. For<br/>\nexample, you can say:<br/>\n<br/>\npublic class DatabaseTest {<br/>\n@BeforeClass public static void isDatabaseAccessible() {<br/>\nUser result= Database.login(&quot;kent&quot;);<br/>\nassumeThat(not(isError(result));<br/>\n}<br/>\n...<br/>\n}<br/>\n<br/>\nThis is a bit of a workaround because runner don&#39;t yet handle failed<br/>\nassumptions as anything other than successful tests, but it gives you a<br/>\nricher language to express assumptions than a textual classification<br/>\nscheme.<br/>\n<br/>\nThe Point<br/>\n<br/>\nSo now the point of this long post. Are there other uses of<br/>\nclassification<br/>\nthat I&#39;ve missed? Is the above way of expressing assumptions (or<br/>\nsomething<br/>\nderived from it like an explicit @Assumption) sufficient?<br/>\n<br/>\nRegards,<br/>\n<br/>\nKent Beck<br/>\nThree Rivers Institute<br/>\n<br/>\n[Non-text portions of this message have been removed]<br/>\n<br/>\n <br/>\n<br/>\n<br/>\n<br/>\n[Non-text portions of this message have been removed]</div>", 
    "prevInTime": 19630, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1185547671", 
    "canDelete": false, 
    "nextInTopic": 19639, 
    "prevInTopic": 19627, 
    "headers": {
        "inReplyToHeader": "PDAwMzEwMWM3Y2ZkNSRhZmY1ZTU2MCQ2NzAxYThjMEBrZW50c3BhdmlsaW9uPg==", 
        "messageIdInHeader": "PDVDRDM3QjZFMDkwNDU0NDg5QzVGQzE1QjlCNEI1QjE5MTg5OTM1QHNsY2VzMDIuYWQuZmFzdC5ubz4=", 
        "referencesHeader": "PDAwMzEwMWM3Y2ZkNSRhZmY1ZTU2MCQ2NzAxYThjMEBrZW50c3BhdmlsaW9uPg=="
    }
}