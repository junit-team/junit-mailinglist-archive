{
    "numMessagesInTopic": 8, 
    "nextInTime": 22516, 
    "senderId": "vfRM5Zd-QDlFU5rK5e8ZkSp1ssCtDAoYHMotfn54Dg6WG3YRLHm64pt6kRyLv37eFycDrd3HvaWSL6BGAb9qQXCMm6O1R4wCbFLKYkkLWzLJC1HSLx6Q", 
    "systemMessage": false, 
    "subject": "RE: [junit] JUnitBenchmarks (application of @Rule)", 
    "from": "&quot;Loritsch, Berin C.&quot; &lt;berin.loritsch@...&gt;", 
    "authorName": "Loritsch, Berin C.", 
    "msgSnippet": "I’m not going to argue at all about the benchmark comments.  Essentially we are in agreement.  Since most of my tests (currently only self tests) are less", 
    "msgId": 22515, 
    "profile": "bloritsch", 
    "topicId": 22503, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 428096731, 
    "messageBody": "<div id=\"ygrps-yiv-2050859753\">I’m not going to argue at all about the benchmark comments.  Essentially we are in agreement.  Since most of my tests (currently only self tests) are less than a ms, very minor differences in timing can affect the speed of the tests to a very large degree.  For example, running my own tests within the Maven infrastructure has provided a variance between 2ms and 9ms to run the entire suite of tests.  That variance depends on whether the garbage collector is running during testing or not.\r<br/>\n\r<br/>\n \r<br/>\n\r<br/>\nThe goal of the library isn’t so much to work miracles as it is to make it easier to do this type of testing.\r<br/>\n\r<br/>\n \r<br/>\n\r<br/>\nFor QoS testing, let’s say you have a suite of tests that simply verify correctness.  For a simple system, that can be enough.  However, you may discover race conditions and deadlocks in parallel code in a production environment.  The idea is to run all those correctness tests over and over until the system passes with a high enough degree of certainty or you introduce a failure.  In addition to ensuring correctness under load, the test framework will allow you to ensure that all the responses are within a certain timeout threshold.\r<br/>\n\r<br/>\n \r<br/>\n\r<br/>\nAt least that is the end goal.  Another short win would be when there are a mix of short and long running tests.  Unless you have a suite of many long running tests, running the tests in parallel will allow you to shorten the clock time of testing.  Shorter clock times mean quicker turn around for testing.  That in turn encourages the tests to be run more frequently.\r<br/>\n\r<br/>\n \r<br/>\n\r<br/>\nThere’s a lot to be worked out as of yet.  My “Holy Grail”, so to speak, is to have the executing tests behave as if it were running single threaded from the perspective of the test writer.  That is my real end goal.  QoS testing would be a nice and easy win along with the project.\r<br/>\n\r<br/>\n \r<br/>\n\r<br/>\nFrom: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a> [mailto:<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>] On Behalf Of Dawid Weiss\r<br/>\nSent: Monday, March 08, 2010 2:37 PM\r<br/>\nTo: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>\r<br/>\nSubject: Re: [junit] JUnitBenchmarks (application of @Rule)\r<br/>\n\r<br/>\n \r<br/>\n\r<br/>\n  \r<br/>\n\r<br/>\n<blockquote><span title=\"ireply\"> &gt; I started a new project to flesh out my ideas from the RT I posted last week that might fit this solution well.  In essence, the project I\r<br/>\n\r<br/>\n </span></blockquote>Oh, interesting.\r<br/>\n\r<br/>\n<blockquote><span title=\"ireply\"> &gt; gotten it to the place where it can run its own tests and the result events are processed in a separate thread.\r<br/>\n\r<br/>\n&gt; On a minor side note, when the bulk of your tests are short and do not involve a lot of objects, you can see as much as 100% speed gains.  Essentially, by short I mean less than a millisecond in duration.  The speed gains are achieved by not penalizing the tests while you write to the console.  In more substantive tests you will not see as much of a speed gain.\r<br/>\n\r<br/>\n </span></blockquote>Micro-benchmarking is tricky itself, no library is going to guarantee\r<br/>\ncommon sense here. What you&#39;re talking about is really a bad benchmark\r<br/>\n-- if you include an operation with such a large time variance\r<br/>\n(writing to console), the results will have a high variance too, of\r<br/>\ncourse.\r<br/>\n\r<br/>\n<blockquote><span title=\"ireply\"> &gt; Essentially the QoS testing framework will have some hooks to specify numbers of runs, parameters, etc.  My hope is that at the very\r<br/>\n\r<br/>\n </span></blockquote>This library I posted does have some sort of this -- there are\r<br/>\nannotations that drive the benchmarking process (number of warmup\r<br/>\nruns, benchmarks runs, reset for the GC on every round, etc.).\r<br/>\n\r<br/>\n<blockquote><span title=\"ireply\"> &gt; testing for benchmarks and quality of service is a little different from regular unit testing.\r<br/>\n\r<br/>\n </span></blockquote>I believe it may be, don&#39;t know much about QoS.\r<br/>\n\r<br/>\n<blockquote><span title=\"ireply\"> &gt; Also note: for more accurate test timing, use the System.nanoTime().  Most JVM implementations only increment the system clock every 10ms.  That’s fine enough for telling the time, but when your individual tests are typically faster than 10ms that lack of granularity can hurt.\r<br/>\n\r<br/>\n </span></blockquote>In fact they are both equally unreliable, so changing to theoretically\r<br/>\nsmaller granularity is not really going to help. From our experience,\r<br/>\nyou need to design a benchmark that takes a more significant amount of\r<br/>\ntime (in the order of milliseconds at least) and make sure HotSpot has\r<br/>\ndone its job (and no deoptimizations occur). In any other scenario\r<br/>\nbenchmark results will be too close to noise and prone to large\r<br/>\nvariance distortions due to background processes and other activity.\r<br/>\n\r<br/>\nDawid\r<br/>\n\r<br/>\n\r<br/>\n\r<br/>\n<br/>\n<br/>\n[Non-text portions of this message have been removed]</div>", 
    "prevInTime": 22514, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1268079810", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 22514, 
    "headers": {
        "inReplyToHeader": "PGJhYThjNTczMTAwMzA4MTEzNnU0YjUzYWZmMm04ZjU5NjBhZGU4MWQ0MWE1QG1haWwuZ21haWwuY29tPg==", 
        "messageIdInHeader": "PDc1RjVFRDhBNUE1NTM2NDZBNDZFMDBFNkVDODU0RkEzMDQ1MTMyRURAdmFmZjAxLW1haWwwMS5hZC5nZC1haXMuY29tPg==", 
        "referencesHeader": "PGhuMm45cytyN2xxQGVHcm91cHMuY29tPiA8NGY3ZGE2YjkxMDAzMDgwNjMwdDFiNWE2Y2RjeGE3ZmRmZjc5ZWIzMWM3ZjlAbWFpbC5nbWFpbC5jb20+IDxiYWE4YzU3MzEwMDMwODA2NDdsMmEwMTQzOTdoYmZhYmY0MjAzYTEwOTAxNEBtYWlsLmdtYWlsLmNvbT4gPDRmN2RhNmI5MTAwMzA4MDcwMms3ZWI3ZmQwMm4xZmZkYTMxN2ExMmFjMjc0QG1haWwuZ21haWwuY29tPiA8YmFhOGM1NzMxMDAzMDgwODI3cjM1NDlkYWZleDJiOGMyNzk1NzE0MDA3MDJAbWFpbC5nbWFpbC5jb20+IDw3NUY1RUQ4QTVBNTUzNjQ2QTQ2RTAwRTZFQzg1NEZBMzA0NTEzMjkwQHZhZmYwMS1tYWlsMDEuYWQuZ2QtYWlzLmNvbT4gPGJhYThjNTczMTAwMzA4MTEzNnU0YjUzYWZmMm04ZjU5NjBhZGU4MWQ0MWE1QG1haWwuZ21haWwuY29tPg=="
    }
}