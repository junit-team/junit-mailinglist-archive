{
    "numMessagesInTopic": 12, 
    "nextInTime": 20755, 
    "senderId": "9mrtkg49YEDV-7B3VDaqF-KAvygn-QKx9ENGyEBrmPGv61SDxYepXiH19ltPGeI4BqzGFFoRt6PHBcBq6ojoVjP46mzlM3lVVA", 
    "systemMessage": true, 
    "subject": "RE: [junit] Anyone help me to figure out the java.lang.StackOverflowError problem?", 
    "from": "fuguo wei &lt;tawqir-wei@...&gt;", 
    "authorName": "fuguo wei", 
    "msgSnippet": "Dear all, I am so glad to get your response. Thank you again. Maybe I used it wrong. I was wandering where I am wrong for a few days. I am confused. Kindly", 
    "msgId": 20754, 
    "profile": "tawqir_wei", 
    "topicId": 20751, 
    "spamInfo": {
        "reason": "5", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 322916937, 
    "messageBody": "<div id=\"ygrps-yiv-1828642429\">Dear all, I am so glad to get your response. Thank you again. Maybe I used it wrong. I was wandering where I am wrong for a few days. I am confused. Kindly hope you could help me. here is the code.(in the attachment) By the way, I tried the debug my source code with Eclipse debugger. There is no problem.  Best regardsWEI FUGUO<br/>\n_________________________________________________________________<br/>\nInvite your mail contacts to join your friends list with Windows Live Spaces. It&#39;s easy!<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://spaces.live.com/spacesapi.aspx?wx_action=create&wx_url=/friends.aspx&mkt=en-us\">http://spaces.live.com/spacesapi.aspx?wx_action=create&wx_url=/friends.aspx&mkt=en-us</a><br/>\n  ----------<br/>\n<br/>\n(1) the test case is like this<br/>\n <br/>\n public void testCreateTableCluster() {<br/>\n  mapper2.createTableCluster();<br/>\n  assertNotNull(mapper.getClassMap().getTableCluster());<br/>\n }<br/>\n<br/>\n(2) the createTableCluster() source code is like this<br/>\n<br/>\n public void createTableCluster() {<br/>\n  tableCluster.createMasterTable(tableName, classmap);<br/>\n }<br/>\n <br/>\n(3) the createMasterTable() source code is like this<br/>\n<br/>\n public MasterTableMap createMasterTable(String aTablename, ClassMap aClassmap) <br/>\n {<br/>\n  return (MasterTableMap)createTable(aTablename,aClassmap,&#39;masterTable&#39;);<br/>\n }<br/>\n<br/>\n(4) createTable() source code<br/>\n <br/>\n public TableMap createTable(String aTablename, ClassMap aClassmap, String aTabletype) <br/>\n {<br/>\n  pf.ColumnMap colummap=null;<br/>\n  TableMap result =null; <br/>\n  if (aTabletype.equals(&#39;masterTable&#39;))<br/>\n  {<br/>\n   result= new MasterTableMap(aTablename);<br/>\n   this.set_masterTableMap(result);<br/>\n  }<br/>\n  else if (aTabletype.equals(&#39;independentTable&#39;))<br/>\n   result= new IndependentTableMap(aTablename);<br/>\n  else if (aTabletype.equals(&#39;dependentTable&#39;))<br/>\n   result= new DependentTableMap(aTablename);<br/>\n  setCurrentTableMap(result);<br/>\n  aClassmap.setMasterTable(result); <br/>\n  <br/>\n  java.util.List tempList =aClassmap.getColumnMaps();<br/>\n  <br/>\n  Iterator tmpIter = tempList.iterator();<br/>\n  while (tmpIter.hasNext()) <br/>\n  {<br/>\n   colummap = (pf.ColumnMap)tmpIter.next();<br/>\n   colummap.getAttributeMapper().createTableSqlProcess(this, colummap, aClassmap);<br/>\n  }<br/>\n  addTableMaps(result);<br/>\n  return result;<br/>\n }<br/>\n(5) one of createTableSqlProcess() is like this. [many classes which inherit from the same parent have createTableSqlProcess]<br/>\n <br/>\n public void createTableSqlProcess(TableCluster aTablecluster, pf.ColumnMap aColumnmap, pf.ClassMap aMasterClass) {<br/>\n  ArrayColumnMap arrayColumnmap = (ArrayColumnMap)aColumnmap;<br/>\n  ClassMap classmap=null;<br/>\n  pf.PersistenceClass persisClass=null;<br/>\n  String tableName =null;<br/>\n  configfiend.RelationshipItem relation=null;<br/>\n  DependentTableMap depentable=null; <br/>\n  <br/>\n  String elementCategory=arrayColumnmap.getElementCategory();<br/>\n  if (elementCategory.equals(&#39;Complex&#39;))<br/>\n  {<br/>\n   classmap =arrayColumnmap.getClassMap();<br/>\n   if (classmap==null)<br/>\n   {<br/>\n    logger.debug(&#39;The array attribute &#39;+arrayColumnmap.getColumnName()+&#39;&#39;s related class was not there, the system will load it at once!&#39;);<br/>\n    persisClass=PersistentClassManager.loadPersistenceClass(arrayColumnmap.getFieldType());<br/>\n    if (persisClass!=null)<br/>\n    {<br/>\n     classmap=persisClass.getMapper().getClassMap();<br/>\n    }<br/>\n    else<br/>\n    {<br/>\n     logger.debug(&#39;couldn&#39;t get the persistence class from peristence class lib. the process will be terminated&#39;);<br/>\n     return;<br/>\n    } <br/>\n   }<br/>\n   tableName=classmap.getTableName();<br/>\n   relation=arrayColumnmap.getRelationship();<br/>\n   if (arrayColumnmap.isReflectRelation())<br/>\n   {<br/>\n    if (relation!=null)<br/>\n    {<br/>\n     if ((relation.getRelationshipType().equals(&#39;Composition&#39;))||(relation.getRelationshipType().equals(&#39;Strong Aggregation&#39;)))<br/>\n     {<br/>\n      depentable=aTablecluster.createDependentTable(tableName, classmap);<br/>\n      depentable.setReferenceTable(aMasterClass.getMasterTable());<br/>\n     }<br/>\n     else<br/>\n      aTablecluster.createIndependentTable(tableName, classmap);<br/>\n    }<br/>\n   }<br/>\n   else<br/>\n    aTablecluster.createIndependentTable(tableName, classmap);<br/>\n  }<br/>\n  else<br/>\n  {<br/>\n   String fieldname=arrayColumnmap.getFieldName();<br/>\n   String fieldtype=arrayColumnmap.getFieldType();<br/>\n   TableField tablefield=new TableField(fieldname,fieldtype,aMasterClass.getDomainClass());<br/>\n   aTablecluster.getCurrentTableMap().addField(tablefield);<br/>\n   <br/>\n      String tempstr =aMasterClass.getDomainClass().getName().substring(aMasterClass.getDomainClass().getName().lastIndexOf(&#39;.&#39;)+1)+&#39;oid&#39;;<br/>\n   if (fieldname.toUpperCase().indexOf(tempstr.toUpperCase())!=-1)<br/>\n    aTablecluster.getCurrentTableMap().setPrimaryKey(tablefield);<br/>\n  }<br/>\n }<br/>\n<br/>\nas you can see the createTable method is invoked recursively in createTableSqlProcess() [the bold statement]<br/>\n <br/>\nthe sourse code of createDependentTable() likes this<br/>\n <br/>\n public DependentTableMap createDependentTable(String aTablename, ClassMap aClassmap) {<br/>\n  return (DependentTableMap)createTable(aTablename,aClassmap,&#39;dependentTable&#39;);<br/>\n }<br/>\n<br/>\nthe sourse code of createIndependentTable() likes this<br/>\n <br/>\n public IndependentTableMap createIndependentTable(String aTablename, ClassMap aClassmap) {<br/>\n  return (IndependentTableMap)createTable(aTablename,aClassmap,&#39;independentTable&#39;);<br/>\n }<br/>\n<br/>\n<br/>\n<br/>\nthe two methods are like the createMasterTable() at the beginning of the source code I listed here.<br/>\n <br/>\nthe createTable() is invoked recursively, as you can see. I guess that&#39;s the point why JUnit wrong.<br/>\nthe Junit errow message screen was captured in the attachement.<br/>\n<br/>\n<br/>\n[Non-text portions of this message have been removed]</div>", 
    "prevInTime": 20753, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1217842466", 
    "canDelete": false, 
    "nextInTopic": 20760, 
    "prevInTopic": 20752, 
    "headers": {
        "messageIdInHeader": "PEJBWTEyMi1XMjAwQTdEMjFEODdCMjI3NkRGNTUwOTE3ODBAcGh4LmdibD4="
    }
}