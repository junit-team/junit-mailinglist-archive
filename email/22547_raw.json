{
    "numMessagesInTopic": 23, 
    "nextInTime": 22548, 
    "senderId": "V9lO0-dLX0vNJUSVZol3nzV6kIhjpiCwKVohCw2tZSiVJEopmfwiAVmCq3vqKDA2lBokUmoKxxvbGxa4IOGpv10f", 
    "systemMessage": false, 
    "subject": "Re: [junit] Re: @DataPoints called several times for Theories", 
    "from": "David Saff &lt;david@...&gt;", 
    "authorName": "David Saff", 
    "msgSnippet": "On Mon, Mar 15, 2010 at 9:05 AM, Loritsch, Berin C. ... Sadly, ParameterSupplier only applies to one parameter at a time, but I could imagine a unified API", 
    "msgId": 22547, 
    "rawEmail": "Return-Path: &lt;david.saff@...&gt;\r\nX-Sender: david.saff@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nX-Received: (qmail 12488 invoked from network); 15 Mar 2010 13:51:46 -0000\r\nX-Received: from unknown (98.137.34.44)\n  by m10.grp.re1.yahoo.com with QMQP; 15 Mar 2010 13:51:46 -0000\r\nX-Received: from unknown (HELO mail-px0-f180.google.com) (209.85.216.180)\n  by mta1.grp.sp2.yahoo.com with SMTP; 15 Mar 2010 13:51:46 -0000\r\nX-Received: by pxi10 with SMTP id 10so2136561pxi.31\n        for &lt;junit@yahoogroups.com&gt;; Mon, 15 Mar 2010 06:51:46 -0700 (PDT)\r\nMIME-Version: 1.0\r\nX-Received: by 10.141.90.1 with SMTP id s1mr5823864rvl.42.1268661105323; Mon, 15 \n\tMar 2010 06:51:45 -0700 (PDT)\r\nIn-Reply-To: &lt;75F5ED8A5A553646A46E00E6EC854FA30378C7E4@...-ais.com&gt;\r\nReferences: &lt;58dba2251002180943q238dd8dv11ab48736321e178@...&gt;\n\t &lt;hlkif2+3mte@...&gt;\n\t &lt;58dba2251003121544p3cd7dd28h1a899ce657f66ad3@...&gt;\n\t &lt;a527fddf1003140915l73761ee1r781ba20fc768e42e@...&gt;\n\t &lt;75F5ED8A5A553646A46E00E6EC854FA30378C7E4@...-ais.com&gt;\r\nDate: Mon, 15 Mar 2010 09:51:45 -0400\r\nX-Google-Sender-Auth: 872047ba8b6ae562\r\nMessage-ID: &lt;4f7da6b91003150651m12f2796kf9aab17ff312cd93@...&gt;\r\nTo: junit@yahoogroups.com\r\nCc: Shin Hwei Tan &lt;stan6@...&gt;, Sang Y Baik &lt;sybaik2@...&gt;\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Transfer-Encoding: quoted-printable\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: David Saff &lt;david@...&gt;\r\nSubject: Re: [junit] Re: @DataPoints called several times for Theories\r\nX-Yahoo-Group-Post: member; u=341876227; y=OOpwGVP8sn8aU-GqGY4AKFXXwIbzhAhKbQ0G12tzaBs\r\nX-Yahoo-Profile: dsaff\r\n\r\nOn Mon, Mar 15, 2010 at 9:05 AM, Loritsch, Berin C.\n&lt;berin.loritsch@gd-ais.=\r\ncom&gt; wrote:\n&gt; I&#39;m still going through the patch. =A0Is there a default Clon=\r\neStrategy available? =A0Any cloneable object (implements the Cloneable inte=\r\nrface) will be much quicker than another copy strategy. =A0It&#39;s also an int=\r\nerface and a copy strategy that comes with the JVM since before Java 2.\n&gt;\n&gt;=\r\n Here&#39;s a problem I spotted in the implementation:\n&gt;\n&gt; protected Object get=\r\nCopyStrategyInvokedObject(Object value,\n&gt; =A0 =A0 =A0 =A0Class&lt;? extends Co=\r\npyStrategy&gt; copyStrategy, int index) throws CopyStrategyFailureException {\n=\r\n&gt; =A0 =A0 =A0try {\n&gt; =A0 =A0 =A0 =A0return copyStrategy.newInstance().copyD=\r\nataPoint(value);\n&gt; =A0 =A0 =A0} catch (Exception e) {\n&gt; =A0 =A0 =A0 =A0thro=\r\nw new CopyStrategyFailureException(value, index, copyStrategy.getSimpleName=\r\n());\n&gt; =A0 =A0 =A0}\n&gt; =A0 =A0}\n&gt;\n&gt;\n&gt; Invoking copyStrategy.newInstance() fo=\r\nr every object that needs to be copied is going to be a major performance d=\r\nrain. =A0Not only are we creating more work for the garbage collector, we a=\r\nre going through the overhead of the reflection API to do it. =A0You will h=\r\nave an order of magnitude better performance if you get your instance of th=\r\ne CopyStrategy first, and pass that as necessary.\n&gt;\n&gt; Perhaps another point=\r\n of making the code cleaner would be to pull all the data collection stuff =\r\ninto its own API. =A0It might even be able to support parameterized tests a=\r\ns well as theories. =A0I imagine that was the idea behind ParameterSupplier=\r\n?\n\nSadly, ParameterSupplier only applies to one parameter at a time, but\nI =\r\ncould imagine a unified API that included interfaces for both.\n\n   David\n\n&gt;=\r\n\n&gt; ________________________________\n&gt;\n&gt; From: junit@yahoogroups.com on beha=\r\nlf of Mike Forsberg\n&gt; Sent: Sun 3/14/2010 12:15 PM\n&gt; To: junit@yahoogroups.=\r\ncom; Shin Hwei Tan; Sang Y Baik\n&gt; Subject: Re: [junit] Re: @DataPoints call=\r\ned several times for Theories\n&gt;\n&gt;\n&gt;\n&gt;\n&gt; Please feel free to join the mailin=\r\ng list. I would find the discussion\n&gt; interesting and wish it would not run=\r\n offline.\n&gt;\n&gt; Big Mike\n&gt;\n&gt; On Fri, Mar 12, 2010 at 6:44 PM, Brett Daniel &lt;b=\r\nrettdaniel@... &lt;mailto:brettdaniel%40gmail.com&gt; &gt; wrote:\n&gt;\n&gt;&gt;\n&gt;&gt;\n&gt;&gt; T=\r\nhe undergrads I am advising recently pushed a patch that addresses the\n&gt;&gt; i=\r\nssue of mutable data points.\n&gt;&gt;\n&gt;&gt;\n&gt;&gt; http://github.com/stan6/junit/commit/=\r\ndcfa3c41446c469a4edc7513e9e7a9b610b04020 &lt;http://github.com/stan6/junit/com=\r\nmit/dcfa3c41446c469a4edc7513e9e7a9b610b04020&gt;\n&gt;&gt;\n&gt;&gt; The patch allows develo=\r\npers to define &quot;copy strategies&quot; that duplicate\n&gt;&gt; marked data points befor=\r\ne every theory execution. In this way, every\n&gt;&gt; execution receives a pristi=\r\nne data point, which removes the problems caused\n&gt;&gt; when a theory mutates d=\r\nata points. This is orthogonal to datapoint\n&gt;&gt; (re)creation, but I think co=\r\npy strategies may help address the bug that\n&gt;&gt; Berin found.\n&gt;&gt;\n&gt;&gt; The patch=\r\n creates a new, optional &quot;copyStrategy&quot; parameter for the\n&gt;&gt; @DataPoint and=\r\n @DataPoints annotations. If the developer wants to copy data\n&gt;&gt; points, he=\r\n or she sets the parameter to a class implementing a new\n&gt;&gt; CopyStrategy in=\r\nterface.\n&gt;&gt;\n&gt;&gt; Here is an example:\n&gt;&gt;\n&gt;&gt; @RunWith(Theories.class)\n&gt;&gt; public=\r\n class TestMutable {\n&gt;&gt;\n&gt;&gt; @DataPoint(copyStrategy =3D MutableWithCopyStrat=\r\negy.class)\n&gt;&gt; public static Mutable mutable =3D new Mutable();\n&gt;&gt;\n&gt;&gt; @Theor=\r\ny\n&gt;&gt; public static testMutate(Mutable a) {\n&gt;&gt; a.mutate();\n&gt;&gt; }\n&gt;&gt;\n&gt;&gt; @Theor=\r\ny\n&gt;&gt; public static testNotMutated(Mutable a) {\n&gt;&gt; assertFalse(a.isMutated()=\r\n);\n&gt;&gt; }\n&gt;&gt; }\n&gt;&gt;\n&gt;&gt; In the current implementation of JUnit, the second theor=\r\ny may fail because\n&gt;&gt; the first theory mutates the datapoint. With a copy s=\r\ntrategy enabled, both\n&gt;&gt; theories receive a new value.\n&gt;&gt;\n&gt;&gt; Strategies can=\r\n do almost anything: clone the data point, call a factory\n&gt;&gt; method, or--as=\r\n in the following implementation--instantaiate a new object\n&gt;&gt; with a copy =\r\nconstructor.\n&gt;&gt;\n&gt;&gt; public class MutableWithCopyStrategy implements CopyStra=\r\ntegy {\n&gt;&gt; public Object copyDataPoint(Object toCopy) throws Exception {\n&gt;&gt; =\r\nreturn new Mutable((Mutable)toCopy);\n&gt;&gt; }\n&gt;&gt; }\n&gt;&gt;\n&gt;&gt; There are several bene=\r\nfits to this implementation. First, the new parameter\n&gt;&gt; is completely opti=\r\nonal; if it is omitted, the theory runner behaves as it\n&gt;&gt; always has. Seco=\r\nnd, it doesn&#39;t require modifying the data point&#39;s class\n&gt;&gt; (for\n&gt;&gt; example,=\r\n to add a copy constructor or clone method). Most importantly, it\n&gt;&gt; makes =\r\nit clear to the tester that without a copy strategy one theory\n&gt;&gt; execution=\r\n can impact another.\n&gt;&gt;\n&gt;&gt; I have CC&#39;d the two students in this email. Plea=\r\nse direct any questions to\n&gt;&gt; them.\n&gt;&gt;\n&gt;&gt; Brett\n&gt;&gt;\n&gt;&gt;\n&gt;&gt; On Thu, Feb 18, 20=\r\n10 at 5:28 PM, Berin &lt;berin.loritsch@... &lt;mailto:berin.loritsch%40gd=\r\n-ais.com&gt; &lt;berin.loritsch%40gd-ais.com&gt;&gt;\n&gt;&gt; wrote:\n&gt;&gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt; I agre=\r\ne with your prognosis, about fresh data points for testing the\n&gt;&gt; &gt; theorie=\r\ns. That is precisely why I proposed reading them once, and cloning\n&gt;&gt; &gt; the=\r\nm (making a copy) as needed for each theory. With that approach we\n&gt;&gt; even\n=\r\n&gt;&gt; &gt; get the protection from mutated data points when you use the @DataPoin=\r\nt\n&gt;&gt; to\n&gt;&gt; &gt; mark a static field.\n&gt;&gt; &gt;\n&gt;&gt; &gt; Cloning is a much quicker opera=\r\ntion, does not execute any constructors.\n&gt;&gt; It\n&gt;&gt; &gt; merely copies the conte=\r\nnts of the object memory verbatim.\n&gt;&gt; &gt;\n&gt;&gt; &gt; With the current implementatio=\r\nn, if you are not prepared for the\n&gt;&gt; &gt; combinatorial affect of 60 data poi=\r\nnts combined with 60 data points for\n&gt;&gt; each\n&gt;&gt; &gt; theory there is a major d=\r\nisconnect. The majority of the overhead in this\n&gt;&gt; &gt; particular scenario ha=\r\ns to do with creating objects (with the additional\n&gt;&gt; &gt; overhead of doing i=\r\nt by reflection).\n&gt;&gt; &gt;\n&gt;&gt; &gt; When I created only one instance of each class =\r\ninstead of two, the\n&gt;&gt; &gt; performance was twice as fast (i.e. 37 seconds dow=\r\nn to about 16 seconds).\n&gt;&gt; &gt;\n&gt;&gt; &gt; Essentially the number of times your @Dat=\r\naPoints method is called depends\n&gt;&gt; &gt; on the number of parameters in your @=\r\nTheory and how many theories you\n&gt;&gt; have.\n&gt;&gt; &gt; Essentially the formula for =\r\nmy theory (ha, ha) of the execution is like\n&gt;&gt; &gt; this:\n&gt;&gt; &gt;\n&gt;&gt; &gt; N^(p-1) + =\r\n1\n&gt;&gt; &gt;\n&gt;&gt; &gt; where:\n&gt;&gt; &gt;\n&gt;&gt; &gt; N is the number of data points returned by the=\r\n method\n&gt;&gt; &gt; p is the number of parameters\n&gt;&gt; &gt; and the + 1 represents the =\r\nrun where the data point is read the first\n&gt;&gt; time\n&gt;&gt; &gt;\n&gt;&gt; &gt; So for 60 data=\r\n points it is run 61 times for two parameters. With three\n&gt;&gt; &gt; parameters i=\r\nt would be called 3601 times. I have to verify with three\n&gt;&gt; &gt; parameters. =\r\nThe theory is called N^p times for sure and that is expected.\n&gt;&gt; &gt;\n&gt;&gt; &gt; Wit=\r\nh the above formula, the mapping of number of calls to parameters for\n&gt;&gt; 60=\r\n\n&gt;&gt; &gt; data points would be:\n&gt;&gt; &gt;\n&gt;&gt; &gt; 1 -&gt; 2 (I know this is wrong which gi=\r\nves me doubts on the formula)\n&gt;&gt; &gt; 2 -&gt; 61\n&gt;&gt; &gt; 3 -&gt; 3601\n&gt;&gt; &gt; 3 -&gt; 216001\n=\r\n&gt;&gt; &gt;\n&gt;&gt; &gt; Essentially when the Assignments class needs to make the combinat=\r\nions, it\n&gt;&gt; &gt; will collect the data points initially for each theory. It th=\r\nen calls the\n&gt;&gt; &gt; data points again for each existing data point it collect=\r\ned from the\n&gt;&gt; first\n&gt;&gt; &gt; read. With a third parameter it would take all th=\r\nose combinations again,\n&gt;&gt; to\n&gt;&gt; &gt; add all the permutations for the next ro=\r\nund.\n&gt;&gt; &gt;\n&gt;&gt; &gt; I might be wrong and the real formula would be like this:\n&gt;&gt;=\r\n &gt;\n&gt;&gt; &gt; N^0 + N^1 ... + N^(p-1)\n&gt;&gt; &gt;\n&gt;&gt; &gt; If this is the correct formula, t=\r\nhen if you have 60 data points the\n&gt;&gt; number\n&gt;&gt; &gt; of times the method is ca=\r\nlled would map to the number of parameters like\n&gt;&gt; &gt; this:\n&gt;&gt; &gt;\n&gt;&gt; &gt; 1 -&gt; 1=\r\n\n&gt;&gt; &gt; 2 -&gt; 61\n&gt;&gt; &gt; 3 -&gt; 3661\n&gt;&gt; &gt; 4 -&gt; 219661\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt; --- In junit@y=\r\nahoogroups.com &lt;mailto:junit%40yahoogroups.com&gt; =A0&lt;junit%40yahoogroups.com=\r\n&gt; &lt;junit%\n&gt;&gt; 40yahoogroups.com&gt;, Brett Daniel\n&gt;&gt;\n&gt;&gt; &gt; &lt;brettdaniel@...&gt; wro=\r\nte:\n&gt;&gt; &gt; &gt;\n&gt;&gt; &gt; &gt; Berin,\n&gt;&gt; &gt; &gt;\n&gt;&gt; &gt; &gt; When a theory mutates data points, i=\r\nt might be beneficial to recreate\n&gt;&gt; &gt; &gt; the data point for every theory in=\r\nvocation. Doing so prevents one\n&gt;&gt; &gt; &gt; theory execution from affecting othe=\r\nrs. I wrote about this issue in\n&gt;&gt; &gt; &gt; the following weblog post:\n&gt;&gt; &gt; &gt;\n&gt;&gt;=\r\n &gt; &gt; http://www.brettdaniel.com/archives/2009/09/24/200845/ &lt;http://www.bre=\r\nttdaniel.com/archives/2009/09/24/200845/&gt;\n&gt;&gt; &gt; &gt;\n&gt;&gt; &gt; &gt; You are correct, th=\r\nough, that copying would avoid some of the overhead\n&gt;&gt; &gt; &gt; in calling datap=\r\noint methods. It is interesting you mention this idea,\n&gt;&gt; &gt; &gt; because I am =\r\ncurrently overseeing two students who for their senior\n&gt;&gt; &gt; &gt; thesis projec=\r\nt are implementing framework for copying datapoints. I\n&gt;&gt; &gt; &gt; will post mor=\r\ne information to the mailing list as the project\n&gt;&gt; &gt; &gt; continues.\n&gt;&gt; &gt; &gt;\n&gt;=\r\n&gt; &gt; &gt; Brett\n&gt;&gt; &gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt;\n&gt;&gt; [Non-text portions of this message =\r\nhave been removed]\n&gt;&gt;\n&gt;&gt;\n&gt;&gt;\n&gt;\n&gt; [Non-text portions of this message have bee=\r\nn removed]\n&gt;\n&gt;\n&gt;\n&gt;\n&gt;\n&gt;\n&gt; [Non-text portions of this message have been remov=\r\ned]\n&gt;\n&gt;\n&gt;\n&gt; ------------------------------------\n&gt;\n&gt; Yahoo! Groups Links\n&gt;\n=\r\n&gt;\n&gt;\n&gt;\n\n", 
    "profile": "dsaff", 
    "topicId": 22425, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 341876227, 
    "prevInTime": 22546, 
    "contentTrasformed": false, 
    "postDate": "1268661105", 
    "canDelete": false, 
    "nextInTopic": 22548, 
    "prevInTopic": 22546, 
    "headers": {
        "inReplyToHeader": "PDc1RjVFRDhBNUE1NTM2NDZBNDZFMDBFNkVDODU0RkEzMDM3OEM3RTRAdmFmZjAxLW1haWwwMS5hZC5nZC1haXMuY29tPg==", 
        "messageIdInHeader": "PDRmN2RhNmI5MTAwMzE1MDY1MW0xMmYyNzk2a2Y5YWFiMTdmZjMxMmNkOTNAbWFpbC5nbWFpbC5jb20+", 
        "referencesHeader": "PDU4ZGJhMjI1MTAwMjE4MDk0M3EyMzhkZDhkdjExYWI0ODczNjMyMWUxNzhAbWFpbC5nbWFpbC5jb20+CSA8aGxraWYyKzNtdGVAZUdyb3Vwcy5jb20+CSA8NThkYmEyMjUxMDAzMTIxNTQ0cDNjZDdkZDI4aDFhODk5Y2U2NTdmNjZhZDNAbWFpbC5nbWFpbC5jb20+CSA8YTUyN2ZkZGYxMDAzMTQwOTE1bDczNzYxZWUxcjc4MWJhMjBmYzc2OGU0MmVAbWFpbC5nbWFpbC5jb20+CSA8NzVGNUVEOEE1QTU1MzY0NkE0NkUwMEU2RUM4NTRGQTMwMzc4QzdFNEB2YWZmMDEtbWFpbDAxLmFkLmdkLWFpcy5jb20+"
    }
}