{
    "numMessagesInTopic": 12, 
    "nextInTime": 20774, 
    "senderId": "XjZEPPY0dpklvYX35Ny6PDQXMFmvKZA-N06WZ8X49p5JJvr-I083Ojr_iu3t6ZMZDpKky5T5tx1Iiq_Q9O4ae-wM7Kljik4", 
    "systemMessage": true, 
    "subject": "Re: [junit] Anyone help me to figure out the java.lang.StackOverflowError problem?", 
    "from": "Fuguo Wei &lt;tawqir_wei@...&gt;", 
    "authorName": "Fuguo Wei", 
    "msgSnippet": "Dear David staff, I am sure I tried the man funtion debugger. No problem for that. This situation only happens when I use JUnit.   wish you are lucky   WEI", 
    "msgId": 20773, 
    "profile": "tawqir_wei", 
    "topicId": 20751, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 322916593, 
    "messageBody": "<div id=\"ygrps-yiv-2119752123\">Dear David staff,<br/>\nI am sure I tried the man funtion debugger. No problem for that. This situation only happens when I use JUnit.<br/>\n <br/>\nwish you are lucky<br/>\n <br/>\nWEI FUGUO<br/>\n<br/>\n<blockquote><span title=\"qreply\"> --- On Wed, 8/6/08, David Saff &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:david@...\">david@...</a>&gt; wrote:<br/>\n<br/>\nFrom: David Saff &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:david@...\">david@...</a>&gt;<br/>\nSubject: Re: [junit] Anyone help me to figure out the java.lang.StackOverflowError problem?<br/>\nTo: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a><br/>\nDate: Wednesday, August 6, 2008, 5:22 AM<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\nFuguo,<br/>\n<br/>\nI&#39;m sorry this has been bugging you. It&#39;s difficult to understand how<br/>\nJUnit could be encountering a recursion loop that wasn&#39;t there in your<br/>\nproduction code. Have you tried writing a main() method that runs the<br/>\nsame test, but has no dependencies on JUnit? If it also fails with a<br/>\nStackOverflowError, then you can rest assured that JUnit is not the<br/>\nproblem.<br/>\n<br/>\nDavid Saff<br/>\n<br/>\nOn Tue, Aug 5, 2008 at 6:29 AM, Fuguo Wei &lt;tawqir_wei@yahoo. com&gt; wrote:<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; Dear all, I am so upset about the problem I encountered. Wish any one could<br/>\n&gt; help me. Thank here first. It&#39;s the StackOverflowError problem. I thought<br/>\n&gt; It&#39;s because the recursive program I did. Any way ,I don&#39;t know how to solve<br/>\n&gt; this problem.<br/>\n&gt; Maybe I used it wrong. I was wandering where I am wrong for a few days. I am<br/>\n&gt; confused. Kindly hope you could help me. here is the code.(in the attachment<br/>\n&gt; also) if you can not get it, you could check the group file folder as well.<br/>\n&gt; I uploaded them to there. By the way, I tried the debug my source code with<br/>\n&gt; Eclipse debugger. There is no problem.<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; Best regards<br/>\n&gt;<br/>\n&gt; WEI FUGUO<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; (1) the test case is like this<br/>\n&gt;<br/>\n&gt; public void testCreateTableClus ter() {<br/>\n&gt; mapper2.createTable Cluster() ;<br/>\n&gt; assertNotNull( mapper.getClassM ap().getTableClu ster());<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; (2) the createTableCluster( ) source code is like this<br/>\n&gt;<br/>\n&gt; public void createTableCluster( ) {<br/>\n&gt; tableCluster. createMasterTabl e(tableName, classmap);<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; (3) the createMasterTable( ) source code is like this<br/>\n&gt;<br/>\n&gt; public MasterTableMap createMasterTable( String aTablename, ClassMap<br/>\n&gt; aClassmap)<br/>\n&gt; {<br/>\n&gt; return (MasterTableMap) createTable( aTablename, aClassmap, &#39;masterTable&#39; );<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; (4) createTable( ) source code<br/>\n&gt;<br/>\n&gt; public TableMap createTable( String aTablename, ClassMap aClassmap, String<br/>\n&gt; aTabletype)<br/>\n&gt; {<br/>\n&gt; pf.ColumnMap colummap=null;<br/>\n&gt; TableMap result =null;<br/>\n&gt; if (aTabletype. equals(&#39;masterTa ble&#39;))<br/>\n&gt; {<br/>\n&gt; result= new MasterTableMap( aTablename) ;<br/>\n&gt; this.set_masterTabl eMap(result) ;<br/>\n&gt; }<br/>\n&gt; else if (aTabletype. equals(&#39;independ entTable&#39; ))<br/>\n&gt; result= new IndependentTableMap (aTablename) ;<br/>\n&gt; else if (aTabletype. equals(&#39;dependen tTable&#39;))<br/>\n&gt; result= new DependentTableMap( aTablename) ;<br/>\n&gt; setCurrentTableMap( result);<br/>\n&gt; aClassmap.setMaster Table(result) ;<br/>\n&gt;<br/>\n&gt; java.util.List tempList =aClassmap.getColum nMaps();<br/>\n&gt;<br/>\n&gt; Iterator tmpIter = tempList.iterator( );<br/>\n&gt; while (tmpIter.hasNext( ))<br/>\n&gt; {<br/>\n&gt; colummap = (pf.ColumnMap) tmpIter.next( );<br/>\n&gt; colummap.getAttribu teMapper( ).createTableSql Process(this, colummap,<br/>\n&gt; aClassmap);<br/>\n&gt; }<br/>\n&gt; addTableMaps( result);<br/>\n&gt; return result;<br/>\n&gt; }<br/>\n&gt; (5) one of createTableSqlProce ss() is like this. [many classes which<br/>\n&gt; inherit from the same parent have createTableSqlProce ss]<br/>\n&gt;<br/>\n&gt; public void createTableSqlProce ss(TableCluster aTablecluster, pf.ColumnMap<br/>\n&gt; aColumnmap, pf.ClassMap aMasterClass) {<br/>\n&gt; ArrayColumnMap arrayColumnmap = (ArrayColumnMap) aColumnmap;<br/>\n&gt; ClassMap classmap=null;<br/>\n&gt; pf.PersistenceClass persisClass= null;<br/>\n&gt; String tableName =null;<br/>\n&gt; configfiend. RelationshipItem relation=null;<br/>\n&gt; DependentTableMap depentable=null;<br/>\n&gt;<br/>\n&gt; String elementCategory= arrayColumnmap. getElementCatego ry();<br/>\n&gt; if (elementCategory. equals(&#39;Complex&#39; ))<br/>\n&gt; {<br/>\n&gt; classmap =arrayColumnmap. getClassMap( );<br/>\n&gt; if (classmap==null)<br/>\n&gt; {<br/>\n&gt; logger.debug( &#39;The array attribute &#39;+arrayColumnmap. getColumnName( )+&#39;&#39;s<br/>\n&gt; related class was not there, the system will load it at once!&#39;);<br/>\n&gt; persisClass= PersistentClassM anager.loadPersi stenceClass( arrayColumnmap.<br/>\n&gt; getFieldType( ));<br/>\n&gt; if (persisClass! =null)<br/>\n&gt; {<br/>\n&gt; classmap=persisClas s.getMapper( ).getClassMap( );<br/>\n&gt; }<br/>\n&gt; else<br/>\n&gt; {<br/>\n&gt; logger.debug( &#39;couldn&#39;t get the persistence class from peristence class<br/>\n&gt; lib.. the process will be terminated&#39;) ;<br/>\n&gt; return;<br/>\n&gt; }<br/>\n&gt; }<br/>\n&gt; tableName=classmap. getTableName( );<br/>\n&gt; relation=arrayColum nmap.getRelation ship();<br/>\n&gt; if (arrayColumnmap. isReflectRelatio n())<br/>\n&gt; {<br/>\n&gt; if (relation!=null)<br/>\n&gt; {<br/>\n&gt; if ((relation.getRelat ionshipType( ).equals( &#39;Composition&#39; ))||(relation..<br/>\n&gt; getRelationshipT ype().equals( &#39;Strong Aggregation&#39; )))<br/>\n&gt; {<br/>\n&gt; depentable=aTablecl uster.createDepe ndentTable( tableName, classmap);<br/>\n&gt; depentable.setRefer enceTable( aMasterClass. getMasterTable( ));<br/>\n&gt; }<br/>\n&gt; else<br/>\n&gt; aTablecluster. createIndependen tTable(tableName , classmap);<br/>\n&gt; }<br/>\n&gt; }<br/>\n&gt; else<br/>\n&gt; aTablecluster. createIndependen tTable(tableName , classmap);<br/>\n&gt; }<br/>\n&gt; else<br/>\n&gt; {<br/>\n&gt; String fieldname=arrayColu mnmap.getFieldNa me();<br/>\n&gt; String fieldtype=arrayColu mnmap.getFieldTy pe();<br/>\n&gt; TableField tablefield=new TableField(fieldnam e,fieldtype, aMasterClass..<br/>\n&gt; getDomainClass( ));<br/>\n&gt; aTablecluster. getCurrentTableM ap().addField( tablefield) ;<br/>\n&gt;<br/>\n&gt; String tempstr =aMasterClass. getDomainClass( ).getName( ).substring(<br/>\n&gt; aMasterClass. getDomainClass( ).getName( ).lastIndexOf( &#39;.&#39;)+1)+&#39; oid&#39;;<br/>\n&gt; if (fieldname.toUpperC ase().indexOf( tempstr.toUpperC ase())!=- 1)<br/>\n&gt; aTablecluster. getCurrentTableM ap().setPrimaryK ey(tablefield) ;<br/>\n&gt; }<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; as you can see the createTable method is invoked recursively in<br/>\n&gt; createTableSqlProce ss() [the bold statement]<br/>\n&gt;<br/>\n&gt; the sourse code of createDependentTabl e() likes this<br/>\n&gt;<br/>\n&gt; public DependentTableMap createDependentTabl e(String aTablename, ClassMap<br/>\n&gt; aClassmap) {<br/>\n&gt; return (DependentTableMap) createTable( aTablename, aClassmap,<br/>\n&gt; &#39;dependentTable&#39; );<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; the sourse code of createIndependentTa ble() likes this<br/>\n&gt;<br/>\n&gt; public IndependentTableMap createIndependentTa ble(String aTablename,<br/>\n&gt; ClassMap aClassmap) {<br/>\n&gt; return (IndependentTableMa p)createTable( aTablename, aClassmap,<br/>\n&gt; &#39;independentTabl e&#39;);<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; the two methods are like the createMasterTable( ) at the beginning of the<br/>\n&gt; source code I listed here.<br/>\n&gt;<br/>\n&gt; the createTable( ) is invoked recursively, as you can see. I guess that&#39;s<br/>\n&gt; the point why JUnit wrong.<br/>\n&gt;<br/>\n&gt; the Junit errow message screen was captured in the attachement.<br/>\n&gt;<br/>\n&gt; ----------<br/>\n&gt;<br/>\n&gt; (1) the test case is like this<br/>\n&gt;<br/>\n&gt; public void testCreateTableClus ter() {<br/>\n&gt; mapper2.createTable Cluster() ;<br/>\n&gt; assertNotNull( mapper.getClassM ap().getTableClu ster());<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; (2) the createTableCluster( ) source code is like this<br/>\n&gt;<br/>\n&gt; public void createTableCluster( ) {<br/>\n&gt; tableCluster. createMasterTabl e(tableName, classmap);<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; (3) the createMasterTable( ) source code is like this<br/>\n&gt;<br/>\n&gt; public MasterTableMap createMasterTable( String aTablename, ClassMap<br/>\n&gt; aClassmap)<br/>\n&gt; {<br/>\n&gt; return (MasterTableMap) createTable( aTablename, aClassmap, &#39;masterTable&#39; );<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; (4) createTable( ) source code<br/>\n&gt;<br/>\n&gt; public TableMap createTable( String aTablename, ClassMap aClassmap, String<br/>\n&gt; aTabletype)<br/>\n&gt; {<br/>\n&gt; pf.ColumnMap colummap=null;<br/>\n&gt; TableMap result =null;<br/>\n&gt; if (aTabletype. equals(&#39;masterTa ble&#39;))<br/>\n&gt; {<br/>\n&gt; result= new MasterTableMap( aTablename) ;<br/>\n&gt; this.set_masterTabl eMap(result) ;<br/>\n&gt; }<br/>\n&gt; else if (aTabletype. equals(&#39;independ entTable&#39; ))<br/>\n&gt; result= new IndependentTableMap (aTablename) ;<br/>\n&gt; else if (aTabletype. equals(&#39;dependen tTable&#39;))<br/>\n&gt; result= new DependentTableMap( aTablename) ;<br/>\n&gt; setCurrentTableMap( result);<br/>\n&gt; aClassmap.setMaster Table(result) ;<br/>\n&gt;<br/>\n&gt; java.util.List tempList =aClassmap.getColum nMaps();<br/>\n&gt;<br/>\n&gt; Iterator tmpIter = tempList.iterator( );<br/>\n&gt; while (tmpIter.hasNext( ))<br/>\n&gt; {<br/>\n&gt; colummap = (pf.ColumnMap) tmpIter.next( );<br/>\n&gt; colummap.getAttribu teMapper( ).createTableSql Process(this, colummap,<br/>\n&gt; aClassmap);<br/>\n&gt; }<br/>\n&gt; addTableMaps( result);<br/>\n&gt; return result;<br/>\n&gt; }<br/>\n&gt; (5) one of createTableSqlProce ss() is like this. [many classes which inherit<br/>\n&gt; from the same parent have createTableSqlProce ss]<br/>\n&gt;<br/>\n&gt; public void createTableSqlProce ss(TableCluster aTablecluster, pf.ColumnMap<br/>\n&gt; aColumnmap, pf.ClassMap aMasterClass) {<br/>\n&gt; ArrayColumnMap arrayColumnmap = (ArrayColumnMap) aColumnmap;<br/>\n&gt; ClassMap classmap=null;<br/>\n&gt; pf.PersistenceClass persisClass= null;<br/>\n&gt; String tableName =null;<br/>\n&gt; configfiend. RelationshipItem relation=null;<br/>\n&gt; DependentTableMap depentable=null;<br/>\n&gt;<br/>\n&gt; String elementCategory= arrayColumnmap. getElementCatego ry();<br/>\n&gt; if (elementCategory. equals(&#39;Complex&#39; ))<br/>\n&gt; {<br/>\n&gt; classmap =arrayColumnmap. getClassMap( );<br/>\n&gt; if (classmap==null)<br/>\n&gt; {<br/>\n&gt; logger.debug( &#39;The array attribute &#39;+arrayColumnmap. getColumnName( )+&#39;&#39;s<br/>\n&gt; related class was not there, the system will load it at once!&#39;);<br/>\n&gt; persisClass= PersistentClassM anager.loadPersi stenceClass( arrayColumnmap. getFieldType( ));<br/>\n&gt; if (persisClass! =null)<br/>\n&gt; {<br/>\n&gt; classmap=persisClas s.getMapper( ).getClassMap( );<br/>\n&gt; }<br/>\n&gt; else<br/>\n&gt; {<br/>\n&gt; logger.debug( &#39;couldn&#39;t get the persistence class from peristence class lib.<br/>\n&gt; the process will be terminated&#39;) ;<br/>\n&gt; return;<br/>\n&gt; }<br/>\n&gt; }<br/>\n&gt; tableName=classmap. getTableName( );<br/>\n&gt; relation=arrayColum nmap.getRelation ship();<br/>\n&gt; if (arrayColumnmap. isReflectRelatio n())<br/>\n&gt; {<br/>\n&gt; if (relation!=null)<br/>\n&gt; {<br/>\n&gt; if<br/>\n&gt; ((relation.getRelat ionshipType( ).equals( &#39;Composition&#39; ))||(relation. getRelationshipT ype().equals( &#39;Strong<br/>\n&gt; Aggregation&#39; )))<br/>\n&gt; {<br/>\n&gt; depentable=aTablecl uster.createDepe ndentTable( tableName, classmap);<br/>\n&gt; depentable.setRefer enceTable( aMasterClass. getMasterTable( ));<br/>\n&gt; }<br/>\n&gt; else<br/>\n&gt; aTablecluster. createIndependen tTable(tableName , classmap);<br/>\n&gt; }<br/>\n&gt; }<br/>\n&gt; else<br/>\n&gt; aTablecluster. createIndependen tTable(tableName , classmap);<br/>\n&gt; }<br/>\n&gt; else<br/>\n&gt; {<br/>\n&gt; String fieldname=arrayColu mnmap.getFieldNa me();<br/>\n&gt; String fieldtype=arrayColu mnmap.getFieldTy pe();<br/>\n&gt; TableField tablefield=new<br/>\n&gt; TableField(fieldnam e,fieldtype, aMasterClass. getDomainClass( ));<br/>\n&gt; aTablecluster. getCurrentTableM ap().addField( tablefield) ;<br/>\n&gt;<br/>\n&gt; String tempstr<br/>\n&gt; =aMasterClass. getDomainClass( ).getName( ).substring( aMasterClass. getDomainClass( ).getName( ).lastIndexOf( &#39;.&#39;)+1)+&#39; oid&#39;;<br/>\n&gt; if (fieldname.toUpperC ase().indexOf( tempstr.toUpperC ase())!=- 1)<br/>\n&gt; aTablecluster. getCurrentTableM ap().setPrimaryK ey(tablefield) ;<br/>\n&gt; }<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; as you can see the createTable method is invoked recursively in<br/>\n&gt; createTableSqlProce ss() [the bold statement]<br/>\n&gt;<br/>\n&gt; the sourse code of createDependentTabl e() likes this<br/>\n&gt;<br/>\n&gt; public DependentTableMap createDependentTabl e(String aTablename, ClassMap<br/>\n&gt; aClassmap) {<br/>\n&gt; return<br/>\n&gt; (DependentTableMap) createTable( aTablename, aClassmap, &#39;dependentTable&#39; );<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; the sourse code of createIndependentTa ble() likes this<br/>\n&gt;<br/>\n&gt; public IndependentTableMap createIndependentTa ble(String aTablename,<br/>\n&gt; ClassMap aClassmap) {<br/>\n&gt; return<br/>\n&gt; (IndependentTableMa p)createTable( aTablename, aClassmap, &#39;independentTabl e&#39;);<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; the two methods are like the createMasterTable( ) at the beginning of the<br/>\n&gt; source code I listed here.<br/>\n&gt;<br/>\n&gt; the createTable( ) is invoked recursively, as you can see. I guess that&#39;s the<br/>\n&gt; point why JUnit wrong.<br/>\n&gt; the Junit errow message screen was captured in the attachement.<br/>\n&gt;<br/>\n&gt; [Non-text portions of this message have been removed]<br/>\n&gt;<br/>\n&gt; <br/>\n <br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n      <br/>\n<br/>\n[Non-text portions of this message have been removed] </span></blockquote></div>", 
    "prevInTime": 20772, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1218101021", 
    "canDelete": false, 
    "nextInTopic": 20776, 
    "prevInTopic": 20772, 
    "headers": {
        "inReplyToHeader": "PDRmN2RhNmI5MDgwODA2MDMyMmgxNjdkMTg0ZXU4N2RkMzNhODM4ODk0ZjEwQG1haWwuZ21haWwuY29tPg==", 
        "messageIdInHeader": "PDIzOTM0Ni45MjkxOC5xbUB3ZWI0NDgwOC5tYWlsLnNwMS55YWhvby5jb20+"
    }
}