{
    "numMessagesInTopic": 9, 
    "nextInTime": 22488, 
    "senderId": "Va4lQtmgiL_-jChWLBxVQlkZeATHhnw7DmKwNJaxmmVOTiBQjsFLlvR4Gs6cqsXbhifitTZ3hfHnHqM_lyzDtHLQwF1akpYdpJusyJWcu5FL8S5OOGKa", 
    "systemMessage": false, 
    "subject": "[RT] JUnit Core, Parallelism, Documentation", 
    "from": "&quot;Loritsch, Berin C.&quot; &lt;berin.loritsch@...&gt;", 
    "authorName": "Loritsch, Berin C.", 
    "msgSnippet": "RT = Random Thought.  It s a habit I picked up from Stefano Mazzocchi when I used to work with him on the Cocoon project.  Essentially, it s a structured brain", 
    "msgId": 22487, 
    "profile": "bloritsch", 
    "topicId": 22487, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 428096731, 
    "messageBody": "<div id=\"ygrps-yiv-165304950\">RT = Random Thought.  It&#39;s a habit I picked up from Stefano Mazzocchi<br/>\nwhen I used to work with him on the Cocoon project.  Essentially, it&#39;s a<br/>\nstructured brain dump based on observations of the internals of a<br/>\nproject (as such it is longer than most posts).  My apologies if this is<br/>\nnot the forum for this.<br/>\n<br/>\n== Code Maintenance Thoughts ==<br/>\n<br/>\nI&#39;ve been going through some of the JUnit Core to add some JavaDocs<br/>\n(it&#39;s in my forked copy if you want me to do a Push request), and made a<br/>\nfew observations.  I can definitely see how JUnit has begun to evolve<br/>\nover the years, and as is natural with a couple missteps along the way.<br/>\nIt&#39;s hard to get rid of those missteps because some people may have<br/>\nextended them.  Some of the classes have been deprecated with the<br/>\npromise that they would be removed in the next revision (as of 4.4) and<br/>\nthey are still there.  I&#39;m not saying that the current solution is a<br/>\nmisstep, just that it is hard to separate the past ones from the current<br/>\npreferred solution.<br/>\n<br/>\nPart of managing a codebase like this includes separating the public and<br/>\nprivate API.  Some of that has been done with the &quot;internal&quot; package.<br/>\nThere is no reason to worry about deprecating classes and methods in the<br/>\ninternal package because they are not part of the public API.  But I did<br/>\nnotice that when some classes got moved, the old class in full was kept<br/>\nin the original location.  A low maintenance way of performing a move<br/>\nlike that makes use of inheritance.  Essentially the newer class is<br/>\nmoved so there is one maintenance location, and the deprecated class<br/>\nextends the newer class.  Kind of like how the JUnit4 runner provides a<br/>\npreferred alias to the BlockJUnit4Runner class.<br/>\n<br/>\nPart of the core includes a nice little callback interface (the<br/>\nRunListener).  I imagine that a number of integrations make good use of<br/>\nthis little class.  However, with the implementation as it is currently<br/>\nwritten, the RunListener can affect the run performance and parallelism<br/>\navailable.  Essentially, the act of calling a method is a synchronous<br/>\nfunction.  That means a poorly written runner can detrimentally affect<br/>\nthe performance of JUnit.  The one that is included with JUnit is pretty<br/>\ntame, doing the absolute minimum it has to do to track the test<br/>\nprogress.  However, if your tests execute slower in an IDE than with<br/>\nJUnit alone, it&#39;s probably the RunListener slowing things down.<br/>\n<br/>\n== Parallelism Thoughts ==<br/>\n<br/>\nSome of the architectural decisions in JUnit&#39;s core definitely reflect<br/>\nthe synchronous nature that the tests were designed to be written.  I<br/>\ndon&#39;t think there is going to be an easy solution to that problem,<br/>\nunless you stick to a test class per thread model.  More on that a bit<br/>\nlatter.<br/>\n<br/>\nWhen designing for parallel execution of tests (the ParallelComputer<br/>\nhints at this), you usually don&#39;t want an unbounded number of threads to<br/>\nbe executed in the system.  A fairly common approach to taming the<br/>\nthread/work apportioning beast is to use queues and worker threads.<br/>\nEssentially, each test (including the set up and tear down parts) gets<br/>\npushed on to the queue, while the executor pops it off on the other side<br/>\nin another process.  Essentially the relationship to executors to work<br/>\nqueues depends on whatever rules you&#39;ve set up.  For JUnit a simple<br/>\nmapping of executors to the number of processors (cores) or some<br/>\nmultiple of that would be sufficient.  This model is closer to how JMS<br/>\nworks without all the quality of service overhead.  As the executor runs<br/>\nthe test, it sends notification objects to the notification queue.<br/>\nUsing one line of ASCII art, the process looks like this:<br/>\n<br/>\nClasses/Suite ==&gt; Executor ==&gt; Notifier<br/>\n<br/>\nEach &quot;==&gt;&quot; represents a queue.  The notification mechanism then becomes<br/>\nmore like Swing events.  We could even cheat and use an Java 5 enum for<br/>\nthe types of events.  This provides the same interface for all the<br/>\nevents, and the convenience of an enum for determining the type of<br/>\nevent.  If we take this approach a step further, if we substitute a<br/>\nPriorityQueue for the first queue, we get a way to prefer some tests<br/>\nover others (e.g. using categories as a priority mechanism).  Collecting<br/>\nthe results in a separate thread than they are being executed protects<br/>\nthe execution of tests from poorly written listeners.<br/>\n<br/>\nWe could go to a very fine level of detail (i.e. each individual test)<br/>\nif it weren&#39;t for the class setup/tear down methods.  Those kind of<br/>\ntests would force some sort of ordering.  It&#39;s not entirely impossible,<br/>\nbut does require more care.<br/>\n<br/>\nSuch an approach may be over-engineering things a bit, and for short<br/>\nruns of a couple hundred tests that takes less than a second to run<br/>\ndefinitely overkill.  However for larger projects with much larger<br/>\nexecution times, it may be a way to short circuit the execution a bit.<br/>\nEssentially the win here would be the ability to execute tests while<br/>\nthey are still being parsed and prepared.  That can help with things<br/>\nlike Theories where collecting a large number of DataPoints can have a<br/>\nprofound impact on the time it takes to run.<br/>\n<br/>\nIt would be pretty easy to ensure that no more than n+2 threads are used<br/>\nin a system, where n = Runtime.availableProcessors().<br/>\n<br/>\n<br/>\n[Non-text portions of this message have been removed]</div>", 
    "prevInTime": 22486, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1267481827", 
    "canDelete": false, 
    "nextInTopic": 22488, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PDc1RjVFRDhBNUE1NTM2NDZBNDZFMDBFNkVDODU0RkEzMDQ0Qjk3RjJAdmFmZjAxLW1haWwwMS5hZC5nZC1haXMuY29tPg=="
    }
}