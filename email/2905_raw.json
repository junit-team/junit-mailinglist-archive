{
    "topicId": 2885, 
    "postDate": "1002745529", 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "from": "Eric Vought &lt;evought@...&gt;", 
    "canDelete": false, 
    "replyTo": "LIST", 
    "senderId": "PDrjTHab61s_6Ths2JP23kfNgFeYJjc3KpzSiXDsDT3-aFXXu_AiZ_kZDc9-cjGyg747fsSuP0E3MF1CPFtyKlM7NfUX", 
    "nextInTime": 2906, 
    "userId": 0, 
    "prevInTime": 2904, 
    "prevInTopic": 2896, 
    "headers": {
        "inReplyToHeader": "PDlxMGN1cStlaWhwQGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PFBpbmUuTE5YLjQuMzAuMDExMDEwMTQxNDQyMC4zMjUwMS0xMDAwMDBAYnJhaW4ucWx1ZS1sYW4+"
    }, 
    "authorName": "Eric Vought", 
    "numMessagesInTopic": 9, 
    "msgSnippet": "// Contrived example /** * Store documents in some fashion or other. Allow them to be * stored and retrieved by a key. All methods will throw an *", 
    "contentTrasformed": false, 
    "msgId": 2905, 
    "nextInTopic": 0, 
    "systemMessage": false, 
    "rawEmail": "Return-Path: &lt;evought@...&gt;\r\nX-Sender: evought@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (EGP: mail-7_4_1); 10 Oct 2001 20:26:37 -0000\r\nReceived: (qmail 75765 invoked from network); 10 Oct 2001 20:26:36 -0000\r\nReceived: from unknown (10.1.10.27)\n  by 10.1.1.222 with QMQP; 10 Oct 2001 20:26:36 -0000\r\nReceived: from unknown (HELO ral.qlue.com) (65.201.137.7)\n  by mta2 with SMTP; 10 Oct 2001 20:26:36 -0000\r\nReceived: from brain.qlue-lan (brain.qlue-lan [192.168.1.28])\n\tby ral.qlue.com (Postfix) with ESMTP id ED49F14FB5\n\tfor &lt;junit@yahoogroups.com&gt;; Wed, 10 Oct 2001 16:25:35 -0400 (EDT)\r\nDate: Wed, 10 Oct 2001 16:25:29 -0400 (EDT)\r\nTo: &lt;junit@yahoogroups.com&gt;\r\nSubject: Re: [junit] Re: How to test a method without the return value by\n junit?\r\nIn-Reply-To: &lt;9q0cuq+eihp@...&gt;\r\nMessage-ID: &lt;Pine.LNX.4.30.0110101414420.32501-100000@...-lan&gt;\r\nMIME-Version: 1.0\r\nContent-Type: TEXT/PLAIN; charset=US-ASCII\r\nFrom: Eric Vought &lt;evought@...&gt;\r\n\r\n// Contrived example\n\n/**\n * Store documents in some fashion or other. Allow them to be\n * stored and retrieved by a key. All methods will throw an\n * InvalidStateException if the map has not\n * been connected or has already been closed.\n */\npublic interface DocumentMap\n{\n    /** Connect to the back end datastore. Must be first call. */\n    public void connect(String connectInfo) throws IOException;\n\n    /** Store a document with a key. */\n    public void put(String key, Reader doc)\n\tthrows IOException;\n\n    public void delete(String key) throws IOException;\n\n    public boolean contains(String key) throws IOException;\n\n    public Reader get(String key) throws IOException;\n\n    /**\n     * Cleans up persistant resources and closes the connection.\n     * No other methods may be called once close() has been called.\n     */\n    public void close() throws IOException;\n} // DocumentMap\n\nWe have a number of abstract methods here which don&#39;t return anything:\nconnect, delete, put, close. They are abstract, so we don&#39;t know how they\nwill be implemented to test side effects. Clearly, though they will change\nthe state of the object in a way that is detectable from the other\nmethods. The following:\n\npublic void testConnect() throws Exception\n{\n    d_docMap.connect(&quot;Some valid connect string&quot;);\n    d_docMap.close();\n} // testConnect()\n\nShould succeed, just as clearly as:\n\npublic void testCloseNotConnected() throws Exception\n{\n    d_docMap.connect(&quot;Some valid connect string&quot;);\n    try {\n        d_docMap.close();\n    } catch (InvalidStateException e) {\n\t// Succeed\n\treturn;\n    }\n\n    fail(&quot;Didn&#39;t get an InvalidStateException!&quot;);\n} // testCloseNotConnected()\n\nShould get the exception it tests for.\n\nSimilarly, assuming d_docMap is always initialized to empty:\n\npublic void testContainsWhenEmpty()\n{\n    d_docMap.connect(&quot;Some valid connect string&quot;);\n\n    try {\n        assertFalse(d_docMap.contains(&quot;noSuchKey&quot;));\n    } finally {\n        d_docMap.close();\n    }\n} // testContainsWhenEmpty()\n\npublic void testContains()\n{\n    d_docMap.connect(&quot;Some valid connect string&quot;);\n\n    try {\n        d_docMap.put(&quot;key&quot;, d_testStringReader);\n        assertTrue(d_docMap.contains(&quot;key&quot;));\n    } finally {\n        d_docMap.close();\n    }\n} // testContains()\n\nShould succeed. In fact:\n\npublic void testContains()\n{\n    d_docMap.connect(&quot;Some valid connect string&quot;);\n    try {\n        d_docMap.put(&quot;key&quot;, d_testStringReader);\n    } finally {\n        d_docMap.close();\n    }\n\n    d_docMap2.connect(&quot;Some valid connect string&quot;);\n    try {\n        assertTrue(d_docMap.contains(&quot;key&quot;));\n    } finally {\n        d_docMap.close();\n    }\n} // testContains()\n\nShould succeed given the persistant nature expressed in the interface\ndefinition. You should be able to come up with a number of other\ntestcases, e.g. ensureing that contains() returns false after delete(),\nand so forth.\n\nNow, how do you write the testcases for the interface so that you can\nrerun them against implementation classes?\n\npublic class DocumentMapTest extends TestCase\n{\n    public DocumentMapTest(String name) {super(name);}\n\n    public DocumentMap d_docMap;\n    public DocumentMap d_docMap2;\n    public StringReader d_testStringReader;\n\n    public void setUp() throws Exception\n    {\n        d_docMap = setUpDocMap();\n        d_docMap2 = setUpDocMap();\n\n\td_testStringReader = ...\n    } // setUp()\n\n    /** Override this to return the correct subclass. */\n    public DocumentMap setUpDocMap() throws Exception\n    {\n\treturn new DocumentMapStub();\n    } // setUpDocMap()\n\n    // Add tests here ...\n} // DocumentMapTest\n\nWe create a test case which operates on a generic DocumentMap without\ncaring about its particular type. An actual implementation is returned\nfrom setUpDocMap(), which will be overridden in a specific test case\nclass. To test our tests and make sure we understand the interface, we\ncreate DocumentMapStub, the simplest possible valid implementation of a\nDocumentMap, probably using an in-memory HashMap or something to hold its\ndocuments. When we want to test a specific implementation, say FileDocMap:\n\npublic class FileDocMapTest extends DocumentMapTest\n{\n    public FileDocMapTest(String name) {super(name);}\n\n    public DocumentMap setUpDocMap() throws Exception\n    {\n        return new FileDocMap();\n    }\n\n    // Add any specific FileDocMap tests here ...\n} // FileDocMapTest\n\nThe testcases from DocumentMapTest will automatically be pulled in and\nrun. You very well may need to store the connect string and override it in\nthe same way you override the actual class of the DocumenMap, i.e. by\ncreating a setUpConnectString() method.\n\nOn Wed, 10 Oct 2001 chenhuitao@... wrote:\n\n&gt; Thank you for your help! I got some idea from you. Thanks.\n&gt;\n&gt; But if the classes and the methods I want to test are abstract, I\n&gt; can&#39;t know what will happen in the methods of the subclasses which\n&gt; extend from these abstract classes. Why I asked this question is that\n&gt; these classes I will test are a framework of our project, many of\n&gt; them are abstract classes. Our project team must follow this\n&gt; framework and extend from these abstract classes to develop our\n&gt; project. Now I was assigned to test if this framework is correct.\n&gt; What can I do?\n&gt; Any help will be appreciated greatly!\n&gt;\n&gt; --- In junit@y..., Rob Nielsen &lt;rob@v...&gt; wrote:\n&gt; &gt; If the method doesn&#39;t return anything then it probably modifies\n&gt; fields\n&gt; &gt; of the class somehow.  You can therefore test the value of this\n&gt; changed\n&gt; &gt; object. ie:\n&gt; &gt;\n&gt; &gt; public class Foo\n&gt; &gt; {\n&gt; &gt;   int x;\n&gt; &gt;\n&gt; &gt;   public Foo(int x)\n&gt; &gt;   {\n&gt; &gt;     this.x=x;\n&gt; &gt;   }\n&gt; &gt;\n&gt; &gt;   public int getX()\n&gt; &gt;   {\n&gt; &gt;     return x;\n&gt; &gt;   }\n&gt; &gt;\n&gt; &gt;   public void incrementX()\n&gt; &gt;   {\n&gt; &gt;     x++;\n&gt; &gt;   }\n&gt; &gt; }\n&gt; &gt;\n&gt; &gt; public class FooTest extends TestCase\n&gt; &gt; {\n&gt; &gt;   public void testIncrementX()\n&gt; &gt;   {\n&gt; &gt;     Foo foo=new Foo(5);\n&gt; &gt;     foo.incrementX();\n&gt; &gt;     assertEquals(6,foo.getX());\n&gt; &gt;   }\n&gt; &gt; }\n&gt; &gt;\n&gt; &gt; chenhuitao@y... wrote:\n&gt; &gt; &gt;\n&gt; &gt; &gt; I am a newbie to junit.But now i have a job in my hand.I need to\n&gt; use\n&gt; &gt; &gt; JUnit to test some existed java programme.Some methods of classes\n&gt; &gt; &gt; have no return value.I can not change the source programme.How\n&gt; can I\n&gt; &gt; &gt; test these programme by JUnit?\n&gt; &gt; &gt; Thank you for your any help!\n&gt; &gt; &gt; //BR ChenHuitao\n&gt; &gt; &gt;\n&gt; &gt; &gt;\n&gt; &gt; &gt; To unsubscribe from this group, send an email to:\n&gt; &gt; &gt; junit-unsubscribe@y...\n&gt; &gt; &gt;\n&gt; &gt; &gt;\n&gt; &gt; &gt; Your use of Yahoo! Groups is subject to\n&gt; http://docs.yahoo.com/info/terms/\n&gt;\n&gt;\n&gt;\n&gt; To unsubscribe from this group, send an email to:\n&gt; junit-unsubscribe@yahoogroups.com\n&gt;\n&gt;\n&gt; Your use of Yahoo! Groups is subject to http://docs.yahoo.com/info/terms/\n&gt;\n&gt;\n&gt;\n\n-- \nEric Vought\nChief Technical Officer - QLUE Consulting, Inc.\n\nevought@... toll-free: 888-771-3538  RTP area: 919-816-9901\n\n\n", 
    "subject": "Re: [junit] Re: How to test a method without the return value by junit?"
}