{
    "numMessagesInTopic": 1, 
    "nextInTime": 557, 
    "senderId": "F16urOR2rUwlkEGbfTdA0MR1sJEYCGKde8lyC68AXBD5SgtnsEGho9YQP-TPcMO5MFiS_tfVpzcXRFFHdM_J8LcIpyoD", 
    "systemMessage": false, 
    "subject": "TestTimeout decorator", 
    "from": "Sameer Ajmani &lt;ajmani@...&gt;", 
    "authorName": "Sameer Ajmani", 
    "msgSnippet": "All-- I have implemented a new TestDecorator called TestTimeout that allows the user to wrap tests or test suites such that each test is run until completion", 
    "msgId": 556, 
    "topicId": 556, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 0, 
    "messageBody": "<div id=\"ygrps-yiv-1264142373\">All--<br/>\n<br/>\nI have implemented a new TestDecorator called &quot;TestTimeout&quot; that allows<br/>\nthe user to wrap tests or test suites such that each test is run until<br/>\ncompletion or until a specified timeout.  This is good for stopping<br/>\ntests that might enter infinite loops or to implement simple wall-clock<br/>\nperformance tests.  The code is all in one class, given below.<br/>\n<br/>\n--Sameer<br/>\n<br/>\n-------------------------------------<br/>\nSave text below to &quot;TestTimeout.java&quot;<br/>\n-------------------------------------<br/>\npackage junit.extensions;<br/>\n<br/>\nimport junit.framework.Test;<br/>\nimport junit.framework.TestSuite;<br/>\nimport junit.framework.TestResult;<br/>\nimport junit.framework.TestListener;<br/>\nimport junit.framework.AssertionFailedError;<br/>\nimport junit.extensions.TestDecorator;<br/>\nimport java.util.Enumeration;<br/>\nimport java.util.Stack;<br/>\n<br/>\n/**<br/>\n   A TestDecorator that times out if the given Test runs longer than a<br/>\n   specified number of milliseconds.<br/>\n   @author Sameer Ajmani (<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:ajmani@...\">ajmani@...</a>) */<br/>\npublic class TestTimeout extends TestDecorator implements TestListener<br/>\n{<br/>\n    private long _millis; // the timeout in milliseconds<br/>\n    private int _numRun;  // the number of tests run before timeout<br/>\n    /**<br/>\n       Constructs a Test that times out if the given Test runs longer than<br/>\n       millis ms.  */<br/>\n    public TestTimeout(final Test test, final long millis)<br/>\n    {<br/>\n        super(test);<br/>\n        _millis = millis;<br/>\n    }<br/>\n    /**<br/>\n       Constructs a TestSuite from the given TestSuite whose tests time out<br/>\n       if they run longer than millis ms. */<br/>\n    public static TestSuite createSuite(final TestSuite suite,<br/>\n                                        final long millis)<br/>\n    {<br/>\n        if (containsSelf(suite))<br/>\n            throw new IllegalArgumentException<br/>\n                (&quot;TestTimeout.createSuite: suite contains self&quot;);<br/>\n        TestSuite newSuite = new TestSuite();<br/>\n        Enumeration tests = suite.tests();<br/>\n        // wrap each test in the suite with a TestTimeout decorator<br/>\n        while (tests.hasMoreElements()) {<br/>\n            Test test = (Test)tests.nextElement();<br/>\n            if (test instanceof TestSuite)<br/>\n                newSuite.addTest(TestTimeout.createSuite<br/>\n                                 ((TestSuite)test, millis));<br/>\n            else<br/>\n                newSuite.addTest(new TestTimeout(test, millis));<br/>\n        }<br/>\n        return newSuite;<br/>\n    }<br/>\n    /**<br/>\n       Checks if a TestSuite contains itself (should never happen).  Allows<br/>\n       the caller to determine if it&#39;s safe recursively explore the suite.  */<br/>\n    private static boolean containsSelf(final TestSuite suite)<br/>\n    {<br/>\n        return containsSelf(suite, new Stack());<br/>\n    }<br/>\n    private static boolean containsSelf(final TestSuite suite,<br/>\n                                        final Stack stack)<br/>\n    {<br/>\n        if (stack.contains(suite))<br/>\n            return true;<br/>\n        stack.push(suite);<br/>\n        Enumeration tests = suite.tests();<br/>\n        while (tests.hasMoreElements()) {<br/>\n            Test test = (Test)tests.nextElement();<br/>\n            if ((test instanceof TestSuite)<br/>\n                && containsSelf((TestSuite)test, stack))<br/>\n                return true;<br/>\n        }<br/>\n        stack.pop();<br/>\n        return false;<br/>\n    }<br/>\n    /**<br/>\n       Run the underlying Test for up to _millis ms.  If the Test times out,<br/>\n       add an error to the given TestResult. */<br/>\n    public void run(final TestResult result)<br/>\n    {   <br/>\n        _numRun = 0;<br/>\n        result.addListener(this);<br/>\n        runUntilTimeout(result);<br/>\n        result.removeListener(this);<br/>\n        checkResult(result);<br/>\n    }<br/>\n    /**<br/>\n       Run the underlying Test for up to _millis ms.  If testing is<br/>\n       interrupted, add an error to the given TestResult. */<br/>\n    private void runUntilTimeout(final TestResult result)<br/>\n    {<br/>\n        Thread thread = new Thread(new Runnable() {<br/>\n                public void run()<br/>\n                {<br/>\n                    getTest().run(result);<br/>\n                }<br/>\n            });<br/>\n        // ensure the test thread can&#39;t lock up our thread<br/>\n        thread.setDaemon(true);<br/>\n        thread.setPriority(Math.max(Thread.currentThread().getPriority()-1,<br/>\n                                    Thread.MIN_PRIORITY));<br/>\n        thread.start();<br/>\n        try {<br/>\n            thread.join(_millis);<br/>\n        } catch (InterruptedException e) {<br/>\n            result.addError(getTest(), e);<br/>\n        }<br/>\n        if (thread.isAlive())<br/>\n            thread.setPriority(Thread.MIN_PRIORITY);<br/>\n    }<br/>\n    /**<br/>\n       Check that all the TestCases in the underlying Test were run.  If<br/>\n       not, add an error to the given TestResult.  */<br/>\n    private synchronized void checkResult(final TestResult result)<br/>\n    {<br/>\n        int numTests = getTest().countTestCases();<br/>\n        if (_numRun &lt; numTests) {<br/>\n            StringBuffer message = new StringBuffer<br/>\n                (&quot;Test time exceeded &quot;).append(_millis).append(&quot;ms&quot;);<br/>\n            if (numTests &gt; 1) {<br/>\n                message.append(&quot;: &quot;).append(_numRun)<br/>\n                    .append(&quot; out of &quot;).append(numTests)<br/>\n                    .append(&quot; tests run&quot;);<br/>\n            }<br/>\n            result.addError(getTest(),<br/>\n                            new InterruptedException(message.toString()));<br/>\n        }<br/>\n    }<br/>\n    public synchronized void endTest(final Test test)<br/>\n    {<br/>\n        _numRun++;<br/>\n    }<br/>\n    public synchronized void startTest(final Test test)<br/>\n    {<br/>\n        // ignored<br/>\n    }<br/>\n    public synchronized void addError(final Test test, final Throwable t)<br/>\n    {<br/>\n        // ignored<br/>\n    }<br/>\n    public synchronized void addFailure(final Test test,<br/>\n                                        final AssertionFailedError t)<br/>\n    {<br/>\n        // ignored<br/>\n    }<br/>\n}</div>", 
    "prevInTime": 555, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "983215889", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PDIwMDEwMjI2MTkzMS5PQUEyNjk3MkBjaG9yZC5sY3MubWl0LmVkdT4="
    }
}