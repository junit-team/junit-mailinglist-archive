{
    "numMessagesInTopic": 22, 
    "nextInTime": 21375, 
    "senderId": "psXcx8wNhtY_UZLbUrXS3lWSaeTb-ClybH7XcLD0_la0KLc0itMUByZmCBsXBV-xegYvSjGVZS6-JaZvqhQ2Xr_1rNHqJNJGSFsaoEps", 
    "systemMessage": false, 
    "subject": "Re: [junit] Re: Runner for non static inner class in JUnit 4.x", 
    "from": "Lasse Koskela &lt;lasse.koskela@...&gt;", 
    "authorName": "Lasse Koskela", 
    "msgSnippet": "Love it :) Lasse On Thu, Feb 12, 2009 at 8:36 PM, tuomaskarkkainenri", 
    "msgId": 21374, 
    "profile": "lassekoskela", 
    "topicId": 21238, 
    "spamInfo": {
        "reason": "4", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 190530936, 
    "messageBody": "<div id=\"ygrps-yiv-790678935\">Love it :)<br/>\n<br/>\nLasse<br/>\n<br/>\nOn Thu, Feb 12, 2009 at 8:36 PM, tuomaskarkkainenri<br/>\n&lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:tuomaskarkkainenri@...\">tuomaskarkkainenri@...</a>&gt; wrote:<br/>\n<blockquote><span title=\"qreply\"> &gt; David,<br/>\n&gt;<br/>\n&gt; I rewrote my patch into AnnotatedBuilder.<br/>\n&gt; I wrote it in such a way that it decreases the complexity of the<br/>\n&gt; original AnnotatedBuilder. The net effect of adding JDave support is<br/>\n&gt; thus a reduction in complexity.<br/>\n&gt;<br/>\n&gt; What do you think?<br/>\n&gt;<br/>\n&gt; Best regards,<br/>\n&gt; Tuomas<br/>\n&gt;<br/>\n&gt; AnnotatedBuilder.java:<br/>\n&gt;<br/>\n&gt; package org.junit.internal.builders;<br/>\n&gt;<br/>\n&gt; import static java.util.Arrays.asList;<br/>\n&gt;<br/>\n&gt; import java.lang.reflect.Constructor;<br/>\n&gt; import java.lang.reflect.Modifier;<br/>\n&gt; import java.util.List;<br/>\n&gt;<br/>\n&gt; import org.junit.runner.RunWith;<br/>\n&gt; import org.junit.runner.Runner;<br/>\n&gt; import org.junit.runners.model.InitializationError;<br/>\n&gt; import org.junit.runners.model.RunnerBuilder;<br/>\n&gt;<br/>\n&gt; public class AnnotatedBuilder extends RunnerBuilder {<br/>\n&gt; private static final String CONSTRUCTOR_ERROR_FORMAT= &quot;Custom runner<br/>\n&gt; class %1$s should have a public constructor with signature %1$s(Class<br/>\n&gt; testClass) or %1$s(Class testClass, RunnerBuilder builder)&quot;;<br/>\n&gt;<br/>\n&gt; private final RunnerBuilder fSuiteBuilder;<br/>\n&gt;<br/>\n&gt; public AnnotatedBuilder(final RunnerBuilder suiteBuilder) {<br/>\n&gt; fSuiteBuilder= suiteBuilder;<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; @Override<br/>\n&gt; public Runner runnerForClass(final Class&lt;?&gt; testClass) throws Exception {<br/>\n&gt; final RunWith annotation= getRunWithAnnotation(testClass);<br/>\n&gt; if (annotation != null) {<br/>\n&gt; return buildRunner(annotation.value(), testClass);<br/>\n&gt; }<br/>\n&gt; return null;<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; private RunWith getRunWithAnnotation(final Class&lt;?&gt; testClass) {<br/>\n&gt; if (testClass.isAnnotationPresent(RunWith.class)) {<br/>\n&gt; return testClass.getAnnotation(RunWith.class);<br/>\n&gt; }<br/>\n&gt; if (testClassIsANonStaticInnerClass(testClass)) {<br/>\n&gt; return testClass.getDeclaringClass().getAnnotation(RunWith.class);<br/>\n&gt; }<br/>\n&gt; return null;<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; private boolean testClassIsANonStaticInnerClass(final Class&lt;?&gt;<br/>\n&gt; testClass) {<br/>\n&gt; return testClass.isMemberClass()<br/>\n&gt; && !Modifier.isStatic(testClass.getModifiers());<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; private &lt;T extends Runner&gt; T buildRunner(final Class&lt;T&gt; runnerClass,<br/>\n&gt; final Class&lt;?&gt; testClass) throws Exception {<br/>\n&gt; return new InternalBuilder&lt;T&gt;(runnerClass,<br/>\n&gt; fSuiteBuilder).build(testClass);<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; private static class InternalBuilder&lt;T extends Runner&gt; {<br/>\n&gt; private final RunnerBuilder suiteBuilder;<br/>\n&gt;<br/>\n&gt; private final Class&lt;T&gt; runnerClass;<br/>\n&gt;<br/>\n&gt; public InternalBuilder(final Class&lt;T&gt; runnerClass,<br/>\n&gt; final RunnerBuilder suiteBuilder) {<br/>\n&gt; this.runnerClass= runnerClass;<br/>\n&gt; this.suiteBuilder= suiteBuilder;<br/>\n&gt;<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; private T build(final Class&lt;?&gt; testClass) throws Exception {<br/>\n&gt; if (hasValidConstructor()) {<br/>\n&gt; return instantiateRunner(testClass);<br/>\n&gt; }<br/>\n&gt; throw new InitializationError(String.format(<br/>\n&gt; CONSTRUCTOR_ERROR_FORMAT, runnerClass.getSimpleName()));<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; private T instantiateRunner(final Class&lt;?&gt; testClass) throws Exception {<br/>\n&gt; if (hasSimpleConstructor()) {<br/>\n&gt; return getSimpleConstructor().newInstance(testClass);<br/>\n&gt; }<br/>\n&gt; return getConstructorWithSuite(runnerClass).newInstance(testClass,<br/>\n&gt; suiteBuilder);<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; private boolean hasValidConstructor() {<br/>\n&gt; return hasSimpleConstructor()<br/>\n&gt; || hasConstructorWithSuite();<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; private boolean hasSimpleConstructor() {<br/>\n&gt; return getSimpleConstructor() != null;<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; private boolean hasConstructorWithSuite() {<br/>\n&gt; return getConstructorWithSuite(runnerClass) != null;<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; private Constructor&lt;T&gt; getSimpleConstructor() {<br/>\n&gt; for (final Constructor&lt;T&gt; constructor : getConstructors()) {<br/>\n&gt; final List&lt;Class&lt;?&gt;&gt; parameters= asList(constructor<br/>\n&gt; .getParameterTypes());<br/>\n&gt; if (parameters.equals(asList(Class.class))) {<br/>\n&gt; return constructor;<br/>\n&gt; }<br/>\n&gt; }<br/>\n&gt; return null;<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; private Constructor&lt;T&gt; getConstructorWithSuite(<br/>\n&gt; final Class&lt;T&gt; runnerClass) {<br/>\n&gt; for (final Constructor&lt;T&gt; constructor : getConstructors()) {<br/>\n&gt; final List&lt;Class&lt;?&gt;&gt; parameters= asList(constructor<br/>\n&gt; .getParameterTypes());<br/>\n&gt; if (parameters.equals(asList(Class.class, RunnerBuilder.class))) {<br/>\n&gt; return constructor;<br/>\n&gt; }<br/>\n&gt; }<br/>\n&gt; return null;<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; @SuppressWarnings(&quot;unchecked&quot;)<br/>\n&gt; private List&lt;Constructor&lt;T&gt;&gt; getConstructors() {<br/>\n&gt; return asList((Constructor&lt;T&gt;[]) runnerClass.getConstructors());<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; }<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; AnnotatedBuilderTest.java:<br/>\n&gt;<br/>\n&gt; package org.junit.tests.running.classes;<br/>\n&gt;<br/>\n&gt; import static org.hamcrest.core.Is.is;<br/>\n&gt; import static org.junit.Assert.assertThat;<br/>\n&gt; import org.hamcrest.core.IsNull;<br/>\n&gt; import org.junit.Test;<br/>\n&gt; import org.junit.internal.builders.AnnotatedBuilder;<br/>\n&gt; import org.junit.runner.Description;<br/>\n&gt; import org.junit.runner.RunWith;<br/>\n&gt; import org.junit.runner.Runner;<br/>\n&gt; import org.junit.runner.notification.RunNotifier;<br/>\n&gt; import org.junit.runners.model.InitializationError;<br/>\n&gt; import org.junit.runners.model.RunnerBuilder;<br/>\n&gt;<br/>\n&gt; public class AnnotatedBuilderTest {<br/>\n&gt; @Test<br/>\n&gt; public void aClassWithARunWithAnnotationHasRunnerBuilt() throws<br/>\n&gt; Exception {<br/>\n&gt; final Runner runner= new AnnotatedBuilder(null)<br/>\n&gt; .runnerForClass(ClassWithRunWithAnnotation.class);<br/>\n&gt; assertThat(runner, is(FakeRunner.class));<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; @Test<br/>\n&gt; public void<br/>\n&gt; aClassWithARunWithAnnotationThatRequiresASuiteBuilderHasRunnerBuilt()<br/>\n&gt; throws Exception {<br/>\n&gt; final Runner runner= new AnnotatedBuilder(null)<br/>\n&gt;<br/>\n&gt; .runnerForClass(ClassWithRunWithAnnotationWhereTheRunnerRequiresASuiteBuilder.class);<br/>\n&gt; assertThat(runner, is(FakeRunnerThatRequiresSuiteBuilder.class));<br/>\n&gt;<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; @Test<br/>\n&gt; public void aClassWithoutARunWithAnnotationReturnsNull() throws<br/>\n&gt; Exception {<br/>\n&gt; final Runner runner= new AnnotatedBuilder(null)<br/>\n&gt; .runnerForClass(ClassWithoutRunWithAnnotation.class);<br/>\n&gt; assertThat(runner, is(IsNull.&lt;Runner&gt; nullValue()));<br/>\n&gt;<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; @Test<br/>\n&gt; public void<br/>\n&gt; aNonStaticInnerClassWithARunWithAnnotationOnTheDeclaringClassHasRunnerBuilt()<br/>\n&gt; throws Exception {<br/>\n&gt; final Runner runner= new AnnotatedBuilder(null)<br/>\n&gt;<br/>\n&gt; .runnerForClass(DeclaringClassWithRunWithAnnotation.NonStaticInnerClass.class);<br/>\n&gt; assertThat(runner, is(FakeRunner.class));<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; @Test<br/>\n&gt; public void aStaticInnerClassWithARunWithAnnotationHasRunnerBuilt()<br/>\n&gt; throws Exception {<br/>\n&gt; final Runner runner= new AnnotatedBuilder(null)<br/>\n&gt;<br/>\n&gt; .runnerForClass(DeclaringClassWithRunWithAnnotation.StaticInnerClassWithRunWithAnnotation.class);<br/>\n&gt; assertThat(runner, is(FakeRunner.class));<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; @Test<br/>\n&gt; public void<br/>\n&gt; aStaticInnerClassWithARunWithAnnotationOnTheDeclaringClassReturnsNull()<br/>\n&gt; throws Exception {<br/>\n&gt; final Runner runner= new AnnotatedBuilder(null)<br/>\n&gt;<br/>\n&gt; .runnerForClass(DeclaringClassWithRunWithAnnotation.StaticInnerClass.class);<br/>\n&gt; assertThat(runner, is(IsNull.&lt;Runner&gt; nullValue()));<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; @Test(expected= InitializationError.class)<br/>\n&gt; public void<br/>\n&gt; aClassWithARunWithAnnotationThatSpecifiesAnInvalidRunnerThrowsException()<br/>\n&gt; throws Exception {<br/>\n&gt; final Runner runner= new AnnotatedBuilder(null)<br/>\n&gt;<br/>\n&gt; .runnerForClass(ClassWithRunWithAnnotationThatSpecifiesAndInvalidRunner.class);<br/>\n&gt; assertThat(runner, is(IsNull.&lt;Runner&gt; nullValue()));<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; @RunWith(FakeRunner.class)<br/>\n&gt; private static class ClassWithRunWithAnnotation {<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; @RunWith(InvalidRunner.class)<br/>\n&gt; private static class<br/>\n&gt; ClassWithRunWithAnnotationThatSpecifiesAndInvalidRunner {<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; @RunWith(FakeRunnerThatRequiresSuiteBuilder.class)<br/>\n&gt; private static class<br/>\n&gt; ClassWithRunWithAnnotationWhereTheRunnerRequiresASuiteBuilder {<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; private static class ClassWithoutRunWithAnnotation {<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; @RunWith(FakeRunner.class)<br/>\n&gt; private static class DeclaringClassWithRunWithAnnotation {<br/>\n&gt;<br/>\n&gt; public class NonStaticInnerClass {<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; public static class StaticInnerClass {<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; @RunWith(FakeRunner.class)<br/>\n&gt; public static class StaticInnerClassWithRunWithAnnotation {<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; public static class InvalidRunner extends Runner {<br/>\n&gt;<br/>\n&gt; @Override<br/>\n&gt; public Description getDescription() {<br/>\n&gt; return Description.EMPTY;<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; @Override<br/>\n&gt; public void run(final RunNotifier notifier) {<br/>\n&gt; }<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; public static class FakeRunner extends Runner {<br/>\n&gt; public FakeRunner(final Class&lt;?&gt; testClass) {<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; @Override<br/>\n&gt; public Description getDescription() {<br/>\n&gt; return Description.EMPTY;<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; @Override<br/>\n&gt; public void run(final RunNotifier notifier) {<br/>\n&gt; }<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; public static class FakeRunnerThatRequiresSuiteBuilder extends Runner {<br/>\n&gt; public FakeRunnerThatRequiresSuiteBuilder(final Class&lt;?&gt; testClass,<br/>\n&gt; final RunnerBuilder suiteBilder) {<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; @Override<br/>\n&gt; public Description getDescription() {<br/>\n&gt; return Description.EMPTY;<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; @Override<br/>\n&gt; public void run(final RunNotifier notifier) {<br/>\n&gt; }<br/>\n&gt; }<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; And RunWithTest.java, I fixed the error message to:<br/>\n&gt;<br/>\n&gt; @Test<br/>\n&gt; public void characterizeErrorMessageFromBadRunner() {<br/>\n&gt; assertEquals(<br/>\n&gt; &quot;Custom runner class BadRunner should have a public constructor<br/>\n&gt; with signature BadRunner(Class testClass) or BadRunner(Class<br/>\n&gt; testClass, RunnerBuilder builder)&quot;,<br/>\n&gt; JUnitCore.runClasses(Empty.class).getFailures().get(0)<br/>\n&gt; .getMessage());<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; --- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>, David Saff &lt;david@...&gt; wrote:<br/>\n&gt;&gt;<br/>\n&gt;&gt; I&#39;m unexcited about bumping up the JUnit complexity for a single<br/>\n&gt; feature.<br/>\n&gt;&gt; Again, I love JDave, but I&#39;d love a feature suggestion that used one<br/>\n&gt; stone<br/>\n&gt;&gt; to kill at least two birds.<br/>\n&gt;&gt;<br/>\n&gt;&gt; David Saff<br/>\n&gt;&gt;<br/>\n&gt;&gt; On Tue, Feb 3, 2009 at 11:33 AM, tuomaskarkkainenri &lt;<br/>\n&gt;&gt; tuomaskarkkainenri@...&gt; wrote:<br/>\n&gt;&gt;<br/>\n&gt;&gt; &gt; Hi David, Kent,<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt; Did you guys decide on what to do with this issue?<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt; Best regards,<br/>\n&gt;&gt; &gt; Tuomas </span></blockquote></div>", 
    "prevInTime": 21373, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1234983967", 
    "canDelete": false, 
    "nextInTopic": 21429, 
    "prevInTopic": 21349, 
    "headers": {
        "inReplyToHeader": "PGduMXE2aCtxbjE0QGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PDM5NzVlMmQxMDkwMjE4MTEwNnIyMmI2NzNkY3I4ZThjYTI3ZDhkODNkZDg4QG1haWwuZ21haWwuY29tPg==", 
        "referencesHeader": "PDRmN2RhNmI5MDkwMjA0MDcxNXY3ZDhmNGY0NXQ5NTI0ZDM3NTc5NTUwZjMyQG1haWwuZ21haWwuY29tPgkgPGduMXE2aCtxbjE0QGVHcm91cHMuY29tPg=="
    }
}