{
    "numMessagesInTopic": 23, 
    "nextInTime": 22552, 
    "senderId": "vGyK9Z82IpexovZhzgDiKAv3c0Z5u75bTm8xmNUKQg_ev1G3DZpC9JtSjAjy9VV8i-tenJL1AK1sTJgnOfurK0E1", 
    "systemMessage": false, 
    "subject": "Re: [junit] Re: @DataPoints called several times for Theories", 
    "from": "David Saff &lt;david@...&gt;", 
    "authorName": "David Saff", 
    "msgSnippet": "On Mon, Mar 15, 2010 at 2:54 PM, Loritsch, Berin C. ... I _am_ suggesting making that API available to end-users.  I think that copying strategy is just one", 
    "msgId": 22551, 
    "rawEmail": "Return-Path: &lt;david.saff@...&gt;\r\nX-Sender: david.saff@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nX-Received: (qmail 12844 invoked from network); 15 Mar 2010 20:39:29 -0000\r\nX-Received: from unknown (66.196.94.105)\n  by m1.grp.sp2.yahoo.com with QMQP; 15 Mar 2010 20:39:29 -0000\r\nX-Received: from unknown (HELO mail-pv0-f175.google.com) (74.125.83.175)\n  by mta1.grp.re1.yahoo.com with SMTP; 15 Mar 2010 20:39:28 -0000\r\nX-Received: by pvc21 with SMTP id 21so614814pvc.6\n        for &lt;junit@yahoogroups.com&gt;; Mon, 15 Mar 2010 13:39:04 -0700 (PDT)\r\nMIME-Version: 1.0\r\nX-Received: by 10.141.101.19 with SMTP id d19mr1421981rvm.113.1268685544346; \n\tMon, 15 Mar 2010 13:39:04 -0700 (PDT)\r\nIn-Reply-To: &lt;75F5ED8A5A553646A46E00E6EC854FA30378C7EE@...-ais.com&gt;\r\nReferences: &lt;58dba2251002180943q238dd8dv11ab48736321e178@...&gt;\n\t &lt;hlkif2+3mte@...&gt;\n\t &lt;58dba2251003121544p3cd7dd28h1a899ce657f66ad3@...&gt;\n\t &lt;a527fddf1003140915l73761ee1r781ba20fc768e42e@...&gt;\n\t &lt;75F5ED8A5A553646A46E00E6EC854FA30378C7E4@...-ais.com&gt;\n\t &lt;4f7da6b91003150651m12f2796kf9aab17ff312cd93@...&gt;\n\t &lt;58dba2251003151056k4bf24ff2xf161e6415abf4aba@...&gt;\n\t &lt;75F5ED8A5A553646A46E00E6EC854FA30378C7EE@...-ais.com&gt;\r\nDate: Mon, 15 Mar 2010 16:39:04 -0400\r\nX-Google-Sender-Auth: 186bd01db3006fad\r\nMessage-ID: &lt;4f7da6b91003151339k3ba535ecu3c41457234979c4@...&gt;\r\nTo: junit@yahoogroups.com\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Transfer-Encoding: quoted-printable\r\nX-eGroups-Msg-Info: 2:4:8:0:1\r\nFrom: David Saff &lt;david@...&gt;\r\nSubject: Re: [junit] Re: @DataPoints called several times for Theories\r\nX-Yahoo-Group-Post: member; u=341876227; y=02CB7CbpadElugaraedX6-8DfuO6Zk8yjNBjU5ZxWYI\r\nX-Yahoo-Profile: dsaff\r\n\r\nOn Mon, Mar 15, 2010 at 2:54 PM, Loritsch, Berin C.\n&lt;berin.loritsch@gd-ais.=\r\ncom&gt; wrote:\n&gt; This is a good dialog. =A0Personally, and academically, I thi=\r\nnk using Iterable&lt;?&gt; would be much better than arrays for @Datapoints. =A0T=\r\nhat would avoid the toArray(new Mutable[collection.size()]) I would have to=\r\n create and reduce the number of objects in the garbage collector. =A0I gue=\r\nss that would put me on your side with that particular approach. =A0BTW, ar=\r\nrays are iterable... =A0I do create data dynamically for testing theories, =\r\nparticularly if I am testing interface contracts.\n&gt;\n&gt; Regarding extracting =\r\nthe parameters interface, I&#39;m not suggesting making that an API available o=\r\nutside the core.\n\nI _am_ suggesting making that API available to end-users.=\r\n  I think\nthat copying strategy is just one way in which users will want to=\r\n\ncustomize the data point implementation, and that it&#39;s no more work to\ncar=\r\nve out a generic ParameterSupplier hook than a specific\ncopyStrategy hook.\n=\r\n\n&gt;=A0I&#39;m suggesting a little DRY (Don&#39;t Repeat Yourself) to have a class th=\r\nat is responsible for collecting the raw data points (calling the @DataPoin=\r\nt and @DataPoints once), and copying them as necessary to satisfy the param=\r\neter sets on the individual tests. =A0That same approach can theorhetically=\r\n feed parameterized tests. =A0The long and short of it is that I am suggest=\r\ning the change for code maintenance reasons. =A0That would also make my fea=\r\nture enhancement to track each parameter set as a separate test (@Theory(ru=\r\nnDiscretely=3Dtrue)) a bit easier to implement.\n\n&gt;\n&gt; I think it would be re=\r\nasonable to include the CloneableStrategy along with the solution. =A0That =\r\nway, you have custom copy strategies, a cloning copy strategy, and I guess =\r\nthe default would be an identity strategy (i.e. not copying at all).\n&gt;\n&gt; Wi=\r\nth your code example and the current implementation, if the datapoints are =\r\ndefined in the @DataPoints method then you have a fresh instance of each da=\r\nta point--even when the values are identical. =A0That&#39;s due to the bug that=\r\n I mentioned. =A0The @DataPoints is called the first time, and for each dat=\r\na point, it is called again to make the combinations. =A0Using an identity =\r\ncopy strategy (i.e. not copying) will introduce problems with mutable data =\r\ntypes.\n&gt;\n&gt; ________________________________\n&gt;\n&gt; From: junit@yahoogroups.com=\r\n on behalf of Brett Daniel\n&gt; Sent: Mon 3/15/2010 1:56 PM\n&gt; To: junit@yahoog=\r\nroups.com\n&gt; Subject: Re: [junit] Re: @DataPoints called several times for T=\r\nheories\n&gt;\n&gt;\n&gt;\n&gt;\n&gt; David, Berin, and Mike,\n&gt;\n&gt; Thank you very much for the g=\r\nreat comments. I have asked Shin Hwei and Sang\n&gt; to provide their thoughts,=\r\n but until then, here are my answers to your\n&gt; specific questions (SH&S wil=\r\nl correct me if I get anything wrong).\n&gt;\n&gt; David wrote...\n&gt;&gt; do you agree t=\r\nhe below would work with the current implementation\n&gt;&gt; of Theories? It&#39;s fo=\r\nur lines more of boilerplate, but not totally\n&gt; intractable\n&gt;\n&gt; You are cor=\r\nrect that copying within a @Datapoint method would create a new\n&gt; data poin=\r\nt as needed and would probably be a good workaround for Berin&#39;s\n&gt; bug. Howe=\r\nver, I see two drawbacks in addition to those you mention. First,\n&gt; one wou=\r\nld need to include the copy invocation in every @DataPoint method\n&gt; that us=\r\ned createdOnce. In contrast, annotating the @DataPoint itself would\n&gt; provi=\r\nde all consumers with pristine values. Second, the solution fails when\n&gt; us=\r\ning @DataPoints with a theory that takes multiple parameters:\n&gt;\n&gt; private s=\r\ntatic Mutable[] createdOnce =3D new Mutable[] {\n&gt; new Mutable(),\n&gt; new Muta=\r\nble() };\n&gt;\n&gt; @DataPoints()\n&gt; public static Mutable[] mutables() {\n&gt; return =\r\nnew Mutable[] {\n&gt; new Mutable(createdOnce[0]),\n&gt; new Mutable(createdOnce[1]=\r\n)\n&gt; };\n&gt; }\n&gt;\n&gt; @Theory\n&gt; public void testNotMutated(Mutable a, Mutable b) {=\r\n\n&gt; assertFalse(a.isMutated);\n&gt; a.mutate();\n&gt; assertFalse(b.isMutated);\n&gt; b.=\r\nmutate();\n&gt; }\n&gt;\n&gt; The code above fails because a and b can be aliases for t=\r\nhe same object. It\n&gt; may of course be desirable to run a theory on identica=\r\nl instances, but in\n&gt; that case, the user could make that behavior explicit=\r\n in another theory.\n&gt;\n&gt; David wrote...\n&gt;&gt; What would you think of allowing =\r\nfields or methods to\n&gt;&gt; return PontentialAssignment, the type of named refe=\r\nrences to data\n&gt;&gt; values used in the Theories runner?\n&gt; ...\n&gt;&gt; After furthe=\r\nr thought, the ParameterSupplier class is even better for\n&gt;&gt; this kind of t=\r\nhing:\n&gt;\n&gt; Do I understand correctly that you are suggesting pulling the\n&gt; P=\r\notentialAssignment array out of the internal Theory runner and making it\n&gt; =\r\navailable to developers? I seem to remember that Sang and Shin Hwei\n&gt; exper=\r\nimented with modifications to the PotentialAssignment and\n&gt; ParameterSuppli=\r\ner classes, but they can describe what they did better than\n&gt; I.\n&gt;\n&gt; David =\r\nwrote...\n&gt;&gt; @DataPointSource public static PotentialAssignment&lt;Mutable&gt; =3D=\r\n\n&gt;&gt; Copy.ofMutable(new Mutable());\n&gt; ...\n&gt;&gt; @DataSupplier public static One=\r\nTypeSupplier&lt;Mutable&gt; copyMutable =3D\n&gt;&gt; Copies.of(new Mutable());\n&gt;\n&gt; I li=\r\nke the idea of allowing data sources that produce things on-demand\n&gt; rather=\r\n than in a pre-constructed array of values. This gets back to a brief\n&gt; dis=\r\ncussion you and I had a long time ago about having the @DataPoints\n&gt; annota=\r\ntion return Iterable&lt;DataPointType&gt;. That would make things like the\n&gt; foll=\r\nowing possible:\n&gt;\n&gt; @DataPoints\n&gt; public static Iterable&lt;Integer&gt; ints =3D =\r\nInts.between(-10, 10);\n&gt;\n&gt; @DataPoints\n&gt; public static Iterable&lt;Mutable&gt; mu=\r\ntables() {\n&gt; return Copies.of(...);\n&gt; }\n&gt;\n&gt; I don&#39;t know if it is better to=\r\n overload @DataPoints or define new\n&gt; @DataPointSupplier/@DataPointSource a=\r\nnnotations.\n&gt;\n&gt; Berin wrote...\n&gt;&gt; I hope we are not introducing an interfac=\r\ne or base class that\n&gt;&gt; would be required for the data classes to implement=\r\n\n&gt;\n&gt; Absolutely not. That is one of the benefits of defining copy strategie=\r\ns in\n&gt; the @DataPoint annotations: the data point classes themselves remain=\r\n\n&gt; unchaged.\n&gt;\n&gt; Berin wrote...\n&gt;&gt; Is there a default CloneStrategy availab=\r\nle?\n&gt;\n&gt; Sang and Shin Hwei implemented several copy strategies, including o=\r\nne that\n&gt; uses clone, but they did not include them in the patch in an effo=\r\nrt to\n&gt; reduce its size and complexity. Would it be helpful if they pushed =\r\nsome\n&gt; examples?\n&gt;\n&gt; Berin wrote...\n&gt;&gt; Here&#39;s a problem I spotted in the im=\r\nplementation:\n&gt;\n&gt; Thank you very much for looking so closely at Sang and Sh=\r\nin Hwei&#39;s code. I\n&gt; have asked them to address any bugs that you or others =\r\nfind.\n&gt;\n&gt; Brett\n&gt;\n&gt; On Mon, Mar 15, 2010 at 8:51 AM, David Saff &lt;david@saff=\r\n.net &lt;mailto:david%40saff.net&gt; &gt; wrote:\n&gt;\n&gt;&gt;\n&gt;&gt;\n&gt;&gt; On Mon, Mar 15, 2010 at =\r\n9:05 AM, Loritsch, Berin C.\n&gt;&gt; &lt;berin.loritsch@... &lt;mailto:berin.lor=\r\nitsch%40gd-ais.com&gt; =A0&lt;berin.loritsch%40gd-ais.com&gt;&gt; wrote:\n&gt;&gt; &gt; I&#39;m still=\r\n going through the patch. Is there a default CloneStrategy\n&gt;&gt; available? An=\r\ny cloneable object (implements the Cloneable interface) will\n&gt;&gt; be much qui=\r\ncker than another copy strategy. It&#39;s also an interface and a\n&gt;&gt; copy strat=\r\negy that comes with the JVM since before Java 2.\n&gt;&gt; &gt;\n&gt;&gt; &gt; Here&#39;s a problem=\r\n I spotted in the implementation:\n&gt;&gt; &gt;\n&gt;&gt; &gt; protected Object getCopyStrateg=\r\nyInvokedObject(Object value,\n&gt;&gt; &gt; Class&lt;? extends CopyStrategy&gt; copyStrateg=\r\ny, int index) throws\n&gt;&gt; CopyStrategyFailureException {\n&gt;&gt; &gt; try {\n&gt;&gt; &gt; retu=\r\nrn copyStrategy.newInstance().copyDataPoint(value);\n&gt;&gt; &gt; } catch (Exception=\r\n e) {\n&gt;&gt; &gt; throw new CopyStrategyFailureException(value, index,\n&gt;&gt; copyStra=\r\ntegy.getSimpleName());\n&gt;&gt; &gt; }\n&gt;&gt; &gt; }\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt; Invoking copyStrategy.n=\r\newInstance() for every object that needs to be\n&gt;&gt; copied is going to be a m=\r\najor performance drain. Not only are we creating\n&gt;&gt; more work for the garba=\r\nge collector, we are going through the overhead of\n&gt;&gt; the reflection API to=\r\n do it. You will have an order of magnitude better\n&gt;&gt; performance if you ge=\r\nt your instance of the CopyStrategy first, and pass\n&gt;&gt; that as necessary.\n&gt;=\r\n&gt; &gt;\n&gt;&gt; &gt; Perhaps another point of making the code cleaner would be to pull =\r\nall the\n&gt;&gt; data collection stuff into its own API. It might even be able to=\r\n support\n&gt;&gt; parameterized tests as well as theories. I imagine that was the=\r\n idea behind\n&gt;&gt; ParameterSupplier?\n&gt;&gt;\n&gt;&gt; Sadly, ParameterSupplier only appl=\r\nies to one parameter at a time, but\n&gt;&gt; I could imagine a unified API that i=\r\nncluded interfaces for both.\n&gt;&gt;\n&gt;&gt; David\n&gt;&gt;\n&gt;&gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt; __________________=\r\n______________\n&gt;&gt; &gt;\n&gt;&gt; &gt; From: junit@yahoogroups.com &lt;mailto:junit%40yahoog=\r\nroups.com&gt; =A0&lt;junit%40yahoogroups.com&gt; on behalf of Mike\n&gt;&gt; Forsberg\n&gt;&gt; &gt; =\r\nSent: Sun 3/14/2010 12:15 PM\n&gt;&gt; &gt; To: junit@yahoogroups.com &lt;mailto:junit%4=\r\n0yahoogroups.com&gt; =A0&lt;junit%40yahoogroups.com&gt;; Shin Hwei Tan; Sang\n&gt;&gt; Y Ba=\r\nik\n&gt;&gt; &gt; Subject: Re: [junit] Re: @DataPoints called several times for Theor=\r\nies\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt; Please feel free to join the mailing list. I w=\r\nould find the discussion\n&gt;&gt; &gt; interesting and wish it would not run offline=\r\n.\n&gt;&gt; &gt;\n&gt;&gt; &gt; Big Mike\n&gt;&gt; &gt;\n&gt;&gt; &gt; On Fri, Mar 12, 2010 at 6:44 PM, Brett Danie=\r\nl &lt;brettdaniel@... &lt;mailto:brettdaniel%40gmail.com&gt; &lt;brettdaniel%40gm=\r\nail.com&gt;&lt;mailto:\n&gt;&gt; brettdaniel%40gmail.com &lt;brettdaniel%2540gmail.com&gt;&gt; &gt; =\r\nwrote:\n&gt;&gt; &gt;\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; The undergrads I am advising recently pushed =\r\na patch that addresses the\n&gt;&gt; &gt;&gt; issue of mutable data points.\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt;\n=\r\n&gt;&gt; &gt;&gt;\n&gt;&gt; http://github.com/stan6/junit/commit/dcfa3c41446c469a4edc7513e9e7a=\r\n9b610b04020 &lt;http://github.com/stan6/junit/commit/dcfa3c41446c469a4edc7513e=\r\n9e7a9b610b04020&gt; &lt;\n&gt;&gt; http://github.com/stan6/junit/commit/dcfa3c41446c469a=\r\n4edc7513e9e7a9b610b04020 &lt;http://github.com/stan6/junit/commit/dcfa3c41446c=\r\n469a4edc7513e9e7a9b610b04020&gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; The patch allows developers =\r\nto define &quot;copy strategies&quot; that duplicate\n&gt;&gt; &gt;&gt; marked data points before =\r\nevery theory execution. In this way, every\n&gt;&gt; &gt;&gt; execution receives a prist=\r\nine data point, which removes the problems\n&gt;&gt; caused\n&gt;&gt; &gt;&gt; when a theory mu=\r\ntates data points. This is orthogonal to datapoint\n&gt;&gt; &gt;&gt; (re)creation, but =\r\nI think copy strategies may help address the bug that\n&gt;&gt; &gt;&gt; Berin found.\n&gt;&gt;=\r\n &gt;&gt;\n&gt;&gt; &gt;&gt; The patch creates a new, optional &quot;copyStrategy&quot; parameter for th=\r\ne\n&gt;&gt; &gt;&gt; @DataPoint and @DataPoints annotations. If the developer wants to c=\r\nopy\n&gt;&gt; data\n&gt;&gt; &gt;&gt; points, he or she sets the parameter to a class implement=\r\ning a new\n&gt;&gt; &gt;&gt; CopyStrategy interface.\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; Here is an example:\n&gt;&gt; =\r\n&gt;&gt;\n&gt;&gt; &gt;&gt; @RunWith(Theories.class)\n&gt;&gt; &gt;&gt; public class TestMutable {\n&gt;&gt; &gt;&gt;\n&gt;&gt;=\r\n &gt;&gt; @DataPoint(copyStrategy =3D MutableWithCopyStrategy.class)\n&gt;&gt; &gt;&gt; public=\r\n static Mutable mutable =3D new Mutable();\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; @Theory\n&gt;&gt; &gt;&gt; public=\r\n static testMutate(Mutable a) {\n&gt;&gt; &gt;&gt; a.mutate();\n&gt;&gt; &gt;&gt; }\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; @Theo=\r\nry\n&gt;&gt; &gt;&gt; public static testNotMutated(Mutable a) {\n&gt;&gt; &gt;&gt; assertFalse(a.isMu=\r\ntated());\n&gt;&gt; &gt;&gt; }\n&gt;&gt; &gt;&gt; }\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; In the current implementation of JUni=\r\nt, the second theory may fail\n&gt;&gt; because\n&gt;&gt; &gt;&gt; the first theory mutates the=\r\n datapoint. With a copy strategy enabled,\n&gt;&gt; both\n&gt;&gt; &gt;&gt; theories receive a =\r\nnew value.\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; Strategies can do almost anything: clone the data po=\r\nint, call a factory\n&gt;&gt; &gt;&gt; method, or--as in the following implementation--i=\r\nnstantaiate a new\n&gt;&gt; object\n&gt;&gt; &gt;&gt; with a copy constructor.\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; publ=\r\nic class MutableWithCopyStrategy implements CopyStrategy {\n&gt;&gt; &gt;&gt; public Obj=\r\nect copyDataPoint(Object toCopy) throws Exception {\n&gt;&gt; &gt;&gt; return new Mutabl=\r\ne((Mutable)toCopy);\n&gt;&gt; &gt;&gt; }\n&gt;&gt; &gt;&gt; }\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; There are several benefits =\r\nto this implementation. First, the new\n&gt;&gt; parameter\n&gt;&gt; &gt;&gt; is completely opt=\r\nional; if it is omitted, the theory runner behaves as\n&gt;&gt; it\n&gt;&gt; &gt;&gt; always ha=\r\ns. Second, it doesn&#39;t require modifying the data point&#39;s class\n&gt;&gt; &gt;&gt; (for\n&gt;=\r\n&gt; &gt;&gt; example, to add a copy constructor or clone method). Most importantly,=\r\n\n&gt;&gt; it\n&gt;&gt; &gt;&gt; makes it clear to the tester that without a copy strategy one =\r\ntheory\n&gt;&gt; &gt;&gt; execution can impact another.\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; I have CC&#39;d the two =\r\nstudents in this email. Please direct any questions\n&gt;&gt; to\n&gt;&gt; &gt;&gt; them.\n&gt;&gt; &gt;&gt;=\r\n\n&gt;&gt; &gt;&gt; Brett\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; On Thu, Feb 18, 2010 at 5:28 PM, Berin &lt;beri=\r\nn.loritsch@... &lt;mailto:berin.loritsch%40gd-ais.com&gt; &lt;berin.loritsch%=\r\n40gd-ais.com&gt;&lt;mailto:\n&gt;&gt; berin.loritsch%40gd-ais.com &lt;berin.loritsch%2540gd=\r\n-ais.com&gt;&gt;\n&gt;&gt; &lt;berin.loritsch%40gd-ais.com&gt;&gt;\n&gt;&gt; &gt;&gt; wrote:\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; =\r\n&gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; I agree with your prognosis, about fresh data points for testi=\r\nng the\n&gt;&gt; &gt;&gt; &gt; theories. That is precisely why I proposed reading them once=\r\n, and\n&gt;&gt; cloning\n&gt;&gt; &gt;&gt; &gt; them (making a copy) as needed for each theory. Wi=\r\nth that approach we\n&gt;&gt; &gt;&gt; even\n&gt;&gt; &gt;&gt; &gt; get the protection from mutated data=\r\n points when you use the\n&gt;&gt; @DataPoint\n&gt;&gt; &gt;&gt; to\n&gt;&gt; &gt;&gt; &gt; mark a static field=\r\n.\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; Cloning is a much quicker operation, does not execute any=\r\n\n&gt;&gt; constructors.\n&gt;&gt; &gt;&gt; It\n&gt;&gt; &gt;&gt; &gt; merely copies the contents of the object=\r\n memory verbatim.\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; With the current implementation, if you a=\r\nre not prepared for the\n&gt;&gt; &gt;&gt; &gt; combinatorial affect of 60 data points comb=\r\nined with 60 data points\n&gt;&gt; for\n&gt;&gt; &gt;&gt; each\n&gt;&gt; &gt;&gt; &gt; theory there is a major =\r\ndisconnect. The majority of the overhead in\n&gt;&gt; this\n&gt;&gt; &gt;&gt; &gt; particular scen=\r\nario has to do with creating objects (with the\n&gt;&gt; additional\n&gt;&gt; &gt;&gt; &gt; overhe=\r\nad of doing it by reflection).\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; When I created only one inst=\r\nance of each class instead of two, the\n&gt;&gt; &gt;&gt; &gt; performance was twice as fas=\r\nt (i.e. 37 seconds down to about 16\n&gt;&gt; seconds).\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; Essentiall=\r\ny the number of times your @DataPoints method is called\n&gt;&gt; depends\n&gt;&gt; &gt;&gt; &gt; =\r\non the number of parameters in your @Theory and how many theories you\n&gt;&gt; &gt;&gt;=\r\n have.\n&gt;&gt; &gt;&gt; &gt; Essentially the formula for my theory (ha, ha) of the execut=\r\nion is\n&gt;&gt; like\n&gt;&gt; &gt;&gt; &gt; this:\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; N^(p-1) + 1\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; wh=\r\nere:\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; N is the number of data points returned by the method\n=\r\n&gt;&gt; &gt;&gt; &gt; p is the number of parameters\n&gt;&gt; &gt;&gt; &gt; and the + 1 represents the ru=\r\nn where the data point is read the first\n&gt;&gt; &gt;&gt; time\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; So for =\r\n60 data points it is run 61 times for two parameters. With\n&gt;&gt; three\n&gt;&gt; &gt;&gt; &gt;=\r\n parameters it would be called 3601 times. I have to verify with three\n&gt;&gt; &gt;=\r\n&gt; &gt; parameters. The theory is called N^p times for sure and that is\n&gt;&gt; expe=\r\ncted.\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; With the above formula, the mapping of number of call=\r\ns to parameters\n&gt;&gt; for\n&gt;&gt; &gt;&gt; 60\n&gt;&gt; &gt;&gt; &gt; data points would be:\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt;=\r\n &gt; 1 -&gt; 2 (I know this is wrong which gives me doubts on the formula)\n&gt;&gt; &gt;&gt;=\r\n &gt; 2 -&gt; 61\n&gt;&gt; &gt;&gt; &gt; 3 -&gt; 3601\n&gt;&gt; &gt;&gt; &gt; 3 -&gt; 216001\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; Essentiall=\r\ny when the Assignments class needs to make the combinations,\n&gt;&gt; it\n&gt;&gt; &gt;&gt; &gt; =\r\nwill collect the data points initially for each theory. It then calls\n&gt;&gt; th=\r\ne\n&gt;&gt; &gt;&gt; &gt; data points again for each existing data point it collected from =\r\nthe\n&gt;&gt; &gt;&gt; first\n&gt;&gt; &gt;&gt; &gt; read. With a third parameter it would take all thos=\r\ne combinations\n&gt;&gt; again,\n&gt;&gt; &gt;&gt; to\n&gt;&gt; &gt;&gt; &gt; add all the permutations for the =\r\nnext round.\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; I might be wrong and the real formula would be =\r\nlike this:\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; N^0 + N^1 ... + N^(p-1)\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; If this =\r\nis the correct formula, then if you have 60 data points the\n&gt;&gt; &gt;&gt; number\n&gt;&gt;=\r\n &gt;&gt; &gt; of times the method is called would map to the number of parameters\n&gt;=\r\n&gt; like\n&gt;&gt; &gt;&gt; &gt; this:\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; 1 -&gt; 1\n&gt;&gt; &gt;&gt; &gt; 2 -&gt; 61\n&gt;&gt; &gt;&gt; &gt; 3 -&gt; 36=\r\n61\n&gt;&gt; &gt;&gt; &gt; 4 -&gt; 219661\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; --- In junit@yahoogroups.com=\r\n &lt;mailto:junit%40yahoogroups.com&gt; =A0&lt;junit%40yahoogroups.com&gt; &lt;mailto:\n&gt;&gt; =\r\njunit%40yahoogroups.com &lt;junit%2540yahoogroups.com&gt;&gt; &lt;junit%\n&gt;&gt; 40yahoogrou=\r\nps.com&gt; &lt;junit%\n&gt;&gt; &gt;&gt; 40yahoogroups.com&gt;, Brett Daniel\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; &gt; &lt;brett=\r\ndaniel@...&gt; wrote:\n&gt;&gt; &gt;&gt; &gt; &gt;\n&gt;&gt; &gt;&gt; &gt; &gt; Berin,\n&gt;&gt; &gt;&gt; &gt; &gt;\n&gt;&gt; &gt;&gt; &gt; &gt; When a th=\r\neory mutates data points, it might be beneficial to\n&gt;&gt; recreate\n&gt;&gt; &gt;&gt; &gt; &gt; t=\r\nhe data point for every theory invocation. Doing so prevents one\n&gt;&gt; &gt;&gt; &gt; &gt; =\r\ntheory execution from affecting others. I wrote about this issue in\n&gt;&gt; &gt;&gt; &gt;=\r\n &gt; the following weblog post:\n&gt;&gt; &gt;&gt; &gt; &gt;\n&gt;&gt; &gt;&gt; &gt; &gt; http://www.brettdaniel.co=\r\nm/archives/2009/09/24/200845/ &lt;http://www.brettdaniel.com/archives/2009/09/=\r\n24/200845/&gt; =A0&lt;\n&gt;&gt; http://www.brettdaniel.com/archives/2009/09/24/200845/ =\r\n&lt;http://www.brettdaniel.com/archives/2009/09/24/200845/&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; &gt;\n&gt;&gt; &gt;&gt; =\r\n&gt; &gt; You are correct, though, that copying would avoid some of the\n&gt;&gt; overhe=\r\nad\n&gt;&gt; &gt;&gt; &gt; &gt; in calling datapoint methods. It is interesting you mention th=\r\nis\n&gt;&gt; idea,\n&gt;&gt; &gt;&gt; &gt; &gt; because I am currently overseeing two students who fo=\r\nr their senior\n&gt;&gt; &gt;&gt; &gt; &gt; thesis project are implementing framework for copy=\r\ning datapoints. I\n&gt;&gt; &gt;&gt; &gt; &gt; will post more information to the mailing list =\r\nas the project\n&gt;&gt; &gt;&gt; &gt; &gt; continues.\n&gt;&gt; &gt;&gt; &gt; &gt;\n&gt;&gt; &gt;&gt; &gt; &gt; Brett\n&gt;&gt; &gt;&gt; &gt; &gt;\n&gt;&gt; =\r\n&gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; [Non-text portions of this message have be=\r\nen removed]\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt; [Non-text portions of this message =\r\nhave been removed]\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt; [Non-text portions of=\r\n this message have been removed]\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt; ----------------------=\r\n--------------\n&gt;&gt; &gt;\n&gt;&gt; &gt; Yahoo! Groups Links\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt;\n&gt;&gt;\n&gt;\n&gt; =\r\n[Non-text portions of this message have been removed]\n&gt;\n&gt;\n&gt;\n&gt;\n&gt;\n&gt;\n&gt; [Non-te=\r\nxt portions of this message have been removed]\n&gt;\n&gt;\n&gt;\n&gt; --------------------=\r\n----------------\n&gt;\n&gt; Yahoo! Groups Links\n&gt;\n&gt;\n&gt;\n&gt;\n\n", 
    "profile": "dsaff", 
    "topicId": 22425, 
    "spamInfo": {
        "reason": "4", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 341876227, 
    "prevInTime": 22550, 
    "contentTrasformed": false, 
    "postDate": "1268685544", 
    "canDelete": false, 
    "nextInTopic": 22552, 
    "prevInTopic": 22550, 
    "headers": {
        "inReplyToHeader": "PDc1RjVFRDhBNUE1NTM2NDZBNDZFMDBFNkVDODU0RkEzMDM3OEM3RUVAdmFmZjAxLW1haWwwMS5hZC5nZC1haXMuY29tPg==", 
        "messageIdInHeader": "PDRmN2RhNmI5MTAwMzE1MTMzOWszYmE1MzVlY3UzYzQxNDU3MjM0OTc5YzRAbWFpbC5nbWFpbC5jb20+", 
        "referencesHeader": "PDU4ZGJhMjI1MTAwMjE4MDk0M3EyMzhkZDhkdjExYWI0ODczNjMyMWUxNzhAbWFpbC5nbWFpbC5jb20+CSA8aGxraWYyKzNtdGVAZUdyb3Vwcy5jb20+CSA8NThkYmEyMjUxMDAzMTIxNTQ0cDNjZDdkZDI4aDFhODk5Y2U2NTdmNjZhZDNAbWFpbC5nbWFpbC5jb20+CSA8YTUyN2ZkZGYxMDAzMTQwOTE1bDczNzYxZWUxcjc4MWJhMjBmYzc2OGU0MmVAbWFpbC5nbWFpbC5jb20+CSA8NzVGNUVEOEE1QTU1MzY0NkE0NkUwMEU2RUM4NTRGQTMwMzc4QzdFNEB2YWZmMDEtbWFpbDAxLmFkLmdkLWFpcy5jb20+CSA8NGY3ZGE2YjkxMDAzMTUwNjUxbTEyZjI3OTZrZjlhYWIxN2ZmMzEyY2Q5M0BtYWlsLmdtYWlsLmNvbT4JIDw1OGRiYTIyNTEwMDMxNTEwNTZrNGJmMjRmZjJ4ZjE2MWU2NDE1YWJmNGFiYUBtYWlsLmdtYWlsLmNvbT4JIDw3NUY1RUQ4QTVBNTUzNjQ2QTQ2RTAwRTZFQzg1NEZBMzAzNzhDN0VFQHZhZmYwMS1tYWlsMDEuYWQuZ2QtYWlzLmNvbT4="
    }
}