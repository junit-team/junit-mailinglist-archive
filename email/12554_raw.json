{
    "numMessagesInTopic": 10, 
    "nextInTime": 12555, 
    "senderId": "6Sg2wARDg4J5DfbIzc9Fm1vXpyaGBx6Vpz-2YwZrmF6pbNEaXMg2Hke9qanEcr6uNV5NPkO7NHloJDpPyzNoO-uFk7r_", 
    "systemMessage": false, 
    "subject": "Re: [junit] Multithreading: Testing scheduled method invocation?!", 
    "from": "Brett Neumeier &lt;random@...&gt;", 
    "authorName": "Brett Neumeier", 
    "msgSnippet": "... I have done that as well.  My Clock interface encapsulates System.currentTimeMillis(), new Date(), Calendar.getInstance(), and Thread.sleep().  There may", 
    "msgId": 12554, 
    "rawEmail": "Return-Path: &lt;random@...&gt;\r\nX-Sender: random@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (qmail 51813 invoked from network); 28 Dec 2004 01:37:18 -0000\r\nReceived: from unknown (66.218.66.218)\n  by m22.grp.scd.yahoo.com with QMQP; 28 Dec 2004 01:37:18 -0000\r\nReceived: from unknown (HELO thrud.rnd.cx) (69.17.20.53)\n  by mta3.grp.scd.yahoo.com with SMTP; 28 Dec 2004 01:37:18 -0000\r\nReceived: from anome.rnd.cx (anome.rnd.cx [192.168.236.6])\n\tby thrud.rnd.cx (Postfix) with ESMTP id 69D0CF501A\n\tfor &lt;junit@yahoogroups.com&gt;; Mon, 27 Dec 2004 19:23:24 -0600 (CST)\r\nTo: junit@yahoogroups.com\r\nIn-Reply-To: &lt;BFFCC881-5829-11D9-9839-000A95A547BC@...&gt;\r\nReferences: &lt;200412220131.05639.michael@...&gt;\n\t &lt;BFFCC881-5829-11D9-9839-000A95A547BC@...&gt;\r\nContent-Type: text/plain\r\nDate: Mon, 27 Dec 2004 19:45:36 -0600\r\nMessage-Id: &lt;1104198337.10301.47.camel@...&gt;\r\nMime-Version: 1.0\r\nX-Mailer: Evolution 2.0.2 \r\nContent-Transfer-Encoding: 7bit\r\nX-eGroups-Remote-IP: 69.17.20.53\r\nFrom: Brett Neumeier &lt;random@...&gt;\r\nSubject: Re: [junit] Multithreading: Testing scheduled method invocation?!\r\nX-Yahoo-Group-Post: member; u=122508602\r\nX-Yahoo-Profile: xptlq\r\n\r\nOn Mon, 2004-12-27 at 10:07 -0700, Mike Clark wrote:\n&gt; I tried writing some learning tests for Quartz a couple months back.  \n&gt; For what it&#39;s worth, I ran into the same timing issues.\n&gt; \n&gt; Before reaching for sleep(), I tried to refactor Quartz innards so that \n&gt; the internal clock could be programmatically advanced.  Unfortunately, \n&gt; a direct call to System.currentTimeMillis() was duplicated in many \n&gt; places and even after consolidating all those calls through an \n&gt; interface I was unable to mock the clock.\n\nI have done that as well.  My Clock interface encapsulates\nSystem.currentTimeMillis(), new Date(), Calendar.getInstance(), and\nThread.sleep().  There may be other standard API mechanisms that operate\non the current system time, but those were the only ones in use in the\ncode I was refactoring.\n\nMost of those were no problem, but pause (the method that encapsulates\nThread.sleep()) was very difficult to fake.  The problem is that when\nthread A calls pause, all other threads have to be given a chance to\ncall pause before thread A is woken up.  This is tricky because thread\nscheduling in Java is inherently unpredictable, and in Java 1.4 and\nearlier there is no way to determine whether any given thread is\nrunnable or not.  As a result the FakeClock is as reliable as most\nmechanisms for testing multi-threaded code: not perfectly.  \n\nBut the tests are an order of magnitude faster than they were when they\njust used Thread.sleep(), and they are as reliable as they were before,\nso that&#39;s good enough for me.\n\n(Incidentally, in Java 1.5, you can call getState() on a Thread and\nthereby determine whether it is currently runnable, blocked, waiting, in\na timed wait, etc.  But I&#39;m stuck with Java 1.4 at the moment.)\n\nThe code for my Clock interface, and the SystemClock and FakeClock\nimplementations, isn&#39;t currently online anywhere, but if anyone is\ninterested let me know and I&#39;ll send it over.\n\nI don&#39;t think there are any really good solutions to testing\nmultithreaded code in Java at the moment.  The only general approach\nI&#39;ve thought of that SHOULD work properly is to use JDI to launch a\nseparate JVM, and execute the test in that other JVM.  (JDI can be used\nto set breakpoints and method entry watchers, and thereby control\nscheduling absolutely in the test VM.)  But that&#39;s a lot of work, and I\nhaven&#39;t yet been sufficiently motivated to build such a facility.\n\nCheers,\n\nbn\n\n-- \nBrett Neumeier &lt;random@...&gt;\n\n\n", 
    "profile": "xptlq", 
    "topicId": 12519, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 122508602, 
    "prevInTime": 12553, 
    "contentTrasformed": false, 
    "postDate": "1104198336", 
    "canDelete": false, 
    "nextInTopic": 12555, 
    "prevInTopic": 12553, 
    "headers": {
        "inReplyToHeader": "PEJGRkNDODgxLTU4MjktMTFEOS05ODM5LTAwMEE5NUE1NDdCQ0BjbGFya3dhcmUuY29tPg==", 
        "messageIdInHeader": "PDExMDQxOTgzMzcuMTAzMDEuNDcuY2FtZWxAYW5vbWUucm5kLmN4Pg==", 
        "referencesHeader": "PDIwMDQxMjIyMDEzMS4wNTYzOS5taWNoYWVsQHNjaHVlcmlnLmRlPgkgPEJGRkNDODgxLTU4MjktMTFEOS05ODM5LTAwMEE5NUE1NDdCQ0BjbGFya3dhcmUuY29tPg=="
    }
}