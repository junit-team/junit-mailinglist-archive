{
    "numMessagesInTopic": 12, 
    "nextInTime": 20762, 
    "senderId": "w63PE9g8REKHVZE-8MZdjcT0S6eXX5tkMvO_7yVlFsa0Qb9FNa01Vku8adqmeBJYlZ0G6nCV8vnIueUV1fl5Nev73R4", 
    "systemMessage": false, 
    "subject": "Re: [junit] Anyone help me to figure out the java.lang.StackOverflowError problem?", 
    "from": "&quot;David Saff&quot; &lt;david@...&gt;", 
    "authorName": "David Saff", 
    "msgSnippet": "Fuguo, I m sorry this has been bugging you.  It s difficult to understand how JUnit could be encountering a recursion loop that wasn t there in your production", 
    "msgId": 20761, 
    "profile": "dsaff", 
    "topicId": 20751, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 341876227, 
    "messageBody": "<div id=\"ygrps-yiv-1255779888\">Fuguo,<br/>\n<br/>\nI&#39;m sorry this has been bugging you.  It&#39;s difficult to understand how<br/>\nJUnit could be encountering a recursion loop that wasn&#39;t there in your<br/>\nproduction code.  Have you tried writing a main() method that runs the<br/>\nsame test, but has no dependencies on JUnit?  If it also fails with a<br/>\nStackOverflowError, then you can rest assured that JUnit is not the<br/>\nproblem.<br/>\n<br/>\n   David Saff<br/>\n<br/>\n<blockquote><span title=\"qreply\"> On Tue, Aug 5, 2008 at 6:29 AM, Fuguo Wei &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:tawqir_wei@...\">tawqir_wei@...</a>&gt; wrote:<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; Dear all, I am so upset about the problem I encountered. Wish any one could<br/>\n&gt; help me. Thank here first. It&#39;s the StackOverflowError problem. I thought<br/>\n&gt; It&#39;s because the recursive program I did. Any way ,I don&#39;t know how to solve<br/>\n&gt; this problem.<br/>\n&gt; Maybe I used it wrong. I was wandering where I am wrong for a few days. I am<br/>\n&gt; confused. Kindly hope you could help me. here is the code.(in the attachment<br/>\n&gt; also) if you can not get it, you could check the group file folder as well.<br/>\n&gt; I uploaded them to there. By the way, I tried the debug my source code with<br/>\n&gt; Eclipse debugger. There is no problem.<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; Best regards<br/>\n&gt;<br/>\n&gt; WEI FUGUO<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; (1) the test case is like this<br/>\n&gt;<br/>\n&gt; public void testCreateTableClus ter() {<br/>\n&gt; mapper2.createTable Cluster() ;<br/>\n&gt; assertNotNull( mapper.getClassM ap().getTableClu ster());<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; (2) the createTableCluster( ) source code is like this<br/>\n&gt;<br/>\n&gt; public void createTableCluster( ) {<br/>\n&gt; tableCluster. createMasterTabl e(tableName, classmap);<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; (3) the createMasterTable( ) source code is like this<br/>\n&gt;<br/>\n&gt; public MasterTableMap createMasterTable( String aTablename, ClassMap<br/>\n&gt; aClassmap)<br/>\n&gt; {<br/>\n&gt; return (MasterTableMap) createTable( aTablename, aClassmap, &#39;masterTable&#39; );<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; (4) createTable( ) source code<br/>\n&gt;<br/>\n&gt; public TableMap createTable( String aTablename, ClassMap aClassmap, String<br/>\n&gt; aTabletype)<br/>\n&gt; {<br/>\n&gt; pf.ColumnMap colummap=null;<br/>\n&gt; TableMap result =null;<br/>\n&gt; if (aTabletype. equals(&#39;masterTa ble&#39;))<br/>\n&gt; {<br/>\n&gt; result= new MasterTableMap( aTablename) ;<br/>\n&gt; this.set_masterTabl eMap(result) ;<br/>\n&gt; }<br/>\n&gt; else if (aTabletype. equals(&#39;independ entTable&#39; ))<br/>\n&gt; result= new IndependentTableMap (aTablename) ;<br/>\n&gt; else if (aTabletype. equals(&#39;dependen tTable&#39;))<br/>\n&gt; result= new DependentTableMap( aTablename) ;<br/>\n&gt; setCurrentTableMap( result);<br/>\n&gt; aClassmap.setMaster Table(result) ;<br/>\n&gt;<br/>\n&gt; java.util.List tempList =aClassmap.getColum nMaps();<br/>\n&gt;<br/>\n&gt; Iterator tmpIter = tempList.iterator( );<br/>\n&gt; while (tmpIter.hasNext( ))<br/>\n&gt; {<br/>\n&gt; colummap = (pf.ColumnMap) tmpIter.next( );<br/>\n&gt; colummap.getAttribu teMapper( ).createTableSql Process(this, colummap,<br/>\n&gt; aClassmap);<br/>\n&gt; }<br/>\n&gt; addTableMaps( result);<br/>\n&gt; return result;<br/>\n&gt; }<br/>\n&gt; (5) one of createTableSqlProce ss() is like this. [many classes which<br/>\n&gt; inherit from the same parent have createTableSqlProce ss]<br/>\n&gt;<br/>\n&gt; public void createTableSqlProce ss(TableCluster aTablecluster, pf.ColumnMap<br/>\n&gt; aColumnmap, pf.ClassMap aMasterClass) {<br/>\n&gt; ArrayColumnMap arrayColumnmap = (ArrayColumnMap) aColumnmap;<br/>\n&gt; ClassMap classmap=null;<br/>\n&gt; pf.PersistenceClass persisClass= null;<br/>\n&gt; String tableName =null;<br/>\n&gt; configfiend. RelationshipItem relation=null;<br/>\n&gt; DependentTableMap depentable=null;<br/>\n&gt;<br/>\n&gt; String elementCategory= arrayColumnmap. getElementCatego ry();<br/>\n&gt; if (elementCategory. equals(&#39;Complex&#39; ))<br/>\n&gt; {<br/>\n&gt; classmap =arrayColumnmap. getClassMap( );<br/>\n&gt; if (classmap==null)<br/>\n&gt; {<br/>\n&gt; logger.debug( &#39;The array attribute &#39;+arrayColumnmap. getColumnName( )+&#39;&#39;s<br/>\n&gt; related class was not there, the system will load it at once!&#39;);<br/>\n&gt; persisClass= PersistentClassM anager.loadPersi stenceClass( arrayColumnmap.<br/>\n&gt; getFieldType( ));<br/>\n&gt; if (persisClass! =null)<br/>\n&gt; {<br/>\n&gt; classmap=persisClas s.getMapper( ).getClassMap( );<br/>\n&gt; }<br/>\n&gt; else<br/>\n&gt; {<br/>\n&gt; logger.debug( &#39;couldn&#39;t get the persistence class from peristence class<br/>\n&gt; lib.. the process will be terminated&#39;) ;<br/>\n&gt; return;<br/>\n&gt; }<br/>\n&gt; }<br/>\n&gt; tableName=classmap. getTableName( );<br/>\n&gt; relation=arrayColum nmap.getRelation ship();<br/>\n&gt; if (arrayColumnmap. isReflectRelatio n())<br/>\n&gt; {<br/>\n&gt; if (relation!=null)<br/>\n&gt; {<br/>\n&gt; if ((relation.getRelat ionshipType( ).equals( &#39;Composition&#39; ))||(relation.<br/>\n&gt; getRelationshipT ype().equals( &#39;Strong Aggregation&#39; )))<br/>\n&gt; {<br/>\n&gt; depentable=aTablecl uster.createDepe ndentTable( tableName, classmap);<br/>\n&gt; depentable.setRefer enceTable( aMasterClass. getMasterTable( ));<br/>\n&gt; }<br/>\n&gt; else<br/>\n&gt; aTablecluster. createIndependen tTable(tableName , classmap);<br/>\n&gt; }<br/>\n&gt; }<br/>\n&gt; else<br/>\n&gt; aTablecluster. createIndependen tTable(tableName , classmap);<br/>\n&gt; }<br/>\n&gt; else<br/>\n&gt; {<br/>\n&gt; String fieldname=arrayColu mnmap.getFieldNa me();<br/>\n&gt; String fieldtype=arrayColu mnmap.getFieldTy pe();<br/>\n&gt; TableField tablefield=new TableField(fieldnam e,fieldtype, aMasterClass.<br/>\n&gt; getDomainClass( ));<br/>\n&gt; aTablecluster. getCurrentTableM ap().addField( tablefield) ;<br/>\n&gt;<br/>\n&gt; String tempstr =aMasterClass. getDomainClass( ).getName( ).substring(<br/>\n&gt; aMasterClass. getDomainClass( ).getName( ).lastIndexOf( &#39;.&#39;)+1)+&#39; oid&#39;;<br/>\n&gt; if (fieldname.toUpperC ase().indexOf( tempstr.toUpperC ase())!=- 1)<br/>\n&gt; aTablecluster. getCurrentTableM ap().setPrimaryK ey(tablefield) ;<br/>\n&gt; }<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; as you can see the createTable method is invoked recursively in<br/>\n&gt; createTableSqlProce ss() [the bold statement]<br/>\n&gt;<br/>\n&gt; the sourse code of createDependentTabl e() likes this<br/>\n&gt;<br/>\n&gt; public DependentTableMap createDependentTabl e(String aTablename, ClassMap<br/>\n&gt; aClassmap) {<br/>\n&gt; return (DependentTableMap) createTable( aTablename, aClassmap,<br/>\n&gt; &#39;dependentTable&#39; );<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; the sourse code of createIndependentTa ble() likes this<br/>\n&gt;<br/>\n&gt; public IndependentTableMap createIndependentTa ble(String aTablename,<br/>\n&gt; ClassMap aClassmap) {<br/>\n&gt; return (IndependentTableMa p)createTable( aTablename, aClassmap,<br/>\n&gt; &#39;independentTabl e&#39;);<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; the two methods are like the createMasterTable( ) at the beginning of the<br/>\n&gt; source code I listed here.<br/>\n&gt;<br/>\n&gt; the createTable( ) is invoked recursively, as you can see. I guess that&#39;s<br/>\n&gt; the point why JUnit wrong.<br/>\n&gt;<br/>\n&gt; the Junit errow message screen was captured in the attachement.<br/>\n&gt;<br/>\n&gt; ----------<br/>\n&gt;<br/>\n&gt; (1) the test case is like this<br/>\n&gt;<br/>\n&gt; public void testCreateTableCluster() {<br/>\n&gt; mapper2.createTableCluster();<br/>\n&gt; assertNotNull(mapper.getClassMap().getTableCluster());<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; (2) the createTableCluster() source code is like this<br/>\n&gt;<br/>\n&gt; public void createTableCluster() {<br/>\n&gt; tableCluster.createMasterTable(tableName, classmap);<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; (3) the createMasterTable() source code is like this<br/>\n&gt;<br/>\n&gt; public MasterTableMap createMasterTable(String aTablename, ClassMap<br/>\n&gt; aClassmap)<br/>\n&gt; {<br/>\n&gt; return (MasterTableMap)createTable(aTablename,aClassmap,&#39;masterTable&#39;);<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; (4) createTable() source code<br/>\n&gt;<br/>\n&gt; public TableMap createTable(String aTablename, ClassMap aClassmap, String<br/>\n&gt; aTabletype)<br/>\n&gt; {<br/>\n&gt; pf.ColumnMap colummap=null;<br/>\n&gt; TableMap result =null;<br/>\n&gt; if (aTabletype.equals(&#39;masterTable&#39;))<br/>\n&gt; {<br/>\n&gt; result= new MasterTableMap(aTablename);<br/>\n&gt; this.set_masterTableMap(result);<br/>\n&gt; }<br/>\n&gt; else if (aTabletype.equals(&#39;independentTable&#39;))<br/>\n&gt; result= new IndependentTableMap(aTablename);<br/>\n&gt; else if (aTabletype.equals(&#39;dependentTable&#39;))<br/>\n&gt; result= new DependentTableMap(aTablename);<br/>\n&gt; setCurrentTableMap(result);<br/>\n&gt; aClassmap.setMasterTable(result);<br/>\n&gt;<br/>\n&gt; java.util.List tempList =aClassmap.getColumnMaps();<br/>\n&gt;<br/>\n&gt; Iterator tmpIter = tempList.iterator();<br/>\n&gt; while (tmpIter.hasNext())<br/>\n&gt; {<br/>\n&gt; colummap = (pf.ColumnMap)tmpIter.next();<br/>\n&gt; colummap.getAttributeMapper().createTableSqlProcess(this, colummap,<br/>\n&gt; aClassmap);<br/>\n&gt; }<br/>\n&gt; addTableMaps(result);<br/>\n&gt; return result;<br/>\n&gt; }<br/>\n&gt; (5) one of createTableSqlProcess() is like this. [many classes which inherit<br/>\n&gt; from the same parent have createTableSqlProcess]<br/>\n&gt;<br/>\n&gt; public void createTableSqlProcess(TableCluster aTablecluster, pf.ColumnMap<br/>\n&gt; aColumnmap, pf.ClassMap aMasterClass) {<br/>\n&gt; ArrayColumnMap arrayColumnmap = (ArrayColumnMap)aColumnmap;<br/>\n&gt; ClassMap classmap=null;<br/>\n&gt; pf.PersistenceClass persisClass=null;<br/>\n&gt; String tableName =null;<br/>\n&gt; configfiend.RelationshipItem relation=null;<br/>\n&gt; DependentTableMap depentable=null;<br/>\n&gt;<br/>\n&gt; String elementCategory=arrayColumnmap.getElementCategory();<br/>\n&gt; if (elementCategory.equals(&#39;Complex&#39;))<br/>\n&gt; {<br/>\n&gt; classmap =arrayColumnmap.getClassMap();<br/>\n&gt; if (classmap==null)<br/>\n&gt; {<br/>\n&gt; logger.debug(&#39;The array attribute &#39;+arrayColumnmap.getColumnName()+&#39;&#39;s<br/>\n&gt; related class was not there, the system will load it at once!&#39;);<br/>\n&gt; persisClass=PersistentClassManager.loadPersistenceClass(arrayColumnmap.getFieldType());<br/>\n&gt; if (persisClass!=null)<br/>\n&gt; {<br/>\n&gt; classmap=persisClass.getMapper().getClassMap();<br/>\n&gt; }<br/>\n&gt; else<br/>\n&gt; {<br/>\n&gt; logger.debug(&#39;couldn&#39;t get the persistence class from peristence class lib.<br/>\n&gt; the process will be terminated&#39;);<br/>\n&gt; return;<br/>\n&gt; }<br/>\n&gt; }<br/>\n&gt; tableName=classmap.getTableName();<br/>\n&gt; relation=arrayColumnmap.getRelationship();<br/>\n&gt; if (arrayColumnmap.isReflectRelation())<br/>\n&gt; {<br/>\n&gt; if (relation!=null)<br/>\n&gt; {<br/>\n&gt; if<br/>\n&gt; ((relation.getRelationshipType().equals(&#39;Composition&#39;))||(relation.getRelationshipType().equals(&#39;Strong<br/>\n&gt; Aggregation&#39;)))<br/>\n&gt; {<br/>\n&gt; depentable=aTablecluster.createDependentTable(tableName, classmap);<br/>\n&gt; depentable.setReferenceTable(aMasterClass.getMasterTable());<br/>\n&gt; }<br/>\n&gt; else<br/>\n&gt; aTablecluster.createIndependentTable(tableName, classmap);<br/>\n&gt; }<br/>\n&gt; }<br/>\n&gt; else<br/>\n&gt; aTablecluster.createIndependentTable(tableName, classmap);<br/>\n&gt; }<br/>\n&gt; else<br/>\n&gt; {<br/>\n&gt; String fieldname=arrayColumnmap.getFieldName();<br/>\n&gt; String fieldtype=arrayColumnmap.getFieldType();<br/>\n&gt; TableField tablefield=new<br/>\n&gt; TableField(fieldname,fieldtype,aMasterClass.getDomainClass());<br/>\n&gt; aTablecluster.getCurrentTableMap().addField(tablefield);<br/>\n&gt;<br/>\n&gt; String tempstr<br/>\n&gt; =aMasterClass.getDomainClass().getName().substring(aMasterClass.getDomainClass().getName().lastIndexOf(&#39;.&#39;)+1)+&#39;oid&#39;;<br/>\n&gt; if (fieldname.toUpperCase().indexOf(tempstr.toUpperCase())!=-1)<br/>\n&gt; aTablecluster.getCurrentTableMap().setPrimaryKey(tablefield);<br/>\n&gt; }<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; as you can see the createTable method is invoked recursively in<br/>\n&gt; createTableSqlProcess() [the bold statement]<br/>\n&gt;<br/>\n&gt; the sourse code of createDependentTable() likes this<br/>\n&gt;<br/>\n&gt; public DependentTableMap createDependentTable(String aTablename, ClassMap<br/>\n&gt; aClassmap) {<br/>\n&gt; return<br/>\n&gt; (DependentTableMap)createTable(aTablename,aClassmap,&#39;dependentTable&#39;);<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; the sourse code of createIndependentTable() likes this<br/>\n&gt;<br/>\n&gt; public IndependentTableMap createIndependentTable(String aTablename,<br/>\n&gt; ClassMap aClassmap) {<br/>\n&gt; return<br/>\n&gt; (IndependentTableMap)createTable(aTablename,aClassmap,&#39;independentTable&#39;);<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; the two methods are like the createMasterTable() at the beginning of the<br/>\n&gt; source code I listed here.<br/>\n&gt;<br/>\n&gt; the createTable() is invoked recursively, as you can see. I guess that&#39;s the<br/>\n&gt; point why JUnit wrong.<br/>\n&gt; the Junit errow message screen was captured in the attachement.<br/>\n&gt;<br/>\n&gt; [Non-text portions of this message have been removed]<br/>\n&gt;<br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 20760, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1218018150", 
    "canDelete": false, 
    "nextInTopic": 20768, 
    "prevInTopic": 20760, 
    "headers": {
        "inReplyToHeader": "PDI1NTc3MC40NTUxOC5xbUB3ZWI0NDgxMy5tYWlsLnNwMS55YWhvby5jb20+", 
        "messageIdInHeader": "PDRmN2RhNmI5MDgwODA2MDMyMmgxNjdkMTg0ZXU4N2RkMzNhODM4ODk0ZjEwQG1haWwuZ21haWwuY29tPg==", 
        "referencesHeader": "PDI1NTc3MC40NTUxOC5xbUB3ZWI0NDgxMy5tYWlsLnNwMS55YWhvby5jb20+"
    }
}