{
    "numMessagesInTopic": 9, 
    "nextInTime": 3285, 
    "senderId": "YhmKbxf3HQNBf66VhdKQMnDBzf1zuhuhc7ABm_KitQqKCFJDBiYJqdvHrIm_0dsFsMgDWAxypGZ8h6x-OScciLy0Z767", 
    "systemMessage": false, 
    "subject": "RE: [junit] Inner Class, Even Driven Classes", 
    "from": "Eric Vought &lt;evought@...&gt;", 
    "authorName": "Eric Vought", 
    "msgSnippet": "... You can test several things in your testcase: a) Does the call succeed without throwing an exception? Just calling the method in your testcase tells you", 
    "msgId": 3284, 
    "profile": "eric_vought", 
    "topicId": 3227, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 0, 
    "messageBody": "<div id=\"ygrps-yiv-1520684001\">On Fri, 16 Nov 2001 <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:sowmya.srinivasan@...\">sowmya.srinivasan@...</a> wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Hi<br/>\n&gt; Thanks for the detailed reply.<br/>\n&gt;<br/>\n&gt; Can you help me out on the second question .. How do I write test cases for<br/>\n&gt; event driven program ?<br/>\n&gt; For e.g. I have a class A.<br/>\n&gt; This has three functions<br/>\n&gt; 1. public boolean ConnectURL();<br/>\n&gt; This function connects to a particular URL and loads the details onto the<br/>\n&gt; screen. If this is successful, it returns true else false.<br/>\n&gt; 2. public void Initialisation();<br/>\n&gt; This functions initializes some parameters<br/>\n&gt; 3. public boolean Save(Object obj);<br/>\n&gt; This function saves the details on the screen and if successful, it returns<br/>\n&gt; true, else false.<br/>\n&gt;<br/>\n&gt;  In my test class, I will be writing test methods for all these functions.<br/>\n&gt; 1. Do I need to write a test method for the second function that is just<br/>\n&gt; doing some initialization. If so, how will I write that ?<br/>\n<br/>\n </span></blockquote>You can test several things in your testcase:<br/>\n<br/>\na) Does the call succeed without throwing an exception? Just calling the<br/>\nmethod in your testcase tells you somehting, without any assertions.<br/>\nCalling it by itself in a seperate test helps you locate the problem if<br/>\nsomething does actually throw an exception.<br/>\n<br/>\nb) Does it set any fields to initial values? Verify that the values are<br/>\ninitialized correctly. For example does isConnected() return false prior<br/>\nto the call the connectURL()?<br/>\n<br/>\nc) Test internal invariants. We define a method called checkInvariants()<br/>\nin each class we test. When called, this method asserts that certain rules<br/>\nabout its private state are valid. In your case, you might have an<br/>\ninvariant that an internal socket reference is null if and only if the URL<br/>\nis not connected. If you can figure out these invariants and add<br/>\nassertions for them, you can call checkInvariants() after the<br/>\ninitialization. It should also be called in every test whenever the class&#39;<br/>\nstate changes. Search these archives for my previous posts on invariants<br/>\nchecking.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; 2. For the first function, I will write a test method as follows<br/>\n&gt; public boolean testConnectURl() {<br/>\n&gt; \tA obj1;<br/>\n&gt; \tboolean  b = obj1.ConnectURL();<br/>\n&gt; \t/// How do I write an assert statement after this ?<br/>\n&gt; }<br/>\n<br/>\n </span></blockquote>As above, just the fact that the call completes tells you something.<br/>\nHowever, there are several assertions you should be able to make, perhaps<br/>\nwith a little refactoring of the class.<br/>\n<br/>\na) Well, assert that b is true.<br/>\n<br/>\nb) Do you have an isConnected() or similar method? It should presumably<br/>\nreturn true after connectURL() is called.<br/>\n<br/>\nb) Does connecting set any other variables as a side effect? e.g. Can you<br/>\nrequest the host of the system connected to?<br/>\n<br/>\nd) This is another place where you should call a checkInvariants() method.<br/>\nThat method would have access to private state of the class, such as the<br/>\nunderlying socket. It could verify that, if the URL is connected, the<br/>\nsocket is valid and also connected.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; I have seen the archive of all the messages but I am not clear on how I<br/>\n&gt; write test classes for event driven programs.<br/>\n<br/>\n&gt;<br/>\n&gt; Thanks<br/>\n&gt;<br/>\n&gt; Sowmya<br/>\n&gt;  -----Original Message-----<br/>\n&gt; From: \tEric Vought [mailto:<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:evought@...\">evought@...</a>]<br/>\n&gt; Sent:\tFriday, November 09, 2001 10:45 PM<br/>\n&gt; To:\t<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a><br/>\n&gt; Subject:\tRe: [junit] Inner Class, Even Driven Classes<br/>\n&gt;<br/>\n&gt; The short answer is that they are usually tested in the same testcase as the<br/>\n&gt; enclosing class. Where the testcase are complex enough for a sepearte<br/>\n&gt; testcase class to make sense, refactoring the inner class to the top level<br/>\n&gt; will also typically make sense. For the long answer, I&#39;ll lay out a few<br/>\n&gt; cases for you and how they are handled in my experience.<br/>\n&gt; If the class is a tightly coupled private utility, like an iterator or an<br/>\n&gt; event adapter, these are typically tested in the test case for the class.<br/>\n&gt; In the case of an event listener, whether the listener is implemented by an<br/>\n&gt; adapter or the class itself is a minor organizational detail. The important<br/>\n&gt; question is whether the event is dispatched correctly. With iterators, they<br/>\n&gt; tend to be very minor in functionality and extremely tightly coupled.<br/>\n&gt; Iterators are therefore more of a special reference or psuedopod of the<br/>\n&gt; class-under-test than a separate entity and are also tested in the same<br/>\n&gt; testcase.<br/>\n&gt; Sometimes, you use an inner class to define an interface that goes along<br/>\n&gt; with it, such as defining static inner  classes to represent listeners for<br/>\n&gt; events which only that class will generate. The example I have in front of<br/>\n&gt; me right now is a class called LogListener.MaskChangeListener. LogListener<br/>\n&gt; accepts logging events from a Logger for dispatch. A particular LogListener,<br/>\n&gt; however, only accepts events of a particular set of priorities (e.g. WARNING<br/>\n&gt; or above). A Logger wishes to avoid instantiating messages that will never<br/>\n&gt; be processed, so it monitors the priority masks of its Listeners. It should<br/>\n&gt; be obvious that MaskChangeListener is very specific to LogListener and<br/>\n&gt; therefore may as well be a part of it.<br/>\n&gt; In these cases, you have a base class or interface which will be implemented<br/>\n&gt; or extended by some other class. The general practice here is to create a<br/>\n&gt; testcase for that base class (using a stub implementation) and then the<br/>\n&gt; testcases for actual implementations can inherit your abstract testcase to<br/>\n&gt; ensure that invariants are maintained. With the inner class situation,<br/>\n&gt; however, most of the eventual implementations will themselves be inner<br/>\n&gt; classes (adapters) and therefore will not be tested as separate entities.<br/>\n&gt; Further, there really aren&#39;t any invariants to be maintained beyond what the<br/>\n&gt; compiler will verify for you- namely, that a method exists with that<br/>\n&gt; signature in the implementing class. So, in this case, too, there isn&#39;t any<br/>\n&gt; special testing to be done.<br/>\n&gt; As your inner class gets more complex- perhaps it is an abstract class with<br/>\n&gt; some fields or concrete code- the case for doing a seperate testcase gets<br/>\n&gt; stronger, but so does the case for refactoring. Even if the inner class<br/>\n&gt; needs access to private state which you don&#39;t wish to expose, the dependency<br/>\n&gt; can probably be reduced through refactoring to the point where you can use<br/>\n&gt; simple listeners and adapters to connect two top-level classes.<br/>\n&gt; The borderline case I sometimes run into is an inner class representing a<br/>\n&gt; souped up type-safe enumeration. The enumeration has methods to produce or<br/>\n&gt; parse a human-readable representation of a value and has some special code<br/>\n&gt; to handle serialization safely. If the enumeration is conceptually coupled<br/>\n&gt; to the enclosing class, it makes sense to leave it as an inner class.  There<br/>\n&gt; is *some* significant functionality to test (mostly looking for simple<br/>\n&gt; typing errors), which is conceptually different from the functionality of<br/>\n&gt; the top-level class and tends to clutter the testcase a little if included.<br/>\n&gt; I could see a case for breaking this out into multiple testcase if there<br/>\n&gt; were a number of similar inner classes in the top-level class. Otherwise, I<br/>\n&gt; still tend to keep all the tests in one container.<br/>\n&gt; On Fri, 9 Nov 2001 <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:sowmya.srinivasan@...\">sowmya.srinivasan@...</a> wrote:<br/>\n&gt; &gt; Hello<br/>\n&gt; &gt; I have just started using JUnit.<br/>\n&gt; &gt; I have a few queries.<br/>\n&gt; &gt;<br/>\n&gt; &gt; 1. How do I handle inner classes ?<br/>\n&gt; &gt; \tIf I have a class A and this has three inner classes A1, A2, A3 ;<br/>\n&gt; &gt; \t\tShould I write separate test classes for each of these inner<br/>\n&gt; &gt; classes ? (Atest, A1test, A2test, A3test)<br/>\n&gt; &gt; \t\tOR should I write just write one test class( TestA) that<br/>\n&gt; &gt; will handle the functions in the inner classes also ?<br/>\n&gt; &gt;<br/>\n&gt; &gt; 2. I am trying to write test classes for an event driven program. How<br/>\n&gt; &gt; feasible is this ?<br/>\n&gt; &gt;<br/>\n&gt; &gt; Thanks<br/>\n&gt; &gt;<br/>\n&gt; &gt; Sowmya<br/>\n&gt; &gt;<br/>\n&gt; &gt; To unsubscribe from this group, send an email to:<br/>\n&gt; &gt; <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit-unsubscribe@yahoogroups.com\">junit-unsubscribe@yahoogroups.com</a><br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt; Your use of Yahoo! Groups is subject to <a rel=\"nofollow\" target=\"_blank\" href=\"http://docs.yahoo.com/info/terms/\">http://docs.yahoo.com/info/terms/</a><br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt;<br/>\n&gt;<br/>\n<br/>\n </span></blockquote>-- <br/>\nEric Vought<br/>\nChief Technical Officer - QLUE Consulting, Inc.<br/>\n<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:evought@...\">evought@...</a> toll-free: 888-771-3538  RTP area: 919-816-9901</div>", 
    "prevInTime": 3283, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1005923739", 
    "canDelete": false, 
    "nextInTopic": 3286, 
    "prevInTopic": 3281, 
    "headers": {
        "inReplyToHeader": "PDQ4ODE1QUYzQ0E1RkQ1MTFBMjVBMDA1MDhCRTE2RUZGMDFGRThGNkZAZm1nLW9wLmlmbGV4c29sdXRpb25zLmNvbT4=", 
        "messageIdInHeader": "PFBpbmUuTE5YLjQuMzAuMDExMTE2MTAwMTI1MC44MjE5LTEwMDAwMEBicmFpbi5xbHVlLWxhbj4="
    }
}