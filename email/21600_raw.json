{
    "numMessagesInTopic": 7, 
    "nextInTime": 21601, 
    "senderId": "S9BJRgTrCLNy2zHsW-lraPdS-UzTyUCv-ZWJWJAUveYCePtN32ns30zYinCx7I3jbibWy1zYCaLelceil26bj9kfRPPJHIx1", 
    "systemMessage": false, 
    "subject": "Re: Non-static inner classes of test classes using enclosing fixtures?", 
    "from": "&quot;Paul Holser&quot; &lt;pholser@...&gt;", 
    "authorName": "Paul Holser", 
    "msgSnippet": "Hi JUnit, Regarding my previous post, about the desire to have non-static inner test classes of a test class instantiated and run with an enclosing instance: I", 
    "msgId": 21600, 
    "rawEmail": "Return-Path: &lt;pholser@...&gt;\r\nX-Sender: pholser@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nX-Received: (qmail 31983 invoked from network); 13 May 2009 20:25:49 -0000\r\nX-Received: from unknown (98.137.34.44)\n  by m8.grp.re1.yahoo.com with QMQP; 13 May 2009 20:25:49 -0000\r\nX-Received: from unknown (HELO n37b.bullet.mail.sp1.yahoo.com) (66.163.168.151)\n  by mta1.grp.sp2.yahoo.com with SMTP; 13 May 2009 20:25:49 -0000\r\nX-Received: from [69.147.65.148] by n37.bullet.mail.sp1.yahoo.com with NNFMP; 13 May 2009 20:25:46 -0000\r\nX-Received: from [98.137.34.35] by t11.bullet.mail.sp1.yahoo.com with NNFMP; 13 May 2009 20:25:46 -0000\r\nDate: Wed, 13 May 2009 20:25:45 -0000\r\nTo: junit@yahoogroups.com\r\nMessage-ID: &lt;gufac9+abt1@...&gt;\r\nIn-Reply-To: &lt;4f7da6b90905110806q14c881e3vb7e1defea8cc0c62@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=&quot;ISO-8859-1&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\nX-Mailer: Yahoo Groups Message Poster\r\nX-Yahoo-Newman-Property: groups-compose\r\nX-eGroups-Msg-Info: 1:6:0:0:0\r\nFrom: &quot;Paul Holser&quot; &lt;pholser@...&gt;\r\nSubject: Re: Non-static inner classes of test classes using enclosing fixtures?\r\nX-Yahoo-Group-Post: member; u=66805313; y=sLzIGzvo-NsgVAyGclh5KePDqfL6patasuElZpQ4Sh-YnQ\r\nX-Yahoo-Profile: pholser\r\n\r\nHi JUnit,\n\nRegarding my previous post, about the desire to have non-static =\r\ninner\ntest classes of a test class instantiated and run with an enclosing\ni=\r\nnstance: I found a solution that seems workable. I used JUnit 4.5. It\ninvol=\r\nves the following:\n\n-- Mark the enclosing (abstract) class as @RunWith(AllT=\r\nests.class)\n-- Have the concrete implementing class declare a suite() metho=\r\nd which:\n     -- Instantiates the concrete\n     -- Instantiates each of the=\r\n desired inner classes with the concrete\nas their enclosing instance\n     -=\r\n- Wraps the concrete and each of the inners in a\nJUnit4TestInstanceAdapter =\r\n(which I created)\n     -- Adds all the adapted test instances to the suite\n=\r\n     -- Returns the suite.\n\nI ended up creating a JUnit4TestInstanceAdapter=\r\n which hangs onto an\nObject test instance, and uses a BlockJUnit4InstanceRu=\r\nnner (again, my\nclass) whose createTest() just gives the test instance alre=\r\nady created\nand whose collectInitializationErrors() validates @BeforeClass,=\r\n\n@AfterClass, and the instance methods (@Test, @Before, @After). I also\nend=\r\ned up creating a JUnit4TestInstanceAdapterCache (basically a clone of\nJUnit=\r\n4TestAdapterCache) and a JUnit4TestInstanceFacade.\n\nNote that I am not crea=\r\nting new instances of the test class and running\nits befores + test + after=\r\ns for each -- I really didn&#39;t need that level\nof isolation, so I was willin=\r\ng to exchange that isolation for finer\ncontrol of the inner class instantia=\r\ntion.\n\nSo, I was able to leverage existing JUnit extension points to accomp=\r\nlish\nmy goal. I wonder if this would be useful functionality for JUnit to\nh=\r\nave in general: when a test class is detected, and that test class has\nnon-=\r\nstatic inner classes which may themselves be test classes, when\nbuilding up=\r\n tests for the enclosing class, also instantiate the inner\ntest classes and=\r\n attach to the (an?) enclosing test class instance. I\nsaw some previous dis=\r\ncussion about such fixtures in JDave.\n\nWhat do you think? Some code from my=\r\n solution is below.\n\nThanks,\nPaul Holser\n\n\n=3D=3D=3D=3D=3D=3D\n\npublic abstr=\r\nact class UnmodifiableCollectionTestSupport&lt;T&gt; {\n     protected Collection&lt;=\r\nT&gt; items;\n     private T containedItem;\n\n     @Before\n     public final voi=\r\nd initializeHarness() {\n         this.items =3D newCollection();\n         t=\r\nhis.containedItem =3D containedItem();\n         // ...\n     }\n\n     @Test(e=\r\nxpected =3D UnsupportedOperationException.class) {\n     public final void\ns=\r\nhouldPreventOperationThatWouldModifyTheCollection() {\n         // ...\n     =\r\n}\n\n     // tests...\n\n     protected abstract Collection&lt;T&gt; newCollection();=\r\n\n\n     protected abstract T newItem();\n\n     protected abstract T contained=\r\nItem();\n}\n\npublic abstract class UnmodifiableListTestSupport&lt;T&gt; extends\nUnm=\r\nodifiableCollectionTestSupport&lt;T&gt; {\n     // ...\n}\n\n@RunWith(AllTests.class)=\r\n\npublic abstract class UnmodifiableMapTestSupport&lt;K, V&gt; {\n     private Map&lt;=\r\nK, V&gt; entries;\n     private K containedKey;\n     private V containedValue;\n=\r\n\n     @Before\n     public final void initializeHarness() {\n         this.en=\r\ntries =3D newMap();\n         this.containedKey =3D containedKey();\n        =\r\n this.containedValue =3D containedValue();\n         // ...\n     }\n\n     @Te=\r\nst(expected =3D UnsupportedOperationException.class) {\n     public final vo=\r\nid shouldPreventOperationThatWouldModifyTheMap() {\n         // ...\n     }\n\n=\r\n     // tests...\n\n     protected abstract Map&lt;K, V&gt; newMap();\n\n     protect=\r\ned abstract K newKey();\n\n     protected abstract K containedKey();\n\n     pr=\r\notected abstract V containedValue();\n\n     protected static junit.framework=\r\n.Test\nbuildUnmodifiableMapSuite(UnmodifiableMapTestSupport&lt;?, ?&gt; test) {\n  =\r\n       TestSuite suite =3D new TestSuite();\n         suite.addTest(new JUni=\r\nt4TestInstanceAdapter(test));\n         suite.addTest(new JUnit4TestInstance=\r\nAdapter(test.new\nKeySetTest()));\n         suite.addTest(new JUnit4TestInsta=\r\nnceAdapter(test.new\nValuesTest()));\n         suite.addTest(new JUnit4TestIn=\r\nstanceAdapter(test.new\nEntriesTest()));\n         return suite;\n     }\n\n    =\r\n class KeySetTest extends UnmodifiableCollectionTestSupport&lt;K&gt; {\n         @=\r\nOverride protected K containedItem() {\n             return containedKey;\n  =\r\n       }\n\n         @Override protected Collection&lt;K&gt; newCollection() {\n    =\r\n         return entries.keySet();\n         }\n\n         @Override protected =\r\nK newItem() {\n             return newKey();\n         }\n     }\n\n     class V=\r\naluesTest extends UnmodifiableCollectionTestSupport&lt;V&gt; {\n         @Override=\r\n protected V containedItem() {\n             return containedValue;\n        =\r\n }\n\n         @Override protected Collection&lt;V&gt; newCollection() {\n          =\r\n   return entries.values();\n         }\n\n         @Override protected V newI=\r\ntem() {\n             return null;\n         }\n     }\n\n     class EntriesTest=\r\n extends\nUnmodifiableCollectionTestSupport&lt;Map.Entry&lt;K, V&gt;&gt; {\n         @Ove=\r\nrride protected Entry&lt;K, V&gt; containedItem() {\n             return /* new Ma=\r\np.Entry impl whose key is containedKey and\nwhose value is containedValue */=\r\n;\n         }\n\n         @Override protected Collection&lt;Entry&lt;K, V&gt;&gt; newColle=\r\nction() {\n             return entries.entrySet();\n         }\n\n         @Ove=\r\nrride protected Entry&lt;K, V&gt; newItem() {\n             return null;\n         =\r\n}\n     }\n}\n\n// sample implementor\npublic class UnmodifiableMapTest extends\n=\r\nUnmodifiableMapTestSupport&lt;String, String&gt; {\n     public static junit.frame=\r\nwork.Test suite() {\n         return UnmodifiableMapTestSupport.buildUnmodif=\r\niableMapSuite(new\nUnmodifiableMapTest());\n     }\n\n     @Override protected =\r\nString containedKey() {\n         return &quot;foo&quot;;\n     }\n\n     @Override prote=\r\ncted String containedValue() {\n         return &quot;value&quot;;\n     }\n\n     @Overr=\r\nide protected String newKey() {\n         return &quot;bar&quot;;\n     }\n\n     @Overri=\r\nde protected Map&lt;String, String&gt; newMap() {\n         return\nCollections.unm=\r\nodifiableMap(Collections.singletonMap(&quot;foo&quot;, &quot;value&quot;));\n     }\n}\n\n--- In ju=\r\nnit@yahoogroups.com, David Saff &lt;david@...&gt; wrote:\n&gt;\n&gt; Paul,\n&gt;\n&gt; Have you l=\r\nooked at Theory support in JUnit &gt; 4.4?  It may not give you\n&gt; everything y=\r\nou want, but I&#39;d be curious to know how close it gets.\n&gt; Thanks,\n&gt;\n&gt;    Dav=\r\nid\n&gt;\n&gt; On Sat, May 9, 2009 at 1:37 PM, Paul Holser pholser@... wrote:\n&gt; &gt; H=\r\nello JUnit,\n&gt; &gt;\n&gt; &gt; I have some abstract classes that enable a caller to ch=\r\neck that\nclasses which expose collection fields via accessor methods do so =\r\nvia\nthe java.util.Collections#unmodifiable___() facilities.  Here are some\n=\r\nsnippets:\n&gt; &gt;\n&gt; &gt; public abstract class UnmodifiableCollectionTestSupport&lt;T=\r\n&gt; {\n&gt; &gt;    protected Collection&lt;T&gt; items;\n&gt; &gt;    private T containedItem;\n&gt;=\r\n &gt;\n&gt; &gt;    @Before\n&gt; &gt;    public final void initializeHarness() {\n&gt; &gt;       =\r\n this.items =3D newCollection();\n&gt; &gt;        this.containedItem =3D containe=\r\ndItem();\n&gt; &gt;\n&gt; &gt;        assertFalse(&quot;need a non-empty collection&quot;, items.is=\r\nEmpty());\n&gt; &gt;        assertTrue(&quot;need an item that is in the collection&quot;,\ni=\r\ntems.contains(containedItem));\n&gt; &gt;    }\n&gt; &gt;\n&gt; &gt;    @Test(expected =3D Unsup=\r\nportedOperationException.class)\n&gt; &gt;    public final void shouldPreventAdd()=\r\n {\n&gt; &gt;        // ...\n&gt; &gt;    }\n&gt; &gt;\n&gt; &gt;    // etc...\n&gt; &gt;\n&gt; &gt;    protected abs=\r\ntract Collection&lt;T&gt; newCollection();\n&gt; &gt;\n&gt; &gt;    protected abstract T newIte=\r\nm();\n&gt; &gt;\n&gt; &gt;    protected abstract T containedItem();\n&gt; &gt; }\n&gt; &gt;\n&gt; &gt; public =\r\nabstract class UnmodifiableListTestSupport&lt;T&gt; extends\nUnmodifiableCollectio=\r\nnTestSupport&lt;T&gt; {\n&gt; &gt;    @Test(expected =3D UnsupportedOperationException.c=\r\nlass)\n&gt; &gt;    public final void shouldPreventAddAtIndex() {\n&gt; &gt;        // ..=\r\n.\n&gt; &gt;    }\n&gt; &gt;\n&gt; &gt;    // etc...\n&gt; &gt;\n&gt; &gt;    protected final Collection&lt;T&gt; ne=\r\nwCollection() {\n&gt; &gt;        return newList();\n&gt; &gt;    }\n&gt; &gt;\n&gt; &gt;    protected =\r\nabstract List&lt;T&gt; newList();\n&gt; &gt;\n&gt; &gt;    private List&lt;T&gt; list() {\n&gt; &gt;        =\r\nreturn (List&lt;T&gt;) items;\n&gt; &gt;    }\n&gt; &gt; }\n&gt; &gt;\n&gt; &gt; public class UnmodifiableLis=\r\ntTest extends\nUnmodifiableListTestSupport&lt;String&gt; {\n&gt; &gt;    @Override\n&gt; &gt;   =\r\n protected List&lt;String&gt; newList() {\n&gt; &gt;        return unmodifiableList(asLi=\r\nst(&quot;foo&quot;));\n&gt; &gt;    }\n&gt; &gt;\n&gt; &gt;    protected String newItem() {\n&gt; &gt;        ret=\r\nurn &quot;bar&quot;;\n&gt; &gt;    }\n&gt; &gt;\n&gt; &gt;    protected String containedItem() {\n&gt; &gt;      =\r\n  return &quot;foo&quot;;\n&gt; &gt;    }\n&gt; &gt; }\n&gt; &gt;\n&gt; &gt; I am imagining an UnmodifiableMapTes=\r\ntSupport abstract class to do\nsimilar tests for unmodifiable maps:\n&gt; &gt;\n&gt; &gt; =\r\npublic abstract class UnmodifiableMapTestSupport&lt;K, V&gt; {\n&gt; &gt;    private Map=\r\n&lt;K, V&gt; entries;\n&gt; &gt;    private K containedKey;\n&gt; &gt;    private V containedVa=\r\nlue;\n&gt; &gt;\n&gt; &gt;    @Before\n&gt; &gt;    public final void initializeHarness() {\n&gt; &gt; =\r\n       this.entries =3D newMap();\n&gt; &gt;        this.containedKey =3D containe=\r\ndKey();\n&gt; &gt;        this.containedValue =3D containedValue();\n&gt; &gt;\n&gt; &gt;       =\r\n assertFalse(&quot;need a non-empty map&quot;, entries.isEmpty());\n&gt; &gt;        assertT=\r\nrue(&quot;need a key that is in the map&quot;,\nentries.containsKey(containedKey));\n&gt; =\r\n&gt;        assertTrue(&quot;need a value that is in the map&quot;,\nentries.containsValu=\r\ne(containedValue));\n&gt; &gt;    }\n&gt; &gt;\n&gt; &gt;    @Test(expected =3D UnsupportedOpera=\r\ntionException.class)\n&gt; &gt;    public final void shouldPreventPut() {\n&gt; &gt;     =\r\n   // ...\n&gt; &gt;    }\n&gt; &gt;\n&gt; &gt;    protected abstract Map&lt;K, V&gt; newMap();\n&gt; &gt;\n&gt; =\r\n&gt;    protected abstract K newKey();\n&gt; &gt;\n&gt; &gt;    protected abstract K contain=\r\nedKey();\n&gt; &gt;\n&gt; &gt;    protected abstract V containedValue();\n&gt; &gt; }\n&gt; &gt;\n&gt; &gt; No=\r\nt just would I like to test that a map cannot be modified via its\nMap metho=\r\nds, but also I would like to test that the map cannot be\nmutated via the ke=\r\nySet(), values(), and entrySet() views.  It would be\nreally nice if, when s=\r\nomeone subclasses UnmodifiableMapTestSupport, they\ncould get an Un modifiab=\r\nleCollectionTestSupport&lt;K&gt;,\nUnmodifiableCollectionTestSupport&lt;V&gt;, and an\nUn=\r\nmodifiableCollectionTestSupport&lt;Map.Entry&lt;K, V&gt;&gt; instantiated, run,\nand res=\r\nult reported on for the keySet(), values(), and entrySet() views\nof the new=\r\nMap() result.  Otherwise, they would have to hand-roll three\nmore concretes=\r\n of UnmodifiableCollectionTestSupport for testing the\nkeySet(), values(), a=\r\nnd entrySet() views of a given map.\n\n\n\n\n", 
    "profile": "pholser", 
    "topicId": 21578, 
    "spamInfo": {
        "reason": "6", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 66805313, 
    "prevInTime": 21599, 
    "contentTrasformed": false, 
    "postDate": "1242246345", 
    "canDelete": false, 
    "nextInTopic": 21607, 
    "prevInTopic": 21587, 
    "headers": {
        "inReplyToHeader": "PDRmN2RhNmI5MDkwNTExMDgwNnExNGM4ODFlM3ZiN2UxZGVmZWE4Y2MwYzYyQG1haWwuZ21haWwuY29tPg==", 
        "messageIdInHeader": "PGd1ZmFjOSthYnQxQGVHcm91cHMuY29tPg=="
    }
}