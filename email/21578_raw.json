{
    "numMessagesInTopic": 7, 
    "nextInTime": 21579, 
    "senderId": "bY2KNnBvkb9HzgawFfcUAW-zymmN2l2mkLq_yObuV_FH0T7pVw_Ek9uVXsPSw8Ioul1Pk0XfczU4Wmt_CKXzCjCNIt_QIz5k", 
    "systemMessage": false, 
    "subject": "Non-static inner classes of test classes using enclosing fixtures?", 
    "from": "&quot;Paul Holser&quot; &lt;pholser@...&gt;", 
    "authorName": "Paul Holser", 
    "msgSnippet": "Hello JUnit, I have some abstract classes that enable a caller to check that classes which expose collection fields via accessor methods do so via the", 
    "msgId": 21578, 
    "rawEmail": "Return-Path: &lt;pholser@...&gt;\r\nX-Sender: pholser@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nX-Received: (qmail 30532 invoked from network); 9 May 2009 17:38:13 -0000\r\nX-Received: from unknown (69.147.108.201)\n  by m5.grp.sp2.yahoo.com with QMQP; 9 May 2009 17:38:13 -0000\r\nX-Received: from unknown (HELO n39b.bullet.mail.sp1.yahoo.com) (66.163.168.153)\n  by mta2.grp.re1.yahoo.com with SMTP; 9 May 2009 17:38:13 -0000\r\nX-Received: from [69.147.65.174] by n39.bullet.mail.sp1.yahoo.com with NNFMP; 09 May 2009 17:37:59 -0000\r\nX-Received: from [98.137.34.34] by t12.bullet.mail.sp1.yahoo.com with NNFMP; 09 May 2009 17:37:59 -0000\r\nDate: Sat, 09 May 2009 17:37:58 -0000\r\nTo: junit@yahoogroups.com\r\nMessage-ID: &lt;gu4f1m+kbpf@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=&quot;ISO-8859-1&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\nX-Mailer: Yahoo Groups Message Poster\r\nX-Yahoo-Newman-Property: groups-compose\r\nX-eGroups-Msg-Info: 1:6:0:0:0\r\nFrom: &quot;Paul Holser&quot; &lt;pholser@...&gt;\r\nSubject: Non-static inner classes of test classes using enclosing fixtures?\r\nX-Yahoo-Group-Post: member; u=66805313; y=m579K28TlYk2WvDrMDiD-v_oFmIJfaBO6EItX8TNsNkSKg\r\nX-Yahoo-Profile: pholser\r\n\r\nHello JUnit,\n\nI have some abstract classes that enable a caller to check th=\r\nat classes which expose collection fields via accessor methods do so via th=\r\ne java.util.Collections#unmodifiable___() facilities.  Here are some snippe=\r\nts:\n\npublic abstract class UnmodifiableCollectionTestSupport&lt;T&gt; {\n    prote=\r\ncted Collection&lt;T&gt; items;\n    private T containedItem;\n\n    @Before\n    pub=\r\nlic final void initializeHarness() {\n        this.items =3D newCollection()=\r\n;\n        this.containedItem =3D containedItem();\n\n        assertFalse(&quot;nee=\r\nd a non-empty collection&quot;, items.isEmpty());\n        assertTrue(&quot;need an it=\r\nem that is in the collection&quot;, items.contains(containedItem));\n    }\n\n    @=\r\nTest(expected =3D UnsupportedOperationException.class)\n    public final voi=\r\nd shouldPreventAdd() {\n        // ...\n    }\n\n    // etc...\n\n    protected a=\r\nbstract Collection&lt;T&gt; newCollection();\n\n    protected abstract T newItem();=\r\n\n\n    protected abstract T containedItem();\n}\n\npublic abstract class Unmodi=\r\nfiableListTestSupport&lt;T&gt; extends UnmodifiableCollectionTestSupport&lt;T&gt; {\n   =\r\n @Test(expected =3D UnsupportedOperationException.class)\n    public final v=\r\noid shouldPreventAddAtIndex() {\n        // ...\n    }\n\n    // etc...\n\n    pr=\r\notected final Collection&lt;T&gt; newCollection() {\n        return newList();\n   =\r\n }\n\n    protected abstract List&lt;T&gt; newList();\n\n    private List&lt;T&gt; list() {=\r\n\n        return (List&lt;T&gt;) items;\n    }\n}\n\npublic class UnmodifiableListTest=\r\n extends UnmodifiableListTestSupport&lt;String&gt; {\n    @Override\n    protected =\r\nList&lt;String&gt; newList() {\n        return unmodifiableList(asList(&quot;foo&quot;));\n  =\r\n  }\n\n    protected String newItem() {\n        return &quot;bar&quot;;\n    }\n\n    prot=\r\nected String containedItem() {\n        return &quot;foo&quot;;\n    }\n}\n\nI am imaginin=\r\ng an UnmodifiableMapTestSupport abstract class to do similar tests for unmo=\r\ndifiable maps:\n\npublic abstract class UnmodifiableMapTestSupport&lt;K, V&gt; {\n  =\r\n  private Map&lt;K, V&gt; entries;\n    private K containedKey;\n    private V cont=\r\nainedValue;\n\n    @Before\n    public final void initializeHarness() {\n      =\r\n  this.entries =3D newMap();\n        this.containedKey =3D containedKey();\n=\r\n        this.containedValue =3D containedValue();\n\n        assertFalse(&quot;nee=\r\nd a non-empty map&quot;, entries.isEmpty());\n        assertTrue(&quot;need a key that=\r\n is in the map&quot;, entries.containsKey(containedKey));\n        assertTrue(&quot;ne=\r\ned a value that is in the map&quot;, entries.containsValue(containedValue));\n   =\r\n }\n\n    @Test(expected =3D UnsupportedOperationException.class)\n    public =\r\nfinal void shouldPreventPut() {\n        // ...\n    }\n\n    protected abstrac=\r\nt Map&lt;K, V&gt; newMap();\n\n    protected abstract K newKey();\n\n    protected ab=\r\nstract K containedKey();\n\n    protected abstract V containedValue();\n}\n\nNot=\r\n just would I like to test that a map cannot be modified via its Map method=\r\ns, but also I would like to test that the map cannot be mutated via the key=\r\nSet(), values(), and entrySet() views.  It would be really nice if, when so=\r\nmeone subclasses UnmodifiableMapTestSupport, they could get an Un modifiabl=\r\neCollectionTestSupport&lt;K&gt;, UnmodifiableCollectionTestSupport&lt;V&gt;, and an Unm=\r\nodifiableCollectionTestSupport&lt;Map.Entry&lt;K, V&gt;&gt; instantiated, run, and resu=\r\nlt reported on for the keySet(), values(), and entrySet() views of the newM=\r\nap() result.  Otherwise, they would have to hand-roll three more concretes =\r\nof UnmodifiableCollectionTestSupport for testing the keySet(), values(), an=\r\nd entrySet() views of a given map.\n\nIt occurred to me that inner classes of=\r\n UnmodifiableMapTestSupport would be handy:\n\npublic abstract class Unmodifi=\r\nableMapTestSupport&lt;K, V&gt; {\n    // ...\n\n    @Ignore\n    class KeySetTest ext=\r\nends UnmodifiableCollectionTestSupport&lt;K&gt; {\n        protected K containedIt=\r\nem() {\n            return containedKey;\n        }\n\n        protected Collec=\r\ntion&lt;K&gt; newCollection() {\n            return entries.keySet();\n        }\n\n =\r\n       protected K newItem() {\n            return newKey();\n        }\n    }=\r\n\n\n    @Ignore\n    class ValuesTest extends UnmodifiableCollectionTestSuppor=\r\nt&lt;V&gt; {\n        protected V containedItem() {\n            return containedVa=\r\nlue;\n        }\n\n        protected Collection&lt;V&gt; newCollection() {\n         =\r\n   return entries.values();\n        }\n\n        protected V newItem() {\n    =\r\n        return null;\n        }\n    }\n\n    @Ignore\n    class EntriesTest ext=\r\nends UnmodifiableCollectionTestSupport&lt;Map.Entry&lt;K, V&gt;&gt; {\n        protected=\r\n Entry&lt;K, V&gt; containedItem() {\n            return new Map.Entry&lt;K, V&gt;() {\n =\r\n               public K getKey() {\n                    return containedKey;=\r\n\n                }\n\n                public V getValue() {\n                 =\r\n   return containedValue;\n                }\n\n                public V setVa=\r\nlue(V value) {\n                    throw new UnsupportedOperationException(=\r\n);\n                }\n\n                public boolean equals(Object that) {\n=\r\n                    if (!(that instanceof Map.Entry&lt;?, ?&gt;))\n               =\r\n         return false;\n\n                    Map.Entry&lt;?, ?&gt; other =3D (Map.=\r\nEntry) that;\n                    return ObjectUtils.equals(getKey(), other.=\r\ngetKey())\n                        && ObjectUtils.equals(getValue(), other.g=\r\netValue());\n                }\n\n                public int hashCode() {\n    =\r\n                return ObjectUtils.hashCode(getKey()) ^ ObjectUtils.hashCod=\r\ne(getValue());\n                }\n            };\n        }\n\n        protecte=\r\nd Collection&lt;Entry&lt;K, V&gt;&gt; newCollection() {\n            return entries.entr=\r\nySet();\n        }\n\n        protected Entry&lt;K, V&gt; newItem() {\n            re=\r\nturn null;\n        }\n    }\n}\n\nThe inner classes are not static, and are @Ig=\r\nnore&#39;d so that the runner doesn&#39;t report instantiation problems (non-static=\r\n inner classes don&#39;t get a zero-arg ctor, which the default runner requires=\r\n).  I could have, say, runAll() methods on each of these inner classes, and=\r\n then have @Test methods on UnmodifiableMapTestSupport that instantiate one=\r\n of the inner classes and call any @Befores followed by runAll() followed b=\r\ny any @After on them.  But then, runAll() would have to be smart enough to =\r\nrun all the tests, including not bailing out at the first UnsupportedOperat=\r\nionException.  Also, the results of running those tests would not get repor=\r\nted along with the @Test methods of UnmodifiableMapTestSupport.\n\nIs there a=\r\n cleaner way to accomplish my goal?  Maybe using a special kind of Runner? =\r\n Am I missing a more obvious solution?\n\nThanks much.\n\nPaul Holser\n\n\n\n", 
    "profile": "pholser", 
    "topicId": 21578, 
    "spamInfo": {
        "reason": "6", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 66805313, 
    "prevInTime": 21577, 
    "contentTrasformed": false, 
    "postDate": "1241890678", 
    "canDelete": false, 
    "nextInTopic": 21585, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PGd1NGYxbStrYnBmQGVHcm91cHMuY29tPg=="
    }
}