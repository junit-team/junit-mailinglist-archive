{
    "numMessagesInTopic": 67, 
    "nextInTime": 5260, 
    "senderId": "leTcStOACzxwcPy_WLGUvICiIdnvsZvdNiHXRiHaejl3ZI8aTu4vSavkWKtmNvXn8mvwjVRKUwR9y7GjqpyHqSeAJCJ7cSVAndtbBu9H", 
    "systemMessage": false, 
    "subject": "RE: [junit] Re: distinguishing between failures and errors", 
    "from": "Mark Meyers &lt;markm@...&gt;", 
    "authorName": "Mark Meyers", 
    "msgSnippet": "... I disagree, how about: try{ instance.someMethod(null); fail( someMethod should not accept null ); }catch(IllegalArgumentException e){ assertTrue( Client", 
    "msgId": 5259, 
    "topicId": 5186, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 61568997, 
    "messageBody": "<div id=\"ygrps-yiv-330507038\"><blockquote><span title=\"ireply\">&gt; -----Original Message-----<br/>\n&gt; From: Daniel Barclay  <br/>\n&gt; <br/>\n&gt; <br/>\n </span></blockquote>...<br/>\n<blockquote><span title=\"ireply\"> &gt; <br/>\n&gt; Because tests aren&#39;t specifications. <br/>\n&gt; <br/>\n&gt; (How can a test show that the caller is responsible for not <br/>\n&gt; passing in a null pointer?<br/>\n&gt; <br/>\n<br/>\n </span></blockquote>I disagree, how about:<br/>\n\ttry{<br/>\n\t    instance.someMethod(null);<br/>\n\t    fail(&quot;someMethod should not accept null&quot;);<br/>\n\t}catch(IllegalArgumentException e){<br/>\n\t    assertTrue(&quot;Client code should check for null arguments&quot;);<br/>\n\t}<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; You can&#39;t test for any particular behavior from the callee<br/>\n&gt; if the callee&#39;s behavior in the face of a null pointer is <br/>\n&gt; intentially left undefined (e.g., for flexibility in <br/>\n&gt; implementing an interface).)<br/>\n&gt; <br/>\n<br/>\n </span></blockquote>The callee is the class being tested, the specifics for different<br/>\nimplementations could be implemented<br/>\nin specific TestCases, inheriting from an abstract super class (that would<br/>\nbe the class coresponding to the interface).<br/>\nIf the point of the interface is to offer different implementations<br/>\n(Strategy, performance) - in the sense of Map and HashMap/TreeMap - the<br/>\nbehavior in case of <br/>\na null value should be similar.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; (How can a test show that a caller is responsible for not<br/>\n&gt; depending on certain current behavior of an implementation<br/>\n&gt; that is not part of the interface contract?)<br/>\n&gt; <br/>\n<br/>\n </span></blockquote>It can&#39;t, the caller&#39;s TestCase should do that. And possibly the callee&#39;s<br/>\ndocumentation.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; <br/>\n&gt; Because tests are code.  <br/>\n&gt; <br/>\n&gt; (They have syntactic clutter that is necessary for use as tests <br/>\n&gt; but which is just clutter relative to the information useful to a <br/>\n&gt; client programmer.)<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; Because tests, being code, can&#39;t relate code to external concepts.  <br/>\n&gt; <br/>\n&gt; (A specification can say that a function f returns the mathematical<br/>\n&gt; sum of two given integers subject to the limitations of 32-bit<br/>\n&gt; signed binary arithmetic.  How can a test say something like that?)<br/>\n&gt; <br/>\n<br/>\n </span></blockquote>\ttry{<br/>\n\t    int result = instance.f(Integer.MAX_VALUE, Integer.MAX_VALUE);<br/>\n\t    fail(&quot;f should throw Exception when integer limits are met&quot;);<br/>\n\t}catch(IllegalStateException e){<br/>\n\t    assertTrue(&quot;function f returns the mathematical sum of two given<br/>\nintegers subject to the limitations of 32-bit&quot;);<br/>\n\t}<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; <br/>\n&gt; Tests are great, but don&#39;t forget the documentation.<br/>\n&gt; <br/>\n<br/>\n </span></blockquote>AND they are great documentation. Ever tried to compile *.doc with the<br/>\nsource code to detect anomalies<br/>\nin your documentation ?<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; <br/>\n&gt; It seems that some people who write tests waste one advantage of it:  <br/>\n&gt; <br/>\n&gt; I agree that testing, especially writing tests even before <br/>\n&gt; you implement, <br/>\n&gt; is good because it forces you to think about what your code <br/>\n&gt; is supposed <br/>\n&gt; to do and how it&#39;s supposed to be used.  <br/>\n&gt; <br/>\n&gt; Well, if you&#39;re already thinking about the contract, then that&#39;s a<br/>\n&gt; good time to document the contract.  <br/>\n&gt; <br/>\n&gt; <br/>\n&gt; Yes, I know this has to be modulated by what kind of code we&#39;re<br/>\n&gt; talking about (e.g., intra-program calls versus trans-API calls) <br/>\n&gt; and by how stable the interface contract is.  I just wouldn&#39;t<br/>\n&gt; want to have to read test cases instead of Javadoc to figure <br/>\n&gt; out how, say, Sun&#39;s Servlet API worked and was supposed to be <br/>\n&gt; used. <br/>\n&gt; <br/>\n<br/>\n </span></blockquote>Agreed, but it would be nice to have some coding examples too. <br/>\nFor example setting/retrieving JNDI value in it&#39;s simplest form, then you<br/>\ncould <br/>\neasily test a JNDI setup/configuration.<br/>\n<br/>\n<blockquote><span title=\"qreply\"> &gt; <br/>\n&gt; <br/>\n&gt; Daniel<br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 5258, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1025092440", 
    "canDelete": false, 
    "nextInTopic": 5260, 
    "prevInTopic": 5258, 
    "headers": {
        "messageIdInHeader": "PEM0NTBEOTY2NjRDQkQzMTE4MkI2MDBBMEM5NzY2OEIxNjQ4MEIyQENBU0UwNTI+"
    }
}