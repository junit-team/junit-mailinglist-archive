{
    "numMessagesInTopic": 10, 
    "nextInTime": 2738, 
    "senderId": "ehtiEe9vY8FIcJOXjEpg81n8sma3j_X8wSpXUz3Jr28bApwFIIvcbobQty1KtUihYYeJZ_3kUmEDg4Ob42vyBrAT_y8E", 
    "systemMessage": false, 
    "subject": "Re: [junit] Multithreaded code", 
    "from": "Eric Vought &lt;evought@...&gt;", 
    "authorName": "Eric Vought", 
    "msgSnippet": "Well, some points: 1) I don t see where you release the lock in the getsLockAfterwards thread. This can cause your test to fail if you have more than one ", 
    "msgId": 2737, 
    "topicId": 2726, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 0, 
    "messageBody": "<div id=\"ygrps-yiv-1720640211\">Well, some points:<br/>\n<br/>\n1) I don&#39;t see where you release the lock in the getsLockAfterwards<br/>\nthread. This can cause your test to fail if you have more than one<br/>\ntestcase in that test class.<br/>\n<br/>\n2) Along similar lines, you should initialize your LockManager in setUp()<br/>\nto ensure that it is recreated before each test. That way, if a test fails<br/>\nand leaves the LockManager in a bad state, you other tests will still<br/>\nprobably run.<br/>\n<br/>\n3) I think you can make it a bit more robust like so:<br/>\n<br/>\n     public void testBlocks() {<br/>\n         final int recordNo = 1;<br/>\n\t final Object syncObject = new Object();<br/>\n         Runnable getsLockFirst = new Runnable() {<br/>\n             public void run() {<br/>\n\t\t synchronized (syncObject) {<br/>\n                     int recordKey = lockManager.obtainLock(recordNo);<br/>\n\t\t     syncObject.notify();<br/>\n                     try {<br/>\n\t\t         wait(syncObject);<br/>\n                     } catch (InterruptedException e) {}<br/>\n                     lockManager.releaseLock(recordNo, recordKey);<br/>\n                 }<br/>\n             } // run()<br/>\n         }; // Runnable<br/>\n<br/>\n         Thread getLockThread = new Thread(getsLockFirst);<br/>\n<br/>\n\t synchronized (syncObject)<br/>\n\t {<br/>\n         \tgetLockThread.start();<br/>\n\t\ttry {<br/>\n\t \t    wait(syncObject);<br/>\n\t\t} catch InterruptedException(e) {}<br/>\n<br/>\n                assert(lockManager.isRecordLocked(recordNo));<br/>\n\t        syncObject.notify();<br/>\n         }<br/>\n<br/>\n         // wait for thread to finish before returning<br/>\n         try {<br/>\n             getLockThread.join(300);<br/>\n         } catch (InterruptedException e) {}<br/>\n<br/>\n\t // If it is stuck, unstuck it<br/>\n\t If (getLockThread.isAlive())<br/>\n\t {<br/>\n\t     getLockThread.interrupt();<br/>\n\t     fail(&quot;Thread never released lock.&quot;);<br/>\n\t } else {<br/>\n\t    assert(!(lockManager.isRecordLocked(recordNo)));<br/>\n         }<br/>\n    }<br/>\n<br/>\nI haven&#39;t compiled or run this, and it may not be perfect, but there are<br/>\nseveral things to note:<br/>\n<br/>\n1) There&#39;s only one extra thread to worry about.<br/>\n<br/>\n2) You have several control points where you know your thread and the<br/>\ntestcase code are in sync. Your first assert won&#39;t be run until the record<br/>\nlock has been obtained and your thread waits to make sure the testcode has<br/>\nhad a chance to verify that fact. The test method already has a lock on<br/>\nthe synchronization object before the subordinate thread even starts<br/>\nexecuting, so there can be no issue of timing no matter what the platform<br/>\ndoes. The wait() statements release their lock and queue themselves for<br/>\nnotification atomically, providing a smooth transfer of control with no<br/>\npossible timing issues. The test code is bludgeoned into behaving in a<br/>\npredictable, linear manner.<br/>\n<br/>\n3) A join() with a timeout replaces the sleep. This will wait for your<br/>\nchild thread to die before returning, but, if things appear stuck, you get<br/>\nthe option of interrupting the thread. Unlike sleep(), join() will return<br/>\nas quickly as it can.<br/>\n<br/>\n4) Since there are no sleeps anywhere here, your test code should execute<br/>\nas quickly as possible. Otherwise, as you add testcases, the arbitrary<br/>\nlengths of time will begin adding up and you will be tempted to not run<br/>\nthe regression tests as often as you should.<br/>\n<br/>\nTesting threaded code like this is always a royal pain because you<br/>\nspend at least as much time debugging your test code as the code under<br/>\ntest. In this case, you are testing a very simple feature, but the test<br/>\ncode is fairly complex.<br/>\n<br/>\nIn general, though, you should put a lot of effort into factoring out all<br/>\nof your thread synchronization code into centralized, independently<br/>\ntested, reusable code and/or depend on library routines wherever you can.<br/>\nKeep as much of your application as linear as possible so you have to<br/>\nwrite as few of these testcases as possible.<br/>\n<br/>\n<blockquote><span title=\"qreply\"> On Mon, 24 Sep 2001, Emily Bache wrote:<br/>\n<br/>\n&gt; I am also a little unsure of how to test multithreaded code, and I hope my<br/>\n&gt; question is a bit more specific than the last one :-)<br/>\n&gt;<br/>\n&gt; I wrote this test case to test my multithreaded code, and it appears to work<br/>\n&gt; on my platform. (Windows NT, jdk 1.2.2) I am just worried that it only<br/>\n&gt; passes because the thread scheduling of the JVM implementation I am using<br/>\n&gt; happens to work out right. Has anyone else tried to write this kind of test?<br/>\n&gt; What might be a better approach?<br/>\n&gt;<br/>\n&gt; Thanks!<br/>\n&gt;<br/>\n&gt; Emily<br/>\n&gt;<br/>\n&gt; ----- code in question -------------------<br/>\n&gt;<br/>\n&gt; public class LockManagerTest extends TestCase {<br/>\n&gt;     private LockManager lockManager = new LockManager();<br/>\n&gt;<br/>\n&gt;     /**<br/>\n&gt;      * test for the requirement that the obtainLock method on<br/>\n&gt;      * LockManager must block until the requested lock becomes<br/>\n&gt;      * available<br/>\n&gt;      */<br/>\n&gt;     public void testBlocks() {<br/>\n&gt;         final int recordNo = 1;<br/>\n&gt;         Runnable getsLockFirst = new GetAndHoldLockFor100(recordNo);<br/>\n&gt;         Runnable getsLockAfterwards = new Runnable() {<br/>\n&gt;             public void run() {<br/>\n&gt;                 // assert the record is locked when we first ask, but<br/>\n&gt; becomes<br/>\n&gt;                 // available (or else the whole test run hangs).<br/>\n&gt;                 assert(lockManager.isRecordLocked(recordNo));<br/>\n&gt;                 int key = lockManager.obtainLock(recordNo);<br/>\n&gt;             }<br/>\n&gt;         };<br/>\n&gt;         Thread one = new Thread(getsLockFirst);<br/>\n&gt;         Thread two = new Thread(getsLockAfterwards);<br/>\n&gt;         one.start();<br/>\n&gt;         two.start();<br/>\n&gt;         // wait for test to run before returning<br/>\n&gt;         try {<br/>\n&gt;             Thread.currentThread().sleep(300);<br/>\n&gt;         } catch (InterruptedException e) {}<br/>\n&gt;<br/>\n&gt;     }<br/>\n&gt;<br/>\n&gt;     private class GetAndHoldLockFor100 implements Runnable {<br/>\n&gt;         private int recordNo;<br/>\n&gt;         public GetAndHoldLockFor100(int recordNo) {<br/>\n&gt;             this.recordNo = recordNo;<br/>\n&gt;         }<br/>\n&gt;         public void run() {<br/>\n&gt;                 int recordKey = lockManager.obtainLock(recordNo);<br/>\n&gt;                 try {<br/>\n&gt;                     Thread.currentThread().sleep(100);<br/>\n&gt;                 } catch (InterruptedException e) {}<br/>\n&gt;                 lockManager.releaseLock(recordNo, recordKey);<br/>\n&gt;             }<br/>\n&gt;     }<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; ------ end code in question ---------------------------------<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; To unsubscribe from this group, send an email to:<br/>\n&gt; <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit-unsubscribe@yahoogroups.com\">junit-unsubscribe@yahoogroups.com</a><br/>\n&gt;<br/>\n&gt;<br/>\n&gt; Your use of Yahoo! Groups is subject to <a rel=\"nofollow\" target=\"_blank\" href=\"http://docs.yahoo.com/info/terms/\">http://docs.yahoo.com/info/terms/</a><br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n<br/>\n-- <br/>\nEric Vought<br/>\nChief Technical Officer - QLUE Consulting, Inc.<br/>\n<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:evought@...\">evought@...</a> toll-free: 888-771-3538  RTP area: 919-816-9901 </span></blockquote></div>", 
    "prevInTime": 2736, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1001346394", 
    "canDelete": false, 
    "nextInTopic": 2756, 
    "prevInTopic": 2736, 
    "headers": {
        "inReplyToHeader": "PDcwMEVBMTdBMTQyQUQzMTE4QTFFMDAwOEM3MjRCQ0I0RUI3OUY2QGFnYmdudHMwMy5hZ2JnLmludHJhbmV0Pg==", 
        "messageIdInHeader": "PFBpbmUuTE5YLjQuMzAuMDEwOTI0MTAyODEwMC4yMjMwNS0xMDAwMDBAYnJhaW4ucWx1ZS1sYW4+"
    }
}