{
    "numMessagesInTopic": 8, 
    "nextInTime": 21451, 
    "senderId": "9yN55t4QftDCU4R6pF_NDV5oixVQxplO9kuuA7WF7enJU1ExLTXRvL2Xs9-8maOyUUkbjcbg_Z71Kmsa1wuFMGcKq9Q", 
    "systemMessage": false, 
    "subject": "RE: [junit] Listening for after a parameterized instance run...", 
    "from": "&quot;kentb&quot; &lt;kentb@...&gt;", 
    "authorName": "kentb", 
    "msgSnippet": "Mike, Thank you for your proposed addition to JUnit. We won t be integrating it immediately, but I wanted to take a moment to explain why. One of our values in", 
    "msgId": 21450, 
    "profile": "kentlbeck", 
    "topicId": 21437, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 173198504, 
    "messageBody": "<div id=\"ygrps-yiv-1984584621\">Mike,<br/>\n <br/>\nThank you for your proposed addition to JUnit. We won&#39;t be integrating it<br/>\nimmediately, but I wanted to take a moment to explain why.<br/>\n <br/>\nOne of our values in developing JUnit has been conservatism. We change the<br/>\nfeature set slowly and the API even more slowly. Only when a change is<br/>\nobviously widely useful do we add it to the core. If we can add a feature to<br/>\norg.junit.experimental without touching the core, we are more likely to add<br/>\nit. We do this because every feature in JUnit comes with a cost, not just<br/>\nfor us as maintainers but also for our user base. We have always done<br/>\neverything we could to keep the cost of JUnit as low as possible, even at<br/>\nthe risk of reducing the value by excluding features.<br/>\n <br/>\nMy analysis of @Before/AfterParameterize is that it is potentially valuable,<br/>\nbut at present below the line for a core feature. If there is something<br/>\nabout the core that blocks you from developing and maintaining it yourself,<br/>\nwe would very much like to hear about it. In the meantime, we&#39;ll wait for<br/>\nfeedback about the feature.<br/>\n <br/>\nRegards,<br/>\n <br/>\nKent Beck<br/>\nThree Rivers Institute<br/>\n<br/>\n  _____  <br/>\n<br/>\nFrom: junit@yahoogroups.com [mailto:junit@yahoogroups.com] On Behalf Of<br/>\nForsberg, Mike<br/>\nSent: Tuesday, March 24, 2009 1:22 PM<br/>\nTo: junit@yahoogroups.com<br/>\nSubject: RE: [junit] Listening for after a parameterized instance run...<br/>\n<br/>\n<br/>\n<br/>\nWell the problem is that @AfterClass runs after the entire class runs.<br/>\nNot after each parameterized test.<br/>\n<br/>\nA parameterized test performs like building a suite of multiple<br/>\ninstances of your test class, each with different parameters. (That you<br/>\nsupply.) What I want is to run a specific method after each run of a<br/>\nparameterized instance of the &quot;suite&quot;.<br/>\n<br/>\nI&#39;ve implemented a solution, and it is at<br/>\nhttp://github. &lt;http://github.com/bigmikef/junit.&gt; com/bigmikef/junit. It<br/>\nadds @BeforeParameterize and<br/>\n@AfterParameterize to the Parameterized class. These methods are called<br/>\nas expected during a Parameterized run.<br/>\n<br/>\nIt would be awesome if the owners included it in JUnit. I&#39;ve already<br/>\nrequested a pull, but have not heard anything after that.<br/>\n<br/>\nThanks for the help,<br/>\n<br/>\nBig Mike<br/>\n<br/>\nFrom: junit@yahoogroups. &lt;mailto:junit%40yahoogroups.com&gt; com<br/>\n[mailto:junit@yahoogroups. &lt;mailto:junit%40yahoogroups.com&gt; com] On Behalf<br/>\nOf<br/>\nPigneri, Rocco<br/>\nSent: Tuesday, March 24, 2009 9:16 AM<br/>\nTo: junit@yahoogroups. &lt;mailto:junit%40yahoogroups.com&gt; com<br/>\nSubject: RE: [junit] Listening for after a parameterized instance run...<br/>\n<br/>\nAs you can see, I&#39;d like to run both test methods with varying data,<br/>\nchanging the run times for each. This will generate a table of data<br/>\nthat I then can analyze and chart. The key thing I&#39;d like to avoid is<br/>\nusing @After, and only print only after the tests have ran. (Doing<br/>\nsomething like a boolean for each test, and a giant &quot;and&quot; statement VERY<br/>\nBAD)<br/>\n<br/>\nI am unfortunately not familiar with Parameterized runs, but it sounds<br/>\nlike what you want to do could be easily accomplished with the<br/>\n@AfterClass attribute. Or am I not understanding your situation fully?<br/>\n<br/>\nRocco<br/>\n<br/>\nFrom: junit@yahoogroups. &lt;mailto:junit%40yahoogroups.com&gt; com<br/>\n&lt;mailto:junit%40yahoogroups.com&gt;<br/>\n[mailto:junit@yahoogroups. &lt;mailto:junit%40yahoogroups.com&gt; com<br/>\n&lt;mailto:junit%40yahoogroups.com&gt; ] On<br/>\nBehalf Of<br/>\nForsberg, Mike<br/>\nSent: Thursday, March 19, 2009 4:15 PM<br/>\nTo: junit@yahoogroups. &lt;mailto:junit%40yahoogroups.com&gt; com<br/>\n&lt;mailto:junit%40yahoogroups.com&gt; <br/>\nSubject: [junit] Listening for after a parameterized instance run...<br/>\n<br/>\nFirst, I&#39;d like to say great group. I hope to respond to some questions<br/>\nonce I find one that I know the answer too.<br/>\n<br/>\nOn to my question,<br/>\n<br/>\nIs there a way to listen to an event after a parameterized instance<br/>\nruns? <br/>\n<br/>\nWhat I&#39;m doing might be better described with code...<br/>\n<br/>\n@RunWith(Parameterized.class)<br/>\n<br/>\npublic class MyTest {<br/>\n<br/>\nprivate static Map&lt;String, Long&gt; times = new HashMap&lt;String, Long&gt;();<br/>\n<br/>\npublic MyTest(Integer x, Integer y, Integer runs) {<br/>\n<br/>\nthis.x = x;<br/>\n<br/>\nthis.y = y;<br/>\n<br/>\nthis.runs = runs;<br/>\n<br/>\n}<br/>\n<br/>\n@Parameters<br/>\n<br/>\npublic static Collection permutations() {<br/>\n<br/>\nreturn Arrays.asList(new Object[][] {<br/>\n<br/>\n{1, 1, 1},<br/>\n<br/>\n{1, 1, 10}<br/>\n<br/>\n{1, 1, 100}<br/>\n<br/>\n{1, 1, 1000},<br/>\n<br/>\n.. . // vary x and y for each value of runs<br/>\n<br/>\n});<br/>\n<br/>\n}<br/>\n<br/>\n@Test<br/>\n<br/>\npublic void useAlgX() {<br/>\n<br/>\n//alg that uses x for runs number of runs<br/>\n<br/>\n//add timing information to times<br/>\n<br/>\n}<br/>\n<br/>\n@Test<br/>\n<br/>\npublic void useAlgY() {<br/>\n<br/>\n//alg that uses y for runs number of runs<br/>\n<br/>\n//add timing information to times<br/>\n<br/>\n}<br/>\n<br/>\n@AfterParameterizedInstance<br/>\n<br/>\npublic void showParameterInsanceResults() {<br/>\n<br/>\n//print time information in line for this run.<br/>\n<br/>\n}<br/>\n<br/>\n}<br/>\n<br/>\nAs you can see, I&#39;d like to run both test methods with varying data,<br/>\nchanging the run times for each. This will generate a table of data<br/>\nthat I then can analyze and chart. The key thing I&#39;d like to avoid is<br/>\nusing @After, and only print only after the tests have ran. (Doing<br/>\nsomething like a boolean for each test, and a giant &quot;and&quot; statement VERY<br/>\nBAD)<br/>\n<br/>\nI&#39;ll be happy for any help you can render,<br/>\n<br/>\nBig Mike<br/>\n<br/>\nMike Forsberg<br/>\n<br/>\nFactory Automation Engineer II<br/>\n<br/>\nT (512) 602-0220<br/>\n<br/>\n[Non-text portions of this message have been removed]<br/>\n<br/>\n[Non-text portions of this message have been removed]<br/>\n<br/>\n[Non-text portions of this message have been removed]<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n[Non-text portions of this message have been removed]</div>", 
    "prevInTime": 21449, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1238100453", 
    "canDelete": false, 
    "nextInTopic": 21451, 
    "prevInTopic": 21446, 
    "headers": {
        "inReplyToHeader": "PEVBMDM3MzA2NDhGN0FBNDRCMzc3NjZBREJERjY4QUUxMDI4RTdDNzdAU0FVU0VYTUIyLmFtZC5jb20+", 
        "messageIdInHeader": "PEI2NjkzN0FGM0Y0QTRBOTVBQzVGQ0YzRDgyOEE5M0M0QGtlbnRzcGF2aWxpb24+", 
        "referencesHeader": "PEVBMDM3MzA2NDhGN0FBNDRCMzc3NjZBREJERjY4QUUxMDI4RTc3N0RAU0FVU0VYTUIyLmFtZC5jb20+IDxEMDRCNjJBNTZDNjVFQTRCODYwMDM2MTA4QkQwQTY2QzAyRjU0NDhEQGJvc3Rvbi1leC5sYXZhc3Rvcm0ubG9jYWwuY29tPiA8RUEwMzczMDY0OEY3QUE0NEIzNzc2NkFEQkRGNjhBRTEwMjhFN0M3N0BTQVVTRVhNQjIuYW1kLmNvbT4="
    }
}