{
    "numMessagesInTopic": 2, 
    "nextInTime": 6911, 
    "senderId": "KBTFwncGgy12UbVA83OGA6nNHbBDjp10_sc6cRJBgvvAZlCj6HXkZw_Uod8rGUwketVwf-QSOxoNy8JKqh6ZUOizAKYws3dF9XaiPkvd", 
    "systemMessage": false, 
    "subject": "Re: [junit] Making an App Testable", 
    "from": "Eric Armstrong &lt;eric.armstrong@...&gt;", 
    "authorName": "Eric Armstrong", 
    "msgSnippet": "In the JUnit group, Scott Stirling made the interesting observation that a unit-testable app is, in effect, a tracable state machine that you can drive a step", 
    "msgId": 6910, 
    "profile": "ericsilverlight", 
    "topicId": 6910, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 78994084, 
    "messageBody": "<div id=\"ygrps-yiv-109858459\">In the JUnit group, Scott Stirling made the interesting observation that<br/>\n<br/>\na unit-testable app is, in effect, a tracable state machine that you can<br/>\n<br/>\ndrive a step at a time (driving it with a pulse, or strobe, in hardware<br/>\nterms) so that you can examine the results of state-transitions and<br/>\nverify correct behavior.<br/>\n<br/>\n(I&#39;ve included a summary of his excellent post. Although this post is<br/>\ndirected to the TDD list, I&#39;ve cross-posted to the JUnit list to be sure<br/>\n<br/>\nhe is included in as much of the ensuing discussion as possible.)<br/>\n<br/>\nThe question is this: I have an existing app is that is in dire need of<br/>\nrefactoring. Clearly, I need a test suite. The need for refactoring is<br/>\nmade obvious by the fact that fixing some bugs tends to generate<br/>\nothers, so an even more important reason to create the test suite is<br/>\nto make sure that I have thought through the desired behaviors and<br/>\nhave verified that they will occur.<br/>\n<br/>\n  [For those that like specifics: The app processes web pages.<br/>\n   It could be given a file path or a URL as a starting point. In<br/>\n   either case, it must determine whether the page it has been<br/>\n   pointed to is a file, a directory, a server, or a server script, and<br/>\n   do the  appropriate thing in each case. Right now, that seemingly<br/>\n   simple start-up proposition is a mess. It needs refactoring, and<br/>\n   solid testing.]<br/>\n<br/>\nNow then, to get to the question...<br/>\n<br/>\nIt seems to me that there are two ways to convert this java app<br/>\nto &quot;state machine&quot; form, to make it unit-testable.<br/>\n    1. Convert the individual behaviors to (static?) methods, so you<br/>\n        can point-test the methods.<br/>\n<br/>\n    2. Convert the program to a co-routine, so you can return<br/>\n        from it at pre-arranged points, test state, and then continue<br/>\n        from where you left off.<br/>\n<br/>\n   Note:<br/>\n   The app is already in &quot;bean&quot; form, so it is easy to instantiate it<br/>\n   as an object in a test case. That is an underlying requirement<br/>\n   for unit-testing an app which, in this case, has already been met.<br/>\n<br/>\nI&#39;m curious about the viability and desirability of each approach,<br/>\nespecially in a Java environment. For example:<br/>\n  a. Does the functional programming approach (which I have yet<br/>\n      to adequately grasp) provide the right thought-framework for<br/>\n      designing the methods that make for a testable app?<br/>\n  b. Is co-routining realistically achievable for a java app?<br/>\n      (I can&#39;t imagine how, unless it is with some relatively ugly<br/>\n       dispatch-routine that takes an argument telling it what to<br/>\n       do next.)<br/>\n<br/>\nThen, too, there is the chicken and egg problem -- the app needs<br/>\ntests to make refactoring viable, but it needs refactoring to make<br/>\ntesting viable. So an alternative strategy is to do something like<br/>\nthe following:<br/>\n   * Define a series of exit methods that write state information to<br/>\n      a configured I/O stream. (Standard output, by default.)<br/>\n   * Condition the exits on input options.<br/>\n   * For testing, configure the application object with an internal<br/>\n      string-stream, set an option to get the appropriate exit, and<br/>\n      test that the results are as expected.<br/>\n<br/>\nAlthough the third approach does not have quite the elegance of an<br/>\napp that is designed to be testable from the ground up, it seems like<br/>\na decent alternative to test an existing app that badly needs it.<br/>\n<br/>\nI look forward to additional thoughts on the matter.<br/>\n<br/>\n<blockquote><span title=\"qreply\"> &gt; Scott Stirling wrote:<br/>\n&gt;<br/>\n&gt; I&#39;ve been thinking about Test Driven Development and the question of<br/>\n&gt; what is it about it that ensures testability.<br/>\n&gt;  ....<br/>\n&gt; Obviously, a method added for no other purpose than to make a class&#39;s<br/>\n&gt; behavior more directly accessible to external tests ... enhances the<br/>\n&gt; testability of a class.<br/>\n&gt;  ....<br/>\n&gt; So how do you make things testable without corrupting the object<br/>\n&gt; design with behaviors added or modified just to make objects<br/>\n&gt; testable?  And why is it that test driven development, practiced<br/>\n&gt; religiously, will typically give you 100% statement coverage without<br/>\n&gt; adding any test-only methods to a class?<br/>\n&gt;<br/>\n&gt; I think the answer has to do with finite-state machines.  TDD is a<br/>\n&gt; methodology that results in the development of clean, working<br/>\n&gt; finite-state machines.  It works so well because the methodology of<br/>\n&gt; writing tests first drives the mental process to identify and make<br/>\n&gt; explicit, in the appropriate order of priority:<br/>\n&gt;  1. the desired outputs<br/>\n&gt;  2. the inputs and behaviors needed to transition<br/>\n&gt;     the machine from an initial or existing state<br/>\n&gt;     to desired output<br/>\n&gt;  3. the objects that compose the machine (one of the<br/>\n&gt;     least important things at first, contrary to more<br/>\n&gt;     traditional design methodology)....the naming of<br/>\n&gt;     the objects and definition of their boundaries<br/>\n&gt;     evolves as the 1st and 2nd priorities are realized.<br/>\n&gt;<br/>\n&gt; It seems the best way to build and test a finite-state machine is to<br/>\n&gt; make the inputs and outputs explicit, and to make the state<br/>\n&gt; transitions step-wise and traceable.  It&#39;s a fallout from object<br/>\n&gt; oriented programming constraints that the steps become methods in<br/>\n&gt; objects, and the traceability of the steps becomes actualized in your<br/>\n&gt; unit test methods and TestCases.<br/>\n&gt;<br/>\n&gt; After doing TDD, traceability and explicit inputs and outputs are what<br/>\n&gt; you&#39;ve built into your application and which remain, even if you take<br/>\n&gt; away the unit tests when you&#39;re done.<br/>\n&gt;<br/>\n&gt; So going back to the question of testability, I think there are some<br/>\n&gt; basic things that automatically result in testability in OOP (this<br/>\n&gt; list by no means accurate or exhaustive, and inspired by some reading<br/>\n&gt; about state machines in the testing literature, namely Beizer and<br/>\n&gt; Binder):<br/>\n&gt;   - objects or collaborations of objects modeled<br/>\n&gt;     as finite-state machines<br/>\n&gt;   - methods for making state transitions in the<br/>\n&gt;     objects themselves or in other objects<br/>\n&gt;   - explicit inputs to and outputs from methods<br/>\n&gt;   - step-wise, traceable state transitions<br/>\n&gt;<br/>\n&gt; I think these things become realized in terms of language and design<br/>\n&gt; specifics.  For example:<br/>\n&gt;   - traceability requires state transition methods<br/>\n&gt;     to be accessible for unit testing<br/>\n&gt;   - state must be verifiable via attributes or<br/>\n&gt;     methods that return state information that can be<br/>\n&gt;     used in assertions<br/>\n&gt;   - step-wise means you don&#39;t make monolithic &quot;god<br/>\n&gt;     methods&quot;, or classes that hide multiple,<br/>\n&gt;     untraceable transitions<br/>\n&gt;   - explicit inputs means that something like the<br/>\n&gt;     method below should be tuned based on the fact<br/>\n&gt;     that the Connection object is the *actual* input<br/>\n&gt;     needed for the behavior to do its thing:<br/>\n&gt;       public Object doMyThing(<br/>\n&gt;         ConnectionFactory factory,<br/>\n&gt;         String something)<br/>\n&gt;       {<br/>\n&gt;         Connection con = factory.getConnection();<br/>\n&gt;         Object o = doMyThing(con, something);<br/>\n&gt;         con.close();<br/>\n&gt;         return o;<br/>\n&gt;       }<br/>\n&gt;<br/>\n&gt; Passing in the ConnectionFactory, from this perspective, is an<br/>\n&gt; *implicit* input of a Connection, which hides the fact that what&#39;s<br/>\n&gt; really needed for the doMyThing() state transition is a Connection.<br/>\n&gt; The ConnectionFactory is extraneous to the transition enacted by the<br/>\n&gt; method.  But in case you left the signature with the ConnectionFactory<br/>\n&gt; (or Connection for that matter), a MockObject would allow you to keep<br/>\n&gt; the design &quot;pure.&quot;  (So how important is purity of design? That&#39;s<br/>\n&gt; another question.) </span></blockquote></div>", 
    "prevInTime": 6909, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1044660695", 
    "canDelete": false, 
    "nextInTopic": 6917, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PDNFNDQ0MUQ3LjgwQTUxRTdFQHN1bi5jb20+", 
        "referencesHeader": "PEtJRUhJQklPQkFFTEpBSElQTkhETUVNTkNPQUEuc2NvdHRzdGlybGluZ0ByY24uY29tPiA8M0U0MDJGQzkuODM0NTU3NzZAc3VuLmNvbT4="
    }
}