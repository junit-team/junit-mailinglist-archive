{
    "numMessagesInTopic": 5, 
    "nextInTime": 15367, 
    "senderId": "smerfUak6kgk3ou03TXnsGFkb9qYrfmgmlRlhvrgOkD9YAJyzURuOZgTuXBYlgA1q4M8rNjTQUoF6N5tI0JY9FPBaSeQLM2MZR2dTu89a-4", 
    "systemMessage": false, 
    "subject": "Running Only Testable classes with Ant/JUnit task", 
    "from": "&quot;cliftonccraig&quot; &lt;cliftonccraig@...&gt;", 
    "authorName": "cliftonccraig", 
    "msgSnippet": "Hello, This may sound like more of a novice question but I need to know what the best practice is for running all of my tests and ONLY my testable classes with", 
    "msgId": 15366, 
    "profile": "cliftonccraig", 
    "topicId": 15366, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 190580959, 
    "messageBody": "<div id=\"ygrps-yiv-495301492\">Hello,<br/>\n<br/>\nThis may sound like more of a novice question but I need to know what<br/>\nthe best practice is for running all of my tests and ONLY my testable<br/>\nclasses with the Ant Junit task. What I mean is this. I tried using<br/>\nthe batchtest task which is severely limited. It only does a directory<br/>\nscan over my test source to pick up the test classes. The problem is<br/>\nsometimes I may include abstract classes under that umbrella for<br/>\nconveniece methods and they get picked up too. Also there is no<br/>\ngarauntee that the source and class files will be one for one. (Eg.<br/>\nnested classes would go unnoticed as well as source files that<br/>\ndon&#39;t/can&#39;t compile to a equivalent named class.) I would feel alot<br/>\nbetter if I could filter the .class files instead of the source and<br/>\npull out only the classes that are TESTABLE. That is, classes that<br/>\nbegin or end with &quot;Test&quot; and have at least one public no-arg method<br/>\nbeginning with &quot;test&quot;. <br/>\n<br/>\nSo I plugged in DirectorySuiteBuilder from the junit addons project<br/>\nand added some custom code to accomplish this. My custom code, a class<br/>\nnamed DirectoryScannerSuiteBuilder, is included below. The problem<br/>\nwith that approach, while it is a lot more  accurate, is that the<br/>\njunitreport task now lumps all tests under my custom<br/>\nDirectoryScannerSuiteBuilder class name without separating out the<br/>\ndetail. So my question is what would the best approach be? Should I<br/>\nstop being anal and just go with the batchtest approach and stop<br/>\nincluding abstracts under the test source directory? (Incedentally<br/>\nthat&#39;s what I&#39;m resoting to now.) Or is there a more elaborate<br/>\nsolution sort of like a best of breed between the two approaches I&#39;ve<br/>\ntried so far?<br/>\n<br/>\nThanx in advance,<br/>\nCliff<br/>\n<br/>\nMy Code below:<br/>\n<br/>\npackage com.ice.junit.ext;<br/>\n<br/>\nimport junit.framework.Test;<br/>\nimport junit.framework.TestSuite;<br/>\nimport junitx.util.DirectorySuiteBuilder;<br/>\nimport junitx.util.TestFilter;<br/>\n<br/>\nimport java.io.File;<br/>\nimport java.lang.reflect.Method;<br/>\nimport java.lang.reflect.Modifier;<br/>\nimport java.util.Properties;<br/>\n<br/>\n/**<br/>\n * Created by IntelliJ IDEA.<br/>\n * User: CliftonCraig<br/>\n * Date: Nov 5, 2004<br/>\n * Time: 8:02:36 AM<br/>\n * Copywright Nov 5, 2004<br/>\n */<br/>\npublic class DirectoryScannerSuiteBuilder extends TestSuite<br/>\n{<br/>\n    static Properties props;<br/>\n    public static final String KEY_TESTS_DIR = &quot;tests.dir&quot;;<br/>\n    static boolean debug;<br/>\n    public static final String KEY_SELECTOR_DEBUG = &quot;selector.debug&quot;;<br/>\n<br/>\n    public static Properties getProps()<br/>\n    {<br/>\n        if(null==props) props = System.getProperties();<br/>\n        return props;<br/>\n    }<br/>\n<br/>\n    public DirectoryScannerSuiteBuilder()<br/>\n    {<br/>\n    }<br/>\n<br/>\n    public String getName()<br/>\n    {<br/>\n        return &quot;All Tests&quot;;<br/>\n    }<br/>\n<br/>\n    private static void setDebug()<br/>\n    {<br/>\n        if(props.containsKey(KEY_SELECTOR_DEBUG))<br/>\n        {<br/>\n            final String debugProp =<br/>\nprops.getProperty(KEY_SELECTOR_DEBUG);<br/>\n            try<br/>\n            {<br/>\n                debug = stringAsBooleanValue(debugProp);<br/>\n            }<br/>\n            catch(IllegalArgumentException e)<br/>\n            {<br/>\n                throw new IllegalArgumentException(KEY_SELECTOR_DEBUG<br/>\n+ &quot; is set to a non boolean value &quot; + debugProp);<br/>\n            }<br/>\n        }<br/>\n    }<br/>\n<br/>\n    private static boolean stringAsBooleanValue(final String str){<br/>\n        if(str.equalsIgnoreCase(&quot;yes&quot;) || str.equalsIgnoreCase(&quot;true&quot;)<br/>\n                || str.equalsIgnoreCase(&quot;on&quot;)) return true;<br/>\n        else if(str.equalsIgnoreCase(&quot;no&quot;) ||<br/>\nstr.equalsIgnoreCase(&quot;false&quot;)<br/>\n                || str.equalsIgnoreCase(&quot;off&quot;)) return false;<br/>\n        else throw new IllegalArgumentException(&quot;Invalid boolean value<br/>\n&quot; + str);<br/>\n    }<br/>\n<br/>\n    public static void setProps(Properties props)<br/>\n    {<br/>\n        DirectoryScannerSuiteBuilder.props = props;<br/>\n    }<br/>\n<br/>\n    public static Test suite()<br/>\n    {<br/>\n        File dir = new File(getProps().getProperty(KEY_TESTS_DIR));<br/>\n        setDebug();<br/>\n        debug(&quot;Running tests in &quot; + dir);<br/>\n        try<br/>\n        {<br/>\n            final Test suite = new DirectorySuiteBuilder(<br/>\n                                new TestFilter()<br/>\n                                {<br/>\n                                    public boolean include(Class aClass)<br/>\n                                    {<br/>\n                                        final boolean include =<br/>\nfalse==Modifier.isAbstract(aClass.getModifiers()) &&<br/>\nhasTestableMethods(aClass);<br/>\n                                        if(! include) {<br/>\n                                            debug(&quot;Rejecting &quot; +<br/>\naClass.getName());<br/>\n                                        }<br/>\n                                        return include;<br/>\n                                    }<br/>\n<br/>\n                                    public boolean include(String<br/>\nclassName)<br/>\n                                    {<br/>\n                                        String name =<br/>\nclassName.substring(className.lastIndexOf(File.separatorChar) +<br/>\n1).toLowerCase();<br/>\n                                        final boolean include =<br/>\nname.startsWith(&quot;test&quot;) || name.endsWith(&quot;test&quot;);<br/>\n                                        if(! include)<br/>\n                                            debug(&quot;Rejecting &quot; +<br/>\nclassName);<br/>\n                                        return include;<br/>\n                                    }<br/>\n                                }<br/>\n                        ).suite(dir);<br/>\n            debug(&quot;Found &quot; + suite.countTestCases() + &quot; test cases.&quot;);<br/>\n            ((TestSuite) suite).setName(&quot;All Tests&quot;);<br/>\n            return suite;<br/>\n        }<br/>\n        catch(Exception e)<br/>\n        {<br/>\n            throw new RuntimeException(&quot;Could not build test suite.&quot;,e);<br/>\n        }<br/>\n    }<br/>\n<br/>\n    private static void debug(final String msg){<br/>\n        if(debug) System.out.println(msg);<br/>\n    }<br/>\n<br/>\n    private static boolean hasTestableMethods(Class aClass)<br/>\n    {<br/>\n        Method[] methods = aClass.getDeclaredMethods();<br/>\n        for(int i = 0; i &lt; methods.length; i++)<br/>\n        {<br/>\n            if( methods[i].getName().startsWith(&quot;test&quot;)<br/>\n                && 0==methods[i].getParameterTypes().length<br/>\n                && Modifier.isPublic(methods[i].getModifiers()) )<br/>\nreturn true;<br/>\n        }<br/>\n        return false;<br/>\n    }<br/>\n}</div>", 
    "prevInTime": 15365, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1131393779", 
    "canDelete": false, 
    "nextInTopic": 15374, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PGRrb2J0ais3YWNnQGVHcm91cHMuY29tPg=="
    }
}