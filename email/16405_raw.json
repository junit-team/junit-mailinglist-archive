{
    "numMessagesInTopic": 9, 
    "nextInTime": 16406, 
    "senderId": "5IjqUXxy3vULyL1pPQwp5KbEll8ju_yxYEm9fVXuSjFkaNz_XGdUTHOrBSKprb0ZfN7onJU0SSted9cN3X2cFD51zDAetwRskPPoEoRe2A", 
    "systemMessage": false, 
    "subject": "Re: [junit] How to test a recursive method", 
    "from": "&quot;J. B. Rainsberger&quot; &lt;jbrains@...&gt;", 
    "authorName": "J. B. Rainsberger", 
    "msgSnippet": "... This is an interesting example. Let s try testing this with a fake or a mock. We know the basic rule of factorial(n) is this: 1. If n  2, then", 
    "msgId": 16405, 
    "rawEmail": "Return-Path: &lt;jbrains@...&gt;\r\nX-Sender: jbrains@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (qmail 26020 invoked from network); 27 Mar 2006 01:24:25 -0000\r\nReceived: from unknown (66.218.67.35)\n  by m7.grp.scd.yahoo.com with QMQP; 27 Mar 2006 01:24:22 -0000\r\nReceived: from unknown (HELO chilco.textdrive.com) (207.7.108.242)\n  by mta9.grp.scd.yahoo.com with SMTP; 27 Mar 2006 01:23:40 -0000\r\nReceived: from [172.17.198.244] (unknown [208.255.117.67])\n\tby chilco.textdrive.com (Postfix) with ESMTP id 889F5DBF41\n\tfor &lt;junit@yahoogroups.com&gt;; Mon, 27 Mar 2006 01:25:53 +0000 (UTC)\r\nMessage-ID: &lt;44273E95.8020305@...&gt;\r\nDate: Sun, 26 Mar 2006 20:23:33 -0500\r\nUser-Agent: Thunderbird 1.5 (Macintosh/20051201)\r\nMIME-Version: 1.0\r\nTo: junit@yahoogroups.com\r\nReferences: &lt;a03a20930603240948l792312a2tad48cb413dbc8a6b@...&gt; &lt;8ed733900603251553s6177f2a5s882b57cd8f390f88@...&gt;\r\nIn-Reply-To: &lt;8ed733900603251553s6177f2a5s882b57cd8f390f88@...&gt;\r\nContent-Type: text/plain; charset=ISO-8859-1; format=flowed\r\nContent-Transfer-Encoding: 7bit\r\nX-eGroups-Msg-Info: 1:12:0:0\r\nFrom: &quot;J. B. Rainsberger&quot; &lt;jbrains@...&gt;\r\nSubject: Re: [junit] How to test a recursive method\r\nX-Yahoo-Group-Post: member; u=127224993; y=M2dq1AsRZItbKc0e8micRKxzdVLPN5n2j7bzcVjkCP0fWrI\r\nX-Yahoo-Profile: nails762\r\n\r\nSimon Chappell wrote:\n&gt; On 3/24/06, amine achergui &lt;amine.achergui@...&gt; wrote:\n&gt;  &gt; Hi folks,\n&gt;  &gt; Is there any test pattern to test a recursive method ( in my case,\n&gt;  &gt; the method&#39;s body calls  collaborators thus in the test method i use \n&gt; mocks).\n&gt;  &gt; Is there any pattern or recipe to solve this?\n&gt;  &gt; Thx.\n&gt;  &gt; Amine\n&gt; \n&gt; Perhaps J.B. has a specific recipe for this. I do have his book, but\n&gt; it&#39;s at work and I&#39;m at home right now.\n&gt; \n&gt; Anyway, to a certain extent, JUnit doesn&#39;t actually care how the\n&gt; method that it calls does it&#39;s job. If you are testing\n&gt; Library.recursiveMethod() and it returns a result, then just test the\n&gt; result. If there are some standard &quot;easy&quot; results then start by\n&gt; getting those to work right.\n&gt; \n&gt; A more concrete example perhaps: Take the factorial calculation. The\n&gt; input values of zero and one give known, defined, values. So when\n&gt; writing a version of factorial, I&#39;d start with those and ensure that\n&gt; they worked before progressing on to the calculated values.\n&gt; \n&gt; assertEquals(0, Factorial.calculate(0));\n&gt; \n&gt; and\n&gt; \n&gt; assertEquals(1, Factorial.calculate(1));\n&gt; \n&gt; Then, when those tests pass, move onto the input values that you know\n&gt; will force recursive calculations.\n\nThis is an interesting example. Let&#39;s try testing this with a fake or a \nmock.\n\nWe know the basic rule of factorial(n) is this:\n\n1. If n &gt; 2, then factorial(n) = n * factorial(n-1).\n2. If n is 0 or 1, then factorial(n) = 1.\n\nSo the test that might involve a mock would look like this:\n\ntest2:\n     Mock mock = mock(MyMath.class);    // a silly name, I know\n     mock.expects(once()).method(&quot;factorial&quot;).with(eq(1));\n     MyMath myMath = (MyMath) mock.proxy();\n\n     ???\n\nWhat do we do here? If we invoke myMath.factorial(2), then the mock will \nblow up because there&#39;s no expectation for factorial(2).\n\nIf we add a stub for factorial(2), then we are no longer testing the \nimplementation of factorial(n).\n\nThere doesn&#39;t seem to be a way to do this. This is a case where \ninteraction-based testing might help, but we&#39;re stuck.\n\nThe next option I can imagine is splitting the factorial() method like this:\n\nfactorial(n):\n     if n &lt; 0 blow up;\n     if n &lt;= 1 return 1;\n     return computeFactorialForNAtLeast2(n);\n\ncomputeFactorialForNAtLeast2(n):    // another bad name\n     return n * nextFactor(n - 1);\n\nThis way we would mock computeFactorialForNAtLeast2() while testing \nfactorial(n). The method factorial() becomes a lookup table to decide \nwhich computation method to use: either computeFactorialForNAtLeast2() \nor &quot;return 1&quot; or &quot;blow up&quot;.\n\nIn this small example, the separation of the computation algorithms from \nthe algorithm to choose among them looks silly, but it&#39;s a design \ndecision we make in other contexts all the time: one method switches on \ninput, then decides which of a selection of other methods to invoke. \nThis is just a very simple case of it.\n\nLet us remember that the reason to choose interaction-based testing is \n(in part) to substitute for state-based testing when testing the state \nis not what we&#39;re principally interested in. With something that \ncomputes a mathematical quantity, I imagine state is /all/ that matters.\n\nAlso, we&#39;re not trying to avoid some great expensive external resource \nhere. If, by chance, the factorial computing algorithm were a gateway to \nsome parallel processing system to compute the factorials of large \nnumbers (say over 500), then we might certainly extract \ncomputeFactorialForNAtLeast2() into an interface and hide the parallel \nprocessing system behind it. But for this case, I wouldn&#39;t bother.\n\nWhat would interest me is a recursive method that doesn&#39;t fall into the \nsame category as factorial(). Tree algorithms or sorting algorithms \nmight fit, but while I think about how I would test them, I can&#39;t see \nmocks helping me write better tests.\n\nAny examples from the group?\n-- \nJ. B. (Joe) Rainsberger :: http://www.jbrains.info\nYour guide to software craftsmanship\nJUnit Recipes: Practical Methods for Programmer Testing\n2005 Gordon Pask Award for contribution Agile Software Practice\n\n", 
    "profile": "nails762", 
    "topicId": 16390, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 127224993, 
    "prevInTime": 16404, 
    "contentTrasformed": false, 
    "postDate": "1143422613", 
    "canDelete": false, 
    "nextInTopic": 16406, 
    "prevInTopic": 16404, 
    "headers": {
        "inReplyToHeader": "PDhlZDczMzkwMDYwMzI1MTU1M3M2MTc3ZjJhNXM4ODJiNTdjZDhmMzkwZjg4QG1haWwuZ21haWwuY29tPg==", 
        "messageIdInHeader": "PDQ0MjczRTk1LjgwMjAzMDVAcm9nZXJzLmNvbT4=", 
        "referencesHeader": "PGEwM2EyMDkzMDYwMzI0MDk0OGw3OTIzMTJhMnRhZDQ4Y2I0MTNkYmM4YTZiQG1haWwuZ21haWwuY29tPiA8OGVkNzMzOTAwNjAzMjUxNTUzczYxNzdmMmE1czg4MmI1N2NkOGYzOTBmODhAbWFpbC5nbWFpbC5jb20+"
    }
}