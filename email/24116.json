{
    "numMessagesInTopic": 27, 
    "nextInTime": 24117, 
    "senderId": "Awp9JG4o7aXwkUX3oAyb2YhetIIsb6jMPrLcys-8D0O0G2eSPMwAyAzPZqI2PVvOqFLM2kfuhyM-86IFcGa5bvxYcflUUAb3F7NrlnVoVqvEIwklnIv4yDE", 
    "systemMessage": true, 
    "subject": "Re: [junit] assertArrayEquals on arrays of objects", 
    "from": "Stephen Connolly &lt;stephen.alan.connolly@...&gt;", 
    "authorName": "Stephen Connolly", 
    "msgSnippet": "... Wel let s not mention the case I found where in a conference call scheduling application, the DateTimeHelper class got abused by another developer in", 
    "msgId": 24116, 
    "profile": "stephenalanconnolly", 
    "topicId": 24091, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 458231986, 
    "messageBody": "<div id=\"ygrps-yiv-1126594952\">On 19 November 2012 07:47, Matthew Farwell &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:matthew@...\">matthew@...</a>&gt; wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; I partially disagree with this statement. Yes, adding more code adds more<br/>\n&gt; scope for introducing bugs, but if you&#39;re adding code that allows your code<br/>\n&gt; to be tested, then that is a good thing. When I&#39;m dealing with dates and<br/>\n&gt; times in code, then it&#39;s a very common idiom to see a DateTimeHelper which<br/>\n&gt; an be injected so that you can test code which depends on the current date<br/>\n&gt; and time. Without this, it&#39;s very hard to test this sort of code.<br/>\n&gt;<br/>\n&gt; So adding code can make my code more reliable. Within reason, of course.<br/>\n&gt;<br/>\n&gt;<br/>\n </span></blockquote>Wel let&#39;s not mention the case I found where in a conference call<br/>\nscheduling application, the DateTimeHelper class got abused by another<br/>\ndeveloper in production code to &quot;work around&quot; some DST issue causing all<br/>\nsorts of bugs.... which only happened on the last day of October and only<br/>\nif it was a Thursday!<br/>\n<br/>\nThank goodness we had Jenkins running nightly tests, and nobody had<br/>\ncommitted *any* changes to that branch that week... or we would never have<br/>\nfound the bug.<br/>\n<br/>\nAdding code to &quot;make testing easier&quot; can have unintended consequences when<br/>\nothers come along maintaining your code and start to abuse your API<br/>\ncontract!<br/>\n<br/>\n[Yes it was somebody doing something they shouldn&#39;t have... and yes I<br/>\nsuspect they would have used reflection to achieve the same bug if the<br/>\nhelper was not there... but that would have been a bigger more glaring code<br/>\nsmell]<br/>\n<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; I would say that if your equals/hashCode aren&#39;t necessary except for tests,<br/>\n&gt; then don&#39;t put them in. You can always override/mock them in your tests if<br/>\n&gt; you really really need them. However, I would feel that having equals and<br/>\n&gt; hashCode *only* in the tests is probably a code smell. I can&#39;t think of an<br/>\n&gt; example where this would be necessary. Most of the time, I suspect you can<br/>\n&gt; do a sort with an explicit comparator if you want to compare two<br/>\n&gt; collections.<br/>\n&gt;<br/>\n<br/>\n </span></blockquote>The real issue is that Comparator, Object.equals, Object.hashCode all have<br/>\nan implicit contract defined by the JRE, and you need to ensure that they<br/>\nare correctly implemented *with respect to that contract*. The comparisons<br/>\nthat you need to make in unit tests *need not necessarily be the same* as<br/>\nthe required contract that your classes are required to follow for their<br/>\ncorrect behaviour in production.<br/>\n<br/>\nAs long as when you are writing your<br/>\n<br/>\nassertThat(x, is(y))<br/>\n<br/>\nor<br/>\n<br/>\nassertEquals(y, x);<br/>\n<br/>\nyou stop and think: &quot;Is it really the equality as specified by the x&#39;s<br/>\n.equals() method that I want to check&quot; then you are fine.<br/>\n<br/>\nBecause often enough, you may not require that test.<br/>\n<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;<br/>\n&gt; Matthew Farwell.<br/>\n&gt;<br/>\n&gt; 2012/11/18 Stephen Connolly &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:stephen.alan.connolly@...\">stephen.alan.connolly@...</a>&gt;<br/>\n&gt;<br/>\n&gt; &gt; **<br/>\n&gt; &gt;<br/>\n&gt; &gt; Every line of code you write introduces another place for you to write a<br/>\n&gt; &gt; bug. So adding test hooks to your production code, whatever form those<br/>\n&gt; &gt; hooks take, is adding more scope for bugs.<br/>\n&gt; &gt;<br/>\n&gt; &gt; Production code should be just what is required and no more, ie no dead<br/>\n&gt; &gt; code please.<br/>\n&gt; &gt;<br/>\n&gt; &gt; That is the ideal we should strive for, just as 100% coverage is the<br/>\n&gt; ideal<br/>\n&gt; &gt; we should strive for.<br/>\n&gt; &gt;<br/>\n&gt; &gt; Now in practice, for my code, I usually implement equals and hash code...<br/>\n&gt; &gt; But I do so *following the correct contract for equals and hashcode*<br/>\n&gt; &gt;<br/>\n&gt; &gt; One of the elements of that contract is that hashCode of two equal<br/>\n&gt; objects<br/>\n&gt; &gt; should be identical, and that it should be based on the objects final<br/>\n&gt; &gt; fields.<br/>\n&gt; &gt;<br/>\n&gt; &gt; often enough to warrant mentioning (though not every day), unless your<br/>\n&gt; &gt; objects are immutable (I like immutable objects too btw which is why this<br/>\n&gt; &gt; doesn&#39;t happen every day for me) you will find that the necessities of<br/>\n&gt; the<br/>\n&gt; &gt; equals and hashCode contracts with respect to collections etc, results in<br/>\n&gt; &gt; equals methods that only compare on a subset of the objects fields, in<br/>\n&gt; &gt; which case you need, in your tests, to compare on the non-final fields<br/>\n&gt; too.<br/>\n&gt; &gt;<br/>\n&gt; &gt; On other occasions I have found it necessary to leave the equals and<br/>\n&gt; &gt; hashCode methods unimplemented because I need specific behaviour within<br/>\n&gt; &gt; collections. In such cases I typically have test cases to verify that<br/>\n&gt; &gt; equals is inherited from Object so that future maintainers do not<br/>\n&gt; &gt; accidentally add an implementation.<br/>\n&gt; &gt;<br/>\n&gt; &gt; Normally, I use a wrapper class for adding such objects to collections so<br/>\n&gt; &gt; that it is safe to use equals... But that can put an excessive GC load,<br/>\n&gt; and<br/>\n&gt; &gt; as a result you may be forced to go without the wrapper... In a sense it<br/>\n&gt; &gt; is a pity that the collections classes do not allow for plugable hashCode<br/>\n&gt; &gt; and equality strategies,<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; You might never have to test for equality of your objects in production<br/>\n&gt; &gt; but<br/>\n&gt; &gt; &gt; need it for testing.<br/>\n&gt; &gt;<br/>\n&gt; &gt; Or you might have need for the Object.equals behaviour<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; And more generally, there is really nothing wrong with implementing<br/>\n&gt; &gt; &gt; hashCode()/equals() for your objects that match their purpose.<br/>\n&gt; &gt;<br/>\n&gt; &gt; The point is that such purpose may not match the needs of testing.<br/>\n&gt; &gt;<br/>\n&gt; &gt; I agree that 95% if the time adding equals and hashCode is perfectly<br/>\n&gt; fine.<br/>\n&gt; &gt; And since we often use IDE tooling or Guava&#39;s helpers (or equivalent<br/>\n&gt; &gt; helpers) to implement these methods it is very low risk. My point is that<br/>\n&gt; &gt; there are times when it is less clear, and a subset of those where it is<br/>\n&gt; &gt; the wrong thing to do.<br/>\n&gt; &gt;<br/>\n&gt; &gt; You should always know *why* you are adding code to production. Adding<br/>\n&gt; code<br/>\n&gt; &gt; *just because your tests need it* is a bad code smell... It indicates<br/>\n&gt; that<br/>\n&gt; &gt; either you don&#39;t understand a production requirement of your code (which<br/>\n&gt; &gt; may mean that the equals method is needed anyway) or you have a bad<br/>\n&gt; design<br/>\n&gt; &gt; of your production code in the first place.<br/>\n&gt; &gt;<br/>\n&gt; &gt; Another final point is that relying on equals comparing equality as<br/>\n&gt; opposed<br/>\n&gt; &gt; to identity within your tests can hinder refactoring as it may make it<br/>\n&gt; &gt; harder to split the class given that you then have to take care that the<br/>\n&gt; &gt; equals methods are split correctly... Using duck comparison based on eg<br/>\n&gt; &gt; Guava&#39;s helpers is very little work and allows for correct testing.<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt; &gt; --<br/>\n&gt; &gt; &gt; CÃ©dric<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; [Non-text portions of this message have been removed]<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; ------------------------------------<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; Yahoo! Groups Links<br/>\n&gt; &gt;<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt; [Non-text portions of this message have been removed]<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; [Non-text portions of this message have been removed]<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; ------------------------------------<br/>\n&gt;<br/>\n&gt; Yahoo! Groups Links<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n<br/>\n<br/>\n </span></blockquote>[Non-text portions of this message have been removed]</div>", 
    "prevInTime": 24115, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1353325868", 
    "canDelete": false, 
    "nextInTopic": 24118, 
    "prevInTopic": 24115, 
    "headers": {
        "inReplyToHeader": "PENBT0Jrb0ZVTGJrMERNUWlpZDVWLVVVeUFKRjNPUkhpQ2hNZXQ5X3NpQWFkYjh6WTBCZ0BtYWlsLmdtYWlsLmNvbT4=", 
        "messageIdInHeader": "PENBK25Qbk13aGtibmhpSF82RlpvZm84WFc4OU94WFlVOGM4WDJLM2NkK1dQOFNSc0ZLZ0BtYWlsLmdtYWlsLmNvbT4=", 
        "referencesHeader": "PGs4OHA2MytwNmpjQGVHcm91cHMuY29tPgk8REE2RTkyMjgtNkVEQy00NEFFLTkyQTAtMzVCMDZGODExMDRDQGdtYWlsLmNvbT4JPDIwMTIxMTE3MTUzMDU2LjUzYmM2ZjcwQGhhYmFuZXJvPgk8MjREM0NCQjItNEQ3Qy00RUVELUI0NUItOURDNTEwNkRBNDczQGdtYWlsLmNvbT4JPDIwMTIxMTE3MTYyMDA1Ljc3NjBhOWQ0QGhhYmFuZXJvPgk8Q0ErblBuTXpzV2cyemc4YXZBODZQQXdnb1J6SEpwa0trRUZvS1lpSDVqNlQ1YkNDdT1BQG1haWwuZ21haWwuY29tPgk8Q0FPcGhnSkFqZU1fdTVYQUJROFpjNDgxUTFjSC13LWpLREJ6ZTA2ZjVIVGpfTHIyWTNnQG1haWwuZ21haWwuY29tPgk8Q0ErblBuTXdnR1E4V0dIbk9RVTlfbURiT1FFSFdFWkFnOVoyVzF2ZXo0cV9KanMrRV9nQG1haWwuZ21haWwuY29tPgk8Q0FPQmtvRlVMYmswRE1RaWlkNVYtVVV5QUpGM09SSGlDaE1ldDlfc2lBYWRiOHpZMEJnQG1haWwuZ21haWwuY29tPg=="
    }
}