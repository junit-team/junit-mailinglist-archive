{
    "numMessagesInTopic": 2, 
    "nextInTime": 16232, 
    "senderId": "_tyUnzzBcjC5C1wVj1MJZ8QS92ngF9s8fBY0PIrtOAWLK61hy6r4TrBpZ2zfcsrLoqJfRzK9XDKX_NTO6_d3X1xz4s0dqEMRpJi2iQ", 
    "systemMessage": true, 
    "subject": "Re: junit4.0 , JUnitX", 
    "from": "&quot;fujeyla&quot; &lt;jerome.layat@...&gt;", 
    "authorName": "fujeyla", 
    "msgSnippet": "Hi, Just a little message to tell you that you can find here ", 
    "msgId": 16231, 
    "profile": "fujeyla", 
    "topicId": 16201, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 215863126, 
    "messageBody": "<div id=\"ygrps-yiv-1646761154\">Hi,<br/>\n<br/>\nJust a little message to tell you that you can find here <br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.xp-swiss.org/wiki/index.php?title=JUnitX_how_to_eng#JUnitX_5.2_-.3E_No_need_for_TestProxy_.21\">http://www.xp-swiss.org/wiki/index.php?title=JUnitX_how_to_eng#JUnitX_5.2_-.3E_No_need_for_TestProxy_.21</a><br/>\na JUnitX 5.2 version that allows you to avoid creating TextProxy<br/>\nclasses as they are created and compiled at runtime for you, using<br/>\njavassist (if it is in your test classpath).<br/>\nThe JUnitX 5.2 version works very well with previous versions of<br/>\nJUnit, we still have not tested it with JUnit 4.0.<br/>\n<br/>\nAnd notice that JUnitX does not replace JUnit, it&#39;s a JUnit extension ;)<br/>\n<br/>\n<blockquote><span title=\"qreply\"> --- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>, Kamal Ahmed &lt;KAhmed@...&gt; wrote:<br/>\n&gt;<br/>\n&gt; Hi,<br/>\n&gt; <br/>\n&gt; Does Junit4.0 Support Proxy like JunitX Does?<br/>\n&gt; <br/>\n&gt; Here is the example from JUnitX, from their web site:<br/>\n&gt; <br/>\n&gt;  <br/>\n&gt; <br/>\n&gt; 1.\tCreate a Production Source Class (which is the case a lot of times,<br/>\n&gt; when Classes are written without implementing XP)<br/>\n&gt; <br/>\n&gt;  <br/>\n&gt; <br/>\n&gt; package junitx.demo;<br/>\n&gt; <br/>\n&gt; class Inverter<br/>\n&gt; <br/>\n&gt; {<br/>\n&gt; <br/>\n&gt;   protected int _value = 0;<br/>\n&gt; <br/>\n&gt;  <br/>\n&gt; <br/>\n&gt;   public void flip ()<br/>\n&gt; <br/>\n&gt;   {<br/>\n&gt; <br/>\n&gt;     _value = 1 - _value;<br/>\n&gt; <br/>\n&gt;   }<br/>\n&gt; <br/>\n&gt; }<br/>\n&gt; <br/>\n&gt;  <br/>\n&gt; <br/>\n&gt; 2.\tCreate a Test Class<br/>\n&gt; <br/>\n&gt;  <br/>\n&gt; <br/>\n&gt; package junitx.demo;<br/>\n&gt; <br/>\n&gt; import junit.framework.*;<br/>\n&gt; <br/>\n&gt; import junitx.framework.*;<br/>\n&gt; <br/>\n&gt;  <br/>\n&gt; <br/>\n&gt; public class TestInverter extends PrivateTestCase<br/>\n&gt; <br/>\n&gt; {<br/>\n&gt; <br/>\n&gt;   public TestInverter (String aName)<br/>\n&gt; <br/>\n&gt;   {<br/>\n&gt; <br/>\n&gt;     super (aName);<br/>\n&gt; <br/>\n&gt;   }<br/>\n&gt; <br/>\n&gt;  <br/>\n&gt; <br/>\n&gt;   public void testInverter () throws TestAccessException<br/>\n&gt; <br/>\n&gt;   {<br/>\n&gt; <br/>\n&gt;     Object inverter = newInstance   (&quot;junitx.demo.Inverter&quot;, NOARGS);<br/>\n&gt; <br/>\n&gt;     Object dummy    = invokeWithKey (inverter, &quot;flip&quot;, NOARGS);<br/>\n&gt; <br/>\n&gt;  <br/>\n&gt; <br/>\n&gt;     assertEquals (getInt (inverter, &quot;_value&quot;), 1);<br/>\n&gt; <br/>\n&gt;   }<br/>\n&gt; <br/>\n&gt; }<br/>\n&gt; <br/>\n&gt;  <br/>\n&gt; <br/>\n&gt; Notice: <br/>\n&gt; <br/>\n&gt; *\tin this case the TestCase is not extended from &quot;TestCase&quot; as Junit<br/>\n&gt; would have it.<br/>\n&gt; *\tgetInt Method is from JUnitX API<br/>\n&gt; *\tJUnitX allows to create instances of any class the VM can access<br/>\n&gt; using the newInstance method. Furthermore you can invoke any method<br/>\nof that<br/>\n&gt; class independently of its access modifiers using the invokeWithKey<br/>\nmethod.<br/>\n&gt; *\tnewInstance invokes a constructor of a tested class<br/>\n&gt; *\tinvokeWithKey invokes a method on a proxied class using a method<br/>\n&gt; key.<br/>\n&gt; <br/>\n&gt;  <br/>\n&gt; <br/>\n&gt; 3.\tCreate a Test Proxy<br/>\n&gt; <br/>\n&gt; package junitx.demo;<br/>\n&gt; <br/>\n&gt; import java.lang.reflect.*;<br/>\n&gt; <br/>\n&gt;  <br/>\n&gt; <br/>\n&gt; import junit.framework.*;<br/>\n&gt; <br/>\n&gt; import junitx.framework.*;<br/>\n&gt; <br/>\n&gt;  <br/>\n&gt; <br/>\n&gt; public class TestProxy extends junitx.framework.TestProxy<br/>\n&gt; <br/>\n&gt; {<br/>\n&gt; <br/>\n&gt;   public Object newInstance (Object[] anArgList)<br/>\n&gt; <br/>\n&gt;   throws TestAccessException<br/>\n&gt; <br/>\n&gt;   {<br/>\n&gt; <br/>\n&gt;     try<br/>\n&gt; <br/>\n&gt;     {<br/>\n&gt; <br/>\n&gt;       return getProxiedClass ().getConstructor (anArgList).newInstance<br/>\n&gt; (anArgList);<br/>\n&gt; <br/>\n&gt;     }<br/>\n&gt; <br/>\n&gt;     catch (Exception e)<br/>\n&gt; <br/>\n&gt;     {<br/>\n&gt; <br/>\n&gt;       throw new TestAccessException (&quot;could not instantiate &quot; +<br/>\n&gt; getTestedClassName (), e);<br/>\n&gt; <br/>\n&gt;     }<br/>\n&gt; <br/>\n&gt;   }<br/>\n&gt; <br/>\n&gt;  <br/>\n&gt; <br/>\n&gt;  <br/>\n&gt; <br/>\n&gt;   public Object newInstanceWithKey (String aConstructorKey, Object[]<br/>\n&gt; anArgList)<br/>\n&gt; <br/>\n&gt;   throws TestAccessException<br/>\n&gt; <br/>\n&gt;   {<br/>\n&gt; <br/>\n&gt;     try<br/>\n&gt; <br/>\n&gt;     {<br/>\n&gt; <br/>\n&gt;       return getProxiedClass ().getConstructor<br/>\n(aConstructorKey).newInstance<br/>\n&gt; (anArgList);<br/>\n&gt; <br/>\n&gt;     }<br/>\n&gt; <br/>\n&gt;     catch (Exception e)<br/>\n&gt; <br/>\n&gt;     {<br/>\n&gt; <br/>\n&gt;       throw new TestAccessException (&quot;could not instantiate &quot; +<br/>\n&gt; getTestedClassName (), e);<br/>\n&gt; <br/>\n&gt;     }<br/>\n&gt; <br/>\n&gt;   }<br/>\n&gt; <br/>\n&gt; }<br/>\n&gt; <br/>\n&gt; Note: <br/>\n&gt; <br/>\n&gt; *\tTestProxy class allows JUnitX to locate test cases in different<br/>\n&gt; packages than the tested classes. The code of the proxy is always<br/>\nthe same<br/>\n&gt; <br/>\n&gt;  <br/>\n&gt; <br/>\n&gt; 4.\tCreate a Test Package.<br/>\n&gt; <br/>\n&gt;  <br/>\n&gt; <br/>\n&gt; package junitx.demo;<br/>\n&gt; <br/>\n&gt;  <br/>\n&gt; <br/>\n&gt; import junit.framework.*;<br/>\n&gt; <br/>\n&gt; import junitx.framework.*;<br/>\n&gt; <br/>\n&gt;  <br/>\n&gt; <br/>\n&gt; public class TestPackage implements junitx.framework.TestPackage<br/>\n&gt; <br/>\n&gt; {<br/>\n&gt; <br/>\n&gt;   static public Test suite ()<br/>\n&gt; <br/>\n&gt;   {<br/>\n&gt; <br/>\n&gt;     TestSuite suite = new TestSuite (&quot;Inverter tests&quot;);<br/>\n&gt; <br/>\n&gt;  <br/>\n&gt; <br/>\n&gt;     suite.addTestSuite (junitx.demo.TestInverter.class);<br/>\n&gt; <br/>\n&gt;  <br/>\n&gt; <br/>\n&gt;     return suite;<br/>\n&gt; <br/>\n&gt;   }<br/>\n&gt; <br/>\n&gt; }<br/>\n&gt; <br/>\n&gt; So this DOES take one extra Step, and as far as JUnitX claims, this<br/>\nExtra<br/>\n&gt; Step (STEP 3) needs to be done only once prepackage, and the code is<br/>\nalways<br/>\n&gt; the same (correct me if I am wrong)<br/>\n&gt; <br/>\n&gt; Now with this framework, we have the ability to test protected methods,<br/>\n&gt; other then that I don&#39;t see any real value (but I have no experience of<br/>\n&gt; JUnitX, so I am not in a position to say that).<br/>\n&gt; <br/>\n&gt; Anyone care to comment on this? In order to improve test cases.<br/>\n&gt; <br/>\n&gt; Thanks,<br/>\n&gt; <br/>\n&gt; -Kamal. <br/>\n&gt; <br/>\n&gt; <br/>\n&gt; <br/>\n&gt; [Non-text portions of this message have been removed]<br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 16230, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1140951179", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 16201, 
    "headers": {
        "inReplyToHeader": "PDVCMTBFNTBFMTRBNDU5NEVCMUI1NTY2QjY5QUQ5NDA3MEQwMTcxOURAbWFpbGVhc3Q+", 
        "messageIdInHeader": "PGR0czFhYis3Nml0QGVHcm91cHMuY29tPg=="
    }
}