{
    "topicId": 2534, 
    "postDate": "999570241", 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "from": "Eric Vought &lt;evought@...&gt;", 
    "canDelete": false, 
    "replyTo": "LIST", 
    "senderId": "0gOqN4eWh4ud8SyXRMzNxunD662SCqXUAA2zXQ_2T1awZduweGF4rXmFJZWtSUftfPyGzU9joJGDgH1DJs0F7ivqPHBp", 
    "nextInTime": 2558, 
    "userId": 0, 
    "prevInTime": 2556, 
    "prevInTopic": 2555, 
    "headers": {
        "inReplyToHeader": "PDIwMDEwOTAzMTkxNjQ4LjJGRDJBNDY4OTFAbGVuYXJkLm1pY3JvY2VsbGk1LmNvbT4=", 
        "messageIdInHeader": "PFBpbmUuTE5YLjQuMzAuMDEwOTAzMjIxNDI4MC4xNDU1LTEwMDAwMEBicmFpbi5xbHVlLWxhbj4="
    }, 
    "authorName": "Eric Vought", 
    "numMessagesInTopic": 10, 
    "msgSnippet": "I have a test routine called EnumerationEquals(..) which I ve written various variants on for different projects. It takes two Enumerations and compares them", 
    "contentTrasformed": false, 
    "msgId": 2557, 
    "nextInTopic": 2564, 
    "systemMessage": false, 
    "rawEmail": "Return-Path: &lt;evought@...&gt;\r\nX-Sender: evought@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (EGP: mail-7_3_2); 4 Sep 2001 02:29:12 -0000\r\nReceived: (qmail 53459 invoked from network); 4 Sep 2001 02:28:35 -0000\r\nReceived: from unknown (10.1.10.142)\n  by l10.egroups.com with QMQP; 4 Sep 2001 02:28:35 -0000\r\nReceived: from unknown (HELO ral.qlue.com) (65.201.137.7)\n  by mta3 with SMTP; 4 Sep 2001 02:28:34 -0000\r\nReceived: from brain.qlue-lan (brain.qlue-lan [192.168.1.28])\n\tby ral.qlue.com (Postfix) with ESMTP id 40A181CB4A\n\tfor &lt;junit@yahoogroups.com&gt;; Mon,  3 Sep 2001 22:27:18 -0400 (EDT)\r\nDate: Mon, 3 Sep 2001 22:24:01 -0400 (EDT)\r\nTo: &lt;junit@yahoogroups.com&gt;\r\nSubject: Re: [junit] Failing multiple times in one test\r\nIn-Reply-To: &lt;20010903191648.2FD2A46891@...&gt;\r\nMessage-ID: &lt;Pine.LNX.4.30.0109032214280.1455-100000@...-lan&gt;\r\nMIME-Version: 1.0\r\nContent-Type: TEXT/PLAIN; charset=US-ASCII\r\nFrom: Eric Vought &lt;evought@...&gt;\r\n\r\n\nI have a test routine called EnumerationEquals(..) which I&#39;ve written\nvarious variants on for different projects. It takes two Enumerations and\ncompares them for equality, irrespective of order. It returns a hash of\nthe differences between the enumerations. The fact that it takes\nEnumerations allows you to test more than just hash keys and it can be\ntrivially modified to work with Iterators as well.\n\nBasically, you just take each element from the first enum and add it to a\nlocal hash with a dummy key. Then you walk through the second enum and\nsubtract keys that match ones already in the hash (or change the value).\nIf you find an element in the second enum not in the hash, you set it with\nanother distinctive value. If you have keys left in the hash when you are\ndone, you know there are elements in the first enum that are not in the\nsecond. If it fails, you can print the table to get quite clear and useful\ndiagnostics.\n\nThis gives you one testcase with one pass-or-fail, but gives you the\ndebugging ease you are looking for. Better, you can stick this routine in\nyour toolbox and reuse it all over the place. Once I had something like\nthis available, I found myself writing trivial tests for things that I had\nbeen avoiding before.\n\nOn Mon, 3 Sep 2001, Laurent Duperval wrote:\n\n&gt; On  1 Sep, J. B. Rainsberger wrote:\n&gt; &gt;&gt;I&#39;m writing a test whose purpose is to make sure that a Hashtable contains\n&gt; &gt; a\n&gt; &gt;&gt;certain set of keys. Basically, the test will make sure that someone\n&gt; &gt; filling\n&gt; &gt;&gt;out a form on the web provides all the mandatory info\n&gt; &gt;\n&gt; &gt; Hashtable? Tsk, tsk... why aren&#39;t you using Map instead? :)\n&gt; &gt;\n&gt;\n&gt; Uhm... What&#39;s the diff?\n&gt;\n&gt; &gt;&gt;I&#39;d like a way to make\n&gt; &gt;&gt;the test fail for every parameter that is missing and consider each of the\n&gt; &gt;&gt;iterations as one test.\n&gt; &gt;\n&gt; &gt; Silly question: why? Does it matter whether one, two or ten parameters are\n&gt; &gt; not handled correctly? I think it matters more whether they are all\n&gt; &gt; handled correctly, or not.\n&gt; &gt;\n&gt;\n&gt; It does but the fact that one parameter fails may have nothing to do with\n&gt; the fact that another fails since validation may be occuring in different\n&gt; parts of the code. By failing once per invalid parameter, you are\n&gt; immediately pointed to the proper place to debug. And if the test lists all\n&gt; the parameters that failed, a developer could possibly see a pattern, which\n&gt; also helps in debugging.\n&gt;\n&gt; &gt; Also, who cares how many tests there are? Do you? Your manager? I don&#39;t\n&gt; &gt; want to get into the discussion again about counting tests, but I have\n&gt; &gt; never really cared how many tests I have, as long as I&#39;m happy with the\n&gt; &gt; quality of the tests.\n&gt; &gt;\n&gt;\n&gt; No, counting tests wasn&#39;t the motive behind my question.\n&gt;\n&gt; &gt; Since JUnit counts test methods by default, you&#39;d need one method per\n&gt; &gt; parameter. Do you really think that&#39;s a useful thing to do? I don&#39;t.\n&gt; &gt;\n&gt;\n&gt; No, that&#39;s why I asked if there was a better method than what I&#39;m doing now:\n&gt; I have a StringBuffer to which I add all the parameters that failed and then\n&gt; use the StringBuffer in fail().\n&gt;\n&gt; L\n&gt;\n&gt;\n\n-- \nEric Vought\nChief Technical Officer - QLUE Consulting, Inc.\n\nevought@... toll-free: 888-771-3538  RTP area: 919-816-9901\n\n\n", 
    "subject": "Re: [junit] Failing multiple times in one test"
}