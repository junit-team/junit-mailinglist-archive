{
    "numMessagesInTopic": 9, 
    "nextInTime": 5848, 
    "senderId": "gpiFJVJaLQU8lY22csSzbliwfnBhXGy2nkyvsFvaRb7v6Orm9bZihHjev6rjJKLBGQHtF7iM7MdjtMVUCPSqhoFJeqfnvbMWAPLoOrAfxsvjUTQ-", 
    "systemMessage": false, 
    "subject": "Re: [junit] writing testcase for data read from a file", 
    "from": "&quot;J. B. Rainsberger&quot; &lt;jbr@...&gt;", 
    "authorName": "J. B. Rainsberger", 
    "msgSnippet": "So said  Singh Manpreet  on  2002-09-24 ... I assume you mean that the method answers the contents of a file as a String. String readContents(final File file);", 
    "msgId": 5847, 
    "profile": "nails762", 
    "topicId": 5818, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 89240252, 
    "messageBody": "<div id=\"ygrps-yiv-605354208\">So said  Singh Manpreet  on  2002-09-24 <br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;Hi Rainsberger,<br/>\n&gt;<br/>\n&gt;&gt; How do you know whether your method works? What<br/>\n&gt;&gt; would you do to verify<br/>\n&gt;&gt; for yourself that the method reads the data<br/>\n&gt;&gt; correctly? Explain that in<br/>\n&gt;&gt; words and we can convert it to code.<br/>\n&gt;<br/>\n&gt;The method which i want to test returns the file as a<br/>\n&gt;String object.<br/>\n<br/>\n </span></blockquote>I assume you mean that the method answers the contents of a file as a<br/>\nString.<br/>\n<br/>\n     String readContents(final File file);<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Now, i was thinking if i have to test<br/>\n&gt;what is read from the file, in the testcase i would<br/>\n&gt;again be reading from the file. The contents read from<br/>\n&gt;the file would be converted to String which would be<br/>\n&gt;compared to the value returned by the method for which<br/>\n&gt;the testcase is being written (sorry no TFD). But i<br/>\n&gt;found it to be weird idea, so i asked the question :-)<br/>\n<br/>\n </span></blockquote>In this case, you could do this:<br/>\n<br/>\npublic void testReadContents() {<br/>\n    final File newFile = new File(&quot;newfile.txt&quot;);<br/>\n    assertFalse(newFile.exists());<br/>\n    final FileOutputStream newFileOutputStream = new<br/>\nFileOutputStream(newFile);<br/>\n    final PrintWriter out = new PrintWriter(newFileOutputStream);<br/>\n    final String contents = &quot;blah&quot;;<br/>\n    out.print(blah);<br/>\n    newFileOutputStream.flush();<br/>\n    newFileOutputStream.close();<br/>\n<br/>\n    assertEquals(contents, readContents(newFile));<br/>\n<br/>\n    // delete newFile in tearDown()<br/>\n}<br/>\n<br/>\nWrite the file with known contents, then compare those known contents<br/>\nwith the answer from &#39;readContents&#39;.<br/>\n<br/>\nNow ask yourself, what are you really testing? In this test, we test<br/>\nthe following:<br/>\n<br/>\n* File.exists() correctly identifies whether a file exists, so that I<br/>\ndon&#39;t accidentally overwrite an existing file.<br/>\n* FileOutputStream and PrintWriter correctly write my String out to the<br/>\nfile.<br/>\n* readContents reads the file contents correctly.<br/>\n<br/>\nThat&#39;s too much to test at once. It relies too much on the file system,<br/>\nand you should probably assume that the file system works.<br/>\n<br/>\nWhat do you really want to test? It&#39;s simple: the JDK doesn&#39;t include a<br/>\nlibrary call to return the contents of a text file as a String. The<br/>\nclosest thing it does it return the contents of a text file,<br/>\nline-by-line. Your job is to construct the lines into a String with the<br/>\nproper line separator. Perhaps you should just test that!<br/>\n<br/>\nOK, your job may also include handling the exceptions thrown by<br/>\nBufferedFileReader, which are all IOExceptions, as I recall. Test that,<br/>\ntoo!<br/>\n<br/>\nYou can do both without involving the file system. That makes your<br/>\ntests faster and more focussed on testing the code *you* write and not<br/>\nthe code already written by others in the JDK. Much better!<br/>\n<br/>\n    testHandleFileNotFound<br/>\n    testHandleIoExceptionWhileReading<br/>\n    testJoinLines_EmptyLineSet<br/>\n    testJoinLines<br/>\n<br/>\nThose four tests ought to do it. Now readContents does this:<br/>\n<br/>\nString readContents(final File file) throws IOException {<br/>\n    final BufferedReader reader = new BufferedReader(new<br/>\nFileInputStream(file));<br/>\n    final List lines = new ArrayList();<br/>\n    while (true) {<br/>\n        final String line = reader.readLine();<br/>\n        if (line == null) { break; }<br/>\n        lines.add(line);        <br/>\n    }<br/>\n    return joinLines(lines, System.getProperty(&quot;line.separator&quot;,<br/>\n&quot;&#92;n&quot;));<br/>\n}<br/>\n<br/>\nYou write joinLines and test it, or find it from a library. If<br/>\nnecessary, you test how to handle the exceptions.<br/>\n<br/>\nYou may consider the act of reading all the lines in a file and storing<br/>\nthem in a list something worth testing. I don&#39;t. If you do want to test<br/>\nit, instead do something like this:<br/>\n<br/>\ninterface LineProvider {<br/>\n    String readLine() throws IOException;<br/>\n}<br/>\n<br/>\nclass FileLineProvider implements LineProvider {<br/>\n    File file;<br/>\n<br/>\n    FileLineProvider(File file) {<br/>\n        this.file = file;<br/>\n    }<br/>\n<br/>\n    String readLine() throws IOException {<br/>\n        return getBufferedReader().readLine();<br/>\n    }<br/>\n<br/>\n    BufferedReader getBufferedReader() throws IOException {<br/>\n        // lazily instantiate BufferedReader<br/>\n    }<br/>\n}<br/>\n<br/>\nclass StringLineProvider implements LineProvider {<br/>\n    List strings;<br/>\n    Iterator iterator;<br/>\n<br/>\n    FileLineProvider(List strings) {<br/>\n        this.strings = new ArrayList(strings);<br/>\n        iterator = this.strings.iterator();<br/>\n    }<br/>\n<br/>\n    String readLine() {<br/>\n        if (iterator.hasNext()) {<br/>\n            return (String) iterator.next();<br/>\n        }<br/>\n        else {<br/>\n            return null;<br/>\n        }<br/>\n    }<br/>\n}<br/>\n<br/>\nUse StringLineProvider in the test and FileLineProvider in production.<br/>\nNow you have<br/>\n<br/>\nString readContents(LineProvider lineProvider) {<br/>\n    final List lines = new ArrayList();<br/>\n    while (true) {<br/>\n        final String line = lineProvider.readLine();<br/>\n        if (line == null) { break; }<br/>\n        lines.add(line);        <br/>\n    }<br/>\n    return joinLines(lines, System.getProperty(&quot;line.separator&quot;,<br/>\n&quot;&#92;n&quot;));<br/>\n}<br/>\n<br/>\nEven better would be to have LineProvider provide the collection of<br/>\nlines. The loop, after all, only talks to lineProvider.<br/>\n<br/>\nabstract class LineProvider {<br/>\n    LineProvider() {}<br/>\n<br/>\n    abstract String readLine() throws IOException;<br/>\n    <br/>\n    List readContents() {<br/>\n        final List lines = new ArrayList();<br/>\n        while (true) {<br/>\n            final String line = lineProvider.readLine();<br/>\n            if (line == null) { break; }<br/>\n            lines.add(line);        <br/>\n        }<br/>\n        return lines;<br/>\n    }<br/>\n}<br/>\n<br/>\n// Change implementors to be subclasses, now.<br/>\n<br/>\nString readContents(LineProvider lineProvider) {<br/>\n    return joinLines(lineProvider.readContents(),<br/>\nSystem.getProperty(&quot;line.separator&quot;, &quot;&#92;n&quot;));<br/>\n}<br/>\n<br/>\nNow readContents(LineProvider) can&#39;t possibly break -- all it does is<br/>\ndelegate! If joinLines and lineProvider.readContents() work, you&#39;re<br/>\nfree.<br/>\n<br/>\nI know you can get joinLines from a library, so don&#39;t test that.<br/>\n<br/>\nTesting readContents is easy, because it just puts stuff in a list. Two<br/>\nor three tests should cover it.<br/>\n<br/>\nIn fact, I&#39;d love to just have an Iterator-style interface for this and<br/>\nbe done with it. LineProvider is really just an Iterator. I should<br/>\nwrite that, stick in a library on SourceForge and then you have nothing<br/>\nleft to do!<br/>\n<br/>\nTake care.<br/>\n<br/>\nJ. B. Rainsberger,<br/>\nPresident, Diaspar Software Services<br/>\nLet&#39;s write software that people understand.<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.diasparsoftware.com/\">http://www.diasparsoftware.com/</a><br/>\ntelephone: +1 416 791-8603<br/>\nAll correspondence (c) 2002 Diaspar Software Services.<br/>\nIf you want to use it, just ask; don&#39;t steal.</div>", 
    "prevInTime": 5846, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1032899551", 
    "canDelete": false, 
    "nextInTopic": 5866, 
    "prevInTopic": 5839, 
    "headers": {
        "inReplyToHeader": "PDIwMDIwOTI0MDk0MDAwLjQzMzEwLnFtYWlsQHdlYjEzOTAyLm1haWwueWFob28uY29tPg==", 
        "messageIdInHeader": "PDIwMDIwOTI0MTYzMjMxMDczMS4wMDg5QzMyOEBzbXRwPg==", 
        "referencesHeader": "PDIwMDIwOTI0MDk0MDAwLjQzMzEwLnFtYWlsQHdlYjEzOTAyLm1haWwueWFob28uY29tPg=="
    }
}