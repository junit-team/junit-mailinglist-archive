{
    "numMessagesInTopic": 16, 
    "nextInTime": 8381, 
    "senderId": "lPLC6aZwdM5cb96XP_yPsWMJhYiT6DME3oHl1uMgTz9CVrdpryo-BoQ0hHtJfhhndYQazXtUtiZ_BZL84ya83Ey0IrweqChjPQgK2FDVwQ", 
    "systemMessage": false, 
    "subject": "RE: [junit] Re: Fork each test method?", 
    "from": "&quot;Robert DiFalco&quot; &lt;rdifalco@...&gt;", 
    "authorName": "Robert DiFalco", 
    "msgSnippet": "... object , ... nuance ... No, I don t think so. It is exactly the same. My issue is exposing much of the state of the object called Runtime to reset it s", 
    "msgId": 8380, 
    "rawEmail": "Return-Path: &lt;rdifalco@...&gt;\r\nReceived: (qmail 50760 invoked from network); 18 Jun 2003 01:16:51 -0000\r\nReceived: from unknown (66.218.66.218)\n  by m2.grp.scd.yahoo.com with QMQP; 18 Jun 2003 01:16:51 -0000\r\nReceived: from unknown (HELO n6.grp.scd.yahoo.com) (66.218.66.90)\n  by mta3.grp.scd.yahoo.com with SMTP; 18 Jun 2003 01:16:51 -0000\r\nX-eGroups-Return: rdifalco@...\r\nReceived: from [66.218.67.191] by n6.grp.scd.yahoo.com with NNFMP; 18 Jun 2003 01:16:05 -0000\r\nX-Sender: rdifalco@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (qmail 75835 invoked from network); 18 Jun 2003 00:10:04 -0000\r\nReceived: from unknown (66.218.66.218)\n  by m15.grp.scd.yahoo.com with QMQP; 18 Jun 2003 00:10:04 -0000\r\nReceived: from unknown (HELO mail.tripwire.com) (12.33.17.140)\n  by mta3.grp.scd.yahoo.com with SMTP; 18 Jun 2003 00:10:04 -0000\r\nReceived: from seabass.tripwire.com (unverified [10.1.1.24]) by mail.tripwire.com\n (Content Technologies SMTPRS 4.3.6) with ESMTP id &lt;T62e328642dc0a8c0054a8@...&gt; for &lt;junit@yahoogroups.com&gt;;\n Tue, 17 Jun 2003 17:11:10 -0700\r\nX-MimeOLE: Produced By Microsoft Exchange V6.0.6249.0\r\ncontent-class: urn:content-classes:message\r\nMIME-Version: 1.0\r\nContent-Type: text/plain;\n\tcharset=&quot;us-ascii&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\nSubject: RE: [junit] Re: Fork each test method?\r\nDate: Tue, 17 Jun 2003 17:10:03 -0700\r\nMessage-ID: &lt;CFDDEB3B870EE346BB583D2B0420F5AC0101E859@...&gt;\r\nX-MS-Has-Attach: \r\nX-MS-TNEF-Correlator: \r\nThread-Topic: [junit] Re: Fork each test method?\r\nThread-Index: AcM1LA6Rl44TtYSRQJyBsxgk3NKUbAAALobQ\r\nTo: &lt;junit@yahoogroups.com&gt;\r\nFrom: &quot;Robert DiFalco&quot; &lt;rdifalco@...&gt;\r\nX-Yahoo-Group-Post: member; u=35850082\r\nX-Yahoo-Profile: robert_difalco\r\nX-eGroups-Approved-By: vbossica &lt;vladimir@...&gt; via web; 18 Jun 2003 01:16:03 -0000\r\n\r\n&gt;&gt; How is &quot;create a new runtime instance&quot; different from &quot;create a new\nobje=\r\nct&quot;,\n&gt;&gt; since an object is just a runtime instance of a class? There is som=\r\ne\nnuance\n&gt;&gt; in what you&#39;re saying that I can&#39;t see.\n\nNo, I don&#39;t think so. =\r\nIt is exactly the same. My issue is exposing much\nof the state of the objec=\r\nt called Runtime to reset it&#39;s state when what\nyou really want to do is jus=\r\nt create a new object that hides it&#39;s\ndetails of initialization. To me, thi=\r\ns is why a unit testing framework\nshould run each test in a new runtime. Ot=\r\nherwise, we have to break\ncontracts or create (to me) overly complicated co=\r\nde to violate the state\nof the object, and arbitrarily reset it from an ext=\r\nernal client.\n\nBasically, I agree with everything you said. But maybe not t=\r\nhis part:\n\nclass Something\n    Something()\n        this(ClassRegistry.ident=\r\nify(Foo.class))\n\n    Something(identity)\n        // store in instance-level=\r\n variable\n\nI suppose it really depends on Something. Is this meta-state or =\r\nis it\ninstance state? In my example, it was a static because this is a deta=\r\nil\nof Something that is shared across all it&#39;s instances. Now, if we had\nre=\r\nal MetaClasses in Java we might do something different -- say, create\na Som=\r\nethingClass that IS designed as you propose. In this case, however,\ninitial=\r\nizing the class initializes the Identity that is to be used by\nall instance=\r\ns of Something.\n\nSo, I suppose where we differ is that I think a fresh Runt=\r\nime instance\nshould be achieved &quot;the same way each time&quot; -- through creatio=\r\nn. I feel\nI am introducing the possibility for a bug by allowing methods th=\r\nat\nreset state that only exist for testing. I could be wrong, but I believe=\r\n\nyou are saying systems should be design so that one can reset it&#39;s state\nt=\r\nhrough some external actor at any time.\n\nAnd I agree that testing is very i=\r\nmportant, which is why I would like a\nnew runtime for each test method, eve=\r\nn though that would slow down the\nexecution of tests. It&#39;s just that import=\r\nant to me to have a unit\ntesting framework with no side-effects between tes=\r\nt methods.\n\nR.\n\n-----Original Message-----\nFrom: J. B. Rainsberger [mailto:=\r\njbrains@...] \nSent: Tuesday, June 17, 2003 4:56 PM\nTo: junit@yahoogr=\r\noups.com\nSubject: RE: [junit] Re: Fork each test method?\n\n\n&gt;So said Robert =\r\nDiFalco on 2003-06-17 --------------------\n&gt;&gt;&gt; I would think that the easie=\r\nst way to zero out all the caches is to \n&gt;&gt;&gt; create new cache objects.\n&gt;\n&gt;N=\r\no, not really. I don&#39;t expect to be able to convince you but if you \n&gt;have =\r\ncaches, or thread pools, or whatever that &quot;are scoped to the \n&gt;runtime inst=\r\nance they were created in&quot;, the easiest and in fact the \n&gt;most correct way =\r\nto reinitialize them is to create a new runtime \n&gt;instance.\n\nI don&#39;t unders=\r\ntand how what you said is different from what I said.\n\nHow is &quot;create a new=\r\n runtime instance&quot; different from &quot;create a new\nobject&quot;, since an object is=\r\n just a runtime instance of a class? There is\nsome nuance in what you&#39;re sa=\r\nying that I can&#39;t see. If you have the\nenergy, help me understand what that=\r\n is.\n\n&gt;The saddest thing is that there is no reason in production to &quot;zero =\r\nout\n\n&gt;all caches&quot;. Even having such a method indicates (to me) a design fla=\r\nw.\n\n&gt;After all, I don&#39;t expect the value of an immutable object (say an\n&gt;In=\r\nteger) to suddenly change during the life of that object.\n\nI&#39;m not sure wha=\r\nt the former has to do with the latter. I agree with\nyour statement. This i=\r\ns one motivation for keeping from my objects the\ndetails of whether they ar=\r\ne collaborating with caches. In J2EE we may\nwant to cache the result of a J=\r\nNDI lookup. One way to do this is\nabstract away the lookup into a generic o=\r\nbject factory. At test time, we\nuse an in-memory object factory; at product=\r\nion time, we use an object\nfactory backed by JNDI. Everyone wins.\n\n&gt;&gt;&gt; If a=\r\n class uses a cache, then that class should either accept the \n&gt;&gt;&gt; cache fr=\r\nom the outside world or be unaware that it&#39;s using a cache \n&gt;&gt;&gt; at all.\n&gt;\n&gt;=\r\nYou are working too hard at this.\n\nI appreciate your concern. (Not sarcasm:=\r\n it&#39;s nice to know that your\ngoal is to help, and not just puff your chest.=\r\n Many others are guilty of\nthe latter.)\n\n&gt;Things seem simpler to me. For\n&gt;e=\r\nxample, from what you say I am going to assume that you never use \n&gt;string =\r\nconstants in your code.\n\nWell, I never do anything the same way all the tim=\r\ne. Everything depends.\nIn particular, I externalize strings when it makes s=\r\nense, and I don&#39;t\nwhen it doesn&#39;t. I first have to see the pattern or be to=\r\nld by a\ncustomer that the data in question is volatile.\n\n&gt;There isn&#39;t that =\r\nmuch of a difference. I\n&gt;suppose you use a decorator that caches strings an=\r\nd then you make a \n&gt;call on each access of the string (possibly looking in =\r\na map?) instead \n&gt;of simply caching the constant string reference as a stat=\r\nic final?\n\nI don&#39;t see a need for that right now. It depends whether the st=\r\nring\nneeds to change. If the string doesn&#39;t need to change, then I put it i=\r\nn\nthe code until I see evidence that it needs to change.\n\n&gt; Really,\n&gt;there =\r\nis no difference between that and this:\n&gt;\n&gt;class Something\n&gt;{\n&gt;     private=\r\n static final Identity FOO_CLASS_ID =3D \n&gt;ClassRegistry.identify( Foo.class=\r\n );\n&gt;\n&gt;     ...\n&gt;}\n&gt;\n&gt;FOO_CLASS_ID is scoped to the runtime instance it was=\r\n created in.\n\nI think this is the big difference. I have the tendency to bu=\r\nild classes\nand interfaces that collaborate with one another and let the ap=\r\nplication\ncontext (or component runtime context, whatever it is) decide how=\r\n to\nbind runtime objects to one another. So in my code there are relatively=\r\n\nfew cases where an object manages the lifecycle of other objects.\n\nIn part=\r\nicular, FOO_CLASS_ID would be a parameter to Something&#39;s\nconstructor. If th=\r\ne production code wants to use a ClassRegistry to get\nFOO_CLASS_ID, then th=\r\nat&#39;s cool; but if Something only depends on having\na FOO_CLASS_ID, then why=\r\n should it care where the FOO_CLASS_ID came\nfrom? I don&#39;t see the benefit t=\r\nhere.\n\nYou are saying, &quot;This is the simplest place to put that code.&quot; I\ndis=\r\nagree. It&#39;s the easiest, but not necessarily the simplest. What if\nthe appl=\r\nication doesn&#39;t want Something to identify Foo.class as the\nmeans of gettin=\r\ng a FOO_CLASS_ID? What if the application needs to\nprovide that data?\n\nOf c=\r\nourse, I can take my own advice and deal with that when it happens,\nbut I p=\r\nractice TDD, and in so doing, would tend not to write the code\nyou&#39;ve writt=\r\nen there. No value judgment: just a difference in approach.\n\n&gt;It is\n&gt;immuta=\r\nble for the life of the runtime. These may be generated by a \n&gt;database, cr=\r\neated by a synchronized static int, GUID generator or \n&gt;whatever. It doesn&#39;=\r\nt really matter. The contract is that they are good \n&gt;for the life of the R=\r\nuntime. So it makes sense to hide them just as you\n\n&gt;would any other immuta=\r\nble constant -- say a string. The only reason to \n&gt;impose a hash look up on=\r\n every access is, well, I dunno. For testing?\n\nFirst, don&#39;t underestimate t=\r\nhe importance of testing. Testing is damn\nimportant.\n\nYou want to Something=\r\n to hide the way it gets a FOO_CLASS_ID because all\nthat matters is the val=\r\nue: once Something gets the FOO_CLASS_ID, it\ndoesn&#39;t matter how it did that=\r\n. I can&#39;t argue with that. If the system\nonly says this once, then it matte=\r\nrs less where the system says it.\n\nHowever, I claim that by splitting Somet=\r\nhing into Something and\nFooClassIdFactory, I can add only a little complexi=\r\nty but gain the real\nbenefit of making Something easier to test. Here is ho=\r\nw I would do it.\n\nclass Something\n    Something()\n        this(ClassRegistr=\r\ny.identify(Foo.class))\n\n    Something(identity)\n        // store in instanc=\r\ne-level variable\n\nThe default behavior of Something is to use the ClassRegi=\r\nstry to create\nFOO_CLASS_ID, but in my tests, I can just provide whatever d=\r\nata is\neasiest for the tests to provide.\n\nThis is an extremely small amount=\r\n of complexity to add to gain the\nbenefit of testing. Of course, if you don=\r\n&#39;t value testing the same way I\ndo, then you won&#39;t be moved by this. That&#39;s=\r\n fine: do as you find best,\nas will I.\n\n&gt;Now, if you suddenly invalidate th=\r\nose identities or flush the \n&gt;ClassRegistry, you are in deep trouble. What =\r\nis the simplest solution? \n&gt;&quot;Don&#39;t do that.&quot; What is the most complicated s=\r\nolution? &quot;Create a bunch\n\n&gt;of rigging that has no value save for unit tests=\r\n that are unable to \n&gt;create new runtime instances on each run.&quot; Think abou=\r\nt it. Details and \n&gt;Abstraction are one thing, this is another.\n\nYou&#39;re rig=\r\nht. This is another. This is straightforward separation of\nresponsibilities=\r\n. Something just needs an Identity. It shouldn&#39;t much\nmatter where the Iden=\r\ntity comes from. For that reason, Something should\nbe willing to take whate=\r\nver Identity I give it, if I want to give it\none; otherwise, it can use the=\r\n one it wants to use.\n\n&gt;For me, there is nothing\n&gt;worse than seeing designs=\r\n that are overly complicated (obfuscated in\n&gt;fact) for no other reason than=\r\n to serve a principle. Liskov \n&gt;Substitution, Law of Demeter, Coupling and =\r\nCohesion, Shunts, Mock \n&gt;Objects, Decorators....these are all good and wond=\r\nerful things.  All \n&gt;important tools. However, they are capable of improvin=\r\ng code or making \n&gt;code horribly obfuscated and ugly. At this point in its =\r\nevolution, \n&gt;programming is much more like music than science. You can kill=\r\n the feel\n\n&gt;of the code by being too pedantic.\n\nNo argument here: I am guil=\r\nty of using good tools to build bad ashtrays.\nWe all are. We have to take c=\r\nare, though, not to become neo-Luddites,\ndeciding that the tools are the re=\r\nason we built bad ashtrays. That was\nus. We should practise with the tools.=\r\n\n\n&gt;Google &quot;Simplicity&quot;.\n\nSometimes people mistake simplicitly and ease. I&#39;m=\r\n not saying that\nyou&#39;re doing it, but it happens. Here is how my code tends=\r\n to evolve.\n\n1. Implement a few hardcoded concrete cases.\n2. Identify the a=\r\nbstractions by looking at common code.\n3. Extract the abstractions into beh=\r\navioral classes; push the difference\ninto data classes. 4. Decide whether t=\r\no move the values of the data\nclasses outside the system into data files of=\r\n some sort. Rinse and\nrepeat, as needed.\n\nThe result is a bunch of collabor=\r\nating engines and, surprisingly, less\ncode. Also increased flexibility with=\r\nout obscene complexity. (Some\ncomplexity, yes; but then a system without co=\r\nmplexity may not do much of\nanything useful.) I don&#39;t think that&#39;s being &quot;p=\r\nedantic&quot;. When I feel\nthat the code is becoming too complex, I have to step=\r\n back away from the\nkeyboard and think a little. I have to throw away what =\r\nI&#39;ve done and try\nagain. The result is usually better. Sometimes banging ou=\r\nt a silly\nsolution is a good tool to finding a better one.\n\nTake care.\n\n\nJ.=\r\n B. Rainsberger,\nPresident, Diaspar Software Services\nLet&#39;s write software =\r\nthat people understand.\nhttp://www.diasparsoftware.com/\ntelephone: +1 416 7=\r\n91-8603\n\n\n\nTo unsubscribe from this group, send an email to:\njunit-unsubscr=\r\nibe@yahoogroups.com\n \n\nYour use of Yahoo! Groups is subject to\nhttp://docs.=\r\nyahoo.com/info/terms/ \n\n\n\n\n", 
    "profile": "robert_difalco", 
    "topicId": 8358, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 35850082, 
    "prevInTime": 8379, 
    "contentTrasformed": false, 
    "postDate": "1055895003", 
    "canDelete": false, 
    "nextInTopic": 8430, 
    "prevInTopic": 8379, 
    "headers": {
        "messageIdInHeader": "PENGRERFQjNCODcwRUUzNDZCQjU4M0QyQjA0MjBGNUFDMDEwMUU4NTlAc2VhYmFzcy50cmlwd2lyZS5jb20+"
    }
}