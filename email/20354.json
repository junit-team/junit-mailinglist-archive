{
    "numMessagesInTopic": 2, 
    "nextInTime": 20355, 
    "senderId": "gZBHzNKYm4vM5rrfX5ljE5tGXJlvnCML8K-2-1HPOxZNkeT6CZ4JlA4w8DiH3XwjQC5U2gl1GJ6vTP4dqsZjnOr4LNTK-Kio", 
    "systemMessage": false, 
    "subject": "Re: [junit] Recording method calls and their return values like recording makros", 
    "from": "&quot;Nat Pryce&quot; &lt;nat.pryce@...&gt;", 
    "authorName": "Nat Pryce", 
    "msgSnippet": "... This will result in very brittle tests because it will overly constrain the number and order of calls and exact parameter values, many of which will be", 
    "msgId": 20354, 
    "profile": "nat_pryce", 
    "topicId": 20353, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 216973656, 
    "messageBody": "<div id=\"ygrps-yiv-1771300342\">On 04/03/2008, name zero &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:namezero911@...\">namezero911@...</a>&gt; wrote:<br/>\n<blockquote><span title=\"ireply\"> &gt;  What I am looking for is a way to &quot;record&quot; (like recording macros in M$ Office) all interactions with a specific class (including all its methods), which means that it records the invoked method calls itself, the parameters, as well as the returned result(object)s. The workflow would be easy: I make sure that the database layer and the layer I want to test works (it has to call the correct database-layer methods) and then I run the test in &quot;record-mode&quot;. After that I can start the tests in replay mode, I don&#39;t need to use the database object itself anymore but instead the cached results are returned, however, still with the mock-object characteristics (if the methods of the mockobject aren&#39;t called in the correct order or with wrong parameters I would get an exception).<br/>\n<br/>\n<br/>\n </span></blockquote>This will result in very brittle tests because it will overly<br/>\nconstrain the number and order of calls and exact parameter values,<br/>\nmany of which will be irrelevant to the test.  Any change to your<br/>\nobjects will then break your tests for no real reason.<br/>\n<br/>\nIf you&#39;re worried about performance, you could use an in-memory<br/>\ndatabase (E.g. HSQLDB, <a rel=\"nofollow\" target=\"_blank\" href=\"http://hsqldb.org/)\">http://hsqldb.org/)</a> for testing instead of mock<br/>\nobjects.<br/>\n<br/>\nMock objects are tool for test *driven* development.  They help you<br/>\ndesign the communication protocols between your objects.  JMock has<br/>\nmany features that let you describe a protocol to be followed in a<br/>\ntest, not the exact sequence of calls that will occur.  E.g. you can<br/>\nallow or ignore some calls, expect a minimum number of calls, loosen<br/>\nconstraints on parameter values or ignore parameters altogether,<br/>\nexpect calls to occur only when the object is in a specific state, and<br/>\nso on.<br/>\n<br/>\nIn my experience, the result of using mock objects in TDD is an OO<br/>\ndesign in which objects are loosely coupled, talk in a &quot;Tell, Don&#39;t<br/>\nAsk&quot; style and the inter-object protocols are an important aspect of<br/>\nthe design.  In a system that has been written without tests and mock<br/>\nobjects (again, in my experience), classes are more tightly coupled,<br/>\nthere are many static functions and objects have many getters and<br/>\nsetters.  This style of code does not lend itself well to testing with<br/>\nmock objects.<br/>\n<br/>\n--Nat</div>", 
    "prevInTime": 20353, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1204705131", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 20353, 
    "headers": {
        "inReplyToHeader": "PDkyOTc0NS40NTEyOC5xbUB3ZWI1NDEwNy5tYWlsLnJlMi55YWhvby5jb20+", 
        "messageIdInHeader": "PDE3ZmE1M2QwODAzMDUwMDE4cDdmYTBiYzNjZ2E1YTAwNmM2ODNjNjgwMWJAbWFpbC5nbWFpbC5jb20+", 
        "referencesHeader": "PDkyOTc0NS40NTEyOC5xbUB3ZWI1NDEwNy5tYWlsLnJlMi55YWhvby5jb20+"
    }
}