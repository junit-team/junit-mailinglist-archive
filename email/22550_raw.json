{
    "numMessagesInTopic": 23, 
    "nextInTime": 22551, 
    "senderId": "GsWhjxGW7XZYUfSHrN7b0fVsAVqhgLdO_UjCDTEE8m91qebQBOqFwfTulqmoJlnSnGBI64vzJf3OOTONPnem2Sr7DePd-0VlqKsi", 
    "systemMessage": false, 
    "subject": "RE: [junit] Re: @DataPoints called several times for Theories", 
    "from": "Tan Shin Hwei &lt;shinhwei@...&gt;", 
    "authorName": "Tan Shin Hwei", 
    "msgSnippet": "David, Berin, Mike and Brett, Thanks for all the helpful comments. Regarding the default CloneStrategy, Sang and I started with the following strategies: 1.", 
    "msgId": 22550, 
    "rawEmail": "Return-Path: &lt;david@...&gt;\r\nReceived: (qmail 18755 invoked by uid 7800); 15 Mar 2010 20:30:02 -0000\r\nX-Sender: shinhwei@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nX-Received: (qmail 5555 invoked from network); 15 Mar 2010 20:27:25 -0000\r\nX-Received: from unknown (66.196.94.107)\n  by m12.grp.re1.yahoo.com with QMQP; 15 Mar 2010 20:27:25 -0000\r\nX-Received: from unknown (HELO snt0-omc1-s37.snt0.hotmail.com) (65.55.90.48)\n  by mta3.grp.re1.yahoo.com with SMTP; 15 Mar 2010 20:27:25 -0000\r\nX-Received: from SNT125-W9 ([65.55.90.9]) by snt0-omc1-s37.snt0.hotmail.com with Microsoft SMTPSVC(6.0.3790.3959);\n\t Mon, 15 Mar 2010 13:27:08 -0700\r\nMessage-ID: &lt;SNT125-W99F30F3457B2F3E6279BDC02E0@...&gt;\r\nTo: &lt;junit@yahoogroups.com&gt;\r\nDate: Mon, 15 Mar 2010 15:27:07 -0500\r\nImportance: Normal\r\nIn-Reply-To:\n &lt;75F5ED8A5A553646A46E00E6EC854FA30378C7EE@...-ais.com&gt;\r\nReferences:\n &lt;58dba2251002180943q238dd8dv11ab48736321e178@...&gt;&lt;hlkif2+3mte@...&gt;&lt;58dba2251003121544p3cd7dd28h1a899ce657f66ad3@...&gt;&lt;a527fddf1003140915l73761ee1r781ba20fc768e42e@...&gt;&lt;75F5ED8A5A553646A46E00E6EC854FA30378C7E4@...-ais.com&gt;&lt;4f7da6b91003150651m12f2796kf9aab17ff312cd93@...&gt;\n &lt;58dba2251003151056k4bf24ff2xf161e6415abf4aba@...&gt;,&lt;75F5ED8A5A553646A46E00E6EC854FA30378C7EE@...-ais.com&gt;\r\nMIME-Version: 1.0\r\nX-OriginalArrivalTime: 15 Mar 2010 20:27:08.0049 (UTC) FILETIME=[E2527010:01CAC47D]\r\nX-eGroups-Msg-Info: 2:4:8:0:0\r\nFrom: Tan Shin Hwei &lt;shinhwei@...&gt;\r\nSubject: RE: [junit] Re: @DataPoints called several times for Theories\r\nX-Yahoo-Group-Post: member; u=271559074; y=aoFfNFKT7qyq2O1Xs2GNAHOqTazrTKGjDTEQbbq7O3cxAQMCMHY\r\nX-Yahoo-Profile: tanshinhwei\r\nContent-Type: text/plain\r\nContent-Transfer-Encoding: quoted-printable\r\nX-eGroups-Approved-By: dsaff &lt;david@...&gt; via email; 15 Mar 2010 20:30:02 -0000\r\n\r\n\nDavid, Berin, Mike and Brett,\n\nThanks for all the helpful comments. \n\nRega=\r\nrding the default CloneStrategy, Sang and I started with the following stra=\r\ntegies:\n1. Strategy for Collection Class\n2. Using the clone() method for Da=\r\ntaPoint(s) that implements Cloneable\n3. Using Interfaces of DataPoint(s)\n4.=\r\n Using the copy constructor of the DataPoint(s) class\n5. Using the copy con=\r\nstructor of the super class of the DataPoint.\n\nBelow is the method that con=\r\ntains the CloneableStrategy:\n\npublic Object copyDataPoint(Object toBeReplic=\r\nated) throws Exception {\n        try {\n            Method method=3D toBeRep=\r\nlicated.getClass().getMethod(&quot;clone&quot;,\n                    new Class[0]);\n  =\r\n          //invoke the clone method \n            return method.invoke(toBeR=\r\neplicated, new Object[0]);\n        } catch (Exception e) {\n            thro=\r\nw new CopyStrategyFailureException();\n        }\n    }\n\nWhen we implemented =\r\nthe above default strategies, we had a hard time in deciding which strategy=\r\n should be used first. I think the same problem will occur if both copy con=\r\nstructor and cloning are available. In that case, I think the user should b=\r\ne able to chose the desired strategy.  \n\nBerin mentioned the performance is=\r\nsue within the method getCopyStrategyInvokedObject. I agree that creating a=\r\n new instance for every object will have a significant impact on performanc=\r\ne. I will discuss it with Sang and try to fix the problem.\n\nTo: junit@yahoo=\r\ngroups.com; junit@yahoogroups.com\nFrom: berin.loritsch@...\nDate: Mon=\r\n, 15 Mar 2010 14:54:12 -0400\nSubject: RE: [junit] Re: @DataPoints called se=\r\nveral times for Theories\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n  \n\n\n    \n      \n      \n   =\r\n   This is a good dialog.  Personally, and academically, I think using Iter=\r\nable&lt;?&gt; would be much better than arrays for @Datapoints.  That would avoid=\r\n the toArray(new Mutable[collection.size()]) I would have to create and red=\r\nuce the number of objects in the garbage collector.  I guess that would put=\r\n me on your side with that particular approach.  BTW, arrays are iterable..=\r\n.  I do create data dynamically for testing theories, particularly if I am =\r\ntesting interface contracts.\n\n \n\nRegarding extracting the parameters interf=\r\nace, I&#39;m not suggesting making that an API available outside the core.  I&#39;m=\r\n suggesting a little DRY (Don&#39;t Repeat Yourself) to have a class that is re=\r\nsponsible for collecting the raw data points (calling the @DataPoint and @D=\r\nataPoints once), and copying them as necessary to satisfy the parameter set=\r\ns on the individual tests.  That same approach can theorhetically feed para=\r\nmeterized tests.  The long and short of it is that I am suggesting the chan=\r\nge for code maintenance reasons.  That would also make my feature enhanceme=\r\nnt to track each parameter set as a separate test (@Theory(runDiscretely=3D=\r\ntrue)) a bit easier to implement.\n\n \n\nI think it would be reasonable to inc=\r\nlude the CloneableStrategy along with the solution.  That way, you have cus=\r\ntom copy strategies, a cloning copy strategy, and I guess the default would=\r\n be an identity strategy (i.e. not copying at all).\n\n \n\nWith your code exam=\r\nple and the current implementation, if the datapoints are defined in the @D=\r\nataPoints method then you have a fresh instance of each data point--even wh=\r\nen the values are identical.  That&#39;s due to the bug that I mentioned.  The =\r\n@DataPoints is called the first time, and for each data point, it is called=\r\n again to make the combinations.  Using an identity copy strategy (i.e. not=\r\n copying) will introduce problems with mutable data types.\n\n\n\n_____________=\r\n___________________\n\n\n\nFrom: junit@yahoogroups.com on behalf of Brett Danie=\r\nl\n\nSent: Mon 3/15/2010 1:56 PM\n\nTo: junit@yahoogroups.com\n\nSubject: Re: [ju=\r\nnit] Re: @DataPoints called several times for Theories\n\n\n\nDavid, Berin, and=\r\n Mike,\n\n\n\nThank you very much for the great comments. I have asked Shin Hwe=\r\ni and Sang\n\nto provide their thoughts, but until then, here are my answers =\r\nto your\n\nspecific questions (SH&S will correct me if I get anything wrong).=\r\n\n\n\n\nDavid wrote...\n\n&gt; do you agree the below would work with the current im=\r\nplementation\n\n&gt; of Theories? It&#39;s four lines more of boilerplate, but not t=\r\notally\n\nintractable\n\n\n\nYou are correct that copying within a @Datapoint met=\r\nhod would create a new\n\ndata point as needed and would probably be a good w=\r\norkaround for Berin&#39;s\n\nbug. However, I see two drawbacks in addition to tho=\r\nse you mention. First,\n\none would need to include the copy invocation in ev=\r\nery @DataPoint method\n\nthat used createdOnce. In contrast, annotating the @=\r\nDataPoint itself would\n\nprovide all consumers with pristine values. Second,=\r\n the solution fails when\n\nusing @DataPoints with a theory that takes multip=\r\nle parameters:\n\n\n\nprivate static Mutable[] createdOnce =3D new Mutable[] {\n=\r\n\nnew Mutable(),\n\nnew Mutable() };\n\n\n\n@DataPoints()\n\npublic static Mutable[]=\r\n mutables() {\n\nreturn new Mutable[] {\n\nnew Mutable(createdOnce[0]),\n\nnew Mu=\r\ntable(createdOnce[1])\n\n};\n\n}\n\n\n\n@Theory\n\npublic void testNotMutated(Mutable=\r\n a, Mutable b) {\n\nassertFalse(a.isMutated);\n\na.mutate();\n\nassertFalse(b.isM=\r\nutated);\n\nb.mutate();\n\n}\n\n\n\nThe code above fails because a and b can be ali=\r\nases for the same object. It\n\nmay of course be desirable to run a theory on=\r\n identical instances, but in\n\nthat case, the user could make that behavior =\r\nexplicit in another theory.\n\n\n\nDavid wrote...\n\n&gt; What would you think of al=\r\nlowing fields or methods to\n\n&gt; return PontentialAssignment, the type of nam=\r\ned references to data\n\n&gt; values used in the Theories runner?\n\n...\n\n&gt; After =\r\nfurther thought, the ParameterSupplier class is even better for\n\n&gt; this kin=\r\nd of thing:\n\n\n\nDo I understand correctly that you are suggesting pulling th=\r\ne\n\nPotentialAssignment array out of the internal Theory runner and making i=\r\nt\n\navailable to developers? I seem to remember that Sang and Shin Hwei\n\nexp=\r\nerimented with modifications to the PotentialAssignment and\n\nParameterSuppl=\r\nier classes, but they can describe what they did better than\n\nI.\n\n\n\nDavid w=\r\nrote...\n\n&gt; @DataPointSource public static PotentialAssignment&lt;Mutable&gt; =3D\n=\r\n\n&gt; Copy.ofMutable(new Mutable());\n\n...\n\n&gt; @DataSupplier public static OneTy=\r\npeSupplier&lt;Mutable&gt; copyMutable =3D\n\n&gt; Copies.of(new Mutable());\n\n\n\nI like =\r\nthe idea of allowing data sources that produce things on-demand\n\nrather tha=\r\nn in a pre-constructed array of values. This gets back to a brief\n\ndiscussi=\r\non you and I had a long time ago about having the @DataPoints\n\nannotation r=\r\neturn Iterable&lt;DataPointType&gt;. That would make things like the\n\nfollowing p=\r\nossible:\n\n\n\n@DataPoints\n\npublic static Iterable&lt;Integer&gt; ints =3D Ints.betw=\r\neen(-10, 10);\n\n\n\n@DataPoints\n\npublic static Iterable&lt;Mutable&gt; mutables() {\n=\r\n\nreturn Copies.of(...);\n\n}\n\n\n\nI don&#39;t know if it is better to overload @Dat=\r\naPoints or define new\n\n@DataPointSupplier/@DataPointSource annotations.\n\n\n\n=\r\nBerin wrote...\n\n&gt; I hope we are not introducing an interface or base class =\r\nthat\n\n&gt; would be required for the data classes to implement\n\n\n\nAbsolutely n=\r\not. That is one of the benefits of defining copy strategies in\n\nthe @DataPo=\r\nint annotations: the data point classes themselves remain\n\nunchaged.\n\n\n\nBer=\r\nin wrote...\n\n&gt; Is there a default CloneStrategy available?\n\n\n\nSang and Shin=\r\n Hwei implemented several copy strategies, including one that\n\nuses clone, =\r\nbut they did not include them in the patch in an effort to\n\nreduce its size=\r\n and complexity. Would it be helpful if they pushed some\n\nexamples?\n\n\n\nBeri=\r\nn wrote...\n\n&gt; Here&#39;s a problem I spotted in the implementation:\n\n\n\nThank yo=\r\nu very much for looking so closely at Sang and Shin Hwei&#39;s code. I\n\nhave as=\r\nked them to address any bugs that you or others find.\n\n\n\nBrett\n\n\n\nOn Mon, M=\r\nar 15, 2010 at 8:51 AM, David Saff &lt;david@... &lt;mailto:david%40saff.net=\r\n&gt; &gt; wrote:\n\n\n\n&gt;\n\n&gt;\n\n&gt; On Mon, Mar 15, 2010 at 9:05 AM, Loritsch, Berin C.\n\n=\r\n&gt; &lt;berin.loritsch@... &lt;mailto:berin.loritsch%40gd-ais.com&gt;  &lt;berin.l=\r\noritsch%40gd-ais.com&gt;&gt; wrote:\n\n&gt; &gt; I&#39;m still going through the patch. Is th=\r\nere a default CloneStrategy\n\n&gt; available? Any cloneable object (implements =\r\nthe Cloneable interface) will\n\n&gt; be much quicker than another copy strategy=\r\n. It&#39;s also an interface and a\n\n&gt; copy strategy that comes with the JVM sin=\r\nce before Java 2.\n\n&gt; &gt;\n\n&gt; &gt; Here&#39;s a problem I spotted in the implementatio=\r\nn:\n\n&gt; &gt;\n\n&gt; &gt; protected Object getCopyStrategyInvokedObject(Object value,\n\n&gt;=\r\n &gt; Class&lt;? extends CopyStrategy&gt; copyStrategy, int index) throws\n\n&gt; CopyStr=\r\nategyFailureException {\n\n&gt; &gt; try {\n\n&gt; &gt; return copyStrategy.newInstance().c=\r\nopyDataPoint(value);\n\n&gt; &gt; } catch (Exception e) {\n\n&gt; &gt; throw new CopyStrate=\r\ngyFailureException(value, index,\n\n&gt; copyStrategy.getSimpleName());\n\n&gt; &gt; }\n\n=\r\n&gt; &gt; }\n\n&gt; &gt;\n\n&gt; &gt;\n\n&gt; &gt; Invoking copyStrategy.newInstance() for every object t=\r\nhat needs to be\n\n&gt; copied is going to be a major performance drain. Not onl=\r\ny are we creating\n\n&gt; more work for the garbage collector, we are going thro=\r\nugh the overhead of\n\n&gt; the reflection API to do it. You will have an order =\r\nof magnitude better\n\n&gt; performance if you get your instance of the CopyStra=\r\ntegy first, and pass\n\n&gt; that as necessary.\n\n&gt; &gt;\n\n&gt; &gt; Perhaps another point =\r\nof making the code cleaner would be to pull all the\n\n&gt; data collection stuf=\r\nf into its own API. It might even be able to support\n\n&gt; parameterized tests=\r\n as well as theories. I imagine that was the idea behind\n\n&gt; ParameterSuppli=\r\ner?\n\n&gt;\n\n&gt; Sadly, ParameterSupplier only applies to one parameter at a time,=\r\n but\n\n&gt; I could imagine a unified API that included interfaces for both.\n\n&gt;=\r\n\n\n&gt; David\n\n&gt;\n\n&gt;\n\n&gt; &gt;\n\n&gt; &gt; ________________________________\n\n&gt; &gt;\n\n&gt; &gt; From: =\r\njunit@yahoogroups.com &lt;mailto:junit%40yahoogroups.com&gt;  &lt;junit%40yahoogroup=\r\ns.com&gt; on behalf of Mike\n\n&gt; Forsberg\n\n&gt; &gt; Sent: Sun 3/14/2010 12:15 PM\n\n&gt; &gt;=\r\n To: junit@yahoogroups.com &lt;mailto:junit%40yahoogroups.com&gt;  &lt;junit%40yahoo=\r\ngroups.com&gt;; Shin Hwei Tan; Sang\n\n&gt; Y Baik\n\n&gt; &gt; Subject: Re: [junit] Re: @D=\r\nataPoints called several times for Theories\n\n&gt; &gt;\n\n&gt; &gt;\n\n&gt; &gt;\n\n&gt; &gt;\n\n&gt; &gt; Please=\r\n feel free to join the mailing list. I would find the discussion\n\n&gt; &gt; inter=\r\nesting and wish it would not run offline.\n\n&gt; &gt;\n\n&gt; &gt; Big Mike\n\n&gt; &gt;\n\n&gt; &gt; On F=\r\nri, Mar 12, 2010 at 6:44 PM, Brett Daniel &lt;brettdaniel@... &lt;mailto:br=\r\nettdaniel%40gmail.com&gt; &lt;brettdaniel%40gmail.com&gt;&lt;mailto:\n\n&gt; brettdaniel%40g=\r\nmail.com &lt;brettdaniel%2540gmail.com&gt;&gt; &gt; wrote:\n\n&gt; &gt;\n\n&gt; &gt;&gt;\n\n&gt; &gt;&gt;\n\n&gt; &gt;&gt; The u=\r\nndergrads I am advising recently pushed a patch that addresses the\n\n&gt; &gt;&gt; is=\r\nsue of mutable data points.\n\n&gt; &gt;&gt;\n\n&gt; &gt;&gt;\n\n&gt; &gt;&gt;\n\n&gt; http://github.com/stan6/ju=\r\nnit/commit/dcfa3c41446c469a4edc7513e9e7a9b610b04020 &lt;http://github.com/stan=\r\n6/junit/commit/dcfa3c41446c469a4edc7513e9e7a9b610b04020&gt; &lt;\n\n&gt; http://github=\r\n.com/stan6/junit/commit/dcfa3c41446c469a4edc7513e9e7a9b610b04020 &lt;http://gi=\r\nthub.com/stan6/junit/commit/dcfa3c41446c469a4edc7513e9e7a9b610b04020&gt; \n\n&gt; &gt;=\r\n\n\n&gt; &gt;&gt;\n\n&gt; &gt;&gt; The patch allows developers to define &quot;copy strategies&quot; that d=\r\nuplicate\n\n&gt; &gt;&gt; marked data points before every theory execution. In this wa=\r\ny, every\n\n&gt; &gt;&gt; execution receives a pristine data point, which removes the =\r\nproblems\n\n&gt; caused\n\n&gt; &gt;&gt; when a theory mutates data points. This is orthogo=\r\nnal to datapoint\n\n&gt; &gt;&gt; (re)creation, but I think copy strategies may help a=\r\nddress the bug that\n\n&gt; &gt;&gt; Berin found.\n\n&gt; &gt;&gt;\n\n&gt; &gt;&gt; The patch creates a new,=\r\n optional &quot;copyStrategy&quot; parameter for the\n\n&gt; &gt;&gt; @DataPoint and @DataPoints=\r\n annotations. If the developer wants to copy\n\n&gt; data\n\n&gt; &gt;&gt; points, he or sh=\r\ne sets the parameter to a class implementing a new\n\n&gt; &gt;&gt; CopyStrategy inter=\r\nface.\n\n&gt; &gt;&gt;\n\n&gt; &gt;&gt; Here is an example:\n\n&gt; &gt;&gt;\n\n&gt; &gt;&gt; @RunWith(Theories.class)\n=\r\n\n&gt; &gt;&gt; public class TestMutable {\n\n&gt; &gt;&gt;\n\n&gt; &gt;&gt; @DataPoint(copyStrategy =3D Mu=\r\ntableWithCopyStrategy.class)\n\n&gt; &gt;&gt; public static Mutable mutable =3D new Mu=\r\ntable();\n\n&gt; &gt;&gt;\n\n&gt; &gt;&gt; @Theory\n\n&gt; &gt;&gt; public static testMutate(Mutable a) {\n\n&gt;=\r\n &gt;&gt; a.mutate();\n\n&gt; &gt;&gt; }\n\n&gt; &gt;&gt;\n\n&gt; &gt;&gt; @Theory\n\n&gt; &gt;&gt; public static testNotMuta=\r\nted(Mutable a) {\n\n&gt; &gt;&gt; assertFalse(a.isMutated());\n\n&gt; &gt;&gt; }\n\n&gt; &gt;&gt; }\n\n&gt; &gt;&gt;\n\n&gt;=\r\n &gt;&gt; In the current implementation of JUnit, the second theory may fail\n\n&gt; b=\r\necause\n\n&gt; &gt;&gt; the first theory mutates the datapoint. With a copy strategy e=\r\nnabled,\n\n&gt; both\n\n&gt; &gt;&gt; theories receive a new value.\n\n&gt; &gt;&gt;\n\n&gt; &gt;&gt; Strategies =\r\ncan do almost anything: clone the data point, call a factory\n\n&gt; &gt;&gt; method, =\r\nor--as in the following implementation--instantaiate a new\n\n&gt; object\n\n&gt; &gt;&gt; =\r\nwith a copy constructor.\n\n&gt; &gt;&gt;\n\n&gt; &gt;&gt; public class MutableWithCopyStrategy i=\r\nmplements CopyStrategy {\n\n&gt; &gt;&gt; public Object copyDataPoint(Object toCopy) t=\r\nhrows Exception {\n\n&gt; &gt;&gt; return new Mutable((Mutable)toCopy);\n\n&gt; &gt;&gt; }\n\n&gt; &gt;&gt; =\r\n}\n\n&gt; &gt;&gt;\n\n&gt; &gt;&gt; There are several benefits to this implementation. First, the=\r\n new\n\n&gt; parameter\n\n&gt; &gt;&gt; is completely optional; if it is omitted, the theor=\r\ny runner behaves as\n\n&gt; it\n\n&gt; &gt;&gt; always has. Second, it doesn&#39;t require modi=\r\nfying the data point&#39;s class\n\n&gt; &gt;&gt; (for\n\n&gt; &gt;&gt; example, to add a copy constr=\r\nuctor or clone method). Most importantly,\n\n&gt; it\n\n&gt; &gt;&gt; makes it clear to the=\r\n tester that without a copy strategy one theory\n\n&gt; &gt;&gt; execution can impact =\r\nanother.\n\n&gt; &gt;&gt;\n\n&gt; &gt;&gt; I have CC&#39;d the two students in this email. Please dir=\r\nect any questions\n\n&gt; to\n\n&gt; &gt;&gt; them.\n\n&gt; &gt;&gt;\n\n&gt; &gt;&gt; Brett\n\n&gt; &gt;&gt;\n\n&gt; &gt;&gt;\n\n&gt; &gt;&gt; On =\r\nThu, Feb 18, 2010 at 5:28 PM, Berin &lt;berin.loritsch@... &lt;mailto:beri=\r\nn.loritsch%40gd-ais.com&gt; &lt;berin.loritsch%40gd-ais.com&gt;&lt;mailto:\n\n&gt; berin.lor=\r\nitsch%40gd-ais.com &lt;berin.loritsch%2540gd-ais.com&gt;&gt;\n\n&gt; &lt;berin.loritsch%40gd=\r\n-ais.com&gt;&gt;\n\n&gt; &gt;&gt; wrote:\n\n&gt; &gt;&gt;\n\n&gt; &gt;&gt; &gt;\n\n&gt; &gt;&gt; &gt;\n\n&gt; &gt;&gt; &gt; I agree with your pro=\r\ngnosis, about fresh data points for testing the\n\n&gt; &gt;&gt; &gt; theories. That is p=\r\nrecisely why I proposed reading them once, and\n\n&gt; cloning\n\n&gt; &gt;&gt; &gt; them (mak=\r\ning a copy) as needed for each theory. With that approach we\n\n&gt; &gt;&gt; even\n\n&gt; =\r\n&gt;&gt; &gt; get the protection from mutated data points when you use the\n\n&gt; @DataP=\r\noint\n\n&gt; &gt;&gt; to\n\n&gt; &gt;&gt; &gt; mark a static field.\n\n&gt; &gt;&gt; &gt;\n\n&gt; &gt;&gt; &gt; Cloning is a muc=\r\nh quicker operation, does not execute any\n\n&gt; constructors.\n\n&gt; &gt;&gt; It\n\n&gt; &gt;&gt; &gt;=\r\n merely copies the contents of the object memory verbatim.\n\n&gt; &gt;&gt; &gt;\n\n&gt; &gt;&gt; &gt; =\r\nWith the current implementation, if you are not prepared for the\n\n&gt; &gt;&gt; &gt; co=\r\nmbinatorial affect of 60 data points combined with 60 data points\n\n&gt; for\n\n&gt;=\r\n &gt;&gt; each\n\n&gt; &gt;&gt; &gt; theory there is a major disconnect. The majority of the ov=\r\nerhead in\n\n&gt; this\n\n&gt; &gt;&gt; &gt; particular scenario has to do with creating objec=\r\nts (with the\n\n&gt; additional\n\n&gt; &gt;&gt; &gt; overhead of doing it by reflection).\n\n&gt; =\r\n&gt;&gt; &gt;\n\n&gt; &gt;&gt; &gt; When I created only one instance of each class instead of two,=\r\n the\n\n&gt; &gt;&gt; &gt; performance was twice as fast (i.e. 37 seconds down to about 1=\r\n6\n\n&gt; seconds).\n\n&gt; &gt;&gt; &gt;\n\n&gt; &gt;&gt; &gt; Essentially the number of times your @DataPo=\r\nints method is called\n\n&gt; depends\n\n&gt; &gt;&gt; &gt; on the number of parameters in you=\r\nr @Theory and how many theories you\n\n&gt; &gt;&gt; have.\n\n&gt; &gt;&gt; &gt; Essentially the for=\r\nmula for my theory (ha, ha) of the execution is\n\n&gt; like\n\n&gt; &gt;&gt; &gt; this:\n\n&gt; &gt;&gt;=\r\n &gt;\n\n&gt; &gt;&gt; &gt; N^(p-1) + 1\n\n&gt; &gt;&gt; &gt;\n\n&gt; &gt;&gt; &gt; where:\n\n&gt; &gt;&gt; &gt;\n\n&gt; &gt;&gt; &gt; N is the numb=\r\ner of data points returned by the method\n\n&gt; &gt;&gt; &gt; p is the number of paramet=\r\ners\n\n&gt; &gt;&gt; &gt; and the + 1 represents the run where the data point is read the=\r\n first\n\n&gt; &gt;&gt; time\n\n&gt; &gt;&gt; &gt;\n\n&gt; &gt;&gt; &gt; So for 60 data points it is run 61 times =\r\nfor two parameters. With\n\n&gt; three\n\n&gt; &gt;&gt; &gt; parameters it would be called 360=\r\n1 times. I have to verify with three\n\n&gt; &gt;&gt; &gt; parameters. The theory is call=\r\ned N^p times for sure and that is\n\n&gt; expected.\n\n&gt; &gt;&gt; &gt;\n\n&gt; &gt;&gt; &gt; With the abo=\r\nve formula, the mapping of number of calls to parameters\n\n&gt; for\n\n&gt; &gt;&gt; 60\n\n&gt;=\r\n &gt;&gt; &gt; data points would be:\n\n&gt; &gt;&gt; &gt;\n\n&gt; &gt;&gt; &gt; 1 -&gt; 2 (I know this is wrong wh=\r\nich gives me doubts on the formula)\n\n&gt; &gt;&gt; &gt; 2 -&gt; 61\n\n&gt; &gt;&gt; &gt; 3 -&gt; 3601\n\n&gt; &gt;&gt;=\r\n &gt; 3 -&gt; 216001\n\n&gt; &gt;&gt; &gt;\n\n&gt; &gt;&gt; &gt; Essentially when the Assignments class needs=\r\n to make the combinations,\n\n&gt; it\n\n&gt; &gt;&gt; &gt; will collect the data points initi=\r\nally for each theory. It then calls\n\n&gt; the\n\n&gt; &gt;&gt; &gt; data points again for ea=\r\nch existing data point it collected from the\n\n&gt; &gt;&gt; first\n\n&gt; &gt;&gt; &gt; read. With=\r\n a third parameter it would take all those combinations\n\n&gt; again,\n\n&gt; &gt;&gt; to\n=\r\n\n&gt; &gt;&gt; &gt; add all the permutations for the next round.\n\n&gt; &gt;&gt; &gt;\n\n&gt; &gt;&gt; &gt; I migh=\r\nt be wrong and the real formula would be like this:\n\n&gt; &gt;&gt; &gt;\n\n&gt; &gt;&gt; &gt; N^0 + N=\r\n^1 ... + N^(p-1)\n\n&gt; &gt;&gt; &gt;\n\n&gt; &gt;&gt; &gt; If this is the correct formula, then if yo=\r\nu have 60 data points the\n\n&gt; &gt;&gt; number\n\n&gt; &gt;&gt; &gt; of times the method is calle=\r\nd would map to the number of parameters\n\n&gt; like\n\n&gt; &gt;&gt; &gt; this:\n\n&gt; &gt;&gt; &gt;\n\n&gt; &gt;&gt;=\r\n &gt; 1 -&gt; 1\n\n&gt; &gt;&gt; &gt; 2 -&gt; 61\n\n&gt; &gt;&gt; &gt; 3 -&gt; 3661\n\n&gt; &gt;&gt; &gt; 4 -&gt; 219661\n\n&gt; &gt;&gt; &gt;\n\n&gt; =\r\n&gt;&gt; &gt;\n\n&gt; &gt;&gt; &gt; --- In junit@yahoogroups.com &lt;mailto:junit%40yahoogroups.com&gt; =\r\n &lt;junit%40yahoogroups.com&gt; &lt;mailto:\n\n&gt; junit%40yahoogroups.com &lt;junit%2540y=\r\nahoogroups.com&gt;&gt; &lt;junit%\n\n&gt; 40yahoogroups.com&gt; &lt;junit%\n\n&gt; &gt;&gt; 40yahoogroups.=\r\ncom&gt;, Brett Daniel\n\n&gt; &gt;&gt;\n\n&gt; &gt;&gt; &gt; &lt;brettdaniel@...&gt; wrote:\n\n&gt; &gt;&gt; &gt; &gt;\n\n&gt; &gt;&gt; &gt;=\r\n &gt; Berin,\n\n&gt; &gt;&gt; &gt; &gt;\n\n&gt; &gt;&gt; &gt; &gt; When a theory mutates data points, it might b=\r\ne beneficial to\n\n&gt; recreate\n\n&gt; &gt;&gt; &gt; &gt; the data point for every theory invoc=\r\nation. Doing so prevents one\n\n&gt; &gt;&gt; &gt; &gt; theory execution from affecting othe=\r\nrs. I wrote about this issue in\n\n&gt; &gt;&gt; &gt; &gt; the following weblog post:\n\n&gt; &gt;&gt; =\r\n&gt; &gt;\n\n&gt; &gt;&gt; &gt; &gt; http://www.brettdaniel.com/archives/2009/09/24/200845/ &lt;http:=\r\n//www.brettdaniel.com/archives/2009/09/24/200845/&gt;  &lt;\n\n&gt; http://www.brettda=\r\nniel.com/archives/2009/09/24/200845/ &lt;http://www.brettdaniel.com/archives/2=\r\n009/09/24/200845/&gt; &gt;\n\n&gt; &gt;&gt; &gt; &gt;\n\n&gt; &gt;&gt; &gt; &gt; You are correct, though, that copy=\r\ning would avoid some of the\n\n&gt; overhead\n\n&gt; &gt;&gt; &gt; &gt; in calling datapoint meth=\r\nods. It is interesting you mention this\n\n&gt; idea,\n\n&gt; &gt;&gt; &gt; &gt; because I am cur=\r\nrently overseeing two students who for their senior\n\n&gt; &gt;&gt; &gt; &gt; thesis projec=\r\nt are implementing framework for copying datapoints. I\n\n&gt; &gt;&gt; &gt; &gt; will post =\r\nmore information to the mailing list as the project\n\n&gt; &gt;&gt; &gt; &gt; continues.\n\n&gt;=\r\n &gt;&gt; &gt; &gt;\n\n&gt; &gt;&gt; &gt; &gt; Brett\n\n&gt; &gt;&gt; &gt; &gt;\n\n&gt; &gt;&gt; &gt;\n\n&gt; &gt;&gt; &gt;\n\n&gt; &gt;&gt; &gt;\n\n&gt; &gt;&gt;\n\n&gt; &gt;&gt; [Non-=\r\ntext portions of this message have been removed]\n\n&gt; &gt;&gt;\n\n&gt; &gt;&gt;\n\n&gt; &gt;&gt;\n\n&gt; &gt;\n\n&gt; =\r\n&gt; [Non-text portions of this message have been removed]\n\n&gt; &gt;\n\n&gt; &gt;\n\n&gt; &gt;\n\n&gt; &gt;=\r\n\n\n&gt; &gt;\n\n&gt; &gt;\n\n&gt; &gt; [Non-text portions of this message have been removed]\n\n&gt; &gt;\n=\r\n\n&gt; &gt;\n\n&gt; &gt;\n\n&gt; &gt; ------------------------------------\n\n&gt; &gt;\n\n&gt; &gt; Yahoo! Groups=\r\n Links\n\n&gt; &gt;\n\n&gt; &gt;\n\n&gt; &gt;\n\n&gt; &gt;\n\n&gt; \n\n&gt;\n\n\n\n[Non-text portions of this message hav=\r\ne been removed]\n\n\n\n[Non-text portions of this message have been removed]\n\n\n=\r\n\n\n\n\n    \n     \n\n    \n    \n\n\n\n\n\n\n   \t\t \t   \t\t  \n____________________________=\r\n_____________________________________\nHotmail has tools for the New Busy. S=\r\nearch, chat and e-mail from your inbox.\nhttp://www.windowslive.com/campaign=\r\n/thenewbusy?ocid=3DPID27925::T:WLMTAGL:ON:WL:en-US:WM_HMP:032010_1\n\n[Non-te=\r\nxt portions of this message have been removed]\n\n\n", 
    "profile": "tanshinhwei", 
    "topicId": 22425, 
    "spamInfo": {
        "reason": "4", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 271559074, 
    "prevInTime": 22549, 
    "contentTrasformed": false, 
    "postDate": "1268684827", 
    "canDelete": false, 
    "nextInTopic": 22551, 
    "prevInTopic": 22549, 
    "headers": {
        "inReplyToHeader": "PDc1RjVFRDhBNUE1NTM2NDZBNDZFMDBFNkVDODU0RkEzMDM3OEM3RUVAdmFmZjAxLW1haWwwMS5hZC5nZC1haXMuY29tPg==", 
        "messageIdInHeader": "PFNOVDEyNS1XOTlGMzBGMzQ1N0IyRjNFNjI3OUJEQzAyRTBAcGh4LmdibD4=", 
        "referencesHeader": "PDU4ZGJhMjI1MTAwMjE4MDk0M3EyMzhkZDhkdjExYWI0ODczNjMyMWUxNzhAbWFpbC5nbWFpbC5jb20+PGhsa2lmMiszbXRlQGVHcm91cHMuY29tPjw1OGRiYTIyNTEwMDMxMjE1NDRwM2NkN2RkMjhoMWE4OTljZTY1N2Y2NmFkM0BtYWlsLmdtYWlsLmNvbT48YTUyN2ZkZGYxMDAzMTQwOTE1bDczNzYxZWUxcjc4MWJhMjBmYzc2OGU0MmVAbWFpbC5nbWFpbC5jb20+PDc1RjVFRDhBNUE1NTM2NDZBNDZFMDBFNkVDODU0RkEzMDM3OEM3RTRAdmFmZjAxLW1haWwwMS5hZC5nZC1haXMuY29tPjw0ZjdkYTZiOTEwMDMxNTA2NTFtMTJmMjc5NmtmOWFhYjE3ZmYzMTJjZDkzQG1haWwuZ21haWwuY29tPiA8NThkYmEyMjUxMDAzMTUxMDU2azRiZjI0ZmYyeGYxNjFlNjQxNWFiZjRhYmFAbWFpbC5nbWFpbC5jb20+LDw3NUY1RUQ4QTVBNTUzNjQ2QTQ2RTAwRTZFQzg1NEZBMzAzNzhDN0VFQHZhZmYwMS1tYWlsMDEuYWQuZ2QtYWlzLmNvbT4="
    }
}