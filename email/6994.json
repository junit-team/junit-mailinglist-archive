{
    "numMessagesInTopic": 3, 
    "nextInTime": 6995, 
    "senderId": "GD3BWWaSuBTTu85TdCwDjyOD1wzlGknyT8YsFHDSeLyUz-zTGeEBNxNfMeB_rhZYgb_WSRsicg", 
    "systemMessage": false, 
    "subject": "Unit testing multi-threads access to one database", 
    "from": "skss2002@...", 
    "authorName": "skss2002@aol.com", 
    "msgSnippet": "Hello everyone, I am working on a programming assignment, in which I am given a class that implements a simple database using a random access file.  The class", 
    "msgId": 6994, 
    "topicId": 6994, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 107426134, 
    "messageBody": "<div id=\"ygrps-yiv-749713820\">Hello everyone,<br/>\n<br/>\nI am working on a programming assignment, in which I am given a class that <br/>\nimplements a<br/>\nsimple database using a random access file.  The class provides public <br/>\nsynchronized methods such<br/>\nas getRecord(), add(), find(), modify(), delete() to access records in the <br/>\ndatabase.  I am asked to<br/>\ndesign lock(), unlock() methods for locking/unlocking a record to maintain <br/>\ndatabase integerity in multi-<br/>\nusers environment.<br/>\n<br/>\nThe idea is if two database clients attempt to perform the sequence lock(), <br/>\ngetRecord(), modify(),<br/>\nunlock() concurrently, then both modification attempts will be handled <br/>\ncorrectly.  For example, if the<br/>\ndatabase has 4 fields: record number, product name, price, and quantity in <br/>\nstock, the below statements<br/>\nwould be typical in the client code to update an inventory after a sale.<br/>\n<br/>\n/* requestedProduct and orderQuantity are input parameters */<br/>\n            ...<br/>\nint recordNumberFound = find(requestedProduct);<br/>\nlock(recordNumberFound);<br/>\nRecord rec = getRecord(recordNumberFound);<br/>\nif (rec.quantityInStock &gt;= orderQuantity) {<br/>\n    Record newRec = new Record();<br/>\n<br/>\n    /* The following look cumbersome and the Record constructor should be <br/>\nable to take all the fields<br/>\n    as parameters.  The actual implementation is a little more complex than <br/>\nthis, just to demonstrate<br/>\n    there is process needed to create a new record. */<br/>\n    newRec.recordNumber = rec.recordNumber;<br/>\n    newRec.productName = rec.productName;<br/>\n    newRec.price = rec.price;<br/>\n    newRec.quantityInStock = rec.quantityInStock - orderQuantity;<br/>\n<br/>\n    modify(newRec);  // this will overwrite the existing record in the <br/>\ndatabase<br/>\n    unlock(recordNumberFound);<br/>\n} else {<br/>\n    unlock(recordNumberFound);<br/>\n    throw new DatabaseException(&quot;Not enough stock to fulfil the order.&quot;);<br/>\n}<br/>\n<br/>\nBasically, lock() and unlock methods use a HashSet to traffic-control access <br/>\nto a record.  lock()<br/>\nchecks if the record is already in the HashSet, if so then call wait(), if <br/>\nnot then adds it in.  unlock()<br/>\nremoves the record from the HashSet and call notifyAll().  So by puposely <br/>\nomitting the lock() method,<br/>\none or more of the concurrent users can get pass the if-test before the <br/>\nrecord is modified, and the<br/>\nquantityInStock may be overly reduced to negative.<br/>\n<br/>\nTo unit test the above scenario, my TestCase&#39;s setUp() creates a test <br/>\ndatabase by copying all the<br/>\nrecords from the original database, thus creates a new random access file.  <br/>\nIn tearDown(), the random<br/>\naccess file for the test database is deleted.  I thought I could use <br/>\nJunitPerf&#39;s loadTest() method to<br/>\nsimulate multi-users environment by multi-threads.<br/>\n<br/>\nThe first problem I went into was each thread tried to create a new database, <br/>\nwhich was not allowed<br/>\nby the database class supplied to me (it saw there was a random access file <br/>\nwith the same name exist<br/>\nand threw an IOException), and it didn&#39;t exactly serve my test objective <br/>\neither because I tried to<br/>\nsimulate multi-users accessing the same database.<br/>\n<br/>\nAfter some investigation, I found out junit.extensions.TestSetup could force <br/>\none time setUp()<br/>\nand tearDown(), and came up with something like below:<br/>\n<br/>\n    public class DataLockTest {<br/>\n        private static Data testDatabase;<br/>\n        private static final int MAX_USERS = 10;<br/>\n<br/>\n          public static Test suite() {<br/>\n<br/>\n                /*<br/>\n                    1. Open the supplied database class<br/>\n                    2. Copy every record from the original database to <br/>\ntestDatabase<br/>\n<br/>\n                */<br/>\n<br/>\n                // Pass the testDatabase to the test case contained in the <br/>\nDataLockTestHelper class<br/>\n                Test testCase = new DataLockTestHelper(&quot;testModifyWit<br/>\nhNoLock&quot;, testDatabase);<br/>\n<br/>\n                Test loadTest = new LoadTest(testCase, MAX_USERS);<br/>\n                TestSuite suite = new TestSuite();<br/>\n                suite.addTest(loadTest);<br/>\n<br/>\n                // Anonymous TestSetup object for one time tearDown method<br/>\n                TestSetup wrapper = new TestSetup(suite) {<br/>\n<br/>\n                    protected void tearDown() {<br/>\n<br/>\n                        /*<br/>\n                            1. Close testDatabases,<br/>\n                            2. Delete the underlying random access file<br/>\n                                ...<br/>\n                        */<br/>\n                    }<br/>\n                };<br/>\n                return wrapper;<br/>\n    }<br/>\n<br/>\n    public class DataLockTestHelper extends TestCase {<br/>\n        private Data dataSource;<br/>\n        private static final int RECORD_NO = 24;<br/>\n<br/>\n        // Each user uses the same data source provided by DataLockTest<br/>\n        public DataLockTestHelper(String name, Data source) {<br/>\n            super(name);<br/>\n            dataSource = source;<br/>\n        }<br/>\n<br/>\n        /**<br/>\n         * Test fixture is setup in DataLockTest.<br/>\n         */<br/>\n        protected void setUp() {}<br/>\n<br/>\n        /**<br/>\n         * Test fixture is torn down in DataLockTest.<br/>\n         */<br/>\n        protected void tearDown() {}<br/>\n<br/>\n        public void testModifyWithNoLock() throws DatabaseException {<br/>\n            Record record, newRecord;<br/>\n<br/>\n            try {<br/>\n<br/>\n            // comment out lock() method call ----&gt;           <br/>\ndataSource.lock(RECORD_NO);<br/>\n                record = dataSource.getRecord(RECORD_NO);<br/>\n                if (record.quantityInStock &gt;= 3) {<br/>\n                    newRecord = new Record();<br/>\n                    newRecord.recordNumber = record.recordNumber;<br/>\n                    newRecord.price = record.price;<br/>\n<br/>\n                    /* the field has 10 original, so if running 10 threads <br/>\nconcurrently, very like it will become<br/>\n                    negative */<br/>\n                newRecord.quantityInStock = record.quantityInStock - 3;<br/>\n<br/>\n                    dataSource.modify(newRecord);<br/>\n                }<br/>\n            //  comment out unlock() method call ---&gt;        <br/>\ndataSource.unlock(RECORD_NO);<br/>\n<br/>\n                /* Test if the quantity in stock field becomes negative. */<br/>\n                dataSource.lock(RECORD_NO);<br/>\n                record = dataSource.getRecord(RECORD_NO);<br/>\n             int quantity = record.quantityInStock;<br/>\n                dataSource.unlock(RECORD_NO);<br/>\n<br/>\n                /* The test is successful if the field has been overly <br/>\nreduced to negative */<br/>\n                if (quantity &lt; 0) {<br/>\n                    assertTrue(true);<br/>\n                }<br/>\n            } catch(DatabaseException fail) {<br/>\n                fail(&quot;Shouldn&#39;t raise DatabaseException.&quot;);<br/>\n            }<br/>\n        }<br/>\n<br/>\n    }<br/>\n<br/>\n    Now the test is successful, however, I have very skeptical about it.  I <br/>\ndon&#39;t know if it&#39;s ok to pass the<br/>\n    testDatabase to the test case like this, and would some of the concurrent <br/>\nthreads simply leave the<br/>\n    test case gracefully without doing anything if the condition &quot;if <br/>\n(quantity &lt; 0)&quot; is not met.<br/>\n<br/>\n    I appreciate any comment, please help, thanks!<br/>\n<br/>\n<br/>\n[Non-text portions of this message have been removed]</div>", 
    "prevInTime": 6993, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1045634711", 
    "canDelete": false, 
    "nextInTopic": 6997, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PDFlOC4yM2NiMGIwLjJiODQ3ODk3QGFvbC5jb20+"
    }
}