{
    "numMessagesInTopic": 1, 
    "nextInTime": 16590, 
    "senderId": "8g-ErNOxkUCoAuW9s8A5PfQAQO3RooYsPbwRq9EnqAIOsiX1CIGwWYVhEPVx2xQiIzSZRDDs5y0YJK4miYmJDuIb4n89rCZm", 
    "systemMessage": true, 
    "subject": "multiple inheritance design pattern with junit 4", 
    "from": "&quot;eetadic69&quot; &lt;eetadic69@...&gt;", 
    "authorName": "eetadic69", 
    "msgSnippet": "OK, this may seem like it will be a long post, and a apologize prematurely, however I ve stripped the code down to the minimum needed to illustrate a major", 
    "msgId": 16589, 
    "rawEmail": "Return-Path: &lt;eetadic69@...&gt;\r\nReceived: (qmail 10097 invoked from network); 1 May 2006 18:48:44 -0000\r\nReceived: from unknown (66.218.67.35)\n  by m26.grp.scd.yahoo.com with QMQP; 1 May 2006 18:48:44 -0000\r\nReceived: from unknown (HELO n13c.bullet.sc5.yahoo.com) (66.163.187.204)\n  by mta9.grp.scd.yahoo.com with SMTP; 1 May 2006 18:48:44 -0000\r\nReceived: from [66.163.187.120] by n13.bullet.sc5.yahoo.com with NNFMP; 01 May 2006 18:48:24 -0000\r\nReceived: from [66.218.69.3] by t1.bullet.sc5.yahoo.com with NNFMP; 01 May 2006 18:48:24 -0000\r\nReceived: from [66.218.66.81] by t3.bullet.scd.yahoo.com with NNFMP; 01 May 2006 18:48:24 -0000\r\nX-Sender: eetadic69@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (qmail 15709 invoked from network); 30 Apr 2006 22:26:20 -0000\r\nReceived: from unknown (66.218.66.216)\n  by m27.grp.scd.yahoo.com with QMQP; 30 Apr 2006 22:26:20 -0000\r\nReceived: from unknown (HELO n16a.bullet.scd.yahoo.com) (66.94.237.45)\n  by mta1.grp.scd.yahoo.com with SMTP; 30 Apr 2006 22:26:20 -0000\r\nComment: DomainKeys? See http://antispam.yahoo.com/domainkeys\r\nReceived: from [66.218.69.2] by n16.bullet.scd.yahoo.com with NNFMP; 30 Apr 2006 22:26:19 -0000\r\nReceived: from [66.218.66.72] by t2.bullet.scd.yahoo.com with NNFMP; 30 Apr 2006 22:26:19 -0000\r\nDate: Sun, 30 Apr 2006 22:26:19 -0000\r\nTo: junit@yahoogroups.com\r\nMessage-ID: &lt;e33dib+vl4h@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=&quot;ISO-8859-1&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\nX-Mailer: Yahoo Groups Message Poster\r\nX-Yahoo-Newman-Property: groups-system\r\nX-eGroups-Msg-Info: 1:12:0:0\r\nFrom: &quot;eetadic69&quot; &lt;eetadic69@...&gt;\r\nSubject: multiple inheritance design pattern with junit 4\r\nX-Yahoo-Group-Post: member; u=267405105; y=ld3qt0sXNE6GRyLIOsVdHb29Q6vn1L5evlf5N7uifFh9LBbN\r\nX-Yahoo-Profile: eetadic69\r\nX-eGroups-Approved-By: kentlbeck &lt;kentb@...&gt; via web; 01 May 2006 18:48:22 -0000\r\n\r\nOK, this may seem like it will be a long post, and a apologize prematurely,=\r\n however I&#39;ve \nstripped the code down to the minimum needed to illustrate a=\r\n major headache I&#39;ve been \nhaving the past few days, and I&#39;m hoping someone=\r\n here with a little more testing \nbackground can share some ideas with me!\n=\r\n\nTo start, let me simply illustrate a scenario in some library:\n\ninterface =\r\nA\ninterface B\ninterface C extends A, B\nclass D implements C\n\nNow, given the=\r\n above situation, I&#39;d like to create abstract tests for A, B, and C.  Each =\r\ndoes \ntheir own thing and has at least one unique functional test required.=\r\n\n\nLet&#39;s start with A&#39;s tester:\n\npublic abstract class A_Test{\n  public abst=\r\nract Object getObjectA();\n\n  @Test public final void testA(){\n    System.ou=\r\nt.println(this.getObjectA().toString());\n  }\n}\n\nand now B&#39;s tester:\n\npublic=\r\n abstract class B_Test{\n  public abstract Object getObjectB();\n\n  @Test pub=\r\nlic final void testB(){\n    System.out.println(this.getObjectB().toString()=\r\n);\n  }\n}\n\nOK, simple enough so far.  Now comes the tricky stuff, with testi=\r\nng interface C.  The code \nas I have it below is what I *would* like to see=\r\n.  I&#39;ll explain some choices after the listing:\n\npublic abstract class C_Te=\r\nst{\n  public abstract Object getObjectC(String param);\n\n  @Test public fina=\r\nl void interfaceTest(){\n    JUnitCore.runClasses(C_Test.C_Test_A_Test.class=\r\n, C_Test.C_Test_B_Test.class);\n  }\n  @Test public final void testC(){\n    S=\r\nystem.out.println(this.getObjectC(&quot;C&quot;).toString());\n  }\n\n  public final cla=\r\nss C_Test_A_Test extends A_Test{\n    public Object getObjectA(){\n      retu=\r\nrn C_Test.this.getObjectC(&quot;A&quot;);\n    }\n  }\n\n  public final class C_Test_B_Te=\r\nst extends B_Test{\n    public Object getObjectB(){\n      return C_Test.this=\r\n.getObjectC(&quot;B&quot;);\n    }\n  }\n}\n\nWhy did I choose to write C_Test with (non-s=\r\ntatic) inner classes?  Well, ultimately, I&#39;d like \nto write a concrete (non=\r\n-abstract) test for a class (in this case it will be D).  I need to \nensure=\r\n that D is actually being functionally tested for A, B, and C.  D_Test will=\r\n inherit \ndirectly from C_Test, as seen below:\n\npublic class D_Test extends=\r\n C_Test{\n  public Object getObjectC(String param){\n    return new String(pa=\r\nram);\n  }\n}\n\nNow, to functionally test D for A and B compliance, C_Test_A_T=\r\nest and C_Test_B_Test both \nneed access to D&#39;s implementation of getObjectC=\r\n(String).  If I were to make C_Test_A_Test \nor C_Test_B_Test static nested =\r\nclasses, they would not be able to reference D&#39;s getObjectC\n(String) method=\r\n.\n\nIn fact, non-static inner classes are exactly what I want here because I=\r\n want C_Test_A_Test \nand C_Test_B_Test to differ for each extension of C_Te=\r\nst (e.g. if I make another class \ncalled E that also extends C, when testin=\r\ng E I want E&#39;s getObjectC(String) method to be \nused for functional testing=\r\n of A, B, and C).\n\nJUnit doesn&#39;t seem to allow this, however.  I have to sp=\r\necify classes only to be run.  In my \ncase above, I want to specify two cla=\r\nsses to be run (C_Test_A_Test and C_Test_B_Test) that \nare associated with =\r\nan *instance* of C_Test.\n\nI&#39;ve really looked into making C_Test_A_Test and =\r\nC_Test_B_Test static nested classes, but I \ncannot then provide them with a=\r\n reference to an actual implementing test without \nbreaking a strong rule o=\r\nf transparency (the testing of A and B should not need to depend \non knowle=\r\ndge of the existence of a particular implementor... e.g. if I make them acq=\r\nuire a \nreference to D_Test, and then in the future I get rid of D_Test in =\r\nfavor of E_Test, it will \nbreak my existing tests).\n\nI cannot be the only p=\r\nerson to have encountered this problem, but I also cannot find any \ngood de=\r\nsign patterns to solve this online.  Only simpler cases are illustrated (fo=\r\nr example \ncases where I can acquire an instance of C directly, which is no=\r\nt the case here because C is \nalso an interface).\n\nCan anyone help?\n\n(P.S. =\r\nto anyone who has made it this far, thanks already for sticking with my abn=\r\noxiously \nlong post!)\n\n(P.P.S. I&#39;ve also already seen that JUnit 4.1 will h=\r\nave EnclosedRunner, which will execute \nstatic nested classes automatically=\r\n (thus getting rid of the need to call \nJUnitCore.runClasses(...) as I&#39;ve d=\r\none above, but my impression is that non-static inner \nclasses will still b=\r\ne ignored as before).\n\n\n\n\n\n\n\n", 
    "profile": "eetadic69", 
    "topicId": 16589, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 267405105, 
    "prevInTime": 16588, 
    "contentTrasformed": false, 
    "postDate": "1146435979", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PGUzM2RpYit2bDRoQGVHcm91cHMuY29tPg=="
    }
}