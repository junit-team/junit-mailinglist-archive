{
    "numMessagesInTopic": 17, 
    "nextInTime": 7559, 
    "senderId": "dtLEvI7mlqjL9htwjQlUmt2zEIdNOvHh5AFB1WttkS7Aq08aNeGDI-XOkNQPGsjNDsw2VQHpK1NyNRIw015ZPi3nFp96BQ", 
    "systemMessage": false, 
    "subject": "Re: [junit] Junit and RMI, please help ...", 
    "from": "Levi Cook &lt;levicook@...&gt;", 
    "authorName": "Levi Cook", 
    "msgSnippet": "... Or not :) ... Is yahoo any happier w/ .java attachments? Here s console output that occurs while ServerImplFunctionalTest.testMemoryOfDisconnectedClients ", 
    "msgId": 7558, 
    "rawEmail": "Return-Path: &lt;levicook@...&gt;\r\nX-Sender: levicook@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (EGP: mail-8_2_6_5); 7 Apr 2003 06:58:36 -0000\r\nReceived: (qmail 68706 invoked from network); 7 Apr 2003 06:58:36 -0000\r\nReceived: from unknown (66.218.66.217)\n  by m12.grp.scd.yahoo.com with QMQP; 7 Apr 2003 06:58:36 -0000\r\nReceived: from unknown (HELO relay.pulsity.com) (63.136.2.20)\n  by mta2.grp.scd.yahoo.com with SMTP; 7 Apr 2003 06:58:36 -0000\r\nReceived: from salesoutsourcing.com ([63.136.2.18]) by relay.pulsity.com with Microsoft SMTPSVC(5.0.2195.5329);\n\t Mon, 7 Apr 2003 01:58:35 -0500\r\nReceived: from papajo.com [68.114.212.217] by salesoutsourcing.com with ESMTP\n  (SMTPD32-7.07) id A19A33F500A2; Mon, 07 Apr 2003 01:58:34 -0500\r\nDate: Mon, 7 Apr 2003 01:58:33 -0500\r\nSubject: Re: [junit] Junit and RMI, please help ...\r\nMime-Version: 1.0 (Apple Message framework v551)\r\nTo: junit@yahoogroups.com\r\nIn-Reply-To: &lt;31323D82-6899-11D7-BE14-000393AD2732@...&gt;\r\nMessage-Id: &lt;59402564-68C6-11D7-96C8-000393AD2732@...&gt;\r\nX-Mailer: Apple Mail (2.551)\r\nReturn-Path: levicook@...\r\nX-OriginalArrivalTime: 07 Apr 2003 06:58:35.0544 (UTC) FILETIME=[1BDB2180:01C2FCD3]\r\nFrom: Levi Cook &lt;levicook@...&gt;\r\nX-Yahoo-Group-Post: member; u=72977190\r\nX-Yahoo-Profile: lcook53703\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\n\r\n\nOn Sunday, April 6, 2003, at 08:35  PM, Levi Cook wrote:\n\n&gt; I&#39;ve attached my spike in case anyone is interested.\n\nOr not :)\n\n&gt; [Non-text portions of this message have been removed]\n\nIs yahoo any happier w/ .java attachments?\n\nHere&#39;s console output that occurs while\nServerImplFunctionalTest.testMemoryOfDisconnectedClients\nis running.\n\n  1) ServerImpl STDOUT&gt; server bound @ rmi://localhost/Server\n  2) ServerImpl STDOUT&gt; serverThread started\n\n  3) GoodClientScenario STDOUT&gt; Starting\n  4) ServerImpl STDOUT&gt; +++ adding: ClientImpl_Stub[...]\n  5) ServerImpl STDOUT&gt; --- removing: ClientImpl_Stub[...]\n  6) GoodClientScenario STDOUT&gt; Exiting\n\n  7) BadClientScenario STDOUT&gt; Starting\n  8) ServerImpl STDOUT&gt; +++ adding: ClientImpl_Stub[...]\n  9) BadClientScenario STDOUT&gt; Exiting\n10) ServerImpl STDOUT&gt; --- removing: ClientImpl_Stub[...]\n\n\nLines 1-2  Are just confirming that the server is started and\n            available to rmi clients.\n\nLines 3-6  Show what happens during the &quot;good&quot; client scenario.\n            Basically, the &quot;good&quot; client connects to the server,\n            hangs out a second or two, then calls disconnect.\n\nLines 7-10 Demonstrate the &quot;bad&quot; client scenario. Basically,\n            a bad client fails or forgets to call disconnect().\n\n\nThe interesting part of this whole exercise (in my mind anyway)\nwas figuring out what a &quot;reasonable&quot; test-fixture for working w/\nrmi might look like. In other words, getting the production-code\nto pass my test was easy, creating a test-fixture...not so much.\n\nThe interesting bit for me was realizing that functional tests\n(ala launching/forking jvms for each client & server) was the only\nrealistic way to perform developer tests in this domain.\n\nDoes anyone else an alternate technique for testing rmi apps?\n\n-- Levi\n\n\n\n  ----------\n\npublic final class BadClientScenario extends ClientScenario \n{\n\tstatic final String CLIENT_NAME = &quot;BadClient (does _not_ call disconnect)&quot;;\n\tstatic final int RETURN_CODE = 1;\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n        System.out.println(&quot;Starting&quot;);\n        \n\t\tServer s = ClientScenario.getRemoteServer();\n\t\t\n\t\tClient badGuy = new ClientImpl(CLIENT_NAME);\n\t\t\n\t\ts.connect(badGuy);\n\t\t\n\t\tThread.sleep(ClientScenario.SLEEP_TIME);\n\t\t\n\t\t// s.disconnect(badGuy);\n\t\t// ^^^^^^^^^^^^^^^^^^^^\n\t\t// Doesn&#39;t happen on purpose...\n        \n        System.out.println(&quot;Exiting&quot;);\n        System.exit(RETURN_CODE);\n\t}\n}\n  ----------\n\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\n\npublic interface Client extends Remote\n{\n    void ping() throws RemoteException;\n    String getName() throws RemoteException;\n}\n  ----------\n\nimport java.io.Serializable;\nimport java.rmi.RemoteException;\nimport java.rmi.server.UnicastRemoteObject;\n\npublic class ClientImpl implements Serializable, Client\n{\n    private String name;\n\n    ClientImpl(String itsName) throws RemoteException\n    {\n        name = itsName;\n        UnicastRemoteObject.exportObject(this);\n    }\n    \n    public void ping()\n    {\n    }\n\n    public String getName()\n    {\n        return name;\n    }\n\n    public String toString()\n    {\n        return name + &quot; : &quot; + super.toString();\n    }\n\n    public boolean equals(Object obj)\n    {\n        try\n        {\n            return name.equals(((Client) obj).getName());\n        }\n        catch(RemoteException e)\n        {\n            return false;\n        }\n    }\n\n    public int hashCode()\n    {\n        return name.hashCode();\n    }\n}\n\n  ----------\n\nimport java.rmi.Naming;\n\nabstract class ClientScenario\n{\n\tstatic final long SLEEP_TIME = ServerImpl.SLEEP_TIME * 3;\n\t\n\tprivate static Server myServer;\n\t\n\tprotected static Server getRemoteServer() throws Exception\n\t{\n\t\tif(ClientScenario.myServer == null)\n\t\t{\n\t\t\tClientScenario.myServer = (Server) Naming.lookup(ServerImpl.REGISTRY_NAME);\n\t\t}\n\t\treturn ClientScenario.myServer;\n\t}\n}\n  ----------\n\npublic final class GoodClientScenario extends ClientScenario \n{\n\tstatic final int RETURN_CODE = 0;\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n        System.out.println(&quot;Starting&quot;);\n        \n\t\tServer s = ClientScenario.getRemoteServer();\n\t\t\n\t\tClient goodGuy = new ClientImpl(&quot;GoodClient (calls disconnect)&quot;);\n\t\t\n\t\ts.connect(goodGuy);\n\t\t\n\t\tThread.sleep(ClientScenario.SLEEP_TIME);\n\t\t\n\t\ts.disconnect(goodGuy);\n        \n        System.out.println(&quot;Exiting&quot;);\n        \n        System.exit(RETURN_CODE);\n\t}\n}\n  ----------\n\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\nimport java.util.List;\n\npublic interface Server extends Remote\n{\n\tpublic void connect(Client theClient) throws RemoteException;\n\n\tpublic void disconnect(Client theClient) throws RemoteException;\n\t\n\tpublic List activeClientList() throws RemoteException;\n}\n\n  ----------\n\nimport java.io.PrintStream;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ServerImpl extends UnicastRemoteObject implements Server, Runnable\n{\n\tprivate List clientList;\n\tprivate PrintStream out;\n\n\tServerImpl(PrintStream outputStream) throws RemoteException\n\t{\n\t\tsuper();\n\t\tout = outputStream;\n\t\tclientList = new ArrayList();\n\t}\n\n\tpublic void connect(Client theClient)\n\t{\n\t\tout.println(&quot;+++ adding: &quot; + theClient);\n\t\tclientList.add(theClient);\n\t}\n\n\tpublic void disconnect(Client theClient)\n\t{\n\t\tout.println(&quot;--- removing: &quot; + theClient);\n\t\tclientList.remove(theClient);\n\t}\n\n\tpublic List activeClientList()\n\t{\n\t\treturn clientList;\n\t}\n\n\tpublic void run()\n\t{\n\t\tout.println(&quot;serverThread started&quot;);\n\n\t\twhile (true)\n\t\t{\n\t\t\tfor (int i = 0; i &lt; clientList.size(); i++)\n\t\t\t{\n\t\t\t\tClient curClient = (Client) clientList.get(i);\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tcurClient.ping();\n\t\t\t\t}\n\t\t\t\tcatch (RemoteException e)\n\t\t\t\t{\n\t\t\t\t\tdisconnect(curClient);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry\n\t\t\t{\n\t\t\t\tThread.sleep(SLEEP_TIME);\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\te.printStackTrace(out);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic final String REGISTRY_NAME = &quot;rmi://localhost/Server&quot;;\n\tstatic final long SLEEP_TIME = 1000L;\n\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tServerImpl server = new ServerImpl(System.out);\n\t\tNaming.rebind(REGISTRY_NAME, server);\n\t\tSystem.out.println(&quot;server bound @ &quot; + REGISTRY_NAME);\n\n\t\tThread serverThread = new Thread(server);\n\t\tserverThread.start();\n\t}\n}\n\n  ----------\n\nimport junit.framework.TestCase;\n\npublic abstract class ServerImplBaseTest extends TestCase\n{\n    protected void setUpDerivedFixture() throws Exception\n    {\n    };\n\n    protected final void setUp() throws Exception\n    {\n        TestUtils.rmicRemoteObjects();\n        //        ^^^^^^^^^^^^^^^^^^^^\n        // Unfortunate, but necessary since ServerImpl derives\n        // from UnicastRemoteObject.\n        \n        setUpDerivedFixture();\n    }\n\n    protected abstract Server getTestServer() throws Exception;\n\n    public final void testClientManagement() throws Exception\n    {\n        Server serverUT = getTestServer();\n\n        Client a = new ClientImpl(&quot;A&quot;);\n        Client b = new ClientImpl(&quot;B&quot;);\n\n        serverUT.connect(a);\n\n        assertTrue(serverUT.activeClientList().contains(a));\n        assertFalse(serverUT.activeClientList().contains(b));\n\n        serverUT.connect(b);\n\n        assertTrue(serverUT.activeClientList().contains(a));\n        assertTrue(serverUT.activeClientList().contains(b));\n\n        serverUT.disconnect(a);\n\n        assertFalse(serverUT.activeClientList().contains(a));\n        assertTrue(serverUT.activeClientList().contains(b));\n\n        serverUT.disconnect(b);\n\n        assertFalse(serverUT.activeClientList().contains(a));\n        assertFalse(serverUT.activeClientList().contains(b));\n    }\n}\n  ----------\n\nimport java.rmi.Naming;\n\nimport junit.swingui.TestRunner;\n\npublic final class ServerImplFunctionalTest extends ServerImplBaseTest\n{\n    protected final Server getTestServer() throws Exception\n    {\n        return (Server) Naming.lookup(ServerImpl.REGISTRY_NAME);\n    }\n\n    protected final void setUpDerivedFixture() throws Exception\n    {\n        TestUtils.startRmiRegistry();\n        TestUtils.startServerImpl();\n    }\n\n    public void testMemoryOfDisconnectedClients() throws Exception\n    {\n        TestUtils.runGoodClientToCompletion();\n        TestUtils.runBadClientToCompletion();\n\n        // Give Server a couple cycles to cleanup.\n        Thread.sleep(ServerImpl.SLEEP_TIME * 2);\n\n        Server serverUT = getTestServer();\n\n        assertEquals(0, serverUT.activeClientList().size());\n    }\n\n    protected final void tearDown() throws Exception\n    {\n        TestUtils.stopServerImpl();\n        TestUtils.stopRmiRegistry();\n    }\n\n    public static void main(String[] args)\n    {\n        TestRunner.run(ServerImplFunctionalTest.class);\n    }\n}\n\n  ----------\n\nimport junit.swingui.TestRunner;\n\npublic final class ServerImplUnitTest extends ServerImplBaseTest\n{\n\tprotected final Server getTestServer() throws Exception\n\t{\n\t\treturn new ServerImpl(System.out);\n\t}\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\tTestRunner.run(ServerImplUnitTest.class);\n\t}\n}\n\n  ----------\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\nimport junit.framework.Assert;\n\nfinal class TestUtils\n{\n\tprivate TestUtils()\n\t{\n\t\tsuper();\n\t}\n\n\tstatic Process rmiregistryProcess = null;\n\tstatic Process serverProcess = null;\n\n\tstatic Process goodClientProcess = null;\n\tstatic Process badClientProcess = null;\n\n\tstatic void runBadClientToCompletion() throws Exception\n\t{\n\t\tString cmd = &quot;java &quot; + BadClientScenario.class.getName();\n\t\tString jobLabel = BadClientScenario.class.getName();\n\n\t\tbadClientProcess = startProcess(badClientProcess, cmd, jobLabel);\n\n\t\tAssert.assertEquals(\n\t\t\t&quot;abnormal termination&quot;,\n\t\t\tBadClientScenario.RETURN_CODE,\n\t\t\tbadClientProcess.waitFor());\n\n\t\tbadClientProcess = null;\n\t}\n\n\tstatic void runGoodClientToCompletion() throws Exception\n\t{\n\t\tString cmd = &quot;java &quot; + GoodClientScenario.class.getName();\n\t\tString jobLabel = GoodClientScenario.class.getName();\n\n\t\tgoodClientProcess = startProcess(goodClientProcess, cmd, jobLabel);\n\n\t\tAssert.assertEquals(\n\t\t\t&quot;abnormal termination&quot;,\n\t\t\tGoodClientScenario.RETURN_CODE,\n\t\t\tgoodClientProcess.waitFor());\n\n\t\tgoodClientProcess = null;\n\t}\n\n\tstatic void startServerImpl() throws Exception\n\t{\n\t\tString cmd = &quot;java &quot; + ServerImpl.class.getName();\n\t\tString jobLabel = ServerImpl.class.getName();\n\t\tserverProcess = startProcess(serverProcess, cmd, jobLabel);\n\t\tThread.sleep(4000);\n\t}\n\n\tstatic void stopServerImpl()\n\t{\n\t\tserverProcess = stop(serverProcess);\n\t}\n\n\tstatic void startRmiRegistry() throws Exception\n\t{\n\t\tString cmd = &quot;rmiregistry&quot;;\n\t\tString jobLabel = cmd;\n\t\trmiregistryProcess = startProcess(rmiregistryProcess, cmd, jobLabel);\n\t}\n\n\tstatic void stopRmiRegistry()\n\t{\n\t\trmiregistryProcess = stop(rmiregistryProcess);\n\t}\n\n\tstatic void rmicRemoteObjects() throws Exception\n\t{\n\t\tProcess rmicProcess = null;\n\t\tString cmd =\n\t\t\t&quot;rmic -classpath . -d . &quot;\n\t\t\t\t+ ServerImpl.class.getName()\n\t\t\t\t+ &quot; &quot;\n\t\t\t\t+ ClientImpl.class.getName();\n\t\tString jobName = &quot;rmic&quot;;\n\n\t\trmicProcess = startProcess(rmicProcess, cmd, jobName);\n\t\t\n\t\trmicProcess.waitFor();\n\t}\n\n\tprivate static Process startProcess(\n\t\tProcess staticRef,\n\t\tString cmd,\n\t\tString jobLabel)\n\t\tthrows Exception\n\t{\n\t\tif (staticRef != null)\n\t\t{\n\t\t\tstaticRef.destroy();\n\t\t}\n\n\t\tstaticRef = Runtime.getRuntime().exec(cmd);\n\n\t\tnew StreamGobbler(staticRef.getErrorStream(), jobLabel + &quot; STDERR&quot;);\n\t\tnew StreamGobbler(staticRef.getInputStream(), jobLabel + &quot; STDOUT&quot;);\n\n\t\treturn staticRef;\n\t}\n\n\tprivate static Process stop(Process process)\n\t{\n\t\ttry\n\t\t{\n\t\t\tif (process != null)\n\t\t\t\tprocess.destroy();\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tprocess = null;\n\t\t\treturn process; // yes its always null\n\t\t}\n\t}\n\n\tprivate static class StreamGobbler extends Thread\n\t{\n\t\tprivate InputStream is;\n\t\tprivate String type;\n\n\t\tStreamGobbler(InputStream is, String type)\n\t\t{\n\t\t\tthis.is = is;\n\t\t\tthis.type = type;\n\n\t\t\tthis.start();\n\t\t}\n\n\t\tpublic void run()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tInputStreamReader isr = new InputStreamReader(is);\n\t\t\t\tBufferedReader br = new BufferedReader(isr);\n\t\t\t\tString line = null;\n\t\t\t\twhile ((line = br.readLine()) != null)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(type + &quot;&gt; &quot; + line);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ioe)\n\t\t\t{\n\t\t\t\tioe.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n}\n\n[Non-text portions of this message have been removed]\n\n\n", 
    "profile": "lcook53703", 
    "topicId": 7374, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 72977190, 
    "prevInTime": 7557, 
    "contentTrasformed": false, 
    "postDate": "1049698713", 
    "canDelete": false, 
    "nextInTopic": 7590, 
    "prevInTopic": 7557, 
    "headers": {
        "inReplyToHeader": "PDMxMzIzRDgyLTY4OTktMTFENy1CRTE0LTAwMDM5M0FEMjczMkBwYXBham8uY29tPg==", 
        "messageIdInHeader": "PDU5NDAyNTY0LTY4QzYtMTFENy05NkM4LTAwMDM5M0FEMjczMkBwYXBham8uY29tPg=="
    }
}