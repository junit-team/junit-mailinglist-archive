{
    "numMessagesInTopic": 12, 
    "nextInTime": 20761, 
    "senderId": "zUsG3aGqQZoX8fHqOtz9CXy4afuC6SqKVJxhR4X0zqUjRjFbyqv53HY9H8cL8SnIc5NPcKnrEXZI_KAYbC6DGlvHbgA_6ho", 
    "systemMessage": true, 
    "subject": "Anyone help me to figure out the java.lang.StackOverflowError problem?", 
    "from": "Fuguo Wei &lt;tawqir_wei@...&gt;", 
    "authorName": "Fuguo Wei", 
    "msgSnippet": " \nDear all, I am so upset about the problem I encountered. Wish any one could help me. Thank here first. It s the StackOverflowError problem. I thought It s", 
    "msgId": 20760, 
    "profile": "tawqir_wei", 
    "topicId": 20751, 
    "spamInfo": {
        "reason": "5", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 322916593, 
    "messageBody": "<div id=\"ygrps-yiv-1938269578\"> <br/>\nDear all, I am so upset about the problem I encountered. Wish any one could help me. Thank here first. It&#39;s the StackOverflowError problem. I thought It&#39;s because the recursive program I did. Any way ,I don&#39;t know how to solve this problem.<br/>\nMaybe I used it wrong. I was wandering where I am wrong for a few days. I am confused. Kindly hope you could help me. here is the code.(in the attachment also) if you can not get it, you could check the group file folder as well. I uploaded them to there. By the way, I tried the debug my source code with Eclipse debugger. There is no problem. <br/>\n <br/>\n <br/>\nBest regards<br/>\n <br/>\nWEI FUGUO<br/>\n<br/>\n <br/>\n(1) the test case is like this<br/>\n<br/>\npublic void testCreateTableClus ter() {<br/>\nmapper2.createTable Cluster() ;<br/>\nassertNotNull( mapper.getClassM ap().getTableClu ster());<br/>\n}<br/>\n<br/>\n(2) the createTableCluster( ) source code is like this<br/>\n<br/>\npublic void createTableCluster( ) {<br/>\ntableCluster. createMasterTabl e(tableName, classmap);<br/>\n}<br/>\n<br/>\n(3) the createMasterTable( ) source code is like this<br/>\n<br/>\npublic MasterTableMap createMasterTable( String aTablename, ClassMap aClassmap) <br/>\n{<br/>\nreturn (MasterTableMap) createTable( aTablename, aClassmap, &#39;masterTable&#39; );<br/>\n}<br/>\n<br/>\n(4) createTable( ) source code<br/>\n<br/>\npublic TableMap createTable( String aTablename, ClassMap aClassmap, String aTabletype) <br/>\n{<br/>\npf.ColumnMap colummap=null;<br/>\nTableMap result =null; <br/>\nif (aTabletype. equals(&#39;masterTa ble&#39;))<br/>\n{<br/>\nresult= new MasterTableMap( aTablename) ;<br/>\nthis.set_masterTabl eMap(result) ;<br/>\n}<br/>\nelse if (aTabletype. equals(&#39;independ entTable&#39; ))<br/>\nresult= new IndependentTableMap (aTablename) ;<br/>\nelse if (aTabletype. equals(&#39;dependen tTable&#39;))<br/>\nresult= new DependentTableMap( aTablename) ;<br/>\nsetCurrentTableMap( result);<br/>\naClassmap.setMaster Table(result) ; <br/>\n<br/>\njava.util.List tempList =aClassmap.getColum nMaps();<br/>\n<br/>\nIterator tmpIter = tempList.iterator( );<br/>\nwhile (tmpIter.hasNext( )) <br/>\n{<br/>\ncolummap = (pf.ColumnMap) tmpIter.next( );<br/>\ncolummap.getAttribu teMapper( ).createTableSql Process(this, colummap, aClassmap);<br/>\n}<br/>\naddTableMaps( result);<br/>\nreturn result;<br/>\n}<br/>\n(5) one of createTableSqlProce ss() is like this. [many classes which inherit from the same parent have createTableSqlProce ss]<br/>\n<br/>\npublic void createTableSqlProce ss(TableCluster aTablecluster, pf.ColumnMap aColumnmap, pf.ClassMap aMasterClass) {<br/>\nArrayColumnMap arrayColumnmap = (ArrayColumnMap) aColumnmap;<br/>\nClassMap classmap=null;<br/>\npf.PersistenceClass persisClass= null;<br/>\nString tableName =null;<br/>\nconfigfiend. RelationshipItem relation=null;<br/>\nDependentTableMap depentable=null; <br/>\n<br/>\nString elementCategory= arrayColumnmap. getElementCatego ry();<br/>\nif (elementCategory. equals(&#39;Complex&#39; ))<br/>\n{<br/>\nclassmap =arrayColumnmap. getClassMap( );<br/>\nif (classmap==null)<br/>\n{<br/>\nlogger.debug( &#39;The array attribute &#39;+arrayColumnmap. getColumnName( )+&#39;&#39;s related class was not there, the system will load it at once!&#39;);<br/>\npersisClass= PersistentClassM anager.loadPersi stenceClass( arrayColumnmap. getFieldType( ));<br/>\nif (persisClass! =null)<br/>\n{<br/>\nclassmap=persisClas s.getMapper( ).getClassMap( );<br/>\n}<br/>\nelse<br/>\n{<br/>\nlogger.debug( &#39;couldn&#39;t get the persistence class from peristence class lib.. the process will be terminated&#39;) ;<br/>\nreturn;<br/>\n} <br/>\n}<br/>\ntableName=classmap. getTableName( );<br/>\nrelation=arrayColum nmap.getRelation ship();<br/>\nif (arrayColumnmap. isReflectRelatio n())<br/>\n{<br/>\nif (relation!=null)<br/>\n{<br/>\nif ((relation.getRelat ionshipType( ).equals( &#39;Composition&#39; ))||(relation. getRelationshipT ype().equals( &#39;Strong Aggregation&#39; )))<br/>\n{<br/>\ndepentable=aTablecl uster.createDepe ndentTable( tableName, classmap);<br/>\ndepentable.setRefer enceTable( aMasterClass. getMasterTable( ));<br/>\n}<br/>\nelse<br/>\naTablecluster. createIndependen tTable(tableName , classmap);<br/>\n}<br/>\n}<br/>\nelse<br/>\naTablecluster. createIndependen tTable(tableName , classmap);<br/>\n}<br/>\nelse<br/>\n{<br/>\nString fieldname=arrayColu mnmap.getFieldNa me();<br/>\nString fieldtype=arrayColu mnmap.getFieldTy pe();<br/>\nTableField tablefield=new TableField(fieldnam e,fieldtype, aMasterClass. getDomainClass( ));<br/>\naTablecluster. getCurrentTableM ap().addField( tablefield) ;<br/>\n<br/>\nString tempstr =aMasterClass. getDomainClass( ).getName( ).substring( aMasterClass. getDomainClass( ).getName( ).lastIndexOf( &#39;.&#39;)+1)+&#39; oid&#39;;<br/>\nif (fieldname.toUpperC ase().indexOf( tempstr.toUpperC ase())!=- 1)<br/>\naTablecluster. getCurrentTableM ap().setPrimaryK ey(tablefield) ;<br/>\n}<br/>\n}<br/>\n<br/>\nas you can see the createTable method is invoked recursively in createTableSqlProce ss() [the bold statement]<br/>\n<br/>\nthe sourse code of createDependentTabl e() likes this<br/>\n<br/>\npublic DependentTableMap createDependentTabl e(String aTablename, ClassMap aClassmap) {<br/>\nreturn (DependentTableMap) createTable( aTablename, aClassmap, &#39;dependentTable&#39; );<br/>\n}<br/>\n<br/>\nthe sourse code of createIndependentTa ble() likes this<br/>\n<br/>\npublic IndependentTableMap createIndependentTa ble(String aTablename, ClassMap aClassmap) {<br/>\nreturn (IndependentTableMa p)createTable( aTablename, aClassmap, &#39;independentTabl e&#39;);<br/>\n}<br/>\n<br/>\nthe two methods are like the createMasterTable( ) at the beginning of the source code I listed here.<br/>\n<br/>\nthe createTable( ) is invoked recursively, as you can see. I guess that&#39;s the point why JUnit wrong.<br/>\n<br/>\nthe Junit errow message screen was captured in the attachement.<br/>\n<br/>\n<br/>\n<br/>\n      <br/>\n  ----------<br/>\n<br/>\n(1) the test case is like this\r<br/>\n \r<br/>\n public void testCreateTableCluster() {\r<br/>\n  mapper2.createTableCluster();\r<br/>\n  assertNotNull(mapper.getClassMap().getTableCluster());\r<br/>\n }\r<br/>\n\r<br/>\n(2) the createTableCluster() source code is like this\r<br/>\n\r<br/>\n public void createTableCluster() {\r<br/>\n  tableCluster.createMasterTable(tableName, classmap);\r<br/>\n }\r<br/>\n \r<br/>\n(3) the createMasterTable() source code is like this\r<br/>\n\r<br/>\n public MasterTableMap createMasterTable(String aTablename, ClassMap aClassmap) \r<br/>\n {\r<br/>\n  return (MasterTableMap)createTable(aTablename,aClassmap,&#39;masterTable&#39;);\r<br/>\n }\r<br/>\n\r<br/>\n(4) createTable() source code\r<br/>\n \r<br/>\n public TableMap createTable(String aTablename, ClassMap aClassmap, String aTabletype) \r<br/>\n {\r<br/>\n  pf.ColumnMap colummap=null;\r<br/>\n  TableMap result =null; \r<br/>\n  if (aTabletype.equals(&#39;masterTable&#39;))\r<br/>\n  {\r<br/>\n   result= new MasterTableMap(aTablename);\r<br/>\n   this.set_masterTableMap(result);\r<br/>\n  }\r<br/>\n  else if (aTabletype.equals(&#39;independentTable&#39;))\r<br/>\n   result= new IndependentTableMap(aTablename);\r<br/>\n  else if (aTabletype.equals(&#39;dependentTable&#39;))\r<br/>\n   result= new DependentTableMap(aTablename);\r<br/>\n  setCurrentTableMap(result);\r<br/>\n  aClassmap.setMasterTable(result); \r<br/>\n  \r<br/>\n  java.util.List tempList =aClassmap.getColumnMaps();\r<br/>\n  \r<br/>\n  Iterator tmpIter = tempList.iterator();\r<br/>\n  while (tmpIter.hasNext()) \r<br/>\n  {\r<br/>\n   colummap = (pf.ColumnMap)tmpIter.next();\r<br/>\n   colummap.getAttributeMapper().createTableSqlProcess(this, colummap, aClassmap);\r<br/>\n  }\r<br/>\n  addTableMaps(result);\r<br/>\n  return result;\r<br/>\n }\r<br/>\n(5) one of createTableSqlProcess() is like this. [many classes which inherit from the same parent have createTableSqlProcess]\r<br/>\n \r<br/>\n public void createTableSqlProcess(TableCluster aTablecluster, pf.ColumnMap aColumnmap, pf.ClassMap aMasterClass) {\r<br/>\n  ArrayColumnMap arrayColumnmap = (ArrayColumnMap)aColumnmap;\r<br/>\n  ClassMap classmap=null;\r<br/>\n  pf.PersistenceClass persisClass=null;\r<br/>\n  String tableName =null;\r<br/>\n  configfiend.RelationshipItem relation=null;\r<br/>\n  DependentTableMap depentable=null; \r<br/>\n  \r<br/>\n  String elementCategory=arrayColumnmap.getElementCategory();\r<br/>\n  if (elementCategory.equals(&#39;Complex&#39;))\r<br/>\n  {\r<br/>\n   classmap =arrayColumnmap.getClassMap();\r<br/>\n   if (classmap==null)\r<br/>\n   {\r<br/>\n    logger.debug(&#39;The array attribute &#39;+arrayColumnmap.getColumnName()+&#39;&#39;s related class was not there, the system will load it at once!&#39;);\r<br/>\n    persisClass=PersistentClassManager.loadPersistenceClass(arrayColumnmap.getFieldType());\r<br/>\n    if (persisClass!=null)\r<br/>\n    {\r<br/>\n     classmap=persisClass.getMapper().getClassMap();\r<br/>\n    }\r<br/>\n    else\r<br/>\n    {\r<br/>\n     logger.debug(&#39;couldn&#39;t get the persistence class from peristence class lib. the process will be terminated&#39;);\r<br/>\n     return;\r<br/>\n    } \r<br/>\n   }\r<br/>\n   tableName=classmap.getTableName();\r<br/>\n   relation=arrayColumnmap.getRelationship();\r<br/>\n   if (arrayColumnmap.isReflectRelation())\r<br/>\n   {\r<br/>\n    if (relation!=null)\r<br/>\n    {\r<br/>\n     if ((relation.getRelationshipType().equals(&#39;Composition&#39;))||(relation.getRelationshipType().equals(&#39;Strong Aggregation&#39;)))\r<br/>\n     {\r<br/>\n      depentable=aTablecluster.createDependentTable(tableName, classmap);\r<br/>\n      depentable.setReferenceTable(aMasterClass.getMasterTable());\r<br/>\n     }\r<br/>\n     else\r<br/>\n      aTablecluster.createIndependentTable(tableName, classmap);\r<br/>\n    }\r<br/>\n   }\r<br/>\n   else\r<br/>\n    aTablecluster.createIndependentTable(tableName, classmap);\r<br/>\n  }\r<br/>\n  else\r<br/>\n  {\r<br/>\n   String fieldname=arrayColumnmap.getFieldName();\r<br/>\n   String fieldtype=arrayColumnmap.getFieldType();\r<br/>\n   TableField tablefield=new TableField(fieldname,fieldtype,aMasterClass.getDomainClass());\r<br/>\n   aTablecluster.getCurrentTableMap().addField(tablefield);\r<br/>\n   \r<br/>\n      String tempstr =aMasterClass.getDomainClass().getName().substring(aMasterClass.getDomainClass().getName().lastIndexOf(&#39;.&#39;)+1)+&#39;oid&#39;;\r<br/>\n   if (fieldname.toUpperCase().indexOf(tempstr.toUpperCase())!=-1)\r<br/>\n    aTablecluster.getCurrentTableMap().setPrimaryKey(tablefield);\r<br/>\n  }\r<br/>\n }\r<br/>\n\r<br/>\nas you can see the createTable method is invoked recursively in createTableSqlProcess() [the bold statement]\r<br/>\n \r<br/>\nthe sourse code of createDependentTable() likes this\r<br/>\n \r<br/>\n public DependentTableMap createDependentTable(String aTablename, ClassMap aClassmap) {\r<br/>\n  return (DependentTableMap)createTable(aTablename,aClassmap,&#39;dependentTable&#39;);\r<br/>\n }\r<br/>\n\r<br/>\nthe sourse code of createIndependentTable() likes this\r<br/>\n \r<br/>\n public IndependentTableMap createIndependentTable(String aTablename, ClassMap aClassmap) {\r<br/>\n  return (IndependentTableMap)createTable(aTablename,aClassmap,&#39;independentTable&#39;);\r<br/>\n }\r<br/>\n\r<br/>\n\r<br/>\n\r<br/>\nthe two methods are like the createMasterTable() at the beginning of the source code I listed here.\r<br/>\n \r<br/>\nthe createTable() is invoked recursively, as you can see. I guess that&#39;s the point why JUnit wrong.\r<br/>\nthe Junit errow message screen was captured in the attachement.\r<br/>\n<br/>\n<br/>\n[Non-text portions of this message have been removed]</div>", 
    "prevInTime": 20759, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1217932183", 
    "canDelete": false, 
    "nextInTopic": 20761, 
    "prevInTopic": 20754, 
    "headers": {
        "messageIdInHeader": "PDI1NTc3MC40NTUxOC5xbUB3ZWI0NDgxMy5tYWlsLnNwMS55YWhvby5jb20+"
    }
}