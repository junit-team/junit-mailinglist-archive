{
    "numMessagesInTopic": 6, 
    "nextInTime": 20466, 
    "senderId": "-E4chFjjShTnXsA8xO9ix1F9ywJo26mJ42xvEtp06REZYoGmteD8lUD-X7J40tu2nWBgBTXV23hkvyV17sQAaaLC110w5dw0giwmEQ", 
    "systemMessage": true, 
    "subject": "Re: TextListener improvement", 
    "from": "&quot;toalexsmail&quot; &lt;toalexsmail@...&gt;", 
    "authorName": "toalexsmail", 
    "msgSnippet": "... See also https://sourceforge.net/tracker/?func=detail&atid=365278&aid=1913115&group_id=15278 (there is a path described below their) Here is my solution: ", 
    "msgId": 20465, 
    "rawEmail": "Return-Path: &lt;toalexsmail@...&gt;\r\nReceived: (qmail 8644 invoked from network); 28 Apr 2008 23:56:02 -0000\r\nReceived: from unknown (66.218.67.94)\n  by m55.grp.scd.yahoo.com with QMQP; 28 Apr 2008 23:56:02 -0000\r\nReceived: from unknown (HELO n10.bullet.mail.re1.yahoo.com) (69.147.103.137)\n  by mta15.grp.scd.yahoo.com with SMTP; 28 Apr 2008 23:56:01 -0000\r\nReceived: from [68.142.237.88] by n10.bullet.mail.re1.yahoo.com with NNFMP; 28 Apr 2008 23:56:01 -0000\r\nReceived: from [209.73.164.86] by t4.bullet.re3.yahoo.com with NNFMP; 28 Apr 2008 23:56:01 -0000\r\nReceived: from [66.218.66.84] by t8.bullet.scd.yahoo.com with NNFMP; 28 Apr 2008 23:56:00 -0000\r\nX-Sender: toalexsmail@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nX-Received: (qmail 20269 invoked from network); 28 Apr 2008 22:09:00 -0000\r\nX-Received: from unknown (66.218.67.94)\n  by m47.grp.scd.yahoo.com with QMQP; 28 Apr 2008 22:09:00 -0000\r\nX-Received: from unknown (HELO n18a.bullet.sp1.yahoo.com) (69.147.64.127)\n  by mta15.grp.scd.yahoo.com with SMTP; 28 Apr 2008 22:09:00 -0000\r\nX-Received: from [216.252.122.217] by n18.bullet.sp1.yahoo.com with NNFMP; 28 Apr 2008 22:09:00 -0000\r\nX-Received: from [66.218.69.5] by t2.bullet.sp1.yahoo.com with NNFMP; 28 Apr 2008 22:09:00 -0000\r\nX-Received: from [66.218.66.92] by t5.bullet.scd.yahoo.com with NNFMP; 28 Apr 2008 22:09:00 -0000\r\nDate: Mon, 28 Apr 2008 22:08:58 -0000\r\nTo: junit@yahoogroups.com\r\nMessage-ID: &lt;fv5htq+j2mm@...&gt;\r\nIn-Reply-To: &lt;fr8ets+dk2g@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=&quot;ISO-8859-1&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\nX-Mailer: Yahoo Groups Message Poster\r\nX-Yahoo-Newman-Property: groups-system\r\nX-eGroups-Msg-Info: 1:6:0:0:0\r\nFrom: &quot;toalexsmail&quot; &lt;toalexsmail@...&gt;\r\nSubject: Re: TextListener improvement\r\nX-Yahoo-Group-Post: member; u=340165037; y=ReoJ-kf3uoI8H3P6yAahF2CaRSmUB2B1JMUHcG8XgtFlfREujgw\r\nX-Yahoo-Profile: toalexsmail\r\nX-eGroups-Approved-By: mark_l_salter &lt;marksalter@...&gt; via web; 28 Apr 2008 23:55:58 -0000\r\n\r\n--- In junit@yahoogroups.com, &quot;toalexsmail&quot; &lt;toalexsmail@...&gt; wrote:\n&gt;\n&gt; Cu=\r\nrrently TextListener on every event simply writes to standard output\n&gt; (or =\r\nto PrintWriter). If junits or application aslo writes its logs to\n&gt; standar=\r\nd output then this output is mixed. For example, failures will\n&gt; be written=\r\n inside the logs of the application and not in the end.\n&gt; Moreover, if ther=\r\ne is some activity in @AfterClass that also prints to\n&gt; the standard output=\r\n than this will be written down AFTER summary of\n&gt; the Junit.\n&gt; \n&gt; I have p=\r\nartial solution to this situation. TextListener (or a new\n&gt; class, say Cons=\r\noleListener) should create new PrintWriter(new\n&gt; StringWriter()) and collec=\r\nt the result their.  On testRunFinished() it\n&gt; should flush the information=\r\n from StringWriter to the PrintStream that\n&gt; received in the constructor (S=\r\ntring.out for example).\n&gt; This solution doesn&#39;t solve situation when there =\r\nis some writing to\n&gt; the standard output in @AfterClass.\n&gt;\n\nSee also\nhttps:=\r\n//sourceforge.net/tracker/?func=3Ddetail&atid=3D365278&aid=3D1913115&group_=\r\nid=3D15278\n(there is a path described below their)\n\nHere is my solution:\n\np=\r\nublic class JUnitTest{\n \t\n\tpublic static void main(String[] args){\n\t\tReques=\r\nt r =3D Request.aClass(JUnitTest.class);\n\t\tJUnitCore runner =3D new JUnitCo=\r\nre();\n\t\tPrintStream out =3D System.out;\n\t\tRunListener runListener =3D new F=\r\nlushedPrintStreamListener(out);\n\t\trunner.addListener(runListener);\n\t\tResult=\r\n result =3D runner.run(r);\n\t\tint code =3D -1;\n\t\tint failures =3D result.get=\r\nFailureCount();\n\t\tif(failures&gt;0){\n\t\t\tcode =3D -failures;\n\t\t} else {\n\t\t\tcode=\r\n =3D result.getIgnoreCount();\n\t\t}\n\t\tSystem.exit(code); \n          }\n\n}\n\npub=\r\nlic class PrintStreamListener extends RunListener{\n\t//Definition of delimit=\r\ners is in Description\n\tprivate static final Pattern DISPAY_NAME_PATTERN =3D=\r\n\nPattern.compile(&quot;()&quot;); \n\tprivate TextListener textListener;\n\tprivate Print=\r\nStream writer;\n\t\n\tpublic PrintStreamListener() {\n\t\tthis(System.out);\n\t}\n\n\tp=\r\nublic PrintStreamListener(PrintStream writer) {\n\t\tsuper();\n\t\tthis.textListe=\r\nner =3D new TextListener(writer);\n\t\tthis.writer =3D writer;\n\t}\n\t\n\t/**\n\t * F=\r\nor sub-classes use.\n\t * \n\t * @return\n\t */\n\tprotected PrintStream getWriter(=\r\n){\n\t\treturn writer;\n\t}\n\t\n\tprivate PrintStream getNotNullWriter(){\n\t\tPrintSt=\r\nream writer =3D getWriter();\n\t\tif(writer=3D=3Dnull){\n\t\t\tthrow new IllegalSt=\r\nateException(&quot;writer should be not null&quot;);\n\t\t}\n\t\treturn writer;\n\t}\n\t\n\t\n\t/**=\r\n\n\t * This method can be overriden in sub-classes.\n\t * \n\t * @param descripti=\r\non\n\t * @throws IllegalArgumentException if description is null.\n\t */\n\tprote=\r\ncted void writeMethodName(Description description){\n\t\tif(description=3D=3Dn=\r\null){\n\t\t\tthrow new IllegalArgumentException(&quot;description should be not null=\r\n&quot;);\n\t\t}\n\t\tString displayName =3D description.getDisplayName();\n\t\tString[] c=\r\nomplexNames =3D DISPAY_NAME_PATTERN.split(displayName, 3);\n\t\tString methodN=\r\name =3D (complexNames=3D=3Dnull ||\ncomplexNames.length!=3D2)?displayName:co=\r\nmplexNames[1];\n\t\tPrintStream writer =3D getNotNullWriter();\n\t\t\n\t\twriter.pri=\r\nnt(methodName);\n\t\twriter.print(&#39; &#39;);\n\t}\n\t\n\t\n\t/**\n\t * Called when an atomic =\r\ntest is about to be started.\n\t * @param description the description of the =\r\ntest that is about to be\nrun \n\t * (generally a class and method name)\n\t */\n=\r\n\t@Override\n\tpublic void testStarted(Description description)  {\n\t\ttextListe=\r\nner.testStarted(description);\n\t}\n\n\n\t/** \n\t * Called when an atomic test fai=\r\nls.\n\t * @param failure describes the test that failed and the exception\ntha=\r\nt was thrown\n\t */\n\t@Override\n\tpublic void testFailure(Failure failure)  {\n\t=\r\n\tDescription description =3D failure.getDescription();\n\t\tPrintStream writer=\r\n =3D getNotNullWriter();\n\n\t\twriteMethodName(description);\n\t\ttextListener.te=\r\nstFailure(failure);\n\t\twriter.println();\n\t}\n\n\t/**\n\t * Called when a test wil=\r\nl not be run, generally because a test\nmethod is annotated \n\t * with {@link=\r\n org.junit.Ignore}.\n\t * @param description describes the test that will not=\r\n be run\n\t */\n\t@Override\n\tpublic void testIgnored(Description description)  =\r\n{\n\t\twriteMethodName(description);\n\t\tPrintStream writer =3D getNotNullWriter=\r\n();\n\t\ttextListener.testIgnored(description);\n\t\twriter.println();\n\t}\n\t\n\t\n\t@O=\r\nverride\n\tpublic void testRunFinished(Result result) {\n\t\ttextListener.testRu=\r\nnFinished(result);\n\t}\n\t\n\t/**\n\t * Called before any tests have been run.\n\t *=\r\n @param description describes the tests to be run\n\t */\n\t@Override\n\tpublic v=\r\noid testRunStarted(Description description) throws Exception {\n\t\tPrintStrea=\r\nm writer =3D getNotNullWriter();\n\t\tString displayName =3D description.getDi=\r\nsplayName();\n\t\tString[] complexNames =3D DISPAY_NAME_PATTERN.split(displayN=\r\name, 3);\n\t\tString className =3D (complexNames=3D=3Dnull ||\ncomplexNames.len=\r\ngth!=3D2)?displayName:complexNames[0];\n\t\twriter.print(&quot;started to test &quot;+cl=\r\nassName);\n\t\twriter.println();\t\t\n\t}\n}\n\npublic class FlushedPrintStreamListen=\r\ner extends PrintStreamListener{\n\n\tpublic FlushedPrintStreamListener() {\n\t\ts=\r\nuper();\n\t}\n\n\tpublic FlushedPrintStreamListener(PrintStream writer) {\n\t\tsupe=\r\nr(writer);\n\t}\n\t\n\t/**\n\t * Called when an atomic test is about to be started.=\r\n\n\t * @param description the description of the test that is about to be\nrun=\r\n \n\t * (generally a class and method name)\n\t */\n\t@Override\n\tpublic void test=\r\nStarted(Description description)  {\n\t\tsuper.testStarted(description);\n\t\tflu=\r\nsh();\n\t}\n\n\n\t/** \n\t * Called when an atomic test fails.\n\t * @param failure d=\r\nescribes the test that failed and the exception\nthat was thrown\n\t */\n\t@Over=\r\nride\n\tpublic void testFailure(Failure failure)  {\n\t\tsuper.testFailure(failu=\r\nre);\n\t\tflush();\n\t}\n\n\t/**\n\t * Called when a test will not be run, generally =\r\nbecause a test\nmethod is annotated \n\t * with {@link org.junit.Ignore}.\n\t * =\r\n@param description describes the test that will not be run\n\t */\n\t@Override\n=\r\n\tpublic void testIgnored(Description description)  {\n\t\tsuper.testIgnored(de=\r\nscription);\n\t\tflush();\n\t}\n\t\n\t\n\t\n\n\t@Override\n\tpublic void testRunFinished(Re=\r\nsult result) {\n\t\tsuper.testRunFinished(result);\n\t\t//flush();\n\t}\n\t\n\t/**\n\t * =\r\nCalled before any tests have been run.\n\t * @param description describes the=\r\n tests to be run\n\t */\n\t@Override\n\tpublic void testRunStarted(Description de=\r\nscription) throws Exception {\n\t\tsuper.testRunStarted(description);\n\t\tflushR=\r\nunStarted();\n\t}\n\n\t/**\n\t * Can be changed in sub-class.\n\t */\n\tprotected void=\r\n flushRunStarted(){\n\t\t//don&#39; flush\n\t\t\n\t}\n\t\n\t/**\n\t * Can be changed in sub-c=\r\nlass.\n\t * \n\t */\n\tprotected void flush(){\n\t\tPrintStream writer =3D getWriter=\r\n();\n\t\tif(writer!=3Dnull){\n\t\t\twriter.flush();\n\t\t}\n\t}\n\t\n}\n\n/**\n * Redirect an=\r\n output stream to a logger.\n * This class is useful to redirect standard ou=\r\ntput or \n * standard error to a Logger. An example use is\n *\n * &lt;pre&gt;\n * fi=\r\nnal LoggerOutputStream outputStream =3D \n *     new LoggerOutputStream( log=\r\n );\n * final PrintStream output =3D new PrintStream( outputStream, true );\n=\r\n *\n * System.setOut( output );\n * &lt;/pre&gt;\n *\n */\npublic class LoggerOutputSt=\r\nream\n    extends OutputStream\n{    \n    ///Logger that we log to\n    privat=\r\ne final Log        m_logger;\n\n   \n    ///The buffered output so far\n    pri=\r\nvate final StringBuffer  m_output    =3D new StringBuffer(1024);\n\n    ///Fl=\r\nag set to true once stream closed\n    private boolean             m_closed;=\r\n\n\n    /**\n     * Construct OutputStreamLogger to write to a particular logg=\r\ner at\na particular priority.\n     *\n     * @param logger the logger to writ=\r\ne to\n     * @param priority the priority at which to log\n     */\n    public=\r\n LoggerOutputStream( final Log logger)\n    {\n        m_logger =3D logger;\n =\r\n   }\n\n    /**\n     * Shutdown stream.\n     *\n     */\n    public void close(=\r\n)\n        throws IOException\n    {\n        flush();\n        super.close();\n=\r\n        m_closed =3D true;\n    }\n\n    /**\n     * Write a single byte of dat=\r\na to output stream.\n     *\n     * @param data the byte of data\n     * @exce=\r\nption IOException if an error occurs\n     */\n    public void write( final i=\r\nnt data ) \n        throws IOException\n    {\n        checkValid();\n        \n=\r\n         //Should we properly convert char using locales etc??\n        m_ou=\r\ntput.append( (char)data );\n\n     \n    }\n\n    /**\n     * Flush data to under=\r\nlying logger.\n     *\n     * @exception IOException if an error occurs\n     =\r\n*/\n    public synchronized void flush()\n        throws IOException\n    {\n  =\r\n      checkValid();\n\n         m_logger.info(m_output.toString() );\n        =\r\nm_output.setLength( 0 );\n        \n       \n    }\n\n    /**\n     * Make sure s=\r\ntream is valid.\n     *\n     * @exception IOException if an error occurs\n   =\r\n  */\n    private void checkValid()\n        throws IOException\n    {\n       =\r\n if( true =3D=3D m_closed ) \n        {\n            throw new EOFException( =\r\n&quot;OutputStreamLogger closed&quot; );\n        }\n    }\n}\n\n\n\n\n", 
    "profile": "toalexsmail", 
    "topicId": 20361, 
    "spamInfo": {
        "reason": "6", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 340165037, 
    "prevInTime": 20464, 
    "contentTrasformed": false, 
    "postDate": "1209420538", 
    "canDelete": false, 
    "nextInTopic": 20466, 
    "prevInTopic": 20361, 
    "headers": {
        "inReplyToHeader": "PGZyOGV0cytkazJnQGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PGZ2NWh0cStqMm1tQGVHcm91cHMuY29tPg=="
    }
}