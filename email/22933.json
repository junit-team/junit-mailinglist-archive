{
    "numMessagesInTopic": 8, 
    "nextInTime": 22934, 
    "senderId": "tqkGwL055-dCgHaDyxfWZW98yTp-jQSzz_l9Ms0gqw6AohdqKXQIJ-ShjyWTY4sCIob0yZnk1Or4LZ3eTbJTEfT1OS_9FQqAywWWaz9i", 
    "systemMessage": false, 
    "subject": "Common Test Runner for JVM", 
    "from": "Esko Luontola &lt;esko.luontola@...&gt;", 
    "authorName": "Esko Luontola", 
    "msgSnippet": "I ll soon start writing a new test runner - a common test runner for the JVM, codename CTR4J. It will provide a superset of JUnit s test runner s features,", 
    "msgId": 22933, 
    "profile": "egeluontola", 
    "topicId": 22933, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 395435659, 
    "messageBody": "<div id=\"ygrps-yiv-269956538\">I&#39;ll soon start writing a new test runner - a common test runner for the <br/>\nJVM, codename CTR4J. It will provide a superset of JUnit&#39;s test runner&#39;s <br/>\nfeatures, while at the same time overcoming some of JUnit&#39;s limitations <br/>\nand helping integration with development tools. I would like to hear <br/>\nyour opinions on this project.<br/>\n<br/>\n<br/>\n\tMOTIVATION<br/>\n<br/>\nJUnit&#39;s test runner - especially the org.junit.runner.RunWith annotation <br/>\n- has been very successful in providing a common interface for running <br/>\ntests from multiple testing frameworks. If a testing framework provides <br/>\na org.junit.runner.Runner implementation, every Java build tool and IDE <br/>\nwill automatically support the framework.<br/>\n<br/>\nHowever with the rise of Scala testing frameworks (Specs, ScalaTest, <br/>\nSpecsy - the last one being written by me), some limitations of JUnit&#39;s <br/>\ntest runner are coming to the fore:<br/>\n<br/>\n- JUnit makes an implicit assumption that all tests are known before any <br/>\ntest code is executed. For example IntelliJ IDEA calls <br/>\nRunner.getDescription() before calling Runner.run() and has problems if <br/>\nthe descriptions change during test execution. But in the Scala testing <br/>\nframeworks, in order to achieve a concise syntax, test declarations are <br/>\nimplemented as method calls in the class constructor, which means that <br/>\nat least some of the test code must be executed before it is known that <br/>\nwhat tests there are.<br/>\n<br/>\n- JUnit doesn&#39;t know the concept of nested tests. It knows the concept <br/>\nof suites containing suites, but not &quot;test methods&quot; which contain other <br/>\n&quot;test methods&quot;. But at least Specs and Specsy allow organizing tests <br/>\ninto unlimitedly nested closures. For them this limitation means that <br/>\nIDEs are not able to show the right mental model of what is really <br/>\nhappening during test execution, which makes understanding test output <br/>\nharder.<br/>\n<br/>\n- There is an implicit assumption that test names are the same as method <br/>\nnames, and that the tests are implemented as methods. For example in <br/>\nIntelliJ IDEA it&#39;s possible to navigate from the test results into test <br/>\nmethods. But with the Scala frameworks this is not possible, because the <br/>\ntest names to not correspond any method declaration (and a string search <br/>\nis not 100% reliable because the test name could be generated <br/>\ndynamically or there could be multiple tests with the same name; at <br/>\nleast Specsy allows duplicate names).<br/>\n<br/>\nThere are also some other limitations which affect all Java testing <br/>\nframeworks:<br/>\n<br/>\n- When a test prints something, IntelliJ IDEA collects what is printed <br/>\nto stdout and stderr, so that when you select a test in the test <br/>\nresults, it will show only what that test printed. This is very useful <br/>\nfor debugging with println-statements. But because there is no <br/>\nsynchronization between the test runner and the IDE which reads the <br/>\nstdout/err, IDEA doesn&#39;t always associate what a test printed with the <br/>\ncorrect test, especially when the tests are very fast.<br/>\n<br/>\n- No built-in support for executing the tests in parallel. Third-party <br/>\ntools are needed for it.<br/>\n<br/>\nPossibly because of being faced with the above limitations, at least <br/>\nSpecs, ScalaTest and TestNG have implemented their own test runners. <br/>\nThis in turn means that the IDEs need to support each test runner <br/>\nindividually, which results in varying levels of quality and features <br/>\nbetween the integration with different test runners. For example, at <br/>\nleast some time ago, IDEA&#39;s Scala plugin did not support automatically <br/>\nfinding all Specs tests in the project and executing them.<br/>\n<br/>\nThere is also code duplication inside and between all IDEs, build tools <br/>\nand CI servers because they have had to write code to keep track of the <br/>\ntest execution state, and that needs to be repeated for each test runner.<br/>\n<br/>\n<br/>\n\tTHE PROJECT<br/>\n<br/>\nI&#39;ll soon start writing a test runner to solve the above mentioned <br/>\nlimitations and to ease the integration with build tools, IDEs, CI <br/>\nservers etc. The license will be Apache License 2.0. I&#39;m also thinking <br/>\nof making this not only open source, but also &quot;open development&quot;, by <br/>\nscreencasting similar to <a rel=\"nofollow\" target=\"_blank\" href=\"http://jamesshore.com/Blog/Lets-Play/\">http://jamesshore.com/Blog/Lets-Play/</a><br/>\n<br/>\nWhat the test runner will provide to testing frameworks, is a superset <br/>\nof the features provided by these JUnit classes: RunWith, Runner, <br/>\nDescription, RunNotifier. The API will be a bit more generic and with <br/>\nnew abstractions, in order to support for example nested tests.<br/>\n<br/>\nWhat the test runner will provide to IDEs, build tools and CI servers, <br/>\nis a library for launching the tests in a new VM instance, monitoring <br/>\nthe test execution status, collecting the test results and what was <br/>\nprinted to stdout/err etc. The tools just need to configure the <br/>\nclasspath and choose which tests to run (e.g. using file name patters). <br/>\nI will also provide a reference implementation of an UI for running the <br/>\ntests, because running tests as part of the TDD cycle is too important a <br/>\nfeature for its usability to be left in the hands of programmers without <br/>\ninteraction design skills.<br/>\n<br/>\nWhat the test runner will provide to users, is running tests from all <br/>\ntesting frameworks (which support this runner or JUnit&#39;s test runner) in <br/>\none suite, running them in parallel on multiple CPU cores (I&#39;ll tackle <br/>\nparallelization over multiple machines as a separate project, probably <br/>\nas a commercial tool), integration with every development tool on the <br/>\nJVM (I intend to contact all tool vendors and gather requirements from <br/>\nthem to ease the integration) and reliability (backwards compatiblity is <br/>\nvery important to me, and I plan on making it possible for each tool <br/>\nvendor to write integration tests, which will be run as part of the test <br/>\nrunner&#39;s development builds, to detect any breaking changes).<br/>\n<br/>\nSo, I would like to ask for your opinion on this project. Here are some <br/>\nquestions:<br/>\n<br/>\n- Do you find this useful?<br/>\n<br/>\n- If you had the possibility to rewrite JUnit&#39;s test runner, without <br/>\nhaving to think about backwards compatibility, what would you do <br/>\ndifferently? @RunWith&#39;s javadoc says: &quot;We added this feature late in <br/>\ndevelopment. While it seems powerful we expect the runner API to change <br/>\nas we learn how people really use it. Some of the classes that are <br/>\ncurrently internal will likely be refined and become public.&quot;<br/>\n<br/>\n- What do you think would be a good name for the project? One suggestion <br/>\nis CTR4J (actually named similar to SLF4J) which is googleable, but <br/>\nperhaps not very pronounceable or memorable.<br/>\n<br/>\n- What would be a good name for the annotation which corresponds <br/>\n@RunWith? Its name needs to be different to be googleable and to make it <br/>\neasy to annotate a class with both JUnit&#39;s and this test runner&#39;s <br/>\nannotation.<br/>\n<br/>\n- Any other thoughts?<br/>\n<br/>\n-- <br/>\nEsko Luontola<br/>\nwww.orfjackal.net</div>", 
    "prevInTime": 22932, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1284242919", 
    "canDelete": false, 
    "nextInTopic": 22934, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PDRDOEJGREU3LjMwMTA2MDNAZ21haWwuY29tPg=="
    }
}