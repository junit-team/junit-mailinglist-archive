{
    "numMessagesInTopic": 74, 
    "nextInTime": 15978, 
    "senderId": "uuAVO6-cyBe8YGTklWbNC9qu0WfziV5g-h2Ys_uZIRh8H8R-8LdkxhPwVVuNakA78vVKHfuRSRL93MIqfKtExiCVsbsz0olA4Rq9mlFSR8Igf3MLNL6vsUhRq2sM0hDX19ooWrfLmE1-", 
    "systemMessage": false, 
    "subject": "Pluggable Selector considered harmful? (Re: [junit] Re: Observations from a prod", 
    "from": "=?iso-8859-1?q?Harald_M._M=FCller?= &lt;harald.m.mueller@...&gt;", 
    "authorName": "Harald M. MÃ¼ller", 
    "msgSnippet": "... [...] ... to use a ... [...] ... I try to repeat the question - if I missed the point, then please ignore the rest: You want to understand why people who", 
    "msgId": 15977, 
    "rawEmail": "Return-Path: &lt;harald.m.mueller@...&gt;\r\nX-Sender: harald.m.mueller@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (qmail 80314 invoked from network); 6 Feb 2006 14:20:46 -0000\r\nReceived: from unknown (66.218.67.35)\n  by m26.grp.scd.yahoo.com with QMQP; 6 Feb 2006 14:20:46 -0000\r\nReceived: from unknown (HELO n10a.bullet.scd.yahoo.com) (66.94.237.44)\n  by mta9.grp.scd.yahoo.com with SMTP; 6 Feb 2006 14:20:46 -0000\r\nComment: DomainKeys? See http://antispam.yahoo.com/domainkeys\r\nReceived: from [66.218.69.5] by n10.bullet.scd.yahoo.com with NNFMP; 06 Feb 2006 14:19:03 -0000\r\nReceived: from [66.218.66.80] by t5.bullet.scd.yahoo.com with NNFMP; 06 Feb 2006 14:19:03 -0000\r\nDate: Mon, 06 Feb 2006 14:19:03 -0000\r\nTo: junit@yahoogroups.com\r\nMessage-ID: &lt;ds7lsn+mdgg@...&gt;\r\nIn-Reply-To: &lt;43E69F3B.3070101@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=&quot;ISO-8859-1&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\nX-Mailer: Yahoo Groups Message Poster\r\nX-Yahoo-Newman-Property: groups-compose\r\nX-eGroups-Msg-Info: 1:12:0:0\r\nFrom: =?iso-8859-1?q?Harald_M._M=FCller?= &lt;harald.m.mueller@...&gt;\r\nSubject: Pluggable Selector considered harmful? (Re: [junit] Re: Observations from a prod\r\nX-Yahoo-Group-Post: member; u=74507428; y=zQhuHnNcXK34Bru0YMAWgeGW2QpEi87lL8JvNLAUeBpMZjsH_faL0DBhFw\r\nX-Yahoo-Profile: harald_m_mueller\r\n\r\n--- In junit@yahoogroups.com, &quot;J. B. Rainsberger&quot; &lt;jbrains@...&gt; wrote:\n[...=\r\n]\n&gt; [1] A common way to extract test methods from JUnit (3.x) tests is\nto u=\r\nse a \n&gt; naming convention with reflection. Assume that we do not have acces=\r\ns to \n&gt; metainformation such as annotations.\n[...]\n&gt; \n&gt; What I find strange=\r\n in all this is that I demonstrated doing what JUnit \n&gt; does in another pie=\r\nce of code, and even people who use JUnit looked at \n&gt; me like I was high.[=\r\n2] Why the double standard? Why does JUnit get to \n&gt; use this pattern and I=\r\n don&#39;t. It&#39;s just weird, so I&#39;m looking for an \n&gt; explanation by asking the=\r\n more general question, &quot;What&#39;s so bad about \n&gt; Pluggable Selector?&quot;\n\nI try=\r\n to repeat the question - if I missed the point, then please\nignore the res=\r\nt: You want to understand why people who are quite\nunconcerned that JUnit (=\r\nand JBoss and ...) uses reflection (e.g. for a\npluggable selector) find it =\r\nhorrible that you want to use it in\narbitrary application code?\n\nOne possib=\r\nle answer that (at least for me - working with &quot;many-peopled\nprojects&quot;: 20.=\r\n.80 team members or so) appears quite obvious: It&#39;s the\ntooling support.\n\nI=\r\nf you\n\n* need to debug (pressing Fx gets you into the called method)\n* need=\r\n to use JProbe for profiling (get simple call traces)\n* need to use Eclipse=\r\n to find uses of a method\n* need to use Eclipse to do refactoring\n* need to=\r\n use a number of home-grown tools working on source code or\nbyte-code\n\n(and=\r\n who wouldn&#39;t need to use all these tools in a technically\ncomplex, sometim=\r\nes archtectural/design-level mediocre, sometimes\noutspoken *bad* environmen=\r\nt [high turn-around of arbitrarily selected\n&quot;consultants&quot; (actually every l=\r\nevel of hackers that&#39;s out there)] -\ncreating mediocre, sometimes bad desig=\r\nn, code, tests etc. - in other\nwords: In a standard real project :-( ),\nyou=\r\n are faced with the industry standard that compile-time\ndependencies are ha=\r\nndled nicely by all tools; whereas reflection is\nalmost 100% unhandled.\n\nTh=\r\nat doesn&#39;t mean that a stack trace containing some reflection will\nstop all=\r\n developers dead in their tracks - but it means that each\nsequence of\nrefle=\r\nction calls more on a stack trace introduces more &quot;noise&quot; that\nneeds to be =\r\nunderstood and dug through and &quot;filtered out&quot;.\n\nA good rule-of-the-thumb fo=\r\nr reflection in today&#39;s tooling\nenvironments is, in my experience: \n\nIf ref=\r\nlection appears only on top of the stack (i.e., is used by the\n&quot;calling mac=\r\nhine&quot;), it does not disturb that much. If it occurs\n&quot;between application ca=\r\nlls&quot; (e.g. in EJB local calls!), it is hard to\nuse and disrupts work (e.g. =\r\nstepping out of a reflectively called\nmethod, the more so it it threw an ex=\r\nception ...). If it appears\n&quot;beetween application calls&quot; more than 2 or 3 t=\r\nimes, quite a lot of\ntools bevome hcavy-going ...\n\nIt might be that by care=\r\nful tuning of tools (masking of methods in\nshown or recorded or navigated [=\r\ne.g. in debugging] stack traces;\nsearching also through certain patterns of=\r\n strings [e.g. in\nrefacotring]) might alleviate that problem.\n\nAnother way =\r\nmight be to push the tool builders to embrace reflection\nas a &quot;first class =\r\nprogramming concept to be encountered anywhere&quot;,\nwhich hence must be suppor=\r\nted by all (or most) standard functionality\n(however, I&#39;d be hard pressed t=\r\no design a way to e.g. replace in a\nrefactoring tool some - or even all - m=\r\nethods &quot;test...&quot; with e.g.\n&quot;letUsTest...&quot;. Most probably, one would need a =\r\nway of describing the\n&quot;meta-rules&quot; of such &quot;meta-programming idioms&quot; to the=\r\n tool so that it\ncould handle them on the same level as we humans do. A sim=\r\nilar effect\nis slowly taking place with the presentation of data structures=\r\n in\ndebuggers: You can now tell the debugger that it should drill down\nfrom=\r\n an ArrayList or even a TreeSet directly to its &quot;elements&quot;,\ninstead of show=\r\ning you all that structure of elements[] arrays and\nlinked TreeMap$Entry ob=\r\njects. Joe: You are also active in the\nrefactoring community - do you know =\r\nwhether  someone has written an\nextension e.g. to Eclipse for this?).\n\nMy p=\r\nractical experience is also that because of the tooling aspects,\ncode gener=\r\nation from some higher-level language usually(! ... ?)\nblends in with stand=\r\nard tools better - because the generator(s) can\ncreate code which looks qui=\r\nte &quot;hand-written&quot;, at least when looked at\nat the call stack level.\n\nSo in =\r\nthe end, I think the question is NOT AT ALL dynamic typing vs.\nstatic check=\r\ning (or even typing): It is the fact that reflection\nsupport in Java, C# et=\r\nc. is much *less* than a language with\nwell-supported dynamic typing. In su=\r\nch a language, I would expect that\ntools behave according to that dynamic c=\r\noncept, e.g. handle a &quot;string\ncall&quot; exactly the same as a &quot;fixed name call&quot;=\r\n ...\n\n... another attempt to understand by giving a sort of explanation ...=\r\n\n\nRegards\nHarald M.\n\n\n\n\n", 
    "profile": "harald_m_mueller", 
    "topicId": 15891, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 74507428, 
    "prevInTime": 15976, 
    "contentTrasformed": false, 
    "postDate": "1139235543", 
    "canDelete": false, 
    "nextInTopic": 15978, 
    "prevInTopic": 15975, 
    "headers": {
        "inReplyToHeader": "PDQzRTY5RjNCLjMwNzAxMDFAcm9nZXJzLmNvbT4=", 
        "messageIdInHeader": "PGRzN2xzbittZGdnQGVHcm91cHMuY29tPg=="
    }
}