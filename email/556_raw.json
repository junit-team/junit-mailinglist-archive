{
    "topicId": 556, 
    "postDate": "983215889", 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "from": "Sameer Ajmani &lt;ajmani@...&gt;", 
    "canDelete": false, 
    "replyTo": "LIST", 
    "senderId": "IBhopL6HmINO8yuWO0lN8jvkfnztxAp9UucoHT67wKVUALUU_2PVWD45Hpckt95WQG3BB6m-t2AT4EeSVHBOAHXu9vBr", 
    "nextInTime": 557, 
    "userId": 0, 
    "prevInTime": 555, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PDIwMDEwMjI2MTkzMS5PQUEyNjk3MkBjaG9yZC5sY3MubWl0LmVkdT4="
    }, 
    "authorName": "Sameer Ajmani", 
    "numMessagesInTopic": 1, 
    "msgSnippet": "All-- I have implemented a new TestDecorator called TestTimeout that allows the user to wrap tests or test suites such that each test is run until completion", 
    "contentTrasformed": false, 
    "msgId": 556, 
    "nextInTopic": 0, 
    "systemMessage": false, 
    "rawEmail": "Return-Path: &lt;ajmani@...&gt;\r\nX-Sender: ajmani@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (EGP: mail-7_0_4); 26 Feb 2001 19:31:32 -0000\r\nReceived: (qmail 56022 invoked from network); 26 Feb 2001 19:31:32 -0000\r\nReceived: from unknown (10.1.10.27) by l7.egroups.com with QMQP; 26 Feb 2001 19:31:32 -0000\r\nReceived: from unknown (HELO chord.lcs.mit.edu) (18.26.0.40) by mta2 with SMTP; 26 Feb 2001 19:31:29 -0000\r\nReceived: from chord.lcs.mit.edu (localhost [127.0.0.1]) by chord.lcs.mit.edu (8.9.1a/8.9.1) with ESMTP id OAA26972 for &lt;junit@yahoogroups.com&gt;; Mon, 26 Feb 2001 14:31:29 -0500 (EST)\r\nMessage-Id: &lt;200102261931.OAA26972@...&gt;\r\nTo: junit@yahoogroups.com\r\nSubject: TestTimeout decorator\r\nDate: Mon, 26 Feb 2001 14:31:29 -0500\r\nX-eGroups-From: Sameer Ajmani &lt;ajmani@...&gt;\r\nFrom: Sameer Ajmani &lt;ajmani@...&gt;\r\n\r\nAll--\n\nI have implemented a new TestDecorator called &quot;TestTimeout&quot; that allows\nthe user to wrap tests or test suites such that each test is run until\ncompletion or until a specified timeout.  This is good for stopping\ntests that might enter infinite loops or to implement simple wall-clock\nperformance tests.  The code is all in one class, given below.\n\n--Sameer\n\n-------------------------------------\nSave text below to &quot;TestTimeout.java&quot;\n-------------------------------------\npackage junit.extensions;\n\nimport junit.framework.Test;\nimport junit.framework.TestSuite;\nimport junit.framework.TestResult;\nimport junit.framework.TestListener;\nimport junit.framework.AssertionFailedError;\nimport junit.extensions.TestDecorator;\nimport java.util.Enumeration;\nimport java.util.Stack;\n\n/**\n   A TestDecorator that times out if the given Test runs longer than a\n   specified number of milliseconds.\n   @author Sameer Ajmani (ajmani@...) */\npublic class TestTimeout extends TestDecorator implements TestListener\n{\n    private long _millis; // the timeout in milliseconds\n    private int _numRun;  // the number of tests run before timeout\n    /**\n       Constructs a Test that times out if the given Test runs longer than\n       millis ms.  */\n    public TestTimeout(final Test test, final long millis)\n    {\n        super(test);\n        _millis = millis;\n    }\n    /**\n       Constructs a TestSuite from the given TestSuite whose tests time out\n       if they run longer than millis ms. */\n    public static TestSuite createSuite(final TestSuite suite,\n                                        final long millis)\n    {\n        if (containsSelf(suite))\n            throw new IllegalArgumentException\n                (&quot;TestTimeout.createSuite: suite contains self&quot;);\n        TestSuite newSuite = new TestSuite();\n        Enumeration tests = suite.tests();\n        // wrap each test in the suite with a TestTimeout decorator\n        while (tests.hasMoreElements()) {\n            Test test = (Test)tests.nextElement();\n            if (test instanceof TestSuite)\n                newSuite.addTest(TestTimeout.createSuite\n                                 ((TestSuite)test, millis));\n            else\n                newSuite.addTest(new TestTimeout(test, millis));\n        }\n        return newSuite;\n    }\n    /**\n       Checks if a TestSuite contains itself (should never happen).  Allows\n       the caller to determine if it&#39;s safe recursively explore the suite.  */\n    private static boolean containsSelf(final TestSuite suite)\n    {\n        return containsSelf(suite, new Stack());\n    }\n    private static boolean containsSelf(final TestSuite suite,\n                                        final Stack stack)\n    {\n        if (stack.contains(suite))\n            return true;\n        stack.push(suite);\n        Enumeration tests = suite.tests();\n        while (tests.hasMoreElements()) {\n            Test test = (Test)tests.nextElement();\n            if ((test instanceof TestSuite)\n                && containsSelf((TestSuite)test, stack))\n                return true;\n        }\n        stack.pop();\n        return false;\n    }\n    /**\n       Run the underlying Test for up to _millis ms.  If the Test times out,\n       add an error to the given TestResult. */\n    public void run(final TestResult result)\n    {   \n        _numRun = 0;\n        result.addListener(this);\n        runUntilTimeout(result);\n        result.removeListener(this);\n        checkResult(result);\n    }\n    /**\n       Run the underlying Test for up to _millis ms.  If testing is\n       interrupted, add an error to the given TestResult. */\n    private void runUntilTimeout(final TestResult result)\n    {\n        Thread thread = new Thread(new Runnable() {\n                public void run()\n                {\n                    getTest().run(result);\n                }\n            });\n        // ensure the test thread can&#39;t lock up our thread\n        thread.setDaemon(true);\n        thread.setPriority(Math.max(Thread.currentThread().getPriority()-1,\n                                    Thread.MIN_PRIORITY));\n        thread.start();\n        try {\n            thread.join(_millis);\n        } catch (InterruptedException e) {\n            result.addError(getTest(), e);\n        }\n        if (thread.isAlive())\n            thread.setPriority(Thread.MIN_PRIORITY);\n    }\n    /**\n       Check that all the TestCases in the underlying Test were run.  If\n       not, add an error to the given TestResult.  */\n    private synchronized void checkResult(final TestResult result)\n    {\n        int numTests = getTest().countTestCases();\n        if (_numRun &lt; numTests) {\n            StringBuffer message = new StringBuffer\n                (&quot;Test time exceeded &quot;).append(_millis).append(&quot;ms&quot;);\n            if (numTests &gt; 1) {\n                message.append(&quot;: &quot;).append(_numRun)\n                    .append(&quot; out of &quot;).append(numTests)\n                    .append(&quot; tests run&quot;);\n            }\n            result.addError(getTest(),\n                            new InterruptedException(message.toString()));\n        }\n    }\n    public synchronized void endTest(final Test test)\n    {\n        _numRun++;\n    }\n    public synchronized void startTest(final Test test)\n    {\n        // ignored\n    }\n    public synchronized void addError(final Test test, final Throwable t)\n    {\n        // ignored\n    }\n    public synchronized void addFailure(final Test test,\n                                        final AssertionFailedError t)\n    {\n        // ignored\n    }\n}\n\n", 
    "subject": "TestTimeout decorator"
}