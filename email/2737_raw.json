{
    "topicId": 2726, 
    "postDate": "1001346394", 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "from": "Eric Vought &lt;evought@...&gt;", 
    "canDelete": false, 
    "replyTo": "LIST", 
    "senderId": "lJ7jqqJuOQ3AK3hzCbjld1nyntDD_8m5v1C5ZgicdzU51QQs9m2tp9dccngnvn91u_kOWXW-mof5LsZDBrerxmAzKUOU", 
    "nextInTime": 2738, 
    "userId": 0, 
    "prevInTime": 2736, 
    "prevInTopic": 2736, 
    "headers": {
        "inReplyToHeader": "PDcwMEVBMTdBMTQyQUQzMTE4QTFFMDAwOEM3MjRCQ0I0RUI3OUY2QGFnYmdudHMwMy5hZ2JnLmludHJhbmV0Pg==", 
        "messageIdInHeader": "PFBpbmUuTE5YLjQuMzAuMDEwOTI0MTAyODEwMC4yMjMwNS0xMDAwMDBAYnJhaW4ucWx1ZS1sYW4+"
    }, 
    "authorName": "Eric Vought", 
    "numMessagesInTopic": 10, 
    "msgSnippet": "Well, some points: 1) I don t see where you release the lock in the getsLockAfterwards thread. This can cause your test to fail if you have more than one ", 
    "contentTrasformed": false, 
    "msgId": 2737, 
    "nextInTopic": 2756, 
    "systemMessage": false, 
    "rawEmail": "Return-Path: &lt;evought@...&gt;\r\nX-Sender: evought@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (EGP: mail-7_3_2_2); 24 Sep 2001 15:53:19 -0000\r\nReceived: (qmail 81179 invoked from network); 24 Sep 2001 15:52:37 -0000\r\nReceived: from unknown (10.1.10.27)\n  by 10.1.1.220 with QMQP; 24 Sep 2001 15:52:37 -0000\r\nReceived: from unknown (HELO ral.qlue.com) (65.201.137.7)\n  by mta2 with SMTP; 24 Sep 2001 15:53:32 -0000\r\nReceived: from brain.qlue-lan (brain.qlue-lan [192.168.1.28])\n\tby ral.qlue.com (Postfix) with ESMTP id A0F5F541A\n\tfor &lt;junit@yahoogroups.com&gt;; Mon, 24 Sep 2001 11:51:25 -0400 (EDT)\r\nDate: Mon, 24 Sep 2001 11:46:34 -0400 (EDT)\r\nTo: &quot;&#39;junit@yahoogroups.com&#39;&quot; &lt;junit@yahoogroups.com&gt;\r\nSubject: Re: [junit] Multithreaded code\r\nIn-Reply-To: &lt;700EA17A142AD3118A1E0008C724BCB4EB79F6@...&gt;\r\nMessage-ID: &lt;Pine.LNX.4.30.0109241028100.22305-100000@...-lan&gt;\r\nMIME-Version: 1.0\r\nContent-Type: TEXT/PLAIN; charset=US-ASCII\r\nFrom: Eric Vought &lt;evought@...&gt;\r\n\r\n\nWell, some points:\n\n1) I don&#39;t see where you release the lock in the getsLockAfterwards\nthread. This can cause your test to fail if you have more than one\ntestcase in that test class.\n\n2) Along similar lines, you should initialize your LockManager in setUp()\nto ensure that it is recreated before each test. That way, if a test fails\nand leaves the LockManager in a bad state, you other tests will still\nprobably run.\n\n3) I think you can make it a bit more robust like so:\n\n     public void testBlocks() {\n         final int recordNo = 1;\n\t final Object syncObject = new Object();\n         Runnable getsLockFirst = new Runnable() {\n             public void run() {\n\t\t synchronized (syncObject) {\n                     int recordKey = lockManager.obtainLock(recordNo);\n\t\t     syncObject.notify();\n                     try {\n\t\t         wait(syncObject);\n                     } catch (InterruptedException e) {}\n                     lockManager.releaseLock(recordNo, recordKey);\n                 }\n             } // run()\n         }; // Runnable\n\n         Thread getLockThread = new Thread(getsLockFirst);\n\n\t synchronized (syncObject)\n\t {\n         \tgetLockThread.start();\n\t\ttry {\n\t \t    wait(syncObject);\n\t\t} catch InterruptedException(e) {}\n\n                assert(lockManager.isRecordLocked(recordNo));\n\t        syncObject.notify();\n         }\n\n         // wait for thread to finish before returning\n         try {\n             getLockThread.join(300);\n         } catch (InterruptedException e) {}\n\n\t // If it is stuck, unstuck it\n\t If (getLockThread.isAlive())\n\t {\n\t     getLockThread.interrupt();\n\t     fail(&quot;Thread never released lock.&quot;);\n\t } else {\n\t    assert(!(lockManager.isRecordLocked(recordNo)));\n         }\n    }\n\nI haven&#39;t compiled or run this, and it may not be perfect, but there are\nseveral things to note:\n\n1) There&#39;s only one extra thread to worry about.\n\n2) You have several control points where you know your thread and the\ntestcase code are in sync. Your first assert won&#39;t be run until the record\nlock has been obtained and your thread waits to make sure the testcode has\nhad a chance to verify that fact. The test method already has a lock on\nthe synchronization object before the subordinate thread even starts\nexecuting, so there can be no issue of timing no matter what the platform\ndoes. The wait() statements release their lock and queue themselves for\nnotification atomically, providing a smooth transfer of control with no\npossible timing issues. The test code is bludgeoned into behaving in a\npredictable, linear manner.\n\n3) A join() with a timeout replaces the sleep. This will wait for your\nchild thread to die before returning, but, if things appear stuck, you get\nthe option of interrupting the thread. Unlike sleep(), join() will return\nas quickly as it can.\n\n4) Since there are no sleeps anywhere here, your test code should execute\nas quickly as possible. Otherwise, as you add testcases, the arbitrary\nlengths of time will begin adding up and you will be tempted to not run\nthe regression tests as often as you should.\n\nTesting threaded code like this is always a royal pain because you\nspend at least as much time debugging your test code as the code under\ntest. In this case, you are testing a very simple feature, but the test\ncode is fairly complex.\n\nIn general, though, you should put a lot of effort into factoring out all\nof your thread synchronization code into centralized, independently\ntested, reusable code and/or depend on library routines wherever you can.\nKeep as much of your application as linear as possible so you have to\nwrite as few of these testcases as possible.\n\nOn Mon, 24 Sep 2001, Emily Bache wrote:\n\n&gt; I am also a little unsure of how to test multithreaded code, and I hope my\n&gt; question is a bit more specific than the last one :-)\n&gt;\n&gt; I wrote this test case to test my multithreaded code, and it appears to work\n&gt; on my platform. (Windows NT, jdk 1.2.2) I am just worried that it only\n&gt; passes because the thread scheduling of the JVM implementation I am using\n&gt; happens to work out right. Has anyone else tried to write this kind of test?\n&gt; What might be a better approach?\n&gt;\n&gt; Thanks!\n&gt;\n&gt; Emily\n&gt;\n&gt; ----- code in question -------------------\n&gt;\n&gt; public class LockManagerTest extends TestCase {\n&gt;     private LockManager lockManager = new LockManager();\n&gt;\n&gt;     /**\n&gt;      * test for the requirement that the obtainLock method on\n&gt;      * LockManager must block until the requested lock becomes\n&gt;      * available\n&gt;      */\n&gt;     public void testBlocks() {\n&gt;         final int recordNo = 1;\n&gt;         Runnable getsLockFirst = new GetAndHoldLockFor100(recordNo);\n&gt;         Runnable getsLockAfterwards = new Runnable() {\n&gt;             public void run() {\n&gt;                 // assert the record is locked when we first ask, but\n&gt; becomes\n&gt;                 // available (or else the whole test run hangs).\n&gt;                 assert(lockManager.isRecordLocked(recordNo));\n&gt;                 int key = lockManager.obtainLock(recordNo);\n&gt;             }\n&gt;         };\n&gt;         Thread one = new Thread(getsLockFirst);\n&gt;         Thread two = new Thread(getsLockAfterwards);\n&gt;         one.start();\n&gt;         two.start();\n&gt;         // wait for test to run before returning\n&gt;         try {\n&gt;             Thread.currentThread().sleep(300);\n&gt;         } catch (InterruptedException e) {}\n&gt;\n&gt;     }\n&gt;\n&gt;     private class GetAndHoldLockFor100 implements Runnable {\n&gt;         private int recordNo;\n&gt;         public GetAndHoldLockFor100(int recordNo) {\n&gt;             this.recordNo = recordNo;\n&gt;         }\n&gt;         public void run() {\n&gt;                 int recordKey = lockManager.obtainLock(recordNo);\n&gt;                 try {\n&gt;                     Thread.currentThread().sleep(100);\n&gt;                 } catch (InterruptedException e) {}\n&gt;                 lockManager.releaseLock(recordNo, recordKey);\n&gt;             }\n&gt;     }\n&gt; }\n&gt;\n&gt; ------ end code in question ---------------------------------\n&gt;\n&gt;\n&gt; To unsubscribe from this group, send an email to:\n&gt; junit-unsubscribe@yahoogroups.com\n&gt;\n&gt;\n&gt; Your use of Yahoo! Groups is subject to http://docs.yahoo.com/info/terms/\n&gt;\n&gt;\n&gt;\n\n-- \nEric Vought\nChief Technical Officer - QLUE Consulting, Inc.\n\nevought@... toll-free: 888-771-3538  RTP area: 919-816-9901\n\n\n", 
    "subject": "Re: [junit] Multithreaded code"
}