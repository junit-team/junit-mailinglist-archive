{
    "numMessagesInTopic": 38, 
    "nextInTime": 5904, 
    "senderId": "PWrx3CWvSbwAHCygVfD-wezWMfNYiYjncsIKAUZq2QYit-M3hTmo9vzCtg5XHn4AXJlIBy_51zODSYRl5zNmTYqrqII_YsFoU4waYQ", 
    "systemMessage": false, 
    "subject": "Re: [junit] Do JUnit internals suck?!?", 
    "from": "Berin Loritsch &lt;bloritsch@...&gt;", 
    "authorName": "Berin Loritsch", 
    "msgSnippet": "... For these methods, that really isn t too much of a problem. ... right. ... The TestMethodInvoker is the Command pattern I am talking about.  The ", 
    "msgId": 5903, 
    "rawEmail": "Return-Path: &lt;bloritsch@...&gt;\r\nX-Sender: bloritsch@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (EGP: mail-8_1_1_4); 2 Oct 2002 14:38:25 -0000\r\nReceived: (qmail 64802 invoked from network); 2 Oct 2002 14:38:25 -0000\r\nReceived: from unknown (66.218.66.216)\n  by m1.grp.scd.yahoo.com with QMQP; 2 Oct 2002 14:38:25 -0000\r\nReceived: from unknown (HELO www1.kc.aoindustries.com) (209.15.201.70)\n  by mta1.grp.scd.yahoo.com with SMTP; 2 Oct 2002 14:38:24 -0000\r\nReceived: from apache.org ([65.105.132.131])\n\tby www1.kc.aoindustries.com (8.11.6/8.11.0) with ESMTP id g92EcM300389\n\tfor &lt;junit@yahoogroups.com&gt;; Wed, 2 Oct 2002 09:38:22 -0500\r\nMessage-ID: &lt;3D9B0669.4020403@...&gt;\r\nDate: Wed, 02 Oct 2002 10:44:57 -0400\r\nUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.0; en-US; rv:1.1) Gecko/20020826\r\nX-Accept-Language: en-us, en\r\nMIME-Version: 1.0\r\nTo: junit@yahoogroups.com\r\nSubject: Re: [junit] Do JUnit internals suck?!?\r\nReferences: &lt;C450D96664CBD31182B600A0C97668B16481A8@CASE052&gt;\r\nContent-Type: text/plain; charset=us-ascii; format=flowed\r\nContent-Transfer-Encoding: 7bit\r\nFrom: Berin Loritsch &lt;bloritsch@...&gt;\r\nX-Yahoo-Group-Post: member; u=64910131\r\nX-Yahoo-Profile: bloritsch\r\n\r\nMark Meyers wrote:\n&gt; \n&gt;&gt;-----Original Message-----\n&gt;&gt;From: Berin Loritsch [mailto:bloritsch@...]\n&gt;&gt;...\n&gt;&gt;\n&gt;&gt;Another issue I have is that while JUnit defines the Test interface,\n&gt;&gt;it only really expects the TestCase base class.  It is unclear how\n&gt;&gt;the Test interface interacts with the system.  Sometimes I would much\n&gt;&gt;rather work with my own base class that is completely separate from\n&gt;&gt;JUnit.  The Assert class should be made a static utility clasee, not\n&gt;&gt;a base class as well.  That would allow us to work with the assert\n&gt;&gt;methods from any class something like this is much better:\n&gt;&gt;\n&gt; \n&gt; \n&gt; class Xxx extends Assert implements Test ?\n&gt; Never tried it though...\n&gt; \n&gt; \n&gt;&gt;Assert.isTrue( myObject.rocks() );\n&gt;&gt;\n&gt;&gt;than this:\n&gt;&gt;\n&gt;&gt;assertTrue( myObject.rocks() );\n&gt;&gt;\n&gt;&gt;...\n&gt;&gt;\n&gt;&gt;What I would like to see is the following:\n&gt;&gt;\n&gt;&gt;* Explicit use of interfaces--make the contracts clear, and code the\n&gt;&gt;   test runners/collectors to use the interfaces and not the base\n&gt;&gt;   classes.  If there are different contracts with a type of \n&gt;&gt;test/suite,\n&gt;&gt;   then it needs a new interface.\n&gt;&gt;\n&gt;&gt;* Making Assert into a set of static utilities so that we don&#39;t have\n&gt;&gt;   to inherit it to make it useful.\n&gt;&gt;\n&gt; \n&gt; \n&gt; That is the case already:\n&gt; \n&gt; public class Assert...    \n&gt;     static public void assertTrue(boolean condition){\n&gt;         assertTrue(null, condition);\n&gt;     }\n&gt;     static public void fail(String message)...\n&gt; \n&gt; The downside is of course not being able to override those methods...\n&gt; (redefining assertTrue(String, boolean) will not change behavior of\n&gt; assertTrue(boolean) as with instance methods)\n\nFor these methods, that really isn&#39;t too much of a problem.\n\n&gt; \n&gt; \n&gt;&gt;...\n&gt;&gt;* Explicit declaration of the TestCase being the Leaf of the \n&gt;&gt;model, not\n&gt;&gt;   a branch (as it is now treated).  A different interface \n&gt;&gt;for TestSuite\n&gt;&gt;   and TestCase will help.\n&gt;&gt;\n&gt; \n&gt; \n&gt; When writing tests, it is very usefull to group related tests together in a\n&gt; single java file . \n\nright.\n\n&gt; It may be clearer on the &quot;internals&quot; side if there would be a\n&gt; TestMethodInvoker class that takes a TestCase and a Method and invokes the\n&gt; method on the instance. \n&gt; You could get rid of the TestCase(String nameThatIsReallyAMethodName)\n&gt; constructor. The constructor is most definitely confusing to novice users.\n&gt; And they are encouraged to put setUp code in the constructor. It is there\n&gt; anyway, not so the setUp method.\n&gt; The TestSuite and TestMethodInvoker would participate in the composite\n&gt; pattern, the TestCase could then just be collection of test methods (and no\n&gt; longer implement Test, behavior extracted to TestMethodInvoker ).\n&gt; Is that a good idea ?\n&gt; Downside is backward compatibility, of course...\n\n\nThe TestMethodInvoker is the Command pattern I am talking about.  The\nTestMethodInvoker would be able to be constructed like this:\n\npublic class TestMethodInvoker implements Test\n{\n     private final Class m_klass;\n     private final Method m_method;\n\n     public TestMethodInvoker( Class klass, Method method )\n     {\n         m_klass = klass;\n         m_method = method;\n     }\n\n     public TestResult run() throws Exception\n     {\n         // do stuff with the TestResult...\n\n         Object instance = null;\n         try\n         {\n             instance = m_klass.newInstance();\n         }\n         catch ( Exception e )\n         {\n             // legacy code\n             Constructor const = m_klass.getConstructor( new Class[]\n                           { String.class } );\n\n             instance = const.newInstance( new Object[]\n                      { &quot;Change to empty constructor please&quot; } );\n         }\n\n         Object result = m_method.invoke( instance,\n                         new Class[]{}, new Object[] {} );\n     }\n}\n\nOr something along those lines.  The esoteric reflection logic\nis nicely encapsulated, and there is no need for the String\nconstructor.  It does not change the way you write tests, nor\ndoes it fail if you only have the String constructor.\n\nThe Invoker you have there is sort of a &quot;Delegate&quot;, but it allows\nyou to have a new Class from a new ClassLoader for each Invoker,\njust like now.  There is less confusion over what is what.\n\n\n-- \n\n&quot;They that give up essential liberty to obtain a little temporary safety\n  deserve neither liberty nor safety.&quot;\n                 - Benjamin Franklin\n\n\n", 
    "profile": "bloritsch", 
    "topicId": 5875, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 64910131, 
    "prevInTime": 5902, 
    "contentTrasformed": false, 
    "postDate": "1033569897", 
    "canDelete": false, 
    "nextInTopic": 5904, 
    "prevInTopic": 5902, 
    "headers": {
        "messageIdInHeader": "PDNEOUIwNjY5LjQwMjA0MDNAYXBhY2hlLm9yZz4=", 
        "referencesHeader": "PEM0NTBEOTY2NjRDQkQzMTE4MkI2MDBBMEM5NzY2OEIxNjQ4MUE4QENBU0UwNTI+"
    }
}