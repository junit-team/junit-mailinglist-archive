{
    "numMessagesInTopic": 9, 
    "nextInTime": 16897, 
    "senderId": "MmAwJnlmblwuX_BTOBp3ZemfXRj_PAafaxeVYVqkdrhqrAdxinPgPJEkkU3-ySOIomjERfTaFgLklkdLDM6e4I5NzEbBuMjJfFVYRBHyy-0l9hef", 
    "systemMessage": false, 
    "subject": "Re: [junit] Deep Equals of two JavaBeans", 
    "from": "&quot;Joakim Ohlrogge&quot; &lt;joakim.ohlrogge@...&gt;", 
    "authorName": "Joakim Ohlrogge", 
    "msgSnippet": "Java collections implement the equals method so the way I see it you could use equals() on anything that is not an array or a primitive type. That would work", 
    "msgId": 16896, 
    "profile": "j0hlrogge", 
    "topicId": 16890, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 261856052, 
    "messageBody": "<div id=\"ygrps-yiv-322690041\">Java collections implement the equals method so the way I see it you could<br/>\nuse equals() on anything that is not an array or a primitive type. That<br/>\nwould<br/>\nwork for collections and would attempt an equals on any other object.<br/>\n<br/>\nHere is the Javadoc for AbstractMap.equals(Object other):<br/>\n<br/>\nCompares the specified object with this map for equality. Returns true if<br/>\nthe given object is also a map and the two maps represent the same mappings.<br/>\nMore formally, two maps t1 and t2 represent the same mappings if t1.keySet<br/>\n().equals(t2.keySet()) and for every key k in t1.keySet(), (t1.get(k)==null<br/>\n? t2.get(k)==null : t1.get(k).equals(t2.get(k))) . This ensures that the<br/>\nequals method works properly across different implementations of the map<br/>\ninterface.<br/>\n<br/>\nThis implementation first checks if the specified object is this map; if so<br/>\nit returns true. Then, it checks if the specified object is a map whose size<br/>\nis identical to the size of this set; if not, it it returns false. If so, it<br/>\niterates over this map&#39;s entrySet collection, and checks that the specified<br/>\nmap contains each mapping that this map contains. If the specified map fails<br/>\nto contain such a mapping, false is returned. If the iteration completes,<br/>\ntrue is returned.<br/>\nLists, Sets etc als to deep compares with &quot;eager false&quot; or how ever you<br/>\nwould call it when it tries to determine as quickly and efficently when<br/>\nsomething is not equal.<br/>\n<br/>\nCheers!<br/>\n/Joakim Ohlrogge<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<blockquote><span title=\"qreply\"> On 6/8/06, wheelerpoker &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:wheelerpoker@...\">wheelerpoker@...</a>&gt; wrote:<br/>\n&gt;<br/>\n&gt;   I am trying to implement an assertion that does a deep equals of two<br/>\n&gt; POJOs vs. using the POJOs&#39; equals methods like assertEquals(Object,<br/>\n&gt; Object). The code is below. It&#39;s kind of shakey and only works on<br/>\n&gt; properties that are maps, collections, arrays, primitives, and beans<br/>\n&gt; (complex types). It attempts to thwart infinite recursion from cycles<br/>\n&gt; by caching objects in a List and performing reference equality tests.<br/>\n&gt; I&#39;ve tried to make the code thread-safe, but it&#39;s probably not. Can<br/>\n&gt; you look and comment?<br/>\n&gt;<br/>\n&gt; import java.util.ArrayList;<br/>\n&gt; import java.util.Collection;<br/>\n&gt; import java.util.Date;<br/>\n&gt; import java.util.Iterator;<br/>\n&gt; import java.util.List;<br/>\n&gt; import java.util.Map;<br/>\n&gt; import java.util.Set;<br/>\n&gt;<br/>\n&gt; import junit.framework.Assert;<br/>\n&gt;<br/>\n&gt; import org.apache.commons.beanutils.PropertyUtils;<br/>\n&gt; import org.apache.commons.logging.Log;<br/>\n&gt; import org.apache.commons.logging.LogFactory;<br/>\n&gt;<br/>\n&gt; public final class AssertUtil extends Assert {<br/>\n&gt;<br/>\n&gt; private static final Log logger = LogFactory.getLog(AssertUtil.class);<br/>\n&gt; /** for detecting cycles and preventing infinite recursive loop */<br/>\n&gt; private static final List referenceCache = new ArrayList();<br/>\n&gt;<br/>\n&gt; private AssertUtil() {<br/>\n&gt; throw new UnsupportedOperationException(&quot;do not use&quot;);<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; public static synchronized void assertDeepEquals(Object expected,<br/>\n&gt; Object actual) {<br/>\n&gt; logger.debug(&quot;assertDeepEquals called&quot;);<br/>\n&gt; doAssertDeepEquals(null, expected, actual);<br/>\n&gt; logger.debug(&quot;clearing &quot; + referenceCache.size() + &quot; objects<br/>\n&gt; from reference cache&quot;);<br/>\n&gt; referenceCache.clear();<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; private static void doAssertDeepEquals(String name, Object<br/>\n&gt; expected, Object actual) {<br/>\n&gt; if (referenceAlreadyCached(expected)) {<br/>\n&gt; logger.debug(&quot;cycle detected on &quot; + expected);<br/>\n&gt; return;<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; if (expected == null) {<br/>\n&gt; assertNull(&quot;expected &quot; + name + &quot; was null, but actual was<br/>\n&gt; not&quot;, actual);<br/>\n&gt; } else if (expected != null) {<br/>\n&gt; assertNotNull(&quot;expected &quot; + name + &quot; was not null, but<br/>\n&gt; actual was&quot;, actual);<br/>\n&gt;<br/>\n&gt; // both objects guaranteed not null from now on<br/>\n&gt; if (isSimpleProperty(expected)) {<br/>\n&gt; evaluateSimpleProperty(name, expected, actual);<br/>\n&gt; } else {<br/>\n&gt; referenceCache.add(expected);<br/>\n&gt; if (isArrayProperty(expected)) {<br/>\n&gt; evaluateArrayProperty(name, (Object[])expected,<br/>\n&gt; (Object[])actual);<br/>\n&gt; } else if (isCollectionProperty(expected)) {<br/>\n&gt; evaluateCollectionProperty(name,<br/>\n&gt; (Collection)expected, (Collection)actual);<br/>\n&gt; } else if (isMapProperty(expected)) {<br/>\n&gt; evaluateMapProperty((Map)expected, (Map)actual);<br/>\n&gt;<br/>\n&gt; } else {<br/>\n&gt; evaluateComplexProperty(expected, actual);<br/>\n&gt; }<br/>\n&gt; }<br/>\n&gt; }<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; private static void evaluateSimpleProperty(String name, Object<br/>\n&gt; expected, Object actual) {<br/>\n&gt; logger.debug(name + &quot; [expected = &quot; + expected + &quot;, actual = &quot;<br/>\n&gt; + actual + &quot;]&quot;);<br/>\n&gt; assertEquals(name + &quot; not equal&quot;, expected, actual);<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; private static void evaluateArrayProperty(String name, Object[]<br/>\n&gt; expected, Object[] actual) {<br/>\n&gt; if (expected.length != actual.length)<br/>\n&gt; fail(&quot;not the same length&quot;);<br/>\n&gt; for (int i=0; i&lt;expected.length; i++)<br/>\n&gt; doAssertDeepEquals(name + &quot;[&quot; + i + &quot;]&quot;, expected[i],<br/>\n&gt; actual[i]);<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; private static void evaluateCollectionProperty(String name,<br/>\n&gt; Collection expected, Collection actual) {<br/>\n&gt; evaluateArrayProperty(name, expected.toArray(), actual.toArray());<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; /** TODO perform a deep comparison of each maps&#39; keys */<br/>\n&gt; private static void evaluateMapProperty(Map expected, Map actual) {<br/>\n&gt; Set keys = expected.keySet();<br/>\n&gt; if (!keys.equals(actual.keySet()))<br/>\n&gt; fail(&quot;dissimilar keys&quot;);<br/>\n&gt;<br/>\n&gt; for (Iterator i=keys.iterator(); i.hasNext();) {<br/>\n&gt; Object key = i.next();<br/>\n&gt; doAssertDeepEquals(key.toString(), expected.get(key),<br/>\n&gt; actual.get(key));<br/>\n&gt; }<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; private static void evaluateComplexProperty(Object expected,<br/>\n&gt; Object actual) {<br/>\n&gt; Map expectedProps = null, actualProps = null;<br/>\n&gt; try {<br/>\n&gt; expectedProps = PropertyUtils.describe(expected);<br/>\n&gt; actualProps = PropertyUtils.describe(actual);<br/>\n&gt; // not to thrilled about this, better way??<br/>\n&gt; expectedProps.remove(&quot;class&quot;);<br/>\n&gt; actualProps.remove(&quot;class&quot;);<br/>\n&gt; } catch (Exception ex) {<br/>\n&gt; ex.printStackTrace();<br/>\n&gt; logger.error(ex);<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; evaluateMapProperty(expectedProps, actualProps);<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; private static boolean isSimpleProperty(Object o) {<br/>\n&gt; return (<br/>\n&gt; o instanceof CharSequence ||<br/>\n&gt; o instanceof Number ||<br/>\n&gt; o instanceof Boolean ||<br/>\n&gt; o instanceof Date ||<br/>\n&gt; o instanceof Character);<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; private static boolean isArrayProperty(Object o) {<br/>\n&gt; return o.getClass().isArray();<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; private static boolean isCollectionProperty(Object o) {<br/>\n&gt; return (o instanceof Collection);<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; private static boolean isMapProperty(Object o) {<br/>\n&gt; return (o instanceof Map);<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; private static boolean referenceAlreadyCached(Object o) {<br/>\n&gt; for (int i=0, n=referenceCache.size(); i&lt;n; i++) {<br/>\n&gt; if (o == referenceCache.get(i)) {<br/>\n&gt; return true;<br/>\n&gt; }<br/>\n&gt; }<br/>\n&gt; return false;<br/>\n&gt; }<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt;  <br/>\n&gt;<br/>\n<br/>\n<br/>\n[Non-text portions of this message have been removed] </span></blockquote></div>", 
    "prevInTime": 16895, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1149855080", 
    "canDelete": false, 
    "nextInTopic": 16899, 
    "prevInTopic": 16890, 
    "headers": {
        "inReplyToHeader": "PGU2YTFobytyOWZvQGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PGI5ZWU1ZTQxMDYwNjA5MDUxMXYzMGY5NzkyZWsyZTlkZWViNWJkYjY5MjE3QG1haWwuZ21haWwuY29tPg==", 
        "referencesHeader": "PGU2YTFobytyOWZvQGVHcm91cHMuY29tPg=="
    }
}