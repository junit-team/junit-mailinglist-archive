{
    "numMessagesInTopic": 17, 
    "nextInTime": 6864, 
    "senderId": "Ez2rvT3vI-Tif1hmDvYnSvSfjnvfpdDiMk42egMrYt5o9MZd9B_UXBVyjjD46NYd2DWQp6x1ShCzAU_uDPmBzLUNM5rZ1lw1DjVhE7Mh8Q", 
    "systemMessage": false, 
    "subject": "Testability", 
    "from": "&quot;Scott Stirling&quot; &lt;scottstirling@...&gt;", 
    "authorName": "Scott Stirling", 
    "msgSnippet": "I ve been thinking about Test Driven Development and the question of what is it about it that ensures testability.  As Kent Beck says, if you follow TDD ", 
    "msgId": 6863, 
    "profile": "jrun5", 
    "topicId": 6863, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 112036634, 
    "messageBody": "<div id=\"ygrps-yiv-849583121\">I&#39;ve been thinking about Test Driven Development and the question of what is<br/>\nit about it that ensures testability.  As Kent Beck says, if you follow TDD<br/>\nreligiously, you should have 100% statement coverage for your code.  Let me<br/>\nrepeat that: 100%.  I&#39;ve also been thinking about this concept of<br/>\n&quot;testability&quot; and what it means (incidentally, I think &quot;maintainability&quot; is<br/>\nalso pretty reducible to the explanation offered below).<br/>\n<br/>\nOn this list we recently (1/24/2003) had a simple question:<br/>\n<blockquote><span title=\"ireply\"> &gt; I am currently writing a web application which uses the<br/>\n&gt; Websphere connection pool. I can write tests for the rest<br/>\n&gt; of my applciation, how to I test connections to the db, and<br/>\n&gt; objects which use the db connections without having to run<br/>\n&gt; the websphere server? - clairegknowles [<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:mail@...\">mail@...</a>]<br/>\n<br/>\n </span></blockquote>And a simple answer:<br/>\n<blockquote><span title=\"ireply\"> &gt; Write a provider that wraps the pool, mock the provider,<br/>\n&gt; and away you go. - Jason Rogers [<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:jacaetevha@...\">jacaetevha@...</a>]<br/>\n<br/>\n </span></blockquote>Another respondent advocated a different approach, which sparked a thought<br/>\nprovoking debate:<br/>\n<blockquote><span title=\"ireply\"> &gt; Use separate interfaces to get the connection from the<br/>\n&gt; pool and do work with the connection.  I do something<br/>\n&gt; like this (the error handling may be a bit simplified):<br/>\n&gt;<br/>\n&gt; Object doMyThing(Connection con, String something) {<br/>\n&gt;     // do stuff on the connection and return the object.<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; public Object doMyThing(ConnectionFactory factory, String something) {<br/>\n&gt;     Connection con = factory.getConnection();<br/>\n&gt;     return doMyThing(con, something);<br/>\n&gt;     con.close();<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; The database test code invokes the first method; the<br/>\n&gt; real users of the code invoke the second. The second<br/>\n&gt; method isn&#39;t tested, because there&#39;s just not much there<br/>\n&gt; to break. If something did break in it, the functional<br/>\n&gt; tests catch it. - Curt Sampson [mailto:<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:yahoo_sucks@...\">yahoo_sucks@...</a>]<br/>\n<br/>\n </span></blockquote>I engaged in a stimulating debate with Curt on his answer, which I tried to<br/>\nargue wasn&#39;t as elegant or object oriented, in principle, as a mock object<br/>\napproach.  It won&#39;t result in 100% statement coverage, for one thing (which<br/>\nwill require you to trust Curt or whomever that the 5% of code that isn&#39;t<br/>\ncovered by unit tests, &quot;can&#39;t go wrong,&quot; which might be true, but more<br/>\nlikely not).  Most of my objections have been based on the idea that object<br/>\noriented design should be influenced by the need for testability, but so<br/>\nhave Curt&#39;s.  So why are we arguing such different strategies for solving<br/>\nthe problem of &quot;testability?&quot;<br/>\n<br/>\nObviously, a method added for no other purpose than to make a class&#39;s<br/>\nbehavior more directly accessible to external tests (ignore the default<br/>\naccess in the first doMyThing() above) enhances the testability of a class.<br/>\nA test() method right in the class itself would also enhance testability, as<br/>\nwould a main() method that contained a test runnable from the command line.<br/>\nBut I don&#39;t think any of these solutions is a very clean object oriented<br/>\nsolution because the test method has just been tacked on, irrespective of<br/>\nthe object being modeled.<br/>\n<br/>\nFrom a test driven development standpoint, you would not add a main() or a<br/>\ntest() to a class to make it testable because you write the tests before you<br/>\nadd any code to the class.  What test could drive you to write a test()<br/>\nmethod in a class under test (unless you&#39;re writing a testing framework,<br/>\nperhaps)?  I wonder the same thing about any method added to a class.<br/>\n<br/>\nPut another way, I wonder the same thing about any behavior added to an<br/>\nobject.  Testing is not a behavior of most objects.  So we should hope to<br/>\ntest most objects without modeling testing in them in any way.  So how do<br/>\nyou make things testable without corrupting the object design with behaviors<br/>\nadded or modified just to make objects testable?  And why is it that test<br/>\ndriven development, practiced religiously, will typically give you 100%<br/>\nstatement coverage without adding any such test-only methods to a class?<br/>\n<br/>\nI think the answer has to do with finite-state machines.  TDD is a<br/>\nmethodology that results in the development of clean, working finite-state<br/>\nmachines.  It works so well because the methodology of writing tests first<br/>\ndrives the mental process to identify and make explicit, in the appropriate<br/>\norder of priority:<br/>\n1. the desired outputs<br/>\n2. the inputs and behaviors needed to transition the machine from an initial<br/>\nor existing state to desired output<br/>\n3. the objects that compose the machine (one of the least important things<br/>\nat first, contrary to more traditional design methodology).  By this I mean<br/>\nthe objects are initially just named bags of data and behavior; the naming<br/>\nof the objects and definition of their boundaries evolves as the 1st and 2nd<br/>\npriorities are realized.<br/>\n<br/>\nIt seems the best way to build and test a finite-state machine is to make<br/>\nthe inputs and outputs explicit, and to make the state transitions step-wise<br/>\nand traceable.  It&#39;s a fallout from object oriented programming constraints<br/>\nthat the steps become methods in objects, and the traceability of the steps<br/>\nbecomes actualized in your unit test methods and TestCases.<br/>\n<br/>\nAfter doing TDD, traceability and explicit inputs and outputs are what<br/>\nyou&#39;ve built into your application and which remain, even if you take away<br/>\nthe unit tests when you&#39;re done.<br/>\n<br/>\nSo going back to the question of testability, I think there are some basic<br/>\nthings that automatically result in testability in OOP (this list by no<br/>\nmeans accurate or exhaustive, and inspired by some reading about state<br/>\nmachines in the testing literature, namely Beizer and Binder):<br/>\n  - objects or collaborations of objects modeled as finite-state machines<br/>\n  - methods for making state transitions in the objects themselves or in<br/>\nother objects<br/>\n  - explicit inputs to and outputs from methods<br/>\n  - step-wise, traceable state transitions<br/>\n<br/>\nI think these things become realized in terms of language and design<br/>\nspecifics.  For example:<br/>\n  - traceability requires state transition methods to be accessible for unit<br/>\ntesting<br/>\n  - state must be verifiable via attributes or methods that return state<br/>\ninformation and can be used in assertions<br/>\n  - step-wise means you don&#39;t make monolithic, god methods or classes that<br/>\nhide multiple, untraceable transitions<br/>\n  - explicit inputs means that something like the method below should be<br/>\ntuned based on the fact that the Connection object is the *actual* input<br/>\nneeded for the behavior to do its thing:<br/>\n<blockquote><span title=\"ireply\">   &gt; public Object doMyThing(ConnectionFactory factory, String something) {<br/>\n  &gt;     Connection con = factory.getConnection();<br/>\n  &gt;     Object o = doMyThing(con, something);<br/>\n  &gt;     con.close();<br/>\n  &gt;     return o;<br/>\n  &gt; }<br/>\n<br/>\n </span></blockquote>Passing in the ConnectionFactory, from this perspective, is an *implicit*<br/>\ninput of a Connection, which hides the fact that what&#39;s really needed for<br/>\nthe doMyThing() state transition is a Connection.    The ConnectionFactory<br/>\nis extraneous to the transition enacted by the method.  But in case you left<br/>\nthe signature with the ConnectionFactory (or Connection for that matter), a<br/>\nMockObject would allow you to keep the design &quot;pure.&quot;  So how important is<br/>\npurity of design?  That&#39;s another question.<br/>\n<br/>\nScott Stirling<br/>\nFramingham, MA</div>", 
    "prevInTime": 6862, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1044337685", 
    "canDelete": false, 
    "nextInTopic": 6865, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PEtJRUhJQklPQkFFTEpBSElQTkhETUVNTkNPQUEuc2NvdHRzdGlybGluZ0ByY24uY29tPg=="
    }
}