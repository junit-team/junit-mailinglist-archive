{
    "numMessagesInTopic": 67, 
    "nextInTime": 5300, 
    "senderId": "iTYECa3sjukFkIKJOW01Z8yAGy6JMhNaD52hWB-_JW6rrgR5j_skvI_H_9eknXR_YJZojNFj0kwGaniByBNFoxiojYJ-uQxeRCoLVT0tLRqYRoKl", 
    "systemMessage": false, 
    "subject": "RE: [junit] Re: distinguishing between failures and errors", 
    "from": "&quot;J. B. Rainsberger&quot; &lt;jbr@...&gt;", 
    "authorName": "J. B. Rainsberger", 
    "msgSnippet": "... Never. Intentionally undefined means, by definition, that no test case has been conceived for that codepath, let alone written. ... One should not. If", 
    "msgId": 5299, 
    "rawEmail": "Return-Path: &lt;jbr@...&gt;\r\nX-Sender: jbr@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (EGP: mail-8_0_7_4); 2 Jul 2002 20:22:44 -0000\r\nReceived: (qmail 57225 invoked from network); 2 Jul 2002 20:22:44 -0000\r\nReceived: from unknown (66.218.66.217)\n  by m13.grp.scd.yahoo.com with QMQP; 2 Jul 2002 20:22:44 -0000\r\nReceived: from unknown (HELO tomts8-srv.bellnexxia.net) (209.226.175.52)\n  by mta2.grp.scd.yahoo.com with SMTP; 2 Jul 2002 20:22:44 -0000\r\nReceived: from siferra ([64.228.114.29]) by tomts8-srv.bellnexxia.net\n          (InterMail vM.5.01.04.19 201-253-122-122-119-20020516) with ESMTP\n          id &lt;20020702202227.VXXB18868.tomts8-srv.bellnexxia.net@siferra&gt;\n          for &lt;junit@yahoogroups.com&gt;; Tue, 2 Jul 2002 16:22:27 -0400\r\nMessage-ID: &lt;200207021625170735.0491A34F@...&gt;\r\nIn-Reply-To: &lt;D5776D09D084A740B5D7F2926680FCF301247FA3@...&gt;\r\nReferences: &lt;D5776D09D084A740B5D7F2926680FCF301247FA3@...&gt;\r\nX-Mailer: Calypso Version 3.30.00.00 (4)\r\nDate: Tue, 02 Jul 2002 16:25:17 -0400\r\nTo: junit@yahoogroups.com\r\nSubject: RE: [junit] Re: distinguishing between failures and errors\r\nContent-Type: text/plain; charset=&quot;us-ascii&quot;\r\nFrom: &quot;J. B. Rainsberger&quot; &lt;jbr@...&gt;\r\nReply-To: jbr@...\r\nX-Yahoo-Group-Post: member; u=89240252\r\nX-Yahoo-Profile: nails762\r\n\r\n\n&gt;&gt; &gt; You can&#39;t test for any particular behavior from the callee\n&gt;&gt; &gt; if the callee&#39;s behavior in the face of a null pointer is \n&gt;&gt; &gt; intentially left undefined (e.g., for flexibility in \n&gt;&gt; &gt; implementing an interface).)\n&gt;&gt; \n&gt;&gt; The callee is the class being tested, the specifics for different\n&gt;&gt; implementations could be implemented\n&gt;&gt; in specific TestCases, \n&gt;\n&gt;Why test for behavior that is (intentionally) undefined?\n\nNever. &quot;Intentionally undefined&quot; means, by definition, that no test\ncase has been conceived for that codepath, let alone written.\n\n&gt;Consider a method that is defined to return &quot;an instance of some \n&gt;class implementing interface I.&quot;  In that specification, the\n&gt;particular class is undefined.\n&gt;\n&gt;If your implementation currently uses a class C, why test that \n&gt;the returned instance is of class C?\n\nOne should not. If the method signature is\n\n     I foo();\n\nthen the compiler guarantees that the answer to foo() is an I. No test\nis required.\n\nIn a different language, where typing is not so strong, one could\nwrite:\n\n    assertTrue( foo() instanceof I );\n\nor, if typing is not tied to a named interface, but rather a set of\nmethods:\n\n    assertTrue( foo() understands someMessage );\n\n[I use Java-like syntax for clarity. I do not imply that Java is\ninvolved.]\n\n&gt;If you test for class C and treat tests as documentation, then \n&gt;that implies that a caller is allowed to depend on the fact that \n&gt;you return class C.  That is usually _not_ at all what you want.\n\nPrecisely; in this case, the method signature should be\n\n    C foo();\n\nand not &quot;I foo();&quot;. Simple OO design.\n\n&gt;&gt; &gt; (How can a test show that a caller is responsible for not\n&gt;&gt; &gt; depending on certain current behavior of an implementation\n&gt;&gt; &gt; that is not part of the interface contract?)\n\nIt is not the job of a programmer test to think on behalf of the\nprogrammer. The programmer test is designed to codify what the\nprogrammer thinks about how code ought to behave. A programmer that\ndepends on an undocumented implementation detail -- whether documented\nby tests or words -- is taking an unnecessary risk. The programmer\nshould then write a test to codify his assumption about the code he is\nusing and hope that that test never fails. The good news is this: if\nthe undocumented implementation details ever change, the programmer\nwill know immediately and can attempt to recover from the change. Even\nbetter would have been to negotiate with the author of the other\nsoftware and nail down the behavior more.\n\n&gt;&gt; It can&#39;t, the caller&#39;s TestCase should do that. And possibly \n&gt;\n&gt;What caller?  That is, no caller necessarily even exists yet. \n&gt;So no, the caller&#39;s test case cannot do that.  \n\nIf no caller exists yet, then how can you ask the question?\n \n&gt;(And how could a test case for a caller detect whether that \n&gt;caller passes a null pointer to the called method?)\n&gt;\n&gt;&gt; the callee&#39;s documentation.\n&gt;\n&gt;EXACTLY--documentation, not just tests!!!\n\nOnce again: tests *are* documentation. You insist on the *need* for\nwritten documentation. I claim that it is not necessary. It may be\nuseful -- when well-written and kept up to date -- but it is not\nnecessary. Perhaps you simply need to realize that there are other\nforms of documentation than natural-language-written documentation.\n\n&gt;&gt; &gt; Because tests, being code, can&#39;t relate code to external concepts.\n \n&gt;&gt; &gt; \n&gt;&gt; &gt; (A specification can say that a function f returns the\nmathematical\n&gt;&gt; &gt; sum of two given integers subject to the limitations of 32-bit\n&gt;&gt; &gt; signed binary arithmetic.  How can a test say something like\nthat?)\n&gt;&gt; &gt; \n&gt;&gt; \n&gt;&gt; \ttry{\n&gt;&gt; \t    int result = instance.f(Integer.MAX_VALUE, \n&gt;&gt; Integer.MAX_VALUE);\n&gt;&gt; \t    fail(&quot;f should throw Exception when integer limits \n&gt;&gt; are met&quot;);\n&gt;&gt; \t}catch(IllegalStateException e){\n&gt;&gt; \t    assertTrue(&quot;function f returns the mathematical sum \n&gt;&gt; of two given\n&gt;&gt; integers subject to the limitations of 32-bit&quot;);\n&gt;\n&gt;Hmm.  I thought you were talking about having the test logic/behavior\n&gt;define the method behavior.\n\nThis test defines part of the method&#39;s behavior, does it not?\n\n&gt;You can stick documentation text in the test case code, but I don&#39;t\n&gt;think that changes the fact that it&#39;s human-parsed documentation.\n\nI do not understand what you mean in this case by &quot;human-parsed\ndocumentation.&quot; If I write something -- anything -- and you read it, it\nis trivially &quot;human-parsed&quot;: a human parsed it. That&#39;s not terribly\ninteresting in itself.\n\nYou may mean to say, &quot;You can write it as code, but I can still read it\nas words.&quot; Yes. That&#39;s one of the reasons we want easy-to-read tests:\nso humans can read them easily and understand them. But this is also\n*executable* documentation. Executable, self-verifying documentation of\nany kind is better than written documentation for the simple reason\nthat the former cannot be wrong while the latter can be wrong. One can\ntrust the former, but not the latter. I don&#39;t understand why this\nself-evident statement is such a sticking point.\n\n&gt;I do grant that your example shows that documentation doesn&#39;t have to \n&gt;be in some place separate from the tests.\n\nStronger: replace &quot;doesn&#39;t have to be&quot; with &quot;ought not to be&quot;.\n\n&gt;Hey--I have an idea.  You know how Javadoc 1.4 can provide links to \n&gt;the source?  Maybe (ideally, fantasy-land, etc.) it could provide\nlinks \n&gt;to the test case source too.\n\nThat sounds like Literate programming to me.\n\nIf there were a simple correspondence between classes and test cases,\nthis would be an excellent idea; however, test cases -- when written\nwell -- may not correspond so easily to individual classes.\n\nA product roadmap should probably include the following:\n\n* A short description of the overall intent of the product. (What is\nX?)\n* High-level design diagrams: package level, probably.\n* A Javadoc of the test cases, where complex test cases are described\nwhen they cannot be broken down into simpler ones.\n\nCan anyone suggest what might be missing without throwing in the\nkitchen sink?\n\nJ. B. Rainsberger,\nPresident, Diaspar Software Services\nLet&#39;s write software that people understand.\nhttp://www.diasparsoftware.com/\ntelephone: +1 416 791-8603\nAll correspondence (c) 2002 Diaspar Software Services.\nIf you want to use it, just ask; don&#39;t steal.\n\n\n", 
    "profile": "nails762", 
    "topicId": 5186, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 89240252, 
    "prevInTime": 5298, 
    "contentTrasformed": false, 
    "postDate": "1025641517", 
    "canDelete": false, 
    "nextInTopic": 5300, 
    "prevInTopic": 5298, 
    "headers": {
        "inReplyToHeader": "PEQ1Nzc2RDA5RDA4NEE3NDBCNUQ3RjI5MjY2ODBGQ0YzMDEyNDdGQTNAbXVzMDAxbXVsbGV0Lm1lcmNhdG9yLmNvbT4=", 
        "messageIdInHeader": "PDIwMDIwNzAyMTYyNTE3MDczNS4wNDkxQTM0RkBzbXRwMS5zeW1wYXRpY28uY2E+", 
        "referencesHeader": "PEQ1Nzc2RDA5RDA4NEE3NDBCNUQ3RjI5MjY2ODBGQ0YzMDEyNDdGQTNAbXVzMDAxbXVsbGV0Lm1lcmNhdG9yLmNvbT4="
    }
}