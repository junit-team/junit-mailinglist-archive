{
    "numMessagesInTopic": 3, 
    "nextInTime": 24412, 
    "senderId": "SRiFBALInJVIkyztKYc90RT4zxMOxSnxRZYaX3Pr38Xl6TMv_N33V7gLPpwQlYE45dZPyaR7IcG2ZZ9Lbs2X0piJ", 
    "systemMessage": false, 
    "subject": "Re: Rework runner concept / intellij or eclipse formatter file?", 
    "from": "&quot;hkaipe&quot; &lt;hkaipe@...&gt;", 
    "authorName": "hkaipe", 
    "msgSnippet": "... I want to defend the runner concept. I think the runner concept was an excellent and very open-minded move by JUnit-4.x. The runner concept clearly", 
    "msgId": 24411, 
    "profile": "hkaipe", 
    "topicId": 24409, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 478409128, 
    "messageBody": "<div id=\"ygrps-yiv-671683367\"><blockquote><span title=\"ireply\">&gt; I think the runner concept is one of the bigger flaws in junit.<br/>\n<br/>\n </span></blockquote>I want to defend the runner concept. I think the runner concept was an excellent and very open-minded move by JUnit-4.x. The runner concept clearly separates test-reporting (i.e. names and results of test-runs) and test-execution (what happens when a test runs) as two distinctly different concerns.<br/>\n<br/>\nThere is a default runner to support some generally accepted x-unit concepts. I.e. execution of test-methods that report a fail-or-error result by throwing an exception etc. But the runner concept offers a great opportunity to try out other wild ideas about test-execution as well, e.g. tests that don&#39;t have test-methods or exceptions, and have them harnessed as JUnit-tests that can be executed with the regular build-tools and IDEs (such as intellij or eclipse).<br/>\n<br/>\nI believe you recently commented on such a &quot;wild idea&quot; that was discussed in this forum:<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://tech.groups.yahoo.com/group/junit/message/24368\">http://tech.groups.yahoo.com/group/junit/message/24368</a><br/>\n<br/>\nIt would be fairly easy to develop those features in a 3rd-party project and thereafter implement a suitable JUnit-runner, which perhaps could be used like this:<br/>\n<br/>\n@RunWith(AnnotationDrivenSuiteRunner.class)<br/>\n@AnnotationDrivenSuite({ Foo.class, Bar.class})<br/>\npublic class Test_annotation_driven_testing_of_methods_in_Foo_and_Bar {}<br/>\n<br/>\nThis way it is possible for everyone to try out the ideas in IDEs and build-tools without the need to install any extra plugins - because to IDEs and build-tools it will all look like regular JUnit-tests.<br/>\n<br/>\nSo even though JUnit primarily supports certain ideas (test-methods, rules etc) on how to test Java software, its runner concept keeps an open door for anyone who thinks differently and wants to try out alternative ideas.<br/>\n<br/>\n...<br/>\n<blockquote><span title=\"ireply\"> &gt; If you want a certain behaviour you need to use a specific runner.<br/>\n&gt; Often you will want more than just one behaviour. For example you<br/>\n&gt; may want the spring runner with junit and jparams behaviour.<br/>\n&gt; Sometimes you will find a way to makr that work. Sometimes you just dont.<br/>\n<br/>\n </span></blockquote>As Stephen pointed out there are also rules, which are a better fit for some behaviour, but different rules can still be incompatible. As with everything else it depends on how well the runners and rules are implemented and how they are used. Sometimes rules or runners can be properly combined with a variety of other rules or runners - and sometimes they don&#39;t manage to perform in solitude. I have developed CallbackParams, which features a parameterization runner that can be used like this ...<br/>\n<br/>\n@RunWith(CallbackParamsRunner.class)<br/>\n@WrappedRunner(SpringJUnit4ClassRunner.class)<br/>\npublic class AParameterizedSpringTest {<br/>\n<br/>\n... to complement the spring runner or just about any other runner (including many other parameterization runners) with the parameterization-features of CallbackParams. So when you write ...<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; A rework of the runner-concept, introducing something like a<br/>\n&gt; chain for the behaviour-part would be a good idea, i guess.<br/>\n<br/>\n </span></blockquote>... I find it a bit bold, because from my point of view the runner concept can work as a pretty good fit for &quot;a chain for the behaviour-part&quot;. In the CallbackParams docs I have expressed it in terms of Aspect-Oriented Programming (AOP):<br/>\n&quot;JUnit&#39;s annotation @RunWith exposes a pointcut. The class CallbackParamsRunner acts as an advice for this pointcut by making the necessary modifications to the test-class and then delegates test-execution back to JUnit&#39;s built-in Runner implementation or to the specified third-party implementation, which in turn can be regarded as the next advice for the pointcut.&quot;<br/>\n<br/>\nSo the runner concept allows CallbackParamsRunner to apply its advice (i.e. additional behaviour) by making byte-code modifications, i.e. a pattern that is also used by many ~real~ AOP-frameworks to apply their advice.<br/>\n<br/>\nI like to think of rules as other advices that are applied at other pointcuts by JUnit&#39;s default runner (but without byte-code modifications). This way runners and rules can form a chain of behaviour by applying advices for different pointcuts.<br/>\n<br/>\n...<br/>\n<blockquote><span title=\"ireply\"> &gt; This could either be achieved by introducing a runner that does<br/>\n&gt; the work or by introducing this concept deeper into the framework.<br/>\n&gt; How are your thoughts on this?<br/>\n<br/>\n </span></blockquote>Well, I am open for new and clever extension points but why not start by developing it as a 3rd-party project that enforce the new features with a new powerful runner? But you need to do a very good job to make me want to deprecate today&#39;s runner concept ...<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; It could only work well when introduced to junit<br/>\n&gt; and the old concept would get marked deprecated as this makes<br/>\n&gt; runner-providers like spring migrate to the new concept. I would be willing<br/>\n&gt; to give it a try and implement this if you think its a good idea.<br/>\n<br/>\n </span></blockquote>/Henrik</div>", 
    "prevInTime": 24410, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1372612032", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 24410, 
    "headers": {
        "inReplyToHeader": "PENBTjY0VEdDcGVHckx1LTc1cz1MM3ZoSzlaT1UrWmpDd3FFZGFhMGNLN2lWZT1HZXA5QUBtYWlsLmdtYWlsLmNvbT4=", 
        "messageIdInHeader": "PGtxcG9rMCtsdXYzQGVHcm91cHMuY29tPg=="
    }
}