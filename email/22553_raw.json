{
    "numMessagesInTopic": 23, 
    "nextInTime": 22554, 
    "senderId": "6wGL0y60oje4LSa6Y9Ey-ppCfs1aB874TsVrhiVHop3JBcNik2uBa20iGK6uyJo9hNoIjfAxt2ICqlI7nmodmlyT", 
    "systemMessage": false, 
    "subject": "Re: [junit] Re: @DataPoints called several times for Theories", 
    "from": "David Saff &lt;david@...&gt;", 
    "authorName": "David Saff", 
    "msgSnippet": "... I m confused who the secondary consumers are.  Can you give me a code example that requires two copy invocations? ... a and b _can_ be aliases for the same", 
    "msgId": 22553, 
    "rawEmail": "Return-Path: &lt;david.saff@...&gt;\r\nX-Sender: david.saff@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nX-Received: (qmail 1846 invoked from network); 15 Mar 2010 20:46:20 -0000\r\nX-Received: from unknown (98.137.34.44)\n  by m3.grp.sp2.yahoo.com with QMQP; 15 Mar 2010 20:46:20 -0000\r\nX-Received: from unknown (HELO mail-pz0-f173.google.com) (209.85.222.173)\n  by mta1.grp.sp2.yahoo.com with SMTP; 15 Mar 2010 20:46:20 -0000\r\nX-Received: by mail-pz0-f173.google.com with SMTP id 3so2297677pzk.24\n        for &lt;junit@yahoogroups.com&gt;; Mon, 15 Mar 2010 13:46:20 -0700 (PDT)\r\nMIME-Version: 1.0\r\nX-Received: by 10.141.13.6 with SMTP id q6mr6408478rvi.146.1268685980366; Mon, \n\t15 Mar 2010 13:46:20 -0700 (PDT)\r\nIn-Reply-To: &lt;58dba2251003151056k4bf24ff2xf161e6415abf4aba@...&gt;\r\nReferences: &lt;58dba2251002180943q238dd8dv11ab48736321e178@...&gt;\n\t &lt;hlkif2+3mte@...&gt;\n\t &lt;58dba2251003121544p3cd7dd28h1a899ce657f66ad3@...&gt;\n\t &lt;a527fddf1003140915l73761ee1r781ba20fc768e42e@...&gt;\n\t &lt;75F5ED8A5A553646A46E00E6EC854FA30378C7E4@...-ais.com&gt;\n\t &lt;4f7da6b91003150651m12f2796kf9aab17ff312cd93@...&gt;\n\t &lt;58dba2251003151056k4bf24ff2xf161e6415abf4aba@...&gt;\r\nDate: Mon, 15 Mar 2010 16:46:20 -0400\r\nX-Google-Sender-Auth: 95c2320412d4e5ee\r\nMessage-ID: &lt;4f7da6b91003151346j733df1c0g5ec0459a18fcd14c@...&gt;\r\nTo: junit@yahoogroups.com\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Transfer-Encoding: quoted-printable\r\nX-eGroups-Msg-Info: 2:4:8:0:1\r\nFrom: David Saff &lt;david@...&gt;\r\nSubject: Re: [junit] Re: @DataPoints called several times for Theories\r\nX-Yahoo-Group-Post: member; u=341876227; y=rB6xkLHEVe6DHn5H19qYYqWMZdTvmML2kVz0ZpHbM9Y\r\nX-Yahoo-Profile: dsaff\r\n\r\nOn Mon, Mar 15, 2010 at 1:56 PM, Brett Daniel &lt;brettdaniel@...&gt; wrote=\r\n:\n&gt; David, Berin, and Mike,\n&gt;\n&gt; Thank you very much for the great comments.=\r\n I have asked Shin Hwei and Sang\n&gt; to provide their thoughts, but until the=\r\nn, here are my answers to your\n&gt; specific questions (SH&S will correct me i=\r\nf I get anything wrong).\n&gt;\n&gt; David wrote...\n&gt;&gt; do you agree the below would=\r\n work with the current implementation\n&gt;&gt; of Theories? It&#39;s four lines more =\r\nof boilerplate, but not totally\n&gt; intractable\n&gt;\n&gt; You are correct that copy=\r\ning within a @Datapoint method would create a new\n&gt; data point as needed an=\r\nd would probably be a good workaround for Berin&#39;s\n&gt; bug. However, I see two=\r\n drawbacks in addition to those you mention. =A0First,\n&gt; one would need to =\r\ninclude the copy invocation in every @DataPoint method\n&gt; that used createdO=\r\nnce. In contrast, annotating the @DataPoint itself would\n&gt; provide all cons=\r\numers with pristine values.\n\nI&#39;m confused who the secondary consumers are. =\r\n Can you give me a code\nexample that requires two copy invocations?\n\n&gt; Seco=\r\nnd, the solution fails when\n&gt; using @DataPoints with a theory that takes mu=\r\nltiple parameters:\n&gt;\n&gt; =A0 =A0private static Mutable[] createdOnce =3D new =\r\nMutable[] {\n&gt; =A0 =A0 =A0 =A0new Mutable(),\n&gt; =A0 =A0 =A0 =A0new Mutable() =\r\n};\n&gt;\n&gt; =A0 =A0@DataPoints()\n&gt; =A0 =A0public static Mutable[] mutables() {\n&gt;=\r\n =A0 =A0 =A0 =A0return new Mutable[] {\n&gt; =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0new=\r\n Mutable(createdOnce[0]),\n&gt; =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0new Mutable(crea=\r\ntedOnce[1])\n&gt; =A0 =A0 =A0 =A0};\n&gt; =A0 =A0}\n&gt;\n&gt; =A0 =A0@Theory\n&gt; =A0 =A0publ=\r\nic void testNotMutated(Mutable a, Mutable b) {\n&gt; =A0 =A0 =A0 =A0assertFalse=\r\n(a.isMutated);\n&gt; =A0 =A0 =A0 =A0a.mutate();\n&gt; =A0 =A0 =A0 =A0assertFalse(b.=\r\nisMutated);\n&gt; =A0 =A0 =A0 =A0b.mutate();\n&gt; =A0 =A0}\n&gt;\n&gt; The code above fail=\r\ns because a and b can be aliases for the same object. It\n&gt; may of course be=\r\n desirable to run a theory on identical instances, but in\n&gt; that case, the =\r\nuser could make that behavior explicit in another theory.\n\na and b _can_ be=\r\n aliases for the same object under the current\ndefinition of Theories.  If =\r\nthe developer doesn&#39;t want them to be, she\ncan say:\n\nassumeThat(a, not(b));=\r\n\n\nPreventing such aliasing would be a change, rather than an\noptimization, =\r\nin the current semantics of Theories.\n\n&gt;\n&gt; David wrote...\n&gt;&gt; What would you=\r\n think of allowing fields or methods to\n&gt;&gt; return PontentialAssignment, the=\r\n type of named references to data\n&gt;&gt; values used in the Theories runner?\n&gt; =\r\n...\n&gt;&gt; After further thought, the ParameterSupplier class is even better fo=\r\nr\n&gt;&gt; this kind of thing:\n&gt;\n&gt; Do I understand correctly that you are suggest=\r\ning pulling the\n&gt; PotentialAssignment array out of the internal Theory runn=\r\ner and making it\n&gt; available to developers? I seem to remember that Sang an=\r\nd Shin Hwei\n&gt; experimented with modifications to the PotentialAssignment an=\r\nd\n&gt; ParameterSupplier classes, but they can describe what they did better t=\r\nhan\n&gt; I.\n\nYes, indeed.\n\n&gt;\n&gt; David wrote...\n&gt;&gt; @DataPointSource public stati=\r\nc PotentialAssignment&lt;Mutable&gt; =3D\n&gt;&gt; Copy.ofMutable(new Mutable());\n&gt; ...\n=\r\n&gt;&gt; @DataSupplier public static OneTypeSupplier&lt;Mutable&gt; copyMutable =3D\n&gt;&gt; =\r\nCopies.of(new Mutable());\n&gt;\n&gt; I like the idea of allowing data sources that=\r\n produce things on-demand\n&gt; rather than in a pre-constructed array of value=\r\ns. This gets back to a brief\n&gt; discussion you and I had a long time ago abo=\r\nut having the @DataPoints\n&gt; annotation return Iterable&lt;DataPointType&gt;. That=\r\n would make things like the\n&gt; following possible:\n&gt;\n&gt; =A0@DataPoints\n&gt; =A0p=\r\nublic static Iterable&lt;Integer&gt; ints =3D Ints.between(-10, 10);\n&gt;\n&gt; =A0@Data=\r\nPoints\n&gt; =A0public static Iterable&lt;Mutable&gt; mutables() {\n&gt; =A0 =A0return Co=\r\npies.of(...);\n&gt; =A0}\n&gt;\n&gt; I don&#39;t know if it is better to overload @DataPoin=\r\nts or define new\n&gt; @DataPointSupplier/@DataPointSource annotations.\n\nI thin=\r\nk that allowing Iterable for DataPoints is a good idea on its\nown, for the =\r\nreasons you say.  The @DataPointSupplier proposal is\nanother step beyond.\n\n=\r\n&gt;\n&gt; Berin wrote...\n&gt;&gt; I hope we are not introducing an interface or base cl=\r\nass that\n&gt;&gt; would be required for the data classes to implement\n&gt;\n&gt; Absolut=\r\nely not. That is one of the benefits of defining copy strategies in\n&gt; the @=\r\nDataPoint annotations: the data point classes themselves remain\n&gt; unchaged.=\r\n\n&gt;\n&gt; Berin wrote...\n&gt;&gt; Is there a default CloneStrategy available?\n&gt;\n&gt; Sang=\r\n and Shin Hwei implemented several copy strategies, including one that\n&gt; us=\r\nes clone, but they did not include them in the patch in an effort to\n&gt; redu=\r\nce its size and complexity. Would it be helpful if they pushed some\n&gt; examp=\r\nles?\n&gt;\n&gt; Berin wrote...\n&gt;&gt; Here&#39;s a problem I spotted in the implementation=\r\n:\n&gt;\n&gt; Thank you very much for looking so closely at Sang and Shin Hwei&#39;s co=\r\nde. I\n&gt; have asked them to address any bugs that you or others find.\n&gt;\n&gt; Br=\r\nett\n&gt;\n&gt; On Mon, Mar 15, 2010 at 8:51 AM, David Saff &lt;david@...&gt; wrote:=\r\n\n&gt;\n&gt;&gt;\n&gt;&gt;\n&gt;&gt; On Mon, Mar 15, 2010 at 9:05 AM, Loritsch, Berin C.\n&gt;&gt; &lt;berin.l=\r\noritsch@... &lt;berin.loritsch%40gd-ais.com&gt;&gt; wrote:\n&gt;&gt; &gt; I&#39;m still goi=\r\nng through the patch. =A0Is there a default CloneStrategy\n&gt;&gt; available? =A0=\r\nAny cloneable object (implements the Cloneable interface) will\n&gt;&gt; be much q=\r\nuicker than another copy strategy. =A0It&#39;s also an interface and a\n&gt;&gt; copy =\r\nstrategy that comes with the JVM since before Java 2.\n&gt;&gt; &gt;\n&gt;&gt; &gt; Here&#39;s a pr=\r\noblem I spotted in the implementation:\n&gt;&gt; &gt;\n&gt;&gt; &gt; protected Object getCopySt=\r\nrategyInvokedObject(Object value,\n&gt;&gt; &gt; =A0 =A0 =A0 =A0Class&lt;? extends CopyS=\r\ntrategy&gt; copyStrategy, int index) throws\n&gt;&gt; CopyStrategyFailureException {\n=\r\n&gt;&gt; &gt; =A0 =A0 =A0try {\n&gt;&gt; &gt; =A0 =A0 =A0 =A0return copyStrategy.newInstance()=\r\n.copyDataPoint(value);\n&gt;&gt; &gt; =A0 =A0 =A0} catch (Exception e) {\n&gt;&gt; &gt; =A0 =A0=\r\n =A0 =A0throw new CopyStrategyFailureException(value, index,\n&gt;&gt; copyStrateg=\r\ny.getSimpleName());\n&gt;&gt; &gt; =A0 =A0 =A0}\n&gt;&gt; &gt; =A0 =A0}\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt; Invoking=\r\n copyStrategy.newInstance() for every object that needs to be\n&gt;&gt; copied is =\r\ngoing to be a major performance drain. =A0Not only are we creating\n&gt;&gt; more =\r\nwork for the garbage collector, we are going through the overhead of\n&gt;&gt; the=\r\n reflection API to do it. =A0You will have an order of magnitude better\n&gt;&gt; =\r\nperformance if you get your instance of the CopyStrategy first, and pass\n&gt;&gt;=\r\n that as necessary.\n&gt;&gt; &gt;\n&gt;&gt; &gt; Perhaps another point of making the code clea=\r\nner would be to pull all the\n&gt;&gt; data collection stuff into its own API. =A0=\r\nIt might even be able to support\n&gt;&gt; parameterized tests as well as theories=\r\n. =A0I imagine that was the idea behind\n&gt;&gt; ParameterSupplier?\n&gt;&gt;\n&gt;&gt; Sadly, =\r\nParameterSupplier only applies to one parameter at a time, but\n&gt;&gt; I could i=\r\nmagine a unified API that included interfaces for both.\n&gt;&gt;\n&gt;&gt; David\n&gt;&gt;\n&gt;&gt;\n&gt;=\r\n&gt; &gt;\n&gt;&gt; &gt; ________________________________\n&gt;&gt; &gt;\n&gt;&gt; &gt; From: junit@yahoogroups=\r\n.com &lt;junit%40yahoogroups.com&gt; on behalf of Mike\n&gt;&gt; Forsberg\n&gt;&gt; &gt; Sent: Sun=\r\n 3/14/2010 12:15 PM\n&gt;&gt; &gt; To: junit@yahoogroups.com &lt;junit%40yahoogroups.com=\r\n&gt;; Shin Hwei Tan; Sang\n&gt;&gt; Y Baik\n&gt;&gt; &gt; Subject: Re: [junit] Re: @DataPoints =\r\ncalled several times for Theories\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt; Please feel free=\r\n to join the mailing list. I would find the discussion\n&gt;&gt; &gt; interesting and=\r\n wish it would not run offline.\n&gt;&gt; &gt;\n&gt;&gt; &gt; Big Mike\n&gt;&gt; &gt;\n&gt;&gt; &gt; On Fri, Mar 12=\r\n, 2010 at 6:44 PM, Brett Daniel &lt;brettdaniel@...&lt;brettdaniel%40gmail.=\r\ncom&gt;&lt;mailto:\n&gt;&gt; brettdaniel%40gmail.com &lt;brettdaniel%2540gmail.com&gt;&gt; &gt; wrot=\r\ne:\n&gt;&gt; &gt;\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; The undergrads I am advising recently pushed a pa=\r\ntch that addresses the\n&gt;&gt; &gt;&gt; issue of mutable data points.\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;=\r\n&gt;\n&gt;&gt; http://github.com/stan6/junit/commit/dcfa3c41446c469a4edc7513e9e7a9b61=\r\n0b04020&lt;\n&gt;&gt; http://github.com/stan6/junit/commit/dcfa3c41446c469a4edc7513e9=\r\ne7a9b610b04020\n&gt;&gt; &gt;\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; The patch allows developers to define &quot;copy=\r\n strategies&quot; that duplicate\n&gt;&gt; &gt;&gt; marked data points before every theory ex=\r\necution. In this way, every\n&gt;&gt; &gt;&gt; execution receives a pristine data point,=\r\n which removes the problems\n&gt;&gt; caused\n&gt;&gt; &gt;&gt; when a theory mutates data poin=\r\nts. This is orthogonal to datapoint\n&gt;&gt; &gt;&gt; (re)creation, but I think copy st=\r\nrategies may help address the bug that\n&gt;&gt; &gt;&gt; Berin found.\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; The p=\r\natch creates a new, optional &quot;copyStrategy&quot; parameter for the\n&gt;&gt; &gt;&gt; @DataPo=\r\nint and @DataPoints annotations. If the developer wants to copy\n&gt;&gt; data\n&gt;&gt; =\r\n&gt;&gt; points, he or she sets the parameter to a class implementing a new\n&gt;&gt; &gt;&gt;=\r\n CopyStrategy interface.\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; Here is an example:\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; @RunWi=\r\nth(Theories.class)\n&gt;&gt; &gt;&gt; public class TestMutable {\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; @DataPoint(=\r\ncopyStrategy =3D MutableWithCopyStrategy.class)\n&gt;&gt; &gt;&gt; public static Mutable=\r\n mutable =3D new Mutable();\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; @Theory\n&gt;&gt; &gt;&gt; public static testMut=\r\nate(Mutable a) {\n&gt;&gt; &gt;&gt; a.mutate();\n&gt;&gt; &gt;&gt; }\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; @Theory\n&gt;&gt; &gt;&gt; public=\r\n static testNotMutated(Mutable a) {\n&gt;&gt; &gt;&gt; assertFalse(a.isMutated());\n&gt;&gt; &gt;&gt;=\r\n }\n&gt;&gt; &gt;&gt; }\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; In the current implementation of JUnit, the second t=\r\nheory may fail\n&gt;&gt; because\n&gt;&gt; &gt;&gt; the first theory mutates the datapoint. Wit=\r\nh a copy strategy enabled,\n&gt;&gt; both\n&gt;&gt; &gt;&gt; theories receive a new value.\n&gt;&gt; &gt;=\r\n&gt;\n&gt;&gt; &gt;&gt; Strategies can do almost anything: clone the data point, call a fac=\r\ntory\n&gt;&gt; &gt;&gt; method, or--as in the following implementation--instantaiate a n=\r\new\n&gt;&gt; object\n&gt;&gt; &gt;&gt; with a copy constructor.\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; public class Mutabl=\r\neWithCopyStrategy implements CopyStrategy {\n&gt;&gt; &gt;&gt; public Object copyDataPoi=\r\nnt(Object toCopy) throws Exception {\n&gt;&gt; &gt;&gt; return new Mutable((Mutable)toCo=\r\npy);\n&gt;&gt; &gt;&gt; }\n&gt;&gt; &gt;&gt; }\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; There are several benefits to this impleme=\r\nntation. First, the new\n&gt;&gt; parameter\n&gt;&gt; &gt;&gt; is completely optional; if it is=\r\n omitted, the theory runner behaves as\n&gt;&gt; it\n&gt;&gt; &gt;&gt; always has. Second, it d=\r\noesn&#39;t require modifying the data point&#39;s class\n&gt;&gt; &gt;&gt; (for\n&gt;&gt; &gt;&gt; example, t=\r\no add a copy constructor or clone method). Most importantly,\n&gt;&gt; it\n&gt;&gt; &gt;&gt; ma=\r\nkes it clear to the tester that without a copy strategy one theory\n&gt;&gt; &gt;&gt; ex=\r\necution can impact another.\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; I have CC&#39;d the two students in thi=\r\ns email. Please direct any questions\n&gt;&gt; to\n&gt;&gt; &gt;&gt; them.\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; Brett\n&gt;&gt;=\r\n &gt;&gt;\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; On Thu, Feb 18, 2010 at 5:28 PM, Berin &lt;berin.loritsch@gd-a=\r\nis.com&lt;berin.loritsch%40gd-ais.com&gt;&lt;mailto:\n&gt;&gt; berin.loritsch%40gd-ais.com =\r\n&lt;berin.loritsch%2540gd-ais.com&gt;&gt;\n&gt;&gt; &lt;berin.loritsch%40gd-ais.com&gt;&gt;\n&gt;&gt; &gt;&gt; wr=\r\note:\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; I agree with your prognosis, about fresh=\r\n data points for testing the\n&gt;&gt; &gt;&gt; &gt; theories. That is precisely why I prop=\r\nosed reading them once, and\n&gt;&gt; cloning\n&gt;&gt; &gt;&gt; &gt; them (making a copy) as need=\r\ned for each theory. With that approach we\n&gt;&gt; &gt;&gt; even\n&gt;&gt; &gt;&gt; &gt; get the protec=\r\ntion from mutated data points when you use the\n&gt;&gt; @DataPoint\n&gt;&gt; &gt;&gt; to\n&gt;&gt; &gt;&gt;=\r\n &gt; mark a static field.\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; Cloning is a much quicker operation=\r\n, does not execute any\n&gt;&gt; constructors.\n&gt;&gt; &gt;&gt; It\n&gt;&gt; &gt;&gt; &gt; merely copies the =\r\ncontents of the object memory verbatim.\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; With the current im=\r\nplementation, if you are not prepared for the\n&gt;&gt; &gt;&gt; &gt; combinatorial affect =\r\nof 60 data points combined with 60 data points\n&gt;&gt; for\n&gt;&gt; &gt;&gt; each\n&gt;&gt; &gt;&gt; &gt; th=\r\neory there is a major disconnect. The majority of the overhead in\n&gt;&gt; this\n&gt;=\r\n&gt; &gt;&gt; &gt; particular scenario has to do with creating objects (with the\n&gt;&gt; add=\r\nitional\n&gt;&gt; &gt;&gt; &gt; overhead of doing it by reflection).\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; When I=\r\n created only one instance of each class instead of two, the\n&gt;&gt; &gt;&gt; &gt; perfor=\r\nmance was twice as fast (i.e. 37 seconds down to about 16\n&gt;&gt; seconds).\n&gt;&gt; &gt;=\r\n&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; Essentially the number of times your @DataPoints method is call=\r\ned\n&gt;&gt; depends\n&gt;&gt; &gt;&gt; &gt; on the number of parameters in your @Theory and how m=\r\nany theories you\n&gt;&gt; &gt;&gt; have.\n&gt;&gt; &gt;&gt; &gt; Essentially the formula for my theory =\r\n(ha, ha) of the execution is\n&gt;&gt; like\n&gt;&gt; &gt;&gt; &gt; this:\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; N^(p-1) =\r\n+ 1\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; where:\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; N is the number of data points r=\r\neturned by the method\n&gt;&gt; &gt;&gt; &gt; p is the number of parameters\n&gt;&gt; &gt;&gt; &gt; and the=\r\n + 1 represents the run where the data point is read the first\n&gt;&gt; &gt;&gt; time\n&gt;=\r\n&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; So for 60 data points it is run 61 times for two parameters.=\r\n With\n&gt;&gt; three\n&gt;&gt; &gt;&gt; &gt; parameters it would be called 3601 times. I have to =\r\nverify with three\n&gt;&gt; &gt;&gt; &gt; parameters. The theory is called N^p times for su=\r\nre and that is\n&gt;&gt; expected.\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; With the above formula, the map=\r\nping of number of calls to parameters\n&gt;&gt; for\n&gt;&gt; &gt;&gt; 60\n&gt;&gt; &gt;&gt; &gt; data points w=\r\nould be:\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; 1 -&gt; 2 (I know this is wrong which gives me doubts=\r\n on the formula)\n&gt;&gt; &gt;&gt; &gt; 2 -&gt; 61\n&gt;&gt; &gt;&gt; &gt; 3 -&gt; 3601\n&gt;&gt; &gt;&gt; &gt; 3 -&gt; 216001\n&gt;&gt; &gt;=\r\n&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; Essentially when the Assignments class needs to make the combin=\r\nations,\n&gt;&gt; it\n&gt;&gt; &gt;&gt; &gt; will collect the data points initially for each theor=\r\ny. It then calls\n&gt;&gt; the\n&gt;&gt; &gt;&gt; &gt; data points again for each existing data po=\r\nint it collected from the\n&gt;&gt; &gt;&gt; first\n&gt;&gt; &gt;&gt; &gt; read. With a third parameter =\r\nit would take all those combinations\n&gt;&gt; again,\n&gt;&gt; &gt;&gt; to\n&gt;&gt; &gt;&gt; &gt; add all the=\r\n permutations for the next round.\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; I might be wrong and the =\r\nreal formula would be like this:\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; N^0 + N^1 ... + N^(p-1)\n&gt;&gt;=\r\n &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; If this is the correct formula, then if you have 60 data poin=\r\nts the\n&gt;&gt; &gt;&gt; number\n&gt;&gt; &gt;&gt; &gt; of times the method is called would map to the =\r\nnumber of parameters\n&gt;&gt; like\n&gt;&gt; &gt;&gt; &gt; this:\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; 1 -&gt; 1\n&gt;&gt; &gt;&gt; &gt; 2=\r\n -&gt; 61\n&gt;&gt; &gt;&gt; &gt; 3 -&gt; 3661\n&gt;&gt; &gt;&gt; &gt; 4 -&gt; 219661\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; --- In=\r\n junit@yahoogroups.com &lt;junit%40yahoogroups.com&gt; &lt;mailto:\n&gt;&gt; junit%40yahoog=\r\nroups.com &lt;junit%2540yahoogroups.com&gt;&gt; =A0&lt;junit%\n&gt;&gt; 40yahoogroups.com&gt; &lt;ju=\r\nnit%\n&gt;&gt; &gt;&gt; 40yahoogroups.com&gt;, Brett Daniel\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; &gt; &lt;brettdaniel@...&gt;=\r\n wrote:\n&gt;&gt; &gt;&gt; &gt; &gt;\n&gt;&gt; &gt;&gt; &gt; &gt; Berin,\n&gt;&gt; &gt;&gt; &gt; &gt;\n&gt;&gt; &gt;&gt; &gt; &gt; When a theory mutate=\r\ns data points, it might be beneficial to\n&gt;&gt; recreate\n&gt;&gt; &gt;&gt; &gt; &gt; the data poi=\r\nnt for every theory invocation. Doing so prevents one\n&gt;&gt; &gt;&gt; &gt; &gt; theory exec=\r\nution from affecting others. I wrote about this issue in\n&gt;&gt; &gt;&gt; &gt; &gt; the foll=\r\nowing weblog post:\n&gt;&gt; &gt;&gt; &gt; &gt;\n&gt;&gt; &gt;&gt; &gt; &gt; http://www.brettdaniel.com/archives/=\r\n2009/09/24/200845/ &lt;\n&gt;&gt; http://www.brettdaniel.com/archives/2009/09/24/2008=\r\n45/&gt;\n&gt;&gt; &gt;&gt; &gt; &gt;\n&gt;&gt; &gt;&gt; &gt; &gt; You are correct, though, that copying would avoid =\r\nsome of the\n&gt;&gt; overhead\n&gt;&gt; &gt;&gt; &gt; &gt; in calling datapoint methods. It is inter=\r\nesting you mention this\n&gt;&gt; idea,\n&gt;&gt; &gt;&gt; &gt; &gt; because I am currently overseein=\r\ng two students who for their senior\n&gt;&gt; &gt;&gt; &gt; &gt; thesis project are implementi=\r\nng framework for copying datapoints. I\n&gt;&gt; &gt;&gt; &gt; &gt; will post more information=\r\n to the mailing list as the project\n&gt;&gt; &gt;&gt; &gt; &gt; continues.\n&gt;&gt; &gt;&gt; &gt; &gt;\n&gt;&gt; &gt;&gt; &gt; =\r\n&gt; Brett\n&gt;&gt; &gt;&gt; &gt; &gt;\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; [Non-text portions of=\r\n this message have been removed]\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt; [Non-text port=\r\nions of this message have been removed]\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt; =\r\n[Non-text portions of this message have been removed]\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt; -=\r\n-----------------------------------\n&gt;&gt; &gt;\n&gt;&gt; &gt; Yahoo! Groups Links\n&gt;&gt; &gt;\n&gt;&gt; &gt;=\r\n\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt;\n&gt;&gt;\n&gt;\n&gt;\n&gt; [Non-text portions of this message have been removed=\r\n]\n&gt;\n&gt;\n&gt;\n&gt; ------------------------------------\n&gt;\n&gt; Yahoo! Groups Links\n&gt;\n&gt;\n=\r\n&gt;\n&gt;\n\n", 
    "profile": "dsaff", 
    "topicId": 22425, 
    "spamInfo": {
        "reason": "4", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 341876227, 
    "prevInTime": 22552, 
    "contentTrasformed": false, 
    "postDate": "1268685980", 
    "canDelete": false, 
    "nextInTopic": 22555, 
    "prevInTopic": 22552, 
    "headers": {
        "inReplyToHeader": "PDU4ZGJhMjI1MTAwMzE1MTA1Nms0YmYyNGZmMnhmMTYxZTY0MTVhYmY0YWJhQG1haWwuZ21haWwuY29tPg==", 
        "messageIdInHeader": "PDRmN2RhNmI5MTAwMzE1MTM0Nmo3MzNkZjFjMGc1ZWMwNDU5YTE4ZmNkMTRjQG1haWwuZ21haWwuY29tPg==", 
        "referencesHeader": "PDU4ZGJhMjI1MTAwMjE4MDk0M3EyMzhkZDhkdjExYWI0ODczNjMyMWUxNzhAbWFpbC5nbWFpbC5jb20+CSA8aGxraWYyKzNtdGVAZUdyb3Vwcy5jb20+CSA8NThkYmEyMjUxMDAzMTIxNTQ0cDNjZDdkZDI4aDFhODk5Y2U2NTdmNjZhZDNAbWFpbC5nbWFpbC5jb20+CSA8YTUyN2ZkZGYxMDAzMTQwOTE1bDczNzYxZWUxcjc4MWJhMjBmYzc2OGU0MmVAbWFpbC5nbWFpbC5jb20+CSA8NzVGNUVEOEE1QTU1MzY0NkE0NkUwMEU2RUM4NTRGQTMwMzc4QzdFNEB2YWZmMDEtbWFpbDAxLmFkLmdkLWFpcy5jb20+CSA8NGY3ZGE2YjkxMDAzMTUwNjUxbTEyZjI3OTZrZjlhYWIxN2ZmMzEyY2Q5M0BtYWlsLmdtYWlsLmNvbT4JIDw1OGRiYTIyNTEwMDMxNTEwNTZrNGJmMjRmZjJ4ZjE2MWU2NDE1YWJmNGFiYUBtYWlsLmdtYWlsLmNvbT4="
    }
}