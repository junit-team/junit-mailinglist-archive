{
    "numMessagesInTopic": 17, 
    "nextInTime": 6871, 
    "senderId": "7gphmN47BzfpRSGfJXDIa_Erj9awhChXWXz4S3PrhD95KLIyND9c5DwkIb3N0RvLZS9a0dqqskr7u8Tct6MovWHbiK9pKnsaOzrx90A6", 
    "systemMessage": false, 
    "subject": "Re: [junit] Testability", 
    "from": "Eric Armstrong &lt;eric.armstrong@...&gt;", 
    "authorName": "Eric Armstrong", 
    "msgSnippet": "This is really profound. I ve implemented fsm s before, but never characterized a testable app as one that effectively *is* one. I ve summarized the key", 
    "msgId": 6870, 
    "profile": "ericsilverlight", 
    "topicId": 6863, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 78994084, 
    "messageBody": "<div id=\"ygrps-yiv-689204872\">This is really profound. I&#39;ve implemented fsm&#39;s before, but never<br/>\ncharacterized a &quot;testable app&quot; as one that effectively *is* one.<br/>\n<br/>\nI&#39;ve summarized the key points of your post below. It&#39;s going to<br/>\nbear more rumination...<br/>\n<br/>\nScott Stirling wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;  I&#39;ve been thinking about Test Driven Development and the question of<br/>\n&gt; what is it about it that ensures testability.<br/>\n&gt; ....<br/>\n&gt; Obviously, a method added for no other purpose than to make a class&#39;s<br/>\n&gt; behavior more directly accessible to external tests ... enhances the<br/>\n&gt; testability of a class.<br/>\n&gt; ....<br/>\n&gt; So how do you make things testable without corrupting the object<br/>\n&gt; design with behaviors added or modified just to make objects<br/>\n&gt; testable?  And why is it that test driven development, practiced<br/>\n&gt; religiously, will typically give you 100% statement coverage without<br/>\n&gt; adding any test-only methods to a class?<br/>\n&gt;<br/>\n&gt; I think the answer has to do with finite-state machines.  TDD is a<br/>\n&gt; methodology that results in the development of clean, working<br/>\n&gt; finite-state machines.  It works so well because the methodology of<br/>\n&gt; writing tests first drives the mental process to identify and make<br/>\n&gt; explicit, in the appropriate order of priority:<br/>\n&gt; 1. the desired outputs<br/>\n&gt; 2. the inputs and behaviors needed to transition the machine from an<br/>\n&gt; initial or existing state to desired output<br/>\n&gt; 3. the objects that compose the machine (one of the least important<br/>\n&gt; things at first, contrary to more traditional design<br/>\n&gt; methodology)....the naming of the objects and definition of their<br/>\n&gt; boundaries evolves as the 1st and 2nd priorities are realized.<br/>\n&gt;<br/>\n&gt; It seems the best way to build and test a finite-state machine is to<br/>\n&gt; make the inputs and outputs explicit, and to make the state<br/>\n&gt; transitions step-wise and traceable.  It&#39;s a fallout from object<br/>\n&gt; oriented programming constraints that the steps become methods in<br/>\n&gt; objects, and the traceability of the steps becomes actualized in your<br/>\n&gt; unit test methods and TestCases.<br/>\n&gt;<br/>\n&gt; After doing TDD, traceability and explicit inputs and outputs are what<br/>\n&gt; you&#39;ve built into your application and which remain, even if you take<br/>\n&gt; away the unit tests when you&#39;re done.<br/>\n&gt;<br/>\n&gt; So going back to the question of testability, I think there are some<br/>\n&gt; basic things that automatically result in testability in OOP (this<br/>\n&gt; list by no means accurate or exhaustive, and inspired by some reading<br/>\n&gt; about state machines in the testing literature, namely Beizer and<br/>\n&gt; Binder):<br/>\n&gt;   - objects or collaborations of objects modeled as finite-state<br/>\n&gt; machines<br/>\n&gt;   - methods for making state transitions in the objects themselves or<br/>\n&gt; in other objects<br/>\n&gt;   - explicit inputs to and outputs from methods<br/>\n&gt;   - step-wise, traceable state transitions<br/>\n<br/>\n </span></blockquote>Note:<br/>\nHere, I find that I need an example to follow the discussion.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; I think these things become realized in terms of language and design<br/>\n&gt; specifics.  For example:<br/>\n&gt;   - traceability requires state transition methods to be accessible<br/>\n&gt; for unit testing<br/>\n&gt;   - state must be verifiable via attributes or methods that return<br/>\n&gt; state information and can be used in assertions<br/>\n&gt;   - step-wise means you don&#39;t make monolithic, god methods or classes<br/>\n&gt; that hide multiple, untraceable transitions<br/>\n&gt;   - explicit inputs means that something like the method below should<br/>\n&gt; be tuned based on the fact that the Connection object is the *actual*<br/>\n&gt; input needed for the behavior to do its thing:<br/>\n<br/>\n </span></blockquote>So you&#39;re from Framingham, ay? I used to live there.<br/>\nWhere you working? (I was at D.G.)<br/>\n<br/>\nCongratulations again on a fine way to characterize the issue. I&#39;m<br/>\nlooking<br/>\nforward to understanding your thesis even better in the future.</div>", 
    "prevInTime": 6869, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1044393929", 
    "canDelete": false, 
    "nextInTopic": 6875, 
    "prevInTopic": 6865, 
    "headers": {
        "messageIdInHeader": "PDNFNDAyRkM5LjgzNDU1Nzc2QHN1bi5jb20+", 
        "referencesHeader": "PEtJRUhJQklPQkFFTEpBSElQTkhETUVNTkNPQUEuc2NvdHRzdGlybGluZ0ByY24uY29tPg=="
    }
}