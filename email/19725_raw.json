{
    "numMessagesInTopic": 48, 
    "nextInTime": 19726, 
    "senderId": "xp2hzW1hFZfKthdhFNYeU3gccBp-7IZkhY3OWhKTxZ_Nxrnm0fZk3efvCzVXB7Ud6RsaPOE5GlOkjPbc0nirdXu3Vlphtq9p", 
    "systemMessage": false, 
    "subject": "RE: [junit] RE: Assurance/CPU cycle ratio [branching from Re: Test Grouping/Partitioning]", 
    "from": "&quot;Kent Beck&quot; &lt;kentb@...&gt;", 
    "authorName": "Kent Beck", 
    "msgSnippet": "David, Efficient testing (in the assurance/CPU cycle or assurance/clock time sense) requires modular design and careful testing technique. The valuable moment ", 
    "msgId": 19725, 
    "rawEmail": "Return-Path: &lt;kentb@...&gt;\r\nX-Sender: kentb@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (qmail 692 invoked from network); 9 Aug 2007 00:58:22 -0000\r\nReceived: from unknown (66.218.67.33)\n  by m38.grp.scd.yahoo.com with QMQP; 9 Aug 2007 00:58:22 -0000\r\nReceived: from unknown (HELO elasmtp-dupuy.atl.sa.earthlink.net) (209.86.89.62)\n  by mta7.grp.scd.yahoo.com with SMTP; 9 Aug 2007 00:58:22 -0000\r\nReceived: from [67.131.9.243] (helo=kentspavilion)\n\tby elasmtp-dupuy.atl.sa.earthlink.net with asmtp (Exim 4.34)\n\tid 1IIwLA-0007Oq-Ao\n\tfor junit@yahoogroups.com; Wed, 08 Aug 2007 20:57:28 -0400\r\nTo: &lt;junit@yahoogroups.com&gt;\r\nReferences: &lt;003101c7cfd5$aff5e560$6701a8c0@kentspavilion&gt; &lt;5CD37B6E090454489C5FC15B9B4B5B19189935@...&gt;\r\nDate: Wed, 8 Aug 2007 17:57:15 -0700\r\nMessage-ID: &lt;018e01c7da20$3bcae5f0$6701a8c0@kentspavilion&gt;\r\nMIME-Version: 1.0\r\nX-Mailer: Microsoft Office Outlook 11\r\nThread-Index: AcfJzX+fUTyYOYMsTPmUxFy0ThwooQBInQlgATlqtsAAIWuPgAFnV+1w\r\nX-MimeOLE: Produced By Microsoft MimeOLE V6.00.2900.3138\r\nIn-Reply-To: &lt;5CD37B6E090454489C5FC15B9B4B5B19189935@...&gt;\r\nX-ELNK-Trace: 6d780abf06d998e474bf435c0eb9d47883cda70a3f3dc3bef9fb53e7289543941aaed030a51b6fda350badd9bab72f9c350badd9bab72f9c350badd9bab72f9c\r\nX-eGroups-Msg-Info: 1:0:0:0\r\nFrom: &quot;Kent Beck&quot; &lt;kentb@...&gt;\r\nSubject: RE: [junit] RE: Assurance/CPU cycle ratio [branching from Re: Test Grouping/Partitioning]\r\nX-Yahoo-Group-Post: member; u=173198504; y=D6HjuqWEk4ujU8BoRrKGg4pGR4FyxIqF0AWvKpXceEMgQr6M\r\nX-Yahoo-Profile: kentlbeck\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\n\r\nDavid,\n \nEfficient testing (in the assurance/CPU cycle or assurance/clock time sense)\nrequires modular design and careful testing technique. The valuable moment\nis when you can say, &quot;Y can&#39;t possibly be affected by how X is calculated.&quot;\nWhen you can say that (and be right :-), you can test X and Y separately.\nThe setup for each is likely to be cheaper than the setup for testing them\nboth together. Because the tests are cheaper, you can afford to be more\nthorough with each of X and Y.  I think I write fairly efficient tests but I\nhaven&#39;t been aware enough to clearly articulate my design process. \n \nI&#39;d love to help optimize a long-running industrial test suite. I suspect\nthat much of the effort would be spent trying refactorings that might lead\nto separately testable dimensions. I would want to be sure that each step\ndidn&#39;t reduce the assurance provided by the whole suite. Only when tests\nwere clearly redundant would I remove the slower running version.\n \nHas anyone here done any profiling of long-running test suites? I&#39;m curious\nwhat percentage of time is spent in setup/teardown versus actually running\nthe tests.\n \nMy vision is that 24-hour test suites will eventually go the way of\novernight compiles. To achieve this will require advances in design and\ntesting technique, and perhaps tooling as well.\n \nCheers,\n \nKent\n\n  _____  \n\nFrom: junit@yahoogroups.com [mailto:junit@yahoogroups.com] On Behalf Of\nDavid Jackman\nSent: Friday, July 27, 2007 7:48 AM\nTo: junit@yahoogroups.com\nSubject: [junit] RE: Assurance/CPU cycle ratio [branching from Re: Test\nGrouping/Partitioning]\n\n\n\nThis idea of an assurance/CPU cycle ratio is intriguing. Thinking of a\nparticular module where I spend most of my time, I have many hundreds of\nunit tests that do run fairly fast (several seconds), but are slow\nenough that I find myself not running them sometimes so as not to break\nmy momentum. The assurance/CPU cycle ratio concept would imply that it\nshould be possible to improve the ratio without decreasing the assurance\nI&#39;m getting from running the tests. \n\nWhat formulas or patterns did they use for improving this ratio? How\ndid they ensure that they weren&#39;t sacrificing assurance while improving\nperformance (i.e. open the code up for a potential bug in the future\nbecause a particular case is no longer being tested)?\n\n..David..\n\nFrom: junit@yahoogroups. &lt;mailto:junit%40yahoogroups.com&gt; com\n[mailto:junit@yahoogroups. &lt;mailto:junit%40yahoogroups.com&gt; com] On Behalf\nOf\nKent Beck\nSent: Thursday, July 26, 2007 4:38 PM\nTo: junit@yahoogroups. &lt;mailto:junit%40yahoogroups.com&gt; com\nSubject: [junit] Re: Test Grouping/Partitioning\n\nAll,\n\nIt seems clear to me that some sort of test classification scheme is a\nreasonable thing to add to JUnit. However, rather than simply copy one\nof\nthe models out there we&#39;re going to go back to first principles and try\nto\nderive a model for classification that is concise, useful, flexible,\nand,\nabove all, easy to use.\n\nI&#39;ve heard two purposes for classification:\n* Performance\n* Assumptions\n\nPerformance\n\nIf you have tests that run for longer than your attention span (my\nlimits\nare 1 second for the inner loop of programming and 10 minutes for\nintegration), running a subset of the tests can give you some assurance\nthat\nthe software is working. Classification is one way to reduce test run\ntime--just this one test, all tests in this class, all tests in this\npackage, all tests labeled &quot;quick&quot;, etc.\n\nThere are other ways of reducing test run time. For example, you could\nhave\na runner that runs 1 second worth of the tests that have failed most\nrecently or a runner that runs half a second of recently failed tests\nplus\nhalf a second of randomly selected tests.\n\nIn the end I think the systemic solution to test run times is to improve\ndesign and testing techniques to dramatically increase the assurance/CPU\ncycle ratio. \n\nI remember a friend&#39;s story of an early project that used tests\nextensively.\nAfter three years they had a carefully tuned suite that took ten minutes\nto\nrun. When the test runtime increased beyond ten minutes, they would work\non\nthe design of the system and/or the design of the tests to improve the\nassurance/CPU cycle ratio and get the runtime back under ten minutes.\nThen\nmost of the original team left. \n\nA few years later my friend was shown the system. The programmer proudly\nexplained that the test suites now took 24 hours to run, even though the\nsystem had grown little in functionality. They had stopped paying\nattention\nto designing for testability. Every time they added a new axis of\nvariability they blindly ran the cross product of the existing tests\nwith\nall the alternatives for the new axis. Yes they had more tests, but A/C\nhad\ndropped by several orders of magnitude.\n\nIn short, I see using classification to reduce test runtime as a bandage\nmasking the real problem which is low A/C. Using classification to\nreduce\ntest runtime really is a hack and I hope people will continue working to\nimprove design for testability. We will still provide some\nclassification\nmechanism, but that doesn&#39;t make it not a hack.\n\nAssumptions\n\nThe second reason I&#39;ve heard for classification is to avoid a slew of\nmisleadingly failing tests. If my development machine doesn&#39;t have\naccess to\nthe database, then if I run the database tests I&#39;ll get a bunch of\nfailures\neven though the system is really working (or, to be more precise, I\ndon&#39;t\nhave any information about whether the system is really working or not).\n\nClassification is one way to express assumptions. When I say\n&quot;@Test(groups =\n{&quot;database&quot;})&quot; I have declared something about this test. However, this\nexpression seems limited and error-prone to me. I&#39;d prefer to have the\npower\nof a programming language to express my assumptions.\n\nIn the JUnit 4.4 you can use assumeThat() to express assumptions. For\nexample, you can say:\n\npublic class DatabaseTest {\n@BeforeClass public static void isDatabaseAccessible() {\nUser result= Database.login(&quot;kent&quot;);\nassumeThat(not(isError(result));\n}\n...\n}\n\nThis is a bit of a workaround because runner don&#39;t yet handle failed\nassumptions as anything other than successful tests, but it gives you a\nricher language to express assumptions than a textual classification\nscheme.\n\nThe Point\n\nSo now the point of this long post. Are there other uses of\nclassification\nthat I&#39;ve missed? Is the above way of expressing assumptions (or\nsomething\nderived from it like an explicit @Assumption) sufficient?\n\nRegards,\n\nKent Beck\nThree Rivers Institute\n\n[Non-text portions of this message have been removed]\n\n[Non-text portions of this message have been removed]\n\n\n\n \n\n\n[Non-text portions of this message have been removed]\n\n\n", 
    "profile": "kentlbeck", 
    "topicId": 19521, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 173198504, 
    "prevInTime": 19724, 
    "contentTrasformed": false, 
    "postDate": "1186621035", 
    "canDelete": false, 
    "nextInTopic": 19726, 
    "prevInTopic": 19693, 
    "headers": {
        "inReplyToHeader": "PDVDRDM3QjZFMDkwNDU0NDg5QzVGQzE1QjlCNEI1QjE5MTg5OTM1QHNsY2VzMDIuYWQuZmFzdC5ubz4=", 
        "messageIdInHeader": "PDAxOGUwMWM3ZGEyMCQzYmNhZTVmMCQ2NzAxYThjMEBrZW50c3BhdmlsaW9uPg==", 
        "referencesHeader": "PDAwMzEwMWM3Y2ZkNSRhZmY1ZTU2MCQ2NzAxYThjMEBrZW50c3BhdmlsaW9uPiA8NUNEMzdCNkUwOTA0NTQ0ODlDNUZDMTVCOUI0QjVCMTkxODk5MzVAc2xjZXMwMi5hZC5mYXN0Lm5vPg=="
    }
}