{
    "numMessagesInTopic": 18, 
    "nextInTime": 16438, 
    "senderId": "o35Ab5aeqTb1FnrOJiFCH7YL_vi6y1mukgbRJddIhRf9sNQ7DEp4l-ZaI7WgCR5s28PyzfeX511jUjotdG-8MAFzTbgjuBPlwWFaBFeMFg", 
    "systemMessage": false, 
    "subject": "Re: [junit] Re: chosing between jmock and easymock for mocks?", 
    "from": "&quot;J. B. Rainsberger&quot; &lt;jbrains@...&gt;", 
    "authorName": "J. B. Rainsberger", 
    "msgSnippet": "... As I stated before, while I acknowledge this problem, the other benefits from jMock make up for this cost /so far/, /for me/. I find that I don t change", 
    "msgId": 16437, 
    "profile": "nails762", 
    "topicId": 16387, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 127224993, 
    "messageBody": "<div id=\"ygrps-yiv-20858061\">Tammo Freese wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;  &gt; When I practise TDD, I often<br/>\n&gt;  &gt; design interfaces, and forcing me to generate a method stub for a method<br/>\n&gt;  &gt; I might not even like yet is annoying. Keeping the methods as strings<br/>\n&gt;  &gt; allows me to write the test, compile it, and even run it before I decide<br/>\n&gt;  &gt; whether the interface or method signature is good enough to start<br/>\n&gt;  &gt; putting into stone.<br/>\n&gt; <br/>\n&gt; 1) With that method, you never see the method<br/>\n&gt;     as a real method call as in EasyMock. Compare<br/>\n&gt; <br/>\n&gt; control.expectAndReturn(mock.copy(destination, source), true);   // <br/>\n&gt; EasyMock 1.2<br/>\n&gt; <br/>\n&gt; expect(mock.copy(destination, source)).andReturn(true); // EasyMock 2.0 <br/>\n&gt; / 2.1<br/>\n&gt; <br/>\n&gt; to<br/>\n&gt; <br/>\n&gt; mock.expects(once()).method(&quot;copy&quot;).with( eq(destination), eq(source) <br/>\n&gt; ).will(returnValue<br/>\n&gt; (true)); // JMock<br/>\n&gt; <br/>\n&gt; In the EasyMock examples, both show how the method<br/>\n&gt; is used copy(destination, source) and returning true.<br/>\n&gt; It is easy to see that the parameters should be reordered,<br/>\n&gt; and with refactoring-tools, it&#39;s quite fast.<br/>\n&gt; <br/>\n&gt; In the JMock example, it is not that easy to spot the method call, because<br/>\n&gt; the method name is in a string, and the parameters are separated from <br/>\n&gt; this string.<br/>\n&gt; It is harder to see that the parameters should be reordered,<br/>\n&gt; and as refactoring tools don&#39;t work, it&#39;s a pain - especially if<br/>\n&gt; the method is used more than once already in the tests, you have to change<br/>\n&gt; every single ocurrence by hand.<br/>\n<br/>\n </span></blockquote>As I stated before, while I acknowledge this problem, the other benefits <br/>\nfrom jMock make up for this cost /so far/, /for me/. I find that I don&#39;t <br/>\nchange methods on interfaces too frequently. Typically, I change them on <br/>\nclasses before I extract the corresponding interface. By the time I <br/>\nextract the interface, the method is quite stable.<br/>\n<br/>\nAlso, I introduce Parameter Objects quite quickly, which reduces the <br/>\nneed to reorder parameters or change parameter lists.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; 2) Can you explain on how you test-drive a plain old java method then,<br/>\n&gt; without adding a body for it?<br/>\n<br/>\n </span></blockquote>I might not have been clear: in this case, I&#39;m test-driving class A, <br/>\nwhich I see needs a collaborator, so I introduce interface B. In this <br/>\ncase, while test-driving an implementation for A, I&#39;m designing the <br/>\ninterface for B. It is B&#39;s methods (and not A&#39;s) which I can design <br/>\nwithout having even to declare a method signature. After I write a test <br/>\nand am happy with the design, I run the test, watch it fail because the <br/>\nnew method is not yet on B, then I add it to B.<br/>\n-- <br/>\nJ. B. (Joe) Rainsberger :: <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.jbrains.info\">http://www.jbrains.info</a><br/>\nYour guide to software craftsmanship<br/>\nJUnit Recipes: Practical Methods for Programmer Testing<br/>\n2005 Gordon Pask Award for contribution Agile Software Practice</div>", 
    "prevInTime": 16436, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1143809102", 
    "canDelete": false, 
    "nextInTopic": 16438, 
    "prevInTopic": 16436, 
    "headers": {
        "inReplyToHeader": "PGUwaGlyOCtjcmR0QGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PDQ0MkQyNDRFLjEwNjA0MDNAcm9nZXJzLmNvbT4=", 
        "referencesHeader": "PGUwaGlyOCtjcmR0QGVHcm91cHMuY29tPg=="
    }
}