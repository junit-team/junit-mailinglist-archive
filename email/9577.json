{
    "numMessagesInTopic": 125, 
    "nextInTime": 9578, 
    "senderId": "-5YCF85zz6tZXs2ngWhK0iQ9tFB156QTh2DSqmLFZcgc6cVF3eqk4i98wJQ2SGi4_5Ik83W4NwgZYyqqoGl709qj1-KU3tW4BteXRZmeoXqau4t_6Wqec4svng", 
    "systemMessage": false, 
    "subject": "RE: [junit] Re: Help plz...", 
    "from": "&quot;Leeuw van der, Tim&quot; &lt;tim.leeuwvander@...&gt;", 
    "authorName": "Leeuw van der, Tim", 
    "msgSnippet": "Compilation is a lossy process in the sense that it s often not 100% reversible... So in that sense, information certainly got lost. But a correct compiler", 
    "msgId": 9577, 
    "topicId": 9354, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 151182810, 
    "messageBody": "<div id=\"ygrps-yiv-1189308847\">Compilation is a &#39;lossy&#39; process in the sense that it&#39;s often not 100%<br/>\nreversible... So in that sense, information certainly got lost.<br/>\n<br/>\nBut a correct compiler will preserve sufficient information that<br/>\nprocess-execution complies with what the source code specifies.<br/>\n<br/>\n<br/>\nNow about the Java bytecodes; I never looked at them. But I do know that<br/>\nthere&#39;s a &#39;constant pool&#39; for every class which contains all the string<br/>\nconstants referenced somehow in that class; either thru method-invocation or<br/>\ndirect string refs. Method-calling should use the values from this same<br/>\nconstant-pool; the method-invocation itself contains a reference to this<br/>\nentry in the constant-pool.<br/>\n<br/>\nSo 10 invocations of the same method in the same class don&#39;t cause the<br/>\nentire method-name to be included in the constant-pool for every invocation.<br/>\nIf the same string-constant *does* appear multiple times in a classes&#39;<br/>\nconstant pool that can be said to be a compiler bug - after all, string are<br/>\nimmutable.<br/>\n<br/>\nAbout parsing the string to find out the actual bytecode to invoke on a<br/>\nmethod invocation - I have no idea how that is done.<br/>\n<br/>\nHow does a C++ compiler/linker actually store the names of the methods that<br/>\nit needs to call? Doesn&#39;t it also have to store a lot of information about<br/>\nthe namespaces, method names, overloads, parameter types, etc? To determine<br/>\ndynamically at runtime / dll-loadtime where in the code the CPU needs to<br/>\njump for a virtual method invocation? Where does it store that info, and<br/>\nwhen/where/how is that resolved to a memory-address?<br/>\n<br/>\nIs Java-bytecode really hugely inefficient compared to how C++ solves the<br/>\nproblem?<br/>\n<br/>\n<br/>\nregards,<br/>\n<br/>\n--Tim<br/>\n<br/>\n-----Original Message-----<br/>\nFrom: Ron Jeffries [mailto:<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:ronjeffries@...\">ronjeffries@...</a>]<br/>\nSent: dinsdag 30 september 2003 19:44<br/>\nTo: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a><br/>\nSubject: Re: [junit] Re: Help plz...<br/>\n<br/>\n<br/>\n<blockquote><span title=\"qreply\"> On Tuesday, September 30, 2003, at 12:07:31 PM, Jim Dixon wrote:<br/>\n<br/>\n&gt;&gt; &gt; I know that this is official Sun doctrine.  But compilation is always<br/>\n&gt;&gt; &gt; a lossy process, and the smaller the target instruction set, the more<br/>\n&gt;&gt; &gt; information you lose.  The JVM has a small instruction set.  To<br/>\nincrement<br/>\n&gt;&gt; &gt; a variable, you put a 1 on the stack and say &quot;add&quot;.  Oh my :-(<br/>\n&gt;&gt;<br/>\n&gt;&gt; Why does that trouble you?<br/>\n<br/>\n&gt; Is this a real question??<br/>\n<br/>\nYes.<br/>\n<br/>\n&gt; It&#39;s just an example.  With a larger instruction set, you can increment<br/>\n&gt; variables in place, at a lower cost in terms of code size and run time.<br/>\n<br/>\n&gt; The main point is that compilation is a lossy process.  When you write<br/>\n&gt; i++ it&#39;s succinct but very clear.  The compiler translates this into<br/>\n&gt;   push variable<br/>\n&gt;   push 1<br/>\n&gt;   add<br/>\n&gt;   store variable<br/>\n&gt; While it&#39;s not impossible, it&#39;s difficult and expensive for a bytecode<br/>\n&gt; (re)compiler to sort out what&#39;s going on here and optimize back to the<br/>\n&gt; succintness of the original.  The larger the instruction set, the more<br/>\n&gt; information preserved in the bytecode, the less difficult and expensive<br/>\n&gt; the process is.<br/>\n<br/>\nOn the contrary, when it comes to the execution of the program, compilation<br/>\nis emphatically not a lossy process. If it were, then the program&#39;s<br/>\nbehavior would not be what we expect. If it is what we expect, then no<br/>\ninformation has been lost.<br/>\n<br/>\nRon Jeffries<br/>\nwww.XProgramming.com<br/>\nGet over it.  -- The Eagles<br/>\n<br/>\n<br/>\n<br/>\nTo unsubscribe from this group, send an email to:<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit-unsubscribe@yahoogroups.com\">junit-unsubscribe@yahoogroups.com</a><br/>\n <br/>\n<br/>\nYour use of Yahoo! Groups is subject to <a rel=\"nofollow\" target=\"_blank\" href=\"http://docs.yahoo.com/info/terms/\">http://docs.yahoo.com/info/terms/</a> </span></blockquote></div>", 
    "prevInTime": 9576, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1064953036", 
    "canDelete": false, 
    "nextInTopic": 9580, 
    "prevInTopic": 9574, 
    "headers": {
        "messageIdInHeader": "PEREMERDMTQ5MzVCMUQyMTE5ODFBMDAxMDVBMUIyOERCMEE3QjRCQjhATkwtQVNELUVYQ0gtMT4="
    }
}