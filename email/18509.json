{
    "numMessagesInTopic": 7, 
    "nextInTime": 18510, 
    "senderId": "FJK3todQLSaB_iVdNi9fXRLo6LnM46fLAANv1hordPrS5TQ1fdcvMySGhJYf49WUlphECq3KjIwDOKbNa9doFd2lLgIaqgTvuNrpTQta", 
    "systemMessage": false, 
    "subject": "Philosophical question--Multiple assertions in one test case", 
    "from": "&quot;shefehs&quot; &lt;julie_sheffield@...&gt;", 
    "authorName": "shefehs", 
    "msgSnippet": "I ve read all over the place that it s a bad idea to include multiple assertions in one test case, but it seems to me that sometimes it s very useful. For", 
    "msgId": 18509, 
    "profile": "shefehs", 
    "topicId": 18509, 
    "spamInfo": {
        "reason": "6", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 291327437, 
    "messageBody": "<div id=\"ygrps-yiv-1894938011\">I&#39;ve read all over the place that it&#39;s a bad idea to include multiple<br/>\nassertions in one test case, but it seems to me that sometimes it&#39;s<br/>\nvery useful. For example, I have a fairly straightforward DAO and I<br/>\nwant to test the create method.  But to really test it, I need to<br/>\nretrieve it afterwards and make sure it was successfully created.  And<br/>\nI need to clean it up afterwards (or the test will fail next time I<br/>\nrun it and try to create a duplicate), so I call my delete method. <br/>\nThere I&#39;ve exercised 3 methods of my DAO, not just one.  So it feels<br/>\nlike it would save time to assert that each step of the process<br/>\nsucceeded.  <br/>\n<br/>\nExample:<br/>\n  public void testEmployeeCRUD()<br/>\n  throws Exception<br/>\n  {<br/>\n\tint sizeBeforeAdding = em.listEmployees().size();<br/>\n\t_employeeId = em.createEmployee(_fname, _lname, _jobtitle);<br/>\n\t<br/>\n        int sizeAfterAdding = em.listEmployees().size();<br/>\n        log.debug(&quot;Created employee &quot; + _employeeId);<br/>\n        //Make sure that the new list is longer than the old list<br/>\n\tassertTrue(&quot;Create employee failed&quot;, sizeAfterAdding&gt;sizeBeforeAdding);<br/>\n               <br/>\n        Employee emp = em.getEmployee(_employeeId);<br/>\n        assertEquals(&quot;getEmployee failed&quot;, emp.getLName(), _lname);<br/>\n        log.debug(&quot;Retrieved employee &quot; + emp.getLName());<br/>\n                <br/>\n        em.deleteEmployee(emp);<br/>\n                <br/>\n        int sizeAfterDelete = em.listEmployees().size();<br/>\n                <br/>\n        //Make sure that the length of the list after delete <br/>\n        //is the same as it was before we added<br/>\n        assertEquals(&quot;Delete employee failed&quot;, sizeAfterDelete,<br/>\nsizeBeforeAdding);<br/>\n        log.debug(&quot;Deleted employee&quot;);<br/>\n    }<br/>\n<br/>\nThe preceding code works just fine.  If the test fails, I&#39;d look in<br/>\nthe failure message to see which part of it failed, and it seems like<br/>\nthat&#39;s not too difficult.  I know it&#39;s not following best practices<br/>\nbecause it calls 4 separate methods, but when I tried writing a test<br/>\nfor each of those methods, I ended up either calling the other ones in<br/>\nthe setup/teardown or by essentially recreating them in a sample data<br/>\nloading operation.  I&#39;m trying to do good TDD and to convince a<br/>\ncolleague who resists unit tests at all, so I don&#39;t want to do things<br/>\n&quot;wrong&quot; but I also don&#39;t want to make life tremendously more difficult<br/>\nwithout understanding the real reason behind the recommendations.<br/>\n<br/>\nDoes anyone have any thoughts on this principle?  I appreciate the<br/>\nintelligent exchanges I&#39;ve seen on the list in the past so I hope to<br/>\nget a thoughtful discussion going.<br/>\n<br/>\nThanks very much!<br/>\nJulie</div>", 
    "prevInTime": 18508, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1165438297", 
    "canDelete": false, 
    "nextInTopic": 18511, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PGVsN2FncCtkaTJwQGVHcm91cHMuY29tPg=="
    }
}