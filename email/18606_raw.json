{
    "numMessagesInTopic": 32, 
    "nextInTime": 18607, 
    "senderId": "7QhxGsoUbJdyOupRVjf7QDddQdqY0HyJWaE1HeYAaj5wcMZscz5vX69R5GC5WFdtnxsKeVexiaaf6tAPnwo_14miq1udAg", 
    "systemMessage": true, 
    "subject": "Re: [junit] Re: Thinking of improving the auto generation of test cases", 
    "from": "Ole Ersoy &lt;ole_ersoy@...&gt;", 
    "authorName": "Ole Ersoy", 
    "msgSnippet": "Sounds like a really cool idea. Another thought on that subject: We ve said earlier that Unit testing is really about good design. A good design is easy to", 
    "msgId": 18606, 
    "rawEmail": "Return-Path: &lt;ole_ersoy@...&gt;\r\nReceived: (qmail 47542 invoked from network); 31 Dec 2006 21:19:39 -0000\r\nReceived: from unknown (66.218.66.167)\n  by m37.grp.scd.yahoo.com with QMQP; 31 Dec 2006 21:19:39 -0000\r\nReceived: from unknown (HELO n11c.bullet.sp1.yahoo.com) (69.147.64.108)\n  by mta6.grp.scd.yahoo.com with SMTP; 31 Dec 2006 21:19:39 -0000\r\nReceived: from [216.252.122.218] by n11.bullet.sp1.yahoo.com with NNFMP; 31 Dec 2006 21:16:02 -0000\r\nReceived: from [66.218.69.4] by t3.bullet.sp1.yahoo.com with NNFMP; 31 Dec 2006 21:16:02 -0000\r\nReceived: from [66.218.66.84] by t4.bullet.scd.yahoo.com with NNFMP; 31 Dec 2006 21:16:02 -0000\r\nX-Sender: ole_ersoy@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (qmail 55402 invoked from network); 31 Dec 2006 17:30:56 -0000\r\nReceived: from unknown (66.218.66.167)\n  by m41.grp.scd.yahoo.com with QMQP; 31 Dec 2006 17:30:56 -0000\r\nReceived: from unknown (HELO web60720.mail.yahoo.com) (209.73.178.208)\n  by mta6.grp.scd.yahoo.com with SMTP; 31 Dec 2006 17:30:56 -0000\r\nReceived: (qmail 79415 invoked by uid 60001); 31 Dec 2006 17:19:32 -0000\r\nX-YMail-OSG: lJGn7qsVM1kQlO9sTkgl8V.WWrgEr1d_m7uhLaRes0eBA6wGdLYk_r5B8zeJ0BRckBd5SCgvfD2aCJLWc1QDq_6GPny6je5XZqxahOvh2n62HI7kTtvQpojxWw8vEnad_IGo2YFsFE1Sdil2RiLYU4oetvgaHRy8HhcvZDbCPCSO1Sj1Vlpjvn05CV8uqSuYkFhVHHTr\r\nReceived: from [24.13.179.233] by web60720.mail.yahoo.com via HTTP; Sun, 31 Dec 2006 09:19:31 PST\r\nDate: Sun, 31 Dec 2006 09:19:31 -0800 (PST)\r\nTo: junit@yahoogroups.com\r\nIn-Reply-To: &lt;en4331+2ggu@...&gt;\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=iso-8859-1\r\nContent-Transfer-Encoding: 8bit\r\nMessage-ID: &lt;55613.79410.qm@...&gt;\r\nX-eGroups-Msg-Info: 1:0:0:0\r\nFrom: Ole Ersoy &lt;ole_ersoy@...&gt;\r\nSubject: Re: [junit] Re: Thinking of improving the auto generation of test cases\r\nX-Yahoo-Group-Post: member; u=98908154; y=UAhk0LxCn2qpFzV3RFBxxq6MhCtkdu60DqrVL2g111HmJ43s\r\nX-Yahoo-Profile: ole_ersoy\r\nX-Yahoo-Newman-Property: groups-system\r\nX-eGroups-Approved-By: spchappell &lt;simonpeterchappell@...&gt; via web; 31 Dec 2006 21:16:00 -0000\r\n\r\nSounds like a really cool idea.\n\nAnother thought on that subject:\n\nWe&#39;ve said earlier that Unit testing is really about\ngood design.\n\nA good design is easy to unit test.  It breaks\neverything into simple little steps that are easily\nverified.\n\nThis give us reassurance that what we are running\nconsists of several easy to align dominoes that we\nknow will fall when the right pressure is applied and\nthat they won&#39;t fall when the pressure if off.\n\nThis is as opposed to a whole bunch of dominoes\nbunched up where it&#39;s tricky to find the one domino\nthat&#39;s no cooperating.\n\nAlso, it makes it easy to switch out one domino or a\ngroup of dominoes, to verify that the sequence still\nworks.\n\nSo a good design is simple, easy to validate, and easy\nto improve.\n\nHowever once a domino (Class) has been verified /\ntested in the context that it&#39;s contract describes per\nthe expectations around what it is to deliver, we can\nuse that domino and put it in sequences and should\nexclude retesting things we know have been tested\nalready.\n\nSo how do we know what&#39;s been tested already?\n\nSomething that helped isolate issues, using existing\ntest data, would be really cool.\n\nUsing reflection that possibilities of what could go\nwrong can be automagically found, then existing test\nassertions could be used to narrow the set of\npossibilities.\n\nOnce this is done, a report would be generated and\nwould suggest additional constraints (Possibly using\naspects) to put on the methods that are &quot;At risk&quot; of\nthrowing things off.\n\nSo, there would be 2 steps:\n\n1) Map a set of method input ranges to a set of\npossible outputs.  This means we know in advance what\nthe exhaustive set of inputs the method takes as\nparameters.  Aspect Preconditions on method parameters\ncould be to constrain the set so that respects this\nthe parameter rules.\n\n2) Map the input ranges to a set of possible output\nranges.  When doing this type of mapping, break the\nmap into little steps where it&#39;s easy to verify the\ninput range and output range.  Possibly have a test\nfor each range.  Break the range down if necessary and\ntest range subsets...until the test is exhaustive.\n\nSo from a practical point of view what does that mean:\n\nThis is really simple, and I probably don&#39;t have to\nlist it but what the heck: \n\nSuppose you have a method that takes to strings and\nappends them.\n\npublic String append(String 1, String2)\n{\n  return (String1 + String2)\n}\n\nThe risk here is that String1 and String2 may deviate\nfrom the values that they are allowed to have per the\ndesign context.\n\nSo we would have to put constraints on them to ensure\nthat they are correct.\n\nSuppose this is the first method, then there are\nseveral methods that occur after that method returns\nit&#39;s computed String.\n\nIf we know the exhaustive set of input strings (Say be\ncreating an Enum of them), then we know the set that\nthe method can return.\n\nSuppose there was another method that gets strings\nfrom this method.\n\nIt also has constraint on the method that describes\nthe strings allowed.\n\nSuppose that method dissallows one of the strings\nreturned by the first method.  Then that constraint\nshould be put on the first method so that the second\nmethod in the call sequence does not have to worry\nabout doing the constraint checking, since if we did\nit at every step in the call sequence it would be\ncostly.\n\nOr, it could be that we would not want to move the\nconstraint back to that call because that method also\nservices other objects, and they need that value.\n\nBut now we know to check that one possibility on the\nnext method, rather than all the possibilities.\n\nCheers,\n- Ole\n\n\n--- Bob Runstein &lt;rrunstein@...&gt; wrote:\n\n&gt; &gt; On 12/27/06, junitheadache\n&gt; &gt; &lt;bohs01@...&gt; wrote:\n&gt; &gt; Hi all,\n&gt; &gt; \n&gt; &gt; I am currently working on auto generation of test\n&gt; &gt; cases for TDD for\n&gt; &gt; my honors year project. And was considering\n&gt; &gt; modifying JUnit such\n&gt; &gt; that it will auto generate some test cases based\n&gt; &gt; values flagged by\n&gt; &gt; users.\n&gt; \n&gt; How about considering a project where you generate\n&gt; the unit tests by \n&gt; hand and then auto generate the production code from\n&gt; them? Now that \n&gt; would be something!\n&gt; \n&gt; Bob\n&gt; \n&gt; \n\n\n__________________________________________________\nDo You Yahoo!?\nTired of spam?  Yahoo! Mail has the best spam protection around \nhttp://mail.yahoo.com \n\n", 
    "profile": "ole_ersoy", 
    "topicId": 18582, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 98908154, 
    "prevInTime": 18605, 
    "contentTrasformed": false, 
    "postDate": "1167585571", 
    "canDelete": false, 
    "nextInTopic": 18607, 
    "prevInTopic": 18604, 
    "headers": {
        "inReplyToHeader": "PGVuNDMzMSsyZ2d1QGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PDU1NjEzLjc5NDEwLnFtQHdlYjYwNzIwLm1haWwueWFob28uY29tPg=="
    }
}