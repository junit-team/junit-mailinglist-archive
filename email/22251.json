{
    "numMessagesInTopic": 38, 
    "nextInTime": 22252, 
    "senderId": "5-7oiLne82hsZVLFX204tEXchAxvElr5uHuUDR1qCkgjbiunNILLcwQg43lr-Va4vVIZ2qFgi18WGQ2slYxnfOTwTNc8DNdR-3Fpeaezn8QbwXap", 
    "systemMessage": false, 
    "subject": "RE: [junit] Order of execution for tests", 
    "from": "&quot;Charlie Poole&quot; &lt;charlie@...&gt;", 
    "authorName": "Charlie Poole", 
    "msgSnippet": "Hi Kent, ... This makes a certain amount of sense to me. I ve rarely been in the position of being overwhelmed by a lot of test failures myself. When it", 
    "msgId": 22251, 
    "profile": "cpoole98370", 
    "topicId": 22219, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 212099090, 
    "messageBody": "<div id=\"ygrps-yiv-1890633284\">Hi Kent, <br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; From this it looks like you could partially order tests based <br/>\n&gt; on what SUT code they cover. In this case, Test A is &quot;less <br/>\n&gt; than&quot; Test B. You might want to run Test B first as a result.<br/>\n&gt; <br/>\n&gt; I&#39;ve seen two reasons for test ordering:<br/>\n&gt;   * Optimization--getting the whole suite to run more quickly <br/>\n&gt; by not running tests that are guaranteed to fail<br/>\n&gt;   * Precise feedback--getting the most specific test failure <br/>\n&gt; possible and not be overwhelmed by the failure of a whole <br/>\n&gt; bunch of dependent tests<br/>\n&gt; <br/>\n&gt; I assume that only a few tests will fail on any given run <br/>\n&gt; (I&#39;ve measured that failure counts follow a power law <br/>\n&gt; distribution). Because of this I prefer the JUnit Max-style <br/>\n&gt; optimization through test ordering and ignore the precision problem.<br/>\n<br/>\n </span></blockquote>This makes a certain amount of sense to me. I&#39;ve rarely been in<br/>\nthe position of being overwhelmed by a lot of test failures myself.<br/>\nWhen it happens (as it just did this AM) it&#39;s usually when I run<br/>\nthe tests on all platforms after doing a bit of development on<br/>\na single platform. Even then, the confusion is only momentary.<br/>\n<br/>\nAnd yet, I get reports of other folks having this interpretation<br/>\nproblem all the time. It may be that the problem lies in how they<br/>\nare doing their development.<br/>\n<br/>\nIn any case, the mention of JUnit Max leads me to think that <br/>\n*policies* for ordering are perhaps better done outside the test<br/>\nrunning framework itself. Hmmm...<br/>\n<br/>\nCharlie<br/>\n<br/>\n<blockquote><span title=\"qreply\"> &gt; Regards,<br/>\n&gt; <br/>\n&gt; Kent<br/>\n&gt; <br/>\n&gt; On Dec 30, 2009, at 12:11 PM, Charlie Poole wrote:<br/>\n&gt; <br/>\n&gt; &gt; Hi Kent,<br/>\n&gt; &gt; <br/>\n&gt; &gt; &gt; It seems to me that a coverage tool like Clover could <br/>\n&gt; discover this <br/>\n&gt; &gt; &gt; information dynamically with[out] the user having to specify more <br/>\n&gt; &gt; &gt; meta-information about tests that could be wrong and would need <br/>\n&gt; &gt; &gt; maintenance. Isn&#39;t removing tedium why we have computers in the <br/>\n&gt; &gt; &gt; first place?<br/>\n&gt; &gt; <br/>\n&gt; &gt; As far as I know, coverage tools deal well with direct dependencies <br/>\n&gt; &gt; but not with logical (interpretive) dependency.<br/>\n&gt; &gt; <br/>\n&gt; &gt; For example, if we have<br/>\n&gt; &gt; <br/>\n&gt; &gt; Test A --&gt; SUT A --&gt; SUT B<br/>\n&gt; &gt; Test B --&gt; SUT B<br/>\n&gt; &gt; <br/>\n&gt; &gt; Even in this simple case, coverage analysis won&#39;t tell us anything <br/>\n&gt; &gt; about the relationship between A and B, although we could make some <br/>\n&gt; &gt; deductions by examining the results.<br/>\n&gt; &gt; <br/>\n&gt; &gt; If there were some way to tell the framework &quot;Test A depends on <br/>\n&gt; &gt; functionality, which is tested directly by B&quot; then I can imagine <br/>\n&gt; &gt; several good outcomes:<br/>\n&gt; &gt; <br/>\n&gt; &gt; 1) The test result output could be made much clearer - by <br/>\n&gt; emphasizing <br/>\n&gt; &gt; the B result when both tests had failed. Some approaches I <br/>\n&gt; can think <br/>\n&gt; &gt; include subordinating the A result to that of B, <br/>\n&gt; highlighting B, not <br/>\n&gt; &gt; showing A at all and marking A as inconclusive.<br/>\n&gt; &gt; <br/>\n&gt; &gt; 2) Users would be discouraged from seeking annotations that provide <br/>\n&gt; &gt; for direct ordering of tests or the actual &quot;hard&quot;<br/>\n&gt; &gt; dependencies.<br/>\n&gt; &gt; <br/>\n&gt; &gt; 3) Less important, but as an optimization, the framework could <br/>\n&gt; &gt; suppress running of A if B had already failed.<br/>\n&gt; &gt; <br/>\n&gt; &gt; Charlie<br/>\n&gt; &gt; <br/>\n&gt; &gt; &gt; Kent<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; On Dec 29, 2009, at 2:28 PM, Pigneri, Rocco wrote:<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; &gt; Charlie,<br/>\n&gt; &gt; &gt; &gt; <br/>\n&gt; &gt; &gt; &gt; &gt;As a framework author, I can see that allowing the user to <br/>\n&gt; &gt; &gt; &gt; &gt;specify ordering is a simpler implementation. But I think it&#39;s <br/>\n&gt; &gt; &gt; &gt; &gt;more interesting to imagine the user specifying the <br/>\n&gt; nature of the <br/>\n&gt; &gt; &gt; &gt; &gt;dependencies and allowing the framework to figure out <br/>\n&gt; a strategy.<br/>\n&gt; &gt; &gt; &gt; <br/>\n&gt; &gt; &gt; &gt; I am very much with you on this one. In my experience,<br/>\n&gt; &gt; &gt; there have been a lot of times when functions under test <br/>\n&gt; within the <br/>\n&gt; &gt; &gt; same class depend upon each other, and it would have been <br/>\n&gt; great to <br/>\n&gt; &gt; &gt; have the test harness know that information. When I was <br/>\n&gt; refactoring <br/>\n&gt; &gt; &gt; code for a new framework package, I would have loved to <br/>\n&gt; have the UI <br/>\n&gt; &gt; &gt; to display non-dependent tests first as it would have <br/>\n&gt; shown me very <br/>\n&gt; &gt; &gt; clearly the source of the problem.<br/>\n&gt; &gt; &gt; &gt; <br/>\n&gt; &gt; &gt; &gt; Specifying only the relationships in code and leaving the<br/>\n&gt; &gt; &gt; display strategy to the test harness would allow more flexible <br/>\n&gt; &gt; &gt; display and execution of these tests based upon the user&#39;s goals <br/>\n&gt; &gt; &gt; rather than upon the dependencies themselves. I could <br/>\n&gt; imagine myself <br/>\n&gt; &gt; &gt; asking the UI only to display the least dependent <br/>\n&gt; functions&#39; errors <br/>\n&gt; &gt; &gt; and to hide all other errors for quick debugging on sweeping <br/>\n&gt; &gt; &gt; optimizations. I could also want to see the dependent tests in a <br/>\n&gt; &gt; &gt; tree in case I am changing a single class and want to <br/>\n&gt; understand the <br/>\n&gt; &gt; &gt; effects of what I am touching. I could also want to see <br/>\n&gt; all tests in <br/>\n&gt; &gt; &gt; a single list with the least dependent at the top and the most <br/>\n&gt; &gt; &gt; dependent on the bottom when running regression tests. As you can <br/>\n&gt; &gt; &gt; see, the chosen view depends more upon what I am doing <br/>\n&gt; than upon the <br/>\n&gt; &gt; &gt; test dependencies themselves.<br/>\n&gt; &gt; &gt; &gt; <br/>\n&gt; &gt; &gt; &gt; Finally, being able to list dependencies between test<br/>\n&gt; &gt; &gt; classes in addition to test cases would also JUnit to <br/>\n&gt; report which <br/>\n&gt; &gt; &gt; components of the system depend upon each other. This simple <br/>\n&gt; &gt; &gt; extension would greatly increase the power of the <br/>\n&gt; dependency models <br/>\n&gt; &gt; &gt; for larger systems (particularly regression tests).<br/>\n&gt; &gt; &gt; &gt; <br/>\n&gt; &gt; &gt; &gt; Thank you,<br/>\n&gt; &gt; &gt; &gt; <br/>\n&gt; &gt; &gt; &gt; Rocco<br/>\n&gt; &gt; &gt; &gt; <br/>\n&gt; &gt; &gt; &gt; From: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a> [mailto:<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>]<br/>\n&gt; &gt; &gt; On Behalf<br/>\n&gt; &gt; &gt; &gt; Of Charlie Poole<br/>\n&gt; &gt; &gt; &gt; Sent: Thursday, December 24, 2009 12:09 AM<br/>\n&gt; &gt; &gt; &gt; To: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a><br/>\n&gt; &gt; &gt; &gt; Subject: RE: [junit] Order of execution for tests<br/>\n&gt; &gt; &gt; &gt; <br/>\n&gt; &gt; &gt; &gt; Hi Cédric,<br/>\n&gt; &gt; &gt; &gt; <br/>\n&gt; &gt; &gt; &gt; &gt; &gt; On another list, I identified the same variations of <br/>\n&gt; &gt; &gt; &gt; &gt; &gt; dependency but with the variation that for case 1. We might <br/>\n&gt; &gt; &gt; &gt; &gt; &gt; run B<br/>\n&gt; &gt; &gt; anyway but<br/>\n&gt; &gt; &gt; &gt; &gt; &gt; could highlight the error in A in some way. That<br/>\n&gt; &gt; &gt; approach doesn&#39;t<br/>\n&gt; &gt; &gt; &gt; &gt; &gt; require ordering the tests in any particular way, which<br/>\n&gt; &gt; &gt; has some advantages.<br/>\n&gt; &gt; &gt; &gt; &gt; &gt; It still promotes developer efficiency while not worrying <br/>\n&gt; &gt; &gt; &gt; &gt; &gt; about execution efficiency.<br/>\n&gt; &gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt; Yes, we call these &quot;soft dependencies&quot;.<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt; If &quot;b&quot; has a hard dependency on &quot;a&quot; and &quot;a&quot; fails, <br/>\n&gt; &quot;a&quot; will be <br/>\n&gt; &gt; &gt; &gt; &gt; marked &quot;FAILED&quot; and b &quot;SKIPPED&quot;.<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt; If &quot;b&quot; has a soft dependency on &quot;a&quot;, &quot;b&quot; will still run<br/>\n&gt; &gt; &gt; even if &quot;a&quot; <br/>\n&gt; &gt; &gt; &gt; &gt; fails but a warning could be displayed in the log.<br/>\n&gt; &gt; &gt; &gt; <br/>\n&gt; &gt; &gt; &gt; This is an implementation-based view of the tests: i.e. <br/>\n&gt; they will <br/>\n&gt; &gt; &gt; &gt; either be run or not run.<br/>\n&gt; &gt; &gt; &gt; <br/>\n&gt; &gt; &gt; &gt; The distinction I was trying to make - and I think David as<br/>\n&gt; &gt; &gt; well - is<br/>\n&gt; &gt; &gt; &gt; based on the cause and nature of the dependency.<br/>\n&gt; &gt; &gt; &gt; For the sake of argument, I&#39;ll try to redefine what <br/>\n&gt; you&#39;re calling <br/>\n&gt; &gt; &gt; &gt; Hard and Soft along those lines.<br/>\n&gt; &gt; &gt; &gt; <br/>\n&gt; &gt; &gt; &gt; Hard: Test A does something (sets state) upon which B depends.<br/>\n&gt; &gt; &gt; &gt; For example, A may write to a data store and B might try to<br/>\n&gt; &gt; &gt; read the<br/>\n&gt; &gt; &gt; &gt; information back. Or A might create a complex object and B<br/>\n&gt; &gt; &gt; might try<br/>\n&gt; &gt; &gt; &gt; to call a method on that object. If we allow this sort of<br/>\n&gt; &gt; &gt; thing, then<br/>\n&gt; &gt; &gt; &gt; there is no choice but to run A first and it makes sense to<br/>\n&gt; &gt; &gt; not run B<br/>\n&gt; &gt; &gt; &gt; at all if A fails. However, I would not want a unit test<br/>\n&gt; &gt; &gt; framework to<br/>\n&gt; &gt; &gt; &gt; allow it.<br/>\n&gt; &gt; &gt; &gt; <br/>\n&gt; &gt; &gt; &gt; Soft: Test A tests some functionality upon which some other <br/>\n&gt; &gt; &gt; &gt; functionality, tested by B, depends. Therefore, if test A<br/>\n&gt; &gt; &gt; fails, Test<br/>\n&gt; &gt; &gt; &gt; B will either fail as well or be inconclusive, so nothing<br/>\n&gt; &gt; &gt; further can<br/>\n&gt; &gt; &gt; &gt; be learned from test B. In this case, a testing framework could <br/>\n&gt; &gt; &gt; &gt; respond in a number of ways to the dependency:<br/>\n&gt; &gt; &gt; &gt; 1) Run the tests in order, skipping B if A fails.<br/>\n&gt; &gt; &gt; &gt; 2) Run the tests in an arbitrary order, but skip B if A already <br/>\n&gt; &gt; &gt; &gt; ran and failed.<br/>\n&gt; &gt; &gt; &gt; 3) Run the tests in an arbitrary order, not skipping any of<br/>\n&gt; &gt; &gt; them but<br/>\n&gt; &gt; &gt; &gt; organize reporting in such a way that a failure of A takes<br/>\n&gt; &gt; &gt; precedence<br/>\n&gt; &gt; &gt; &gt; over a failure of B.<br/>\n&gt; &gt; &gt; &gt; <br/>\n&gt; &gt; &gt; &gt; As a framework author, I can see that allowing the user <br/>\n&gt; to specify <br/>\n&gt; &gt; &gt; &gt; ordering is a simpler implementation. But I think it&#39;s more <br/>\n&gt; &gt; &gt; &gt; interesting to imagine the user specifying the nature of the <br/>\n&gt; &gt; &gt; &gt; dependencies and allowing the framework to figure out a <br/>\n&gt; strategy.<br/>\n&gt; &gt; &gt; &gt; <br/>\n&gt; &gt; &gt; &gt; Charlie<br/>\n&gt; &gt; &gt; &gt; <br/>\n&gt; &gt; &gt; &gt; &gt; Every time we have discussed this potential feature for<br/>\n&gt; &gt; &gt; TestNG, the<br/>\n&gt; &gt; &gt; &gt; &gt; discussion ended up being non conclusive on the real interest <br/>\n&gt; &gt; &gt; &gt; &gt; and the existing ability to mark certain methods as<br/>\n&gt; &gt; &gt; &quot;alwaysRun&quot; already<br/>\n&gt; &gt; &gt; &gt; &gt; fills a big part of this scenario, so I always ended up<br/>\n&gt; &gt; &gt; punting on<br/>\n&gt; &gt; &gt; &gt; &gt; it, but I&#39;d be happy to hear if someone can come up with<br/>\n&gt; &gt; &gt; a good use<br/>\n&gt; &gt; &gt; &gt; &gt; case for soft dependencies...<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt; --<br/>\n&gt; &gt; &gt; &gt; &gt; ***Cédric<br/>\n&gt; &gt; &gt; &gt; &gt; *<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt; [Non-text portions of this message have been removed]<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt; ------------------------------------<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt; Yahoo! Groups Links<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; <br/>\n&gt; &gt; &gt; &gt; [Non-text portions of this message have been removed]<br/>\n&gt; &gt; &gt; &gt; <br/>\n&gt; &gt; &gt; &gt; <br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; [Non-text portions of this message have been removed]<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; ------------------------------------<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; Yahoo! Groups Links<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; <br/>\n&gt; &gt; <br/>\n&gt; <br/>\n&gt; <br/>\n&gt; <br/>\n&gt; [Non-text portions of this message have been removed]<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; <br/>\n&gt; ------------------------------------<br/>\n&gt; <br/>\n&gt; Yahoo! Groups Links<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; <br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 22250, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1262633153", 
    "canDelete": false, 
    "nextInTopic": 22252, 
    "prevInTopic": 22250, 
    "headers": {
        "inReplyToHeader": "PEMwQThEMTBELTJDQjktNDBBNC1BQ0M2LTQyN0RCNkE1RDY2MEBlYXJ0aGxpbmsubmV0Pg==", 
        "messageIdInHeader": "PDAwMzMwMWNhOGQ3MyRiZDI0MmFlMCQ2NDAxYThjMEBmZXJyYXJpPg=="
    }
}