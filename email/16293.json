{
    "numMessagesInTopic": 13, 
    "nextInTime": 16294, 
    "senderId": "wocgxM9LLFaXw6ZeTzkkZ_vCZV2gc8k1ey_D4JTCWJfIYpvjY6290ZWYZGIK2WhDTLv8IzRRx05tSCFCkN8NMnGkWP0cci4XXP8", 
    "systemMessage": false, 
    "subject": "Testing Abstract Classes", 
    "from": "Kamal Ahmed &lt;KAhmed@...&gt;", 
    "authorName": "Kamal Ahmed", 
    "msgSnippet": "Hi, I found a way to test abstract classes: * Class A = Abstract Class to be tested * Declare a Class C which extends TestCase * In Class C Declare an inner", 
    "msgId": 16293, 
    "topicId": 16293, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 253370470, 
    "messageBody": "<div id=\"ygrps-yiv-781442006\">Hi,<br/>\n<br/>\nI found a way to test abstract classes:<br/>\n<br/>\n <br/>\n<br/>\n* Class A = Abstract Class to be tested<br/>\n<br/>\n <br/>\n<br/>\n* Declare a Class C which extends TestCase<br/>\n<br/>\n <br/>\n<br/>\n* In Class C Declare an inner class B which is static and extends class A,<br/>\nand which implements the unimplemented methods of class A.<br/>\n<br/>\n <br/>\n<br/>\nNow you have access to all the protected and public methods declared in<br/>\nClass A.<br/>\n<br/>\n <br/>\n<br/>\nI know this is also described in the book JUnit Recipes, by J.B Rainsburger,<br/>\nPage 48, Chapter 2:<br/>\n<br/>\n <br/>\n<br/>\n1.\tSelect one of the implementations test cases (not sure what that<br/>\nmeans, does it mean to choose an abstract class?)<br/>\n2.\tCreate a new abstract test case class that stores the tests for the<br/>\nintended behavior (don&#39;t we just have to declare the minimum contract<br/>\nmethods, with &quot;do nothing&quot;?)<br/>\n3.\tChange the implementations test case so it extends the new abstract<br/>\ntest case (in my case the test case extends TestCase class)<br/>\n4.\tFor each implementation test that verifies only interface-scope<br/>\nbehavior. Identify each place where an instance of the implementation is<br/>\ncreated (did not understand this)<br/>\n5.\tInside the test case. Find the code that creates the object under<br/>\ntest. Move this code into a separate creation method, but store the<br/>\ninstantiated object in a reference to the interface, and not the<br/>\nimplementation. (I would need an example just for this)<br/>\n6.\tRepeat until the test has no more direct references to the<br/>\nimplementation by it&#39;s class name.<br/>\n7.\tCreate an abstract method in the abstract test case for each<br/>\ncreation method you extracted (would this be required in case of an inner<br/>\nclass)<br/>\n8.\tNow that the test refers only to the interface and other methods in<br/>\nthe abstract test case, move the test up into the abstract test case.<br/>\n9.\trepeat all steps for each implementation test case, until the only<br/>\ntests remaining in the implementation test cases verify<br/>\nimplementation-specific behavior (did not quite understand this one)<br/>\n<br/>\n <br/>\n<br/>\nSince I did not follow completely what the recipe was, are these two<br/>\napproaches same?<br/>\n<br/>\n <br/>\n<br/>\nThanks,<br/>\n<br/>\n-Kamal.<br/>\n<br/>\n <br/>\n<br/>\n <br/>\n<br/>\n<br/>\n<br/>\n[Non-text portions of this message have been removed]</div>", 
    "prevInTime": 16292, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1142024511", 
    "canDelete": false, 
    "nextInTopic": 16294, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PDVCMTBFNTBFMTRBNDU5NEVCMUI1NTY2QjY5QUQ5NDA3MEQyRTI4QkNAbWFpbGVhc3Q+"
    }
}