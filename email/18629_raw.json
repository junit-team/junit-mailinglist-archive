{
    "numMessagesInTopic": 80, 
    "nextInTime": 18630, 
    "senderId": "iUVPuU4l8oZkhl4BPMgYaHbjZz9dQ5z9X4wMdG9aWSeufya1Wm3VIx4fHBO-Hi2HvCkfaqsLngguRRUoJZM0o2V7rzppXw", 
    "systemMessage": false, 
    "subject": "Re: [junit] 100%% Method Testing and Generating Unit Tests", 
    "from": "Ole Ersoy &lt;ole_ersoy@...&gt;", 
    "authorName": "Ole Ersoy", 
    "msgSnippet": "CÃ©dric, Excellent example old Chap. So a branch is something that takes the code down a certain path. if ( a  10 ) is a branch. I think we agree that it s", 
    "msgId": 18629, 
    "rawEmail": "Return-Path: &lt;ole_ersoy@...&gt;\r\nReceived: (qmail 13158 invoked by uid 7800); 3 Jan 2007 21:33:37 -0000\r\nX-Sender: ole_ersoy@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (qmail 77549 invoked from network); 3 Jan 2007 20:34:10 -0000\r\nReceived: from unknown (66.218.67.33)\n  by m24.grp.scd.yahoo.com with QMQP; 3 Jan 2007 20:34:10 -0000\r\nReceived: from unknown (HELO web60715.mail.yahoo.com) (209.73.178.218)\n  by mta7.grp.scd.yahoo.com with SMTP; 3 Jan 2007 20:34:09 -0000\r\nReceived: (qmail 7243 invoked by uid 60001); 3 Jan 2007 20:34:05 -0000\r\nX-YMail-OSG: THP8z.QVM1lbxmA_i2ErsJD_XjMHafSXhqLIqio6mS8JK8E6NBUePVNqQjsZ8ygm2N0l0ygIXnsZc9xUxEYzZd5XT7dBBonZM1pWN5TR44cxWYQQ2Rou1xe8qsE0njFo9efmTTM4XrhiJRcFSuWBtjRAAIjnqOjdkFGiMU9jASxmTwPevP_W_BOaZiCk.GXk90jWG0Q8\r\nReceived: from [24.13.179.233] by web60715.mail.yahoo.com via HTTP; Wed, 03 Jan 2007 12:34:04 PST\r\nDate: Wed, 3 Jan 2007 12:34:04 -0800 (PST)\r\nTo: junit@yahoogroups.com\r\nIn-Reply-To: &lt;b86b6a9c0701031131o13d24f1eqc747eee84a5247ce@...&gt;\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=iso-8859-1\r\nContent-Transfer-Encoding: 8bit\r\nMessage-ID: &lt;930488.7120.qm@...&gt;\r\nX-eGroups-Msg-Info: 1:0:0:0\r\nFrom: Ole Ersoy &lt;ole_ersoy@...&gt;\r\nSubject: Re: [junit] 100%% Method Testing and Generating Unit Tests\r\nX-Yahoo-Group-Post: member; u=98908154; y=RXDsUBeIta3-vwTJ8xYVF2if5aFo3iPrX9Pub7laozBINTOA\r\nX-Yahoo-Profile: ole_ersoy\r\nX-eGroups-Approved-By: ddoss_2006 &lt;didoss@...&gt; via email; 3 Jan 2007 21:33:36 -0000\r\n\r\nCédric,\n\nExcellent example old Chap.\n\nSo a branch is something that takes the code down a\ncertain path.\n\nif ( a &gt; 10 )\n\nis a branch.\n\nI think we agree that it&#39;s possible to enumerate the\nentire set of branches.\n\nSo for instance \n\na &gt; 10\n\na &lt; 10 \n\na = 10\n\nrepresents 3 different paths.\n\nAnd if I could switch it up \nwith something like this instead:\n\na &gt; 10 && b &lt; 5\n\na &lt; 10 \n\na = 10\n\nI could enumerate the test set like I did for my\nsimple example by \nassuming edge points / the max allowable values for a\nand b (Incidentally in my simple example I did not\ntest values greater than the max allowable values,\nwhich I should have)\n\nSo now we have test input data set:\n\na                     b\n-------------------------------------\n11                    4\n9                     4\n10                    4\naBiggest              4\naBiggest+1            4\naSmallest             4\naSmallest-1           4\n\n11                    5\n9                     5\n10                    5\naBiggest              5\naBiggest+1            5\naSmallest             5\naSmallest-1           5\n\n11                    bMax\n9                     bMax\n10                    bMax\naMax                  bMax\naMax+1                bMax\naMin                  bMax\naMin-1                bMax\n\netc. with bMin and bMin-1\n\nThat&#39;s not so bad...\n\nYour ipod can do that in 5 nanoseconds.\n\nBut these are just the inputs.\n\nWe also have to generate the outputs.\n\nWhich is also easy to do and we would use the \nmethod to calculate them.  This assumes that there\nare no constraints on the output.  Lets just say that\nthe output is just an int\nc.\n\nSuppose c can only be 1 or 2.\n\nWell, that implies further constraints on the inputs,\nso we have to go back and reconstrain.\n\nHowever in this example c can be anything, so we just\ncalculate the possible outputs.\n\nThen we run it through testing.\n\nNow we could test \n\na = 22\na = 23\n\netc.\n\nbut that would be silly since we assume that\nsince we passed values through our enumerated branch\nlist, that represent the beginning and end of the\nrange of allowed values and even the points external\nto that range, we covered everything.\n\nSo now I can look at my generated test code\nand see all the inputs, the expected outputs,\nand run the tests.\n\nI personally would like this since it does a lot of\nthe grunt work for me.\n\nIt&#39;s possible to have a method\nwith a gazillion variables and paths...\n\nbut I would think that that would be a ripe case for\nrefactoring, because it&#39;s tricky to test :-)\n\nAs a matter of fact...it would be nice to have\nsomething that enumerates the branches and generates a\nreport on which methods has a number of branches over\na certain limit...for code refactoring and maintenance\npurposes.\n\nCheers,\n- Ole\n\n\n\n\n\n\n--- Cédric Beust ♔  &lt;cbeust@...&gt; wrote:\n\n&gt; On 1/3/07, Ole Ersoy &lt;ole_ersoy@...&gt; wrote:\n&gt; &gt;\n&gt; &gt; We first have to agree on what 100% means.\n&gt; &gt;\n&gt; &gt; I provided a very simple example in the earlier\n&gt; post.\n&gt; &gt;\n&gt; &gt; The example gives a 100% tested tested method\n&gt; example,\n&gt; &gt; given that the assumptions hold.\n&gt; &gt;\n&gt; &gt; This example can be entirely generated using\n&gt; DataType\n&gt; &gt; meta data.\n&gt; \n&gt; \n&gt; Yes, but your example is too simple since it only\n&gt; contains one branch (most\n&gt; examples extolling the virtues of code coverage have\n&gt; this flaw :-)).\n&gt; \n&gt; 100% coverage means you should cover all the\n&gt; possible branches of your code,\n&gt; which is impossible to achieve in practice.  Even\n&gt; when code coverage tools\n&gt; report 100% coverage (hardly ever happens in my\n&gt; experience), they are still\n&gt; lying to you.\n&gt; \n&gt; Consider the following simple code:\n&gt; \n&gt; public URL createUrl(int a, int b) {\n&gt; \n&gt; try {\n&gt;   if (a == 0 || b == 0) {\n&gt;   }\n&gt; \n&gt;   if (c == 0 && d == 0) {\n&gt;   }\n&gt; }\n&gt; catch(IOException ex) {\n&gt; }\n&gt; catch(MalformedURLException ex) {\n&gt; }\n&gt; \n&gt; 100% coverage for this code means something like\n&gt; 2*2*2*2 = 16 test cases\n&gt; (I&#39;m approximating, but you get the idea).\n&gt; \n&gt; Do you really feel it&#39;s useful to write 16 test\n&gt; cases for these 6 lines of\n&gt; code?\n&gt; \n&gt; Wouldn&#39;t you be better off black-box testing this\n&gt; function instead, and\n&gt; ignore the screams of complaint from your code\n&gt; coverage tool?\n&gt; \n&gt; -- \n&gt; C�dric\n&gt; http://testng.org\n&gt; \n&gt; \n&gt; [Non-text portions of this message have been\n&gt; removed]\n&gt; \n&gt; \n\n\n__________________________________________________\nDo You Yahoo!?\nTired of spam?  Yahoo! Mail has the best spam protection around \nhttp://mail.yahoo.com \n\n", 
    "profile": "ole_ersoy", 
    "topicId": 18605, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 98908154, 
    "prevInTime": 18628, 
    "contentTrasformed": false, 
    "postDate": "1167856444", 
    "canDelete": false, 
    "nextInTopic": 18630, 
    "prevInTopic": 18628, 
    "headers": {
        "inReplyToHeader": "PGI4NmI2YTljMDcwMTAzMTEzMW8xM2QyNGYxZXFjNzQ3ZWVlODRhNTI0N2NlQG1haWwuZ21haWwuY29tPg==", 
        "messageIdInHeader": "PDkzMDQ4OC43MTIwLnFtQHdlYjYwNzE1Lm1haWwueWFob28uY29tPg=="
    }
}