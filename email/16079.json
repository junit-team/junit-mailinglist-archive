{
    "numMessagesInTopic": 40, 
    "nextInTime": 16080, 
    "senderId": "wxejd2k_Kc03qFCZYcnBBinSmzHojhAOvmk8de3rlDFrklQNXhD6MEfwEzOiJtQOQBQBhoTw0HkU_Qwqve7hHwyPoYJS4j54", 
    "systemMessage": true, 
    "subject": "Re: Is Junit-based testing REALLY possible for commercial software development ?", 
    "from": "&quot;j0hlrogge&quot; &lt;j0hlrogge@...&gt;", 
    "authorName": "j0hlrogge", 
    "msgSnippet": "Hi Frank, As Dianne said it may boil down to faith. I am also a firm beleiver in JUnit especially if you use Test-driven development. My experience tells me", 
    "msgId": 16079, 
    "profile": "j0hlrogge", 
    "topicId": 16038, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 256158327, 
    "messageBody": "<div id=\"ygrps-yiv-521344636\">Hi Frank,<br/>\n<br/>\nAs Dianne said it may boil down to faith. I am also a firm beleiver in<br/>\nJUnit especially if you use Test-driven development. My experience<br/>\ntells me that it does make a significant difference especially if you<br/>\nwant to add lots of new features all the time.<br/>\n<br/>\nMy experience is mainly from comercial projects and lately from<br/>\nparticipating in the development of rMock <a rel=\"nofollow\" target=\"_blank\" href=\"http://rmock.sf.net\">http://rmock.sf.net</a><br/>\n<br/>\nLet me put it this way:<br/>\n<br/>\nIf you don&#39;t have the tests to prove that your system works, adding<br/>\nnew features, and knowing you didn&#39;t break anything that used to work,<br/>\nis way harder than if you have them.<br/>\n<br/>\nToday I would actually think twice if I knew that a comercial product<br/>\nwas not properly unit-tested before buying it, I would not trust its<br/>\nquality since I have seen the difference in my code and other peoples<br/>\ncode when changing towards TDD.<br/>\n<br/>\n<br/>\nAs a concrete example of where my faith in unit tests comes from:<br/>\n<br/>\nSome years ago I was a tech-lead (coding tech-lead) for a web-based<br/>\napplication, one of many in a portal. &quot;my&quot; application was supposed to<br/>\ngo live together with a similar application (in terms of complexity)<br/>\ndeveloped by another company.<br/>\nI had managed to get the customer interested in TDD (that to them was<br/>\nthe same as having automated unit tests) and they had agreed to let me<br/>\n&quot;prove my point&quot; on this project well aware that this might take a<br/>\nlittle bit more time since we were all inexperienced in TDD (they were<br/>\nwilling to take the risk since they saw a potential benefit in higher<br/>\nquality and less bugs since going live in that system was<br/>\ntraditionally tedious and error-prone. A bug in a component requires a<br/>\nnew turn in that procedure so it is better if it works when they go<br/>\nlive ;))<br/>\n<br/>\nThe development was no picknick, TDD is not a silver bullet and you<br/>\nmake mistakes while you learn how to master it. This application was<br/>\nno exception.<br/>\nAfter we went live only 2 bugs have ever been discovered and none of<br/>\nthem serious. The other application had more than 100 reported bugs of<br/>\ndifferent levels chriticality the first week.<br/>\n<br/>\nI attribute this difference mainly to the fact that we had unit-tests<br/>\nand the others didn&#39;t (It would be tempting to think that we were<br/>\nsimply that much better and smarter but realistically: our choice of<br/>\nenginering approach was better in this case). It is also interesting<br/>\nto note that we did not need more time to finish our application than<br/>\nthe other team did, I think that this is bvecause they spent more time<br/>\nin word than we did and we spent more time in code than they did,<br/>\nrelying more on our testcases to drive the design and acting on the<br/>\nfeedback we got from our tests. In fact our server side components<br/>\nwere live 1 week before theirs.<br/>\n<br/>\n<br/>\nDo I think unit testing takes more time? Yes and no:<br/>\n<br/>\nYes - because there is more code to write, and in the beginning there<br/>\nis a learning curve. I would say that you would experience a drop in<br/>\nproductivity the first couple of months until you get the &quot;hang of it&quot;<br/>\nTDD is a new way of thinking but it is worth learning. I think TDD is<br/>\nalmost as big of a change as it is to change from procvedural oriented<br/>\nthinking to OO thinking, you never stop learning and it will take you<br/>\nyears to master it (although you will get benefits from it much earlier)<br/>\n<br/>\nNo - because you tend to write less &quot;unused code&quot; simply because<br/>\nhaving to have a test for every line of code you write makes you<br/>\nreluctant to do &quot;might be good if I want to do this in the future&quot;<br/>\nkind of design stunts. This also comes from the knowledge that<br/>\nchanging the code to support those &quot;might be good to haves&quot; is<br/>\nstraight forward, if you have the tests, when they change from &quot;might<br/>\nbe good&quot; to &quot;are necesary&quot;.<br/>\nLess &quot;might be good to haves&quot; alsoe leaves less production code to<br/>\nmaintain wich saves some effort, I don&#39;t remember who said that he<br/>\n&quot;would rather have his developers surf the web than adding code that<br/>\ndid not immediately provide any value&quot;. An interesting thought.<br/>\n<br/>\nNo - Because you tend to do less bug-hunting since your code usually<br/>\nworks.<br/>\n<br/>\nNo - Because your design, with TDD, tends to be simpler, more to the<br/>\npoint and better when you drive it with tests (when you learn how to<br/>\ndo that, before that you will just have very complicated tests and the<br/>\nsame design).<br/>\n<br/>\nYes - Because if you have not been doing test-driven development so<br/>\nfar your design will likely be hard to test until you remedy that. To<br/>\nfix that is time well spent since a testable design is usually an<br/>\nextendable one and when you have your tests you will see that you can<br/>\nadd new features faster than you thought were possible. But<br/>\nproductivity will no doubt drop until you have spent some time<br/>\nrefactoring for testability (and fixing what you break/try to prevent<br/>\nto break stuff while doing that since you have no tests at the moment)<br/>\n<br/>\nI am not saing that your design is bad, I&#39;m saying that it is unlikely<br/>\nto be very good for testing if that has not been a design-goal (from<br/>\nmy experience)<br/>\n<br/>\nAbout testing web-based applications and the effectiveness of unit<br/>\ntests I would say that JUnit is equally appropriate for web, but, with<br/>\nJUnit you test one class at the time (if you do it interaction based)<br/>\nor several classes from one class at the time (if you are doing<br/>\nstatebased testing). In order to find bugs in your HTML etc you need<br/>\nsystem tests and other tools (or add ons) to test that. (The example I<br/>\ngave you was a unit-tested serverside with a manually tested<br/>\npresentation layer). What you want to do though is to put as little<br/>\nbusiness logic in your presentation layer as you can (that is put no<br/>\nbusinesslogic there) so that all your businesslogic can be unit<br/>\ntested. When you have that you find a lot fewer bugs in your<br/>\npresentation-layer.<br/>\n<br/>\nMore and more tools are available testing web apps, I heard about but<br/>\nnever tried &quot;selenium&quot; try that one.  And I also recomend looking at<br/>\nwww.testdriven.com to see if you can find anything that suits you. But<br/>\nregardless of wether you test the generated html or not you can still<br/>\nrely on the fact that what is beneath your presentation-layer works.<br/>\n<br/>\nSorry for the blah, blah response I easilly get caught up in these<br/>\nthings :) I hope you could distill something useful from this massive<br/>\namount of text :)</div>", 
    "prevInTime": 16078, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1139586516", 
    "canDelete": false, 
    "nextInTopic": 16080, 
    "prevInTopic": 16074, 
    "headers": {
        "inReplyToHeader": "PDAyMTAyMDA2MTQzNC40ODQ3LjQzRUNBNDZEMDAwMTJFMDYwMDAwMTJFRjIyMDA3NjEzOTQ5QzlDMDEwQjA3MEJAY29tY2FzdC5uZXQ+", 
        "messageIdInHeader": "PGRzaWNrayttbnBoQGVHcm91cHMuY29tPg=="
    }
}