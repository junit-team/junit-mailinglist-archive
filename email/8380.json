{
    "numMessagesInTopic": 16, 
    "nextInTime": 8381, 
    "senderId": "HdZOH6ujLGLR2LvtS92JtMLCEv3wI-FU5AjYN5rOqNdenwQePIisn05uuS-DygwqqwyIc_pOzbxH88pnKonmRzdPzLtN_4T_8J0Um2N0bA", 
    "systemMessage": false, 
    "subject": "RE: [junit] Re: Fork each test method?", 
    "from": "&quot;Robert DiFalco&quot; &lt;rdifalco@...&gt;", 
    "authorName": "Robert DiFalco", 
    "msgSnippet": "... object , ... nuance ... No, I don t think so. It is exactly the same. My issue is exposing much of the state of the object called Runtime to reset it s", 
    "msgId": 8380, 
    "profile": "robert_difalco", 
    "topicId": 8358, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 35850082, 
    "messageBody": "<div id=\"ygrps-yiv-1365403704\"><blockquote><span title=\"ireply\">&gt;&gt; How is &quot;create a new runtime instance&quot; different from &quot;create a new<br/>\n </span></blockquote>object&quot;,<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt; since an object is just a runtime instance of a class? There is some<br/>\n </span></blockquote>nuance<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt; in what you&#39;re saying that I can&#39;t see.<br/>\n<br/>\n </span></blockquote>No, I don&#39;t think so. It is exactly the same. My issue is exposing much<br/>\nof the state of the object called Runtime to reset it&#39;s state when what<br/>\nyou really want to do is just create a new object that hides it&#39;s<br/>\ndetails of initialization. To me, this is why a unit testing framework<br/>\nshould run each test in a new runtime. Otherwise, we have to break<br/>\ncontracts or create (to me) overly complicated code to violate the state<br/>\nof the object, and arbitrarily reset it from an external client.<br/>\n<br/>\nBasically, I agree with everything you said. But maybe not this part:<br/>\n<br/>\nclass Something<br/>\n    Something()<br/>\n        this(ClassRegistry.identify(Foo.class))<br/>\n<br/>\n    Something(identity)<br/>\n        // store in instance-level variable<br/>\n<br/>\nI suppose it really depends on Something. Is this meta-state or is it<br/>\ninstance state? In my example, it was a static because this is a detail<br/>\nof Something that is shared across all it&#39;s instances. Now, if we had<br/>\nreal MetaClasses in Java we might do something different -- say, create<br/>\na SomethingClass that IS designed as you propose. In this case, however,<br/>\ninitializing the class initializes the Identity that is to be used by<br/>\nall instances of Something.<br/>\n<br/>\nSo, I suppose where we differ is that I think a fresh Runtime instance<br/>\nshould be achieved &quot;the same way each time&quot; -- through creation. I feel<br/>\nI am introducing the possibility for a bug by allowing methods that<br/>\nreset state that only exist for testing. I could be wrong, but I believe<br/>\nyou are saying systems should be design so that one can reset it&#39;s state<br/>\nthrough some external actor at any time.<br/>\n<br/>\nAnd I agree that testing is very important, which is why I would like a<br/>\nnew runtime for each test method, even though that would slow down the<br/>\nexecution of tests. It&#39;s just that important to me to have a unit<br/>\ntesting framework with no side-effects between test methods.<br/>\n<br/>\nR.<br/>\n<br/>\n-----Original Message-----<br/>\nFrom: J. B. Rainsberger [mailto:<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:jbrains@...\">jbrains@...</a>] <br/>\nSent: Tuesday, June 17, 2003 4:56 PM<br/>\nTo: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a><br/>\nSubject: RE: [junit] Re: Fork each test method?<br/>\n<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;So said Robert DiFalco on 2003-06-17 --------------------<br/>\n&gt;&gt;&gt; I would think that the easiest way to zero out all the caches is to <br/>\n&gt;&gt;&gt; create new cache objects.<br/>\n&gt;<br/>\n&gt;No, not really. I don&#39;t expect to be able to convince you but if you <br/>\n&gt;have caches, or thread pools, or whatever that &quot;are scoped to the <br/>\n&gt;runtime instance they were created in&quot;, the easiest and in fact the <br/>\n&gt;most correct way to reinitialize them is to create a new runtime <br/>\n&gt;instance.<br/>\n<br/>\n </span></blockquote>I don&#39;t understand how what you said is different from what I said.<br/>\n<br/>\nHow is &quot;create a new runtime instance&quot; different from &quot;create a new<br/>\nobject&quot;, since an object is just a runtime instance of a class? There is<br/>\nsome nuance in what you&#39;re saying that I can&#39;t see. If you have the<br/>\nenergy, help me understand what that is.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;The saddest thing is that there is no reason in production to &quot;zero out<br/>\n<br/>\n&gt;all caches&quot;. Even having such a method indicates (to me) a design flaw.<br/>\n<br/>\n&gt;After all, I don&#39;t expect the value of an immutable object (say an<br/>\n&gt;Integer) to suddenly change during the life of that object.<br/>\n<br/>\n </span></blockquote>I&#39;m not sure what the former has to do with the latter. I agree with<br/>\nyour statement. This is one motivation for keeping from my objects the<br/>\ndetails of whether they are collaborating with caches. In J2EE we may<br/>\nwant to cache the result of a JNDI lookup. One way to do this is<br/>\nabstract away the lookup into a generic object factory. At test time, we<br/>\nuse an in-memory object factory; at production time, we use an object<br/>\nfactory backed by JNDI. Everyone wins.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt;&gt; If a class uses a cache, then that class should either accept the <br/>\n&gt;&gt;&gt; cache from the outside world or be unaware that it&#39;s using a cache <br/>\n&gt;&gt;&gt; at all.<br/>\n&gt;<br/>\n&gt;You are working too hard at this.<br/>\n<br/>\n </span></blockquote>I appreciate your concern. (Not sarcasm: it&#39;s nice to know that your<br/>\ngoal is to help, and not just puff your chest. Many others are guilty of<br/>\nthe latter.)<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;Things seem simpler to me. For<br/>\n&gt;example, from what you say I am going to assume that you never use <br/>\n&gt;string constants in your code.<br/>\n<br/>\n </span></blockquote>Well, I never do anything the same way all the time. Everything depends.<br/>\nIn particular, I externalize strings when it makes sense, and I don&#39;t<br/>\nwhen it doesn&#39;t. I first have to see the pattern or be told by a<br/>\ncustomer that the data in question is volatile.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;There isn&#39;t that much of a difference. I<br/>\n&gt;suppose you use a decorator that caches strings and then you make a <br/>\n&gt;call on each access of the string (possibly looking in a map?) instead <br/>\n&gt;of simply caching the constant string reference as a static final?<br/>\n<br/>\n </span></blockquote>I don&#39;t see a need for that right now. It depends whether the string<br/>\nneeds to change. If the string doesn&#39;t need to change, then I put it in<br/>\nthe code until I see evidence that it needs to change.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Really,<br/>\n&gt;there is no difference between that and this:<br/>\n&gt;<br/>\n&gt;class Something<br/>\n&gt;{<br/>\n&gt;     private static final Identity FOO_CLASS_ID = <br/>\n&gt;ClassRegistry.identify( Foo.class );<br/>\n&gt;<br/>\n&gt;     ...<br/>\n&gt;}<br/>\n&gt;<br/>\n&gt;FOO_CLASS_ID is scoped to the runtime instance it was created in.<br/>\n<br/>\n </span></blockquote>I think this is the big difference. I have the tendency to build classes<br/>\nand interfaces that collaborate with one another and let the application<br/>\ncontext (or component runtime context, whatever it is) decide how to<br/>\nbind runtime objects to one another. So in my code there are relatively<br/>\nfew cases where an object manages the lifecycle of other objects.<br/>\n<br/>\nIn particular, FOO_CLASS_ID would be a parameter to Something&#39;s<br/>\nconstructor. If the production code wants to use a ClassRegistry to get<br/>\nFOO_CLASS_ID, then that&#39;s cool; but if Something only depends on having<br/>\na FOO_CLASS_ID, then why should it care where the FOO_CLASS_ID came<br/>\nfrom? I don&#39;t see the benefit there.<br/>\n<br/>\nYou are saying, &quot;This is the simplest place to put that code.&quot; I<br/>\ndisagree. It&#39;s the easiest, but not necessarily the simplest. What if<br/>\nthe application doesn&#39;t want Something to identify Foo.class as the<br/>\nmeans of getting a FOO_CLASS_ID? What if the application needs to<br/>\nprovide that data?<br/>\n<br/>\nOf course, I can take my own advice and deal with that when it happens,<br/>\nbut I practice TDD, and in so doing, would tend not to write the code<br/>\nyou&#39;ve written there. No value judgment: just a difference in approach.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;It is<br/>\n&gt;immutable for the life of the runtime. These may be generated by a <br/>\n&gt;database, created by a synchronized static int, GUID generator or <br/>\n&gt;whatever. It doesn&#39;t really matter. The contract is that they are good <br/>\n&gt;for the life of the Runtime. So it makes sense to hide them just as you<br/>\n<br/>\n&gt;would any other immutable constant -- say a string. The only reason to <br/>\n&gt;impose a hash look up on every access is, well, I dunno. For testing?<br/>\n<br/>\n </span></blockquote>First, don&#39;t underestimate the importance of testing. Testing is damn<br/>\nimportant.<br/>\n<br/>\nYou want to Something to hide the way it gets a FOO_CLASS_ID because all<br/>\nthat matters is the value: once Something gets the FOO_CLASS_ID, it<br/>\ndoesn&#39;t matter how it did that. I can&#39;t argue with that. If the system<br/>\nonly says this once, then it matters less where the system says it.<br/>\n<br/>\nHowever, I claim that by splitting Something into Something and<br/>\nFooClassIdFactory, I can add only a little complexity but gain the real<br/>\nbenefit of making Something easier to test. Here is how I would do it.<br/>\n<br/>\nclass Something<br/>\n    Something()<br/>\n        this(ClassRegistry.identify(Foo.class))<br/>\n<br/>\n    Something(identity)<br/>\n        // store in instance-level variable<br/>\n<br/>\nThe default behavior of Something is to use the ClassRegistry to create<br/>\nFOO_CLASS_ID, but in my tests, I can just provide whatever data is<br/>\neasiest for the tests to provide.<br/>\n<br/>\nThis is an extremely small amount of complexity to add to gain the<br/>\nbenefit of testing. Of course, if you don&#39;t value testing the same way I<br/>\ndo, then you won&#39;t be moved by this. That&#39;s fine: do as you find best,<br/>\nas will I.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;Now, if you suddenly invalidate those identities or flush the <br/>\n&gt;ClassRegistry, you are in deep trouble. What is the simplest solution? <br/>\n&gt;&quot;Don&#39;t do that.&quot; What is the most complicated solution? &quot;Create a bunch<br/>\n<br/>\n&gt;of rigging that has no value save for unit tests that are unable to <br/>\n&gt;create new runtime instances on each run.&quot; Think about it. Details and <br/>\n&gt;Abstraction are one thing, this is another.<br/>\n<br/>\n </span></blockquote>You&#39;re right. This is another. This is straightforward separation of<br/>\nresponsibilities. Something just needs an Identity. It shouldn&#39;t much<br/>\nmatter where the Identity comes from. For that reason, Something should<br/>\nbe willing to take whatever Identity I give it, if I want to give it<br/>\none; otherwise, it can use the one it wants to use.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;For me, there is nothing<br/>\n&gt;worse than seeing designs that are overly complicated (obfuscated in<br/>\n&gt;fact) for no other reason than to serve a principle. Liskov <br/>\n&gt;Substitution, Law of Demeter, Coupling and Cohesion, Shunts, Mock <br/>\n&gt;Objects, Decorators....these are all good and wonderful things.  All <br/>\n&gt;important tools. However, they are capable of improving code or making <br/>\n&gt;code horribly obfuscated and ugly. At this point in its evolution, <br/>\n&gt;programming is much more like music than science. You can kill the feel<br/>\n<br/>\n&gt;of the code by being too pedantic.<br/>\n<br/>\n </span></blockquote>No argument here: I am guilty of using good tools to build bad ashtrays.<br/>\nWe all are. We have to take care, though, not to become neo-Luddites,<br/>\ndeciding that the tools are the reason we built bad ashtrays. That was<br/>\nus. We should practise with the tools.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;Google &quot;Simplicity&quot;.<br/>\n<br/>\n </span></blockquote>Sometimes people mistake simplicitly and ease. I&#39;m not saying that<br/>\nyou&#39;re doing it, but it happens. Here is how my code tends to evolve.<br/>\n<br/>\n1. Implement a few hardcoded concrete cases.<br/>\n2. Identify the abstractions by looking at common code.<br/>\n3. Extract the abstractions into behavioral classes; push the difference<br/>\ninto data classes. 4. Decide whether to move the values of the data<br/>\nclasses outside the system into data files of some sort. Rinse and<br/>\nrepeat, as needed.<br/>\n<br/>\nThe result is a bunch of collaborating engines and, surprisingly, less<br/>\ncode. Also increased flexibility without obscene complexity. (Some<br/>\ncomplexity, yes; but then a system without complexity may not do much of<br/>\nanything useful.) I don&#39;t think that&#39;s being &quot;pedantic&quot;. When I feel<br/>\nthat the code is becoming too complex, I have to step back away from the<br/>\nkeyboard and think a little. I have to throw away what I&#39;ve done and try<br/>\nagain. The result is usually better. Sometimes banging out a silly<br/>\nsolution is a good tool to finding a better one.<br/>\n<br/>\nTake care.<br/>\n<br/>\n<br/>\nJ. B. Rainsberger,<br/>\nPresident, Diaspar Software Services<br/>\nLet&#39;s write software that people understand.<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.diasparsoftware.com/\">http://www.diasparsoftware.com/</a><br/>\ntelephone: +1 416 791-8603<br/>\n<br/>\n<br/>\n<br/>\nTo unsubscribe from this group, send an email to:<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit-unsubscribe@yahoogroups.com\">junit-unsubscribe@yahoogroups.com</a><br/>\n <br/>\n<br/>\nYour use of Yahoo! Groups is subject to<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://docs.yahoo.com/info/terms/\">http://docs.yahoo.com/info/terms/</a></div>", 
    "prevInTime": 8379, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1055895003", 
    "canDelete": false, 
    "nextInTopic": 8430, 
    "prevInTopic": 8379, 
    "headers": {
        "messageIdInHeader": "PENGRERFQjNCODcwRUUzNDZCQjU4M0QyQjA0MjBGNUFDMDEwMUU4NTlAc2VhYmFzcy50cmlwd2lyZS5jb20+"
    }
}