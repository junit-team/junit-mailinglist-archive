{
    "numMessagesInTopic": 31, 
    "nextInTime": 7963, 
    "senderId": "Gbn7Nj2gvY_G8FWK3gyo8BK5FQhQu1pEmttGqdtblLUTuPlYg0_w9QD3kmfgyMUhxz8jFy1PfZozTpFdkBIJdkiGJE0OoWy_UxaUO3BP2g", 
    "systemMessage": false, 
    "subject": "Re: [junit] question about Assert.assertEquals", 
    "from": "&quot;J. B. Rainsberger&quot; &lt;jbrains@...&gt;", 
    "authorName": "J. B. Rainsberger", 
    "msgSnippet": "... Sure I can: I compare class objects. Two objects are equal iff their class objects are equal and their respective values are equal. In this case, the", 
    "msgId": 7962, 
    "profile": "nails762", 
    "topicId": 7948, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 127224993, 
    "messageBody": "<div id=\"ygrps-yiv-1549252036\"><blockquote><span title=\"ireply\">&gt;You can write a subclass that reports itself equal to the superclass. <br/>\n&gt;In fact, you can&#39;t avoid it, and that&#39;s the problem.<br/>\n<br/>\n </span></blockquote>Sure I can: I compare class objects. Two objects are equal iff their class objects are equal and their respective values are equal. In this case, the subclass cannot equal the superclass.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;If you use the instanceof approach, then (as you point out) you&#39;re<br/>\n&gt;breaking symmetry.<br/>\n<br/>\n </span></blockquote>You&#39;re also breaking equals.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;However, if you go with a different approach, say ignoring the added<br/>\n&gt;characteristic, you break transitivity.  Bloch&#39;s example from Effective<br/>\n&gt;Java has a ColoredPoint that has a new attribute color.  ColoredPoints<br/>\n&gt;need to be different if they&#39;re different colors.  But what happens<br/>\n&gt;when they&#39;re compared to regular Points?<br/>\n<br/>\n </span></blockquote>If color distinguishes ColoredPoint objects, then a Point can never be equal to a ColoredPoint. Comparing class objects removes that problem.<br/>\n<br/>\nIf a Point could have a default color for the purposes of comparison, then a Point would be a ColoredPoint. (I would declare Point as abstract at that point.)<br/>\n<br/>\nIf a ColoredPoint&#39;s color didn&#39;t matter for equals, then ColoredPoint could inherit Point#equals and that&#39;s all.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;I guess if you change the equals clause of Point to return false for<br/>\n&gt;ColoredPoints you can solve this, but then you&#39;re polluting your<br/>\n&gt;superclass equals method with knowledge of each subclass.<br/>\n<br/>\n </span></blockquote>No you aren&#39;t. If you check class objects, then a Point is never equal to anything other than a Point without knowing specifically what other class we are comparing it to.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;So, in summary, I&#39;m saying that if you subclass an equals for anything<br/>\n&gt;but Object, you&#39;re going to break it.  Be sure that you break it in a<br/>\n&gt;way that you expect.  Does that make sense?<br/>\n<br/>\n </span></blockquote>No, because it isn&#39;t true.<br/>\n<br/>\nConsider the template code:<br/>\n<br/>\npublic boolean equals(Object other) {<br/>\n    if (other != null && getClass() == other.getClass()) {<br/>\n        MyClass that = (MyClass) other;<br/>\n        // compare fields or whatever you like<br/>\n    }<br/>\n    else {<br/>\n        return false;<br/>\n    }<br/>\n}<br/>\n<br/>\nI claim that this implementation of equals fully supports the contract of Object#equals, including the subclass/superclass case. If you think that is false, then please show us a test consistent with the contract of Object#equals that this implementation does not pass.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;Oh, Bloch recommends that in this case you &quot;favor composition over<br/>\n&gt;inheritence&quot;, and have ColoredPoint not extend Point, but pass through<br/>\n&gt;all the common methods to Point, and provide a view method called<br/>\n&gt;asPoint().  I haven&#39;t thought through the ramifications of that.<br/>\n<br/>\n </span></blockquote>If it makes sense to view a ColoredPoint as a plain Point, then this is a good idea; otherwise, it is not.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;Lastly, for the original poster, before J.B. reminds me of it:  be sure<br/>\n&gt;you override hashCode as well, or funny things will happen in your<br/>\n&gt;maps.<br/>\n<br/>\n </span></blockquote>Absolutely! The universal hashCode algorithm is &quot;return 0;&quot;. If you need the object to be a Map key, then write a better hashCode algorithm.<br/>\n<br/>\nTake care.<br/>\n<br/>\n<br/>\nJ. B. Rainsberger,<br/>\nPresident, Diaspar Software Services<br/>\nLet&#39;s write software that people understand.<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.diasparsoftware.com/\">http://www.diasparsoftware.com/</a><br/>\ntelephone: +1 416 791-8603</div>", 
    "prevInTime": 7961, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1052314741", 
    "canDelete": false, 
    "nextInTopic": 7963, 
    "prevInTopic": 7961, 
    "headers": {
        "inReplyToHeader": "PDIwMDMwNTA3MDAwODUwLjIzNjU4LnFtYWlsQHdlYjgwNTEwLm1haWwueWFob28uY29tPg==", 
        "messageIdInHeader": "PDIwMDMwNTA3MDkzOTAxMDMxOC4wMkQzMDU5MkBzc210cC5ibG9vci5pcy5uZXQuY2FibGUucm9nZXJzLmNvbT4=", 
        "referencesHeader": "PDIwMDMwNTA3MDAwODUwLjIzNjU4LnFtYWlsQHdlYjgwNTEwLm1haWwueWFob28uY29tPg=="
    }
}