{
    "numMessagesInTopic": 8, 
    "nextInTime": 22939, 
    "senderId": "WY84exYE0At67SpBCoiMOVgIgPHFjYUuuNbvVn67O1s5FKT9Lq6RGViGc0aMU17atzJfILvt6_F4xa8ewgSMvLAwFT9h", 
    "systemMessage": false, 
    "subject": "Re: [junit] Common Test Runner for JVM", 
    "from": "Bill Venners &lt;bill@...&gt;", 
    "authorName": "Bill Venners", 
    "msgSnippet": "Hi Esko, ... What you say you want here makes sense. My point is that it doesn t require nested tests. You can do it with nested descriptions. That s the", 
    "msgId": 22938, 
    "rawEmail": "Return-Path: &lt;bill@...&gt;\r\nReceived: (qmail 37206 invoked by uid 7800); 13 Sep 2010 21:45:14 -0000\r\nX-Sender: bill@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nX-Received: (qmail 84234 invoked from network); 13 Sep 2010 19:59:13 -0000\r\nX-Received: from unknown (98.137.34.46)\n  by m8.grp.sp2.yahoo.com with QMQP; 13 Sep 2010 19:59:13 -0000\r\nX-Received: from unknown (HELO mail-ww0-f41.google.com) (74.125.82.41)\n  by mta3.grp.sp2.yahoo.com with SMTP; 13 Sep 2010 19:59:12 -0000\r\nX-Received: by wwe15 with SMTP id 15so530201wwe.4\n        for &lt;junit@yahoogroups.com&gt;; Mon, 13 Sep 2010 12:59:11 -0700 (PDT)\r\nMIME-Version: 1.0\r\nX-Received: by 10.216.17.78 with SMTP id i56mr4699378wei.91.1284407950352; Mon,\n 13 Sep 2010 12:59:10 -0700 (PDT)\r\nX-Received: by 10.216.80.130 with HTTP; Mon, 13 Sep 2010 12:59:10 -0700 (PDT)\r\nIn-Reply-To: &lt;4C8E791D.5040704@...&gt;\r\nReferences: &lt;4C8BFDE7.3010603@...&gt;\n\t&lt;AANLkTin4AXk8BGcbXGfm68KQFzLqbVzk+m22CrcUgRt1@...&gt;\n\t&lt;AANLkTim11ORO68irFhHrVCBvqH8vK9BQG26wiUxWd9Zd@...&gt;\n\t&lt;4C8E791D.5040704@...&gt;\r\nDate: Mon, 13 Sep 2010 12:59:10 -0700\r\nMessage-ID: &lt;AANLkTik8hCRgrAvKWpegL8Bh+_QRYv-c53Y-nPO85Qh0@...&gt;\r\nTo: junit@yahoogroups.com\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Transfer-Encoding: quoted-printable\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: Bill Venners &lt;bill@...&gt;\r\nSubject: Re: [junit] Common Test Runner for JVM\r\nX-Yahoo-Group-Post: member; u=416990097; y=1Y0et_arl0LbwvraDZQU7guLXcldhKsALfW3sF65AwUaJVKHBME\r\nX-Yahoo-Profile: billvenners\r\nX-eGroups-Approved-By: dsaff &lt;david@...&gt; via email; 13 Sep 2010 21:45:14 -0000\r\n\r\nHi Esko,\n\nOn Mon, Sep 13, 2010 at 12:18 PM, Esko Luontola &lt;esko.luontola@gm=\r\nail.com&gt; wrote:\n&gt;&gt; =A0&gt; In terms of IDE integration, JUnit just reports a t=\r\nree of\n&gt;&gt; =A0&gt; Descriptions, and results against them. Runners are free to =\r\nstructure\n&gt;&gt; =A0&gt; these trees however they wish. Have you run into IDE limi=\r\ntations for\n&gt;&gt; =A0&gt; displaying/interacting with these trees?\n&gt;&gt; =A0&gt;\n&gt;&gt; I w=\r\nould question the need for nesting tests. I can easily see the benefit\n&gt;&gt; o=\r\nf nesting closures in test code. Several traits in ScalaTest do that, but\n&gt;=\r\n&gt; the model I use in ScalaTest is that each leaf node is one test. The\n&gt;&gt; c=\r\nlosures surrounding the leaf nodes are descriptions, not tests themselves.\n=\r\n&gt;&gt; I would think you and Eric could adopt that approach in Specs and Specsy=\r\n\n&gt;&gt; without much trouble.\n&gt;\n&gt; It would be possible for me to detect the lea=\r\nf nodes after the tests\n&gt; have been run, but I prefer the UI to show the co=\r\nrrect mental model of\n&gt; what is happening during test runs.\n&gt;\n&gt; To illustra=\r\nte, here is a partial version of one of Specsy&#39;s example\n&gt; specs with some =\r\nprintln() debug statements.\n&gt;\n&gt; @RunWith(classOf[Specsy])\n&gt; class StackSpec=\r\n extends Spec {\n&gt; =A0 val stack =3D new scala.collection.mutable.Stack[Stri=\r\nng]\n&gt; =A0 println(stack)\n&gt;\n&gt; =A0 &quot;When objects have been pushed onto a stac=\r\nk&quot; &gt;&gt; {\n&gt; =A0 =A0 stack.push(&quot;pushed first&quot;)\n&gt; =A0 =A0 stack.push(&quot;pushed l=\r\nast&quot;)\n&gt; =A0 =A0 println(stack)\n&gt;\n&gt; =A0 =A0 &quot;the object pushed last is poppe=\r\nd first&quot; &gt;&gt; {\n&gt; =A0 =A0 =A0 val poppedFirst =3D stack.pop()\n&gt; =A0 =A0 =A0 a=\r\nssertThat(poppedFirst, is(&quot;pushed last&quot;))\n&gt; =A0 =A0 =A0 println(stack)\n&gt; =\r\n=A0 =A0 }\n&gt; =A0 =A0 &quot;the object pushed first is popped last&quot; &gt;&gt; {\n&gt; =A0 =A0=\r\n =A0 stack.pop()\n&gt; =A0 =A0 =A0 val poppedLast =3D stack.pop()\n&gt; =A0 =A0 =A0=\r\n assertThat(poppedLast, is(&quot;pushed first&quot;))\n&gt; =A0 =A0 =A0 println(stack)\n&gt; =\r\n=A0 =A0 }\n&gt; =A0 }\n&gt; }\n&gt;\n&gt; To execute that, Specsy needs to instantiate and =\r\nrun the class two\n&gt; times. The first test run will print:\n&gt;\n&gt; Stack()\n&gt; Sta=\r\nck(pushed last, pushed first)\n&gt; Stack(pushed first)\n&gt;\n&gt; The second test run=\r\n will print:\n&gt;\n&gt; Stack()\n&gt; Stack(pushed last, pushed first)\n&gt; Stack()\n&gt;\n&gt; M=\r\ny vision is that the UI would visualize where one test ends and another\n&gt; b=\r\negins. It would provide the same information as the following examples\n&gt; (b=\r\nut better visualized ;).\n&gt;\n&gt; Test run 1:\n&gt;\n&gt; -- &lt;net.orfjackal.specsy.examp=\r\nles.StackSpec&gt;\n&gt; Stack()\n&gt; -- =A0 =A0 &lt;When objects have been pushed onto a=\r\n stack&gt;\n&gt; Stack(pushed last, pushed first)\n&gt; -- =A0 =A0 =A0 =A0 &lt;the object=\r\n pushed last is popped first&gt;\n&gt; Stack(pushed first)\n&gt; -- =A0 =A0 =A0 =A0 &lt;/=\r\nthe object pushed last is popped first&gt;\n&gt; -- =A0 =A0 &lt;/When objects have be=\r\nen pushed onto a stack&gt;\n&gt; -- &lt;/net.orfjackal.specsy.examples.StackSpec&gt;\n&gt;\n&gt;=\r\n Test run 2:\n&gt;\n&gt; -- &lt;net.orfjackal.specsy.examples.StackSpec&gt;\n&gt; Stack()\n&gt; -=\r\n- =A0 =A0 &lt;When objects have been pushed onto a stack&gt;\n&gt; Stack(pushed last,=\r\n pushed first)\n&gt; -- =A0 =A0 =A0 =A0 &lt;the object pushed first is popped last=\r\n&gt;\n&gt; Stack()\n&gt; -- =A0 =A0 =A0 =A0 &lt;/the object pushed first is popped last&gt;\n=\r\n&gt; -- =A0 =A0 &lt;/When objects have been pushed onto a stack&gt;\n&gt; -- &lt;/net.orfja=\r\nckal.specsy.examples.StackSpec&gt;\n&gt;\n&gt; Then when I select &quot;StackSpec&quot; or &quot;When=\r\n objects have been pushed onto a\n&gt; stack&quot; in the tree of tests shown by the=\r\n UI, it would show both of those\n&gt; test runs, because those tests were incl=\r\nuded in both of them. But if I\n&gt; select &quot;the object pushed last is popped f=\r\nirst&quot; then it will show only\n&gt; test run 1, and if I select &quot;the object push=\r\ned first is popped last&quot; it\n&gt; will show only test run 2.\n&gt;\nWhat you say you=\r\n want here makes sense. My point is that it doesn&#39;t\nrequire nested tests. Y=\r\nou can do it with nested descriptions. That&#39;s\nthe approach I take in ScalaT=\r\nest. In ScalaTest the test names for\nStackSpec two tests would be:\n\nWhen ob=\r\njects have been pushed onto a stack the object pushed last is\npopped first\n=\r\nWhen objects have been pushed onto a stack the object pushed first is\npoppe=\r\nd last\n\nBut when you run it through ScalaTest&#39;s standard out reporter, for\n=\r\nexample, the output would look something like:\n\nStackSpec:\nWhen objects hav=\r\ne been pushed onto a stack\n- the object pushed first is popped last\n- the o=\r\nbject pushed first is popped last\n\nThe output looks like a specification. T=\r\nhe number of tests here is 2,\nnot 3, because the outer closure is not a tes=\r\nt with two tests inside\nit but a description clause with two tests inside i=\r\nt. You could write\na reporter that shows these specification-style results =\r\nas a tree that\ncan have the various branches opened and closed, which is I =\r\nthink what\nyou&#39;re really after.\n\nTo me conceptually it is fuzzy to say you =\r\ncan nest a test inside\nanother test. If an inner test fails, does that mean=\r\n all the enclosing\nouter tests fail too? It isn&#39;t clear.\n\nThe other thing I=\r\n heard you mention as a deficiency in JUnit&#39;s runner\nis that tests need to =\r\nhave unique names. (I&#39;m not sure that&#39;s true of\nJUnit but I&#39;ll take your wo=\r\nrk on it.) ScalaTest&#39;s runner does not\nrequire that tests have unique names=\r\n, but Suite does. The reason is it\nallows you to run just one test by provi=\r\nding its name. So while I\nthink the runner needn&#39;t have this requirement, I=\r\n think it is useful\nto ask a suite of tests to run just one test, and a uni=\r\nque name\nrequirement facilitates that.\n\nBill\n----\nBill Venners\nArtima, Inc.=\r\n\nhttp://www.artima.com\n\n", 
    "profile": "billvenners", 
    "topicId": 22933, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 416990097, 
    "prevInTime": 22937, 
    "contentTrasformed": false, 
    "postDate": "1284407950", 
    "canDelete": false, 
    "nextInTopic": 22939, 
    "prevInTopic": 22937, 
    "headers": {
        "inReplyToHeader": "PDRDOEU3OTFELjUwNDA3MDRAZ21haWwuY29tPg==", 
        "messageIdInHeader": "PEFBTkxrVGlrOGhDUmdyQXZLV3BlZ0w4QmgrX1FSWXYtYzUzWS1uUE84NVFoMEBtYWlsLmdtYWlsLmNvbT4=", 
        "referencesHeader": "PDRDOEJGREU3LjMwMTA2MDNAZ21haWwuY29tPgk8QUFOTGtUaW40QVhrOEJHY2JYR2ZtNjhLUUZ6THFiVnprK20yMkNyY1VnUnQxQG1haWwuZ21haWwuY29tPgk8QUFOTGtUaW0xMU9STzY4aXJGaEhyVkNCdnFIOHZLOUJRRzI2d2lVeFdkOVpkQG1haWwuZ21haWwuY29tPgk8NEM4RTc5MUQuNTA0MDcwNEBnbWFpbC5jb20+"
    }
}