{
    "numMessagesInTopic": 20, 
    "nextInTime": 23955, 
    "senderId": "Uikn7QB8kAzu6tnGLEG67hcbeMLvB6KLUHZp847X2q05GzxZHRkQ3AOi3iUofIjtF7sSIyeXdzNwEvcCi_9uIQKmZQF0rwns8g", 
    "systemMessage": false, 
    "subject": "Re: Feedback Required | Extending Junit to perform Data Driven Testing", 
    "from": "&quot;Anuj&quot; &lt;anujkumar1516@...&gt;", 
    "authorName": "Anuj", 
    "msgSnippet": "Hi Matthew, Sorry for replying late. I was caught up in a lot of other stuff. I saw the proposal for @DataProvider and it looks a good start, but IMHO it might", 
    "msgId": 23954, 
    "profile": "anujkumar1516", 
    "topicId": 23950, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 353028991, 
    "messageBody": "<div id=\"ygrps-yiv-577073532\">Hi Matthew,<br/>\nSorry for replying late. I was caught up in a lot of other stuff.<br/>\nI saw the proposal for @DataProvider and it looks a good start, but IMHO it might not turn out to be a great one. Here are some reasons why I feel such apprehension:<br/>\n<br/>\n1)The annotation currently is applied per method, which means that if there is a single class providing the input test data for 10 test methods, the user has to apply the annotation over each test method. This seems undesirable as it promotes duplicacy within the test class. Moreover, running each test method would mean extra processing, which can be avoided by making the annotation support ElementType.TYPE as well. I have a similar annotation(@DataLoader)in my test framework, EasyTest that supports such a behavior.(<a rel=\"nofollow\" target=\"_blank\" href=\"https://github.com/anujgandharv/easytest/blob/master/src/main/java/org/easytest/annotation/DataLoader.java)\">https://github.com/anujgandharv/easytest/blob/master/src/main/java/org/easytest/annotation/DataLoader.java)</a><br/>\n<br/>\n2)It is not clear from the discussion which JUnit Runner will support this annotation: Parameterized or Theories or there would be a new Runner.<br/>\n<br/>\n3)It would be nice if we give some sense of direction to the user regarding the structure of DataProviderClass and the method it supports. So, something like :<br/>\n<br/>\nClass&lt;? extends Provider&gt; dataProviderClass() default EmptyProvider.class;<br/>\n<br/>\n3)I somehow get the feeling(and it could be simply me and if that is the case, please ignore me) that the aspect of performing Data Driven Testing should be given more time, and proper thought should be put in around its design and the way it will be made available to the end users. I feel we should not rush into developing a feature focusing a single use case/requirement, rather we should try to first gather and understand all the aspects of Data Driven Testing and then develop that requirement as a whole rather than in pieces.<br/>\n<br/>\nI would be much more beneficial to the community as a whole.<br/>\n<br/>\nThanks,<br/>\n Anuj<br/>\n<br/>\n<blockquote><span title=\"qreply\"> --- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>, Matthew Farwell &lt;matthew@...&gt; wrote:<br/>\n&gt;<br/>\n&gt; Hello,<br/>\n&gt; <br/>\n&gt; Sorry this took so long to get back to you, but I was trying to get my<br/>\n&gt; thoughts together.<br/>\n&gt; <br/>\n&gt; I don&#39;t believe that the suggestion below fits in with the current JUnit<br/>\n&gt; philospohy, so doesn&#39;t belong in the junit core library. Specifically, I<br/>\n&gt; don&#39;t think CSV/Excel/XML parsing belongs in JUnit, so I agree with your<br/>\n&gt; decision to write it as an extension rather than as part of junit core.<br/>\n&gt; <br/>\n&gt; However, I do believe that we can add stuff to JUnit core in order to allow<br/>\n&gt; people to do this sort of thing more easily, and maybe help you with your<br/>\n&gt; code as well.<br/>\n&gt; <br/>\n&gt; I often have the following problem: I&#39;ve got a class Foo in which I&#39;m<br/>\n&gt; testing multiple methods (foo#addInts & foo#addStrings). So I create a<br/>\n&gt; single class to test the two. But if either of these methods are better<br/>\n&gt; tested using parameterized, then I can&#39;t do it because I have to define the<br/>\n&gt; constructor. So, what I would propose is to have a @DataProvider annotation<br/>\n&gt; which specifies a method to call which returns a collection of data for<br/>\n&gt; this particular method. The test method is called for each item in the<br/>\n&gt; list. See <a rel=\"nofollow\" target=\"_blank\" href=\"https://gist.github.com/3471426\">https://gist.github.com/3471426</a> for a short proposal. I think<br/>\n&gt; this would be fairly easy to do.<br/>\n&gt; <br/>\n&gt; I also think this would be extensible in another framework, specifically in<br/>\n&gt; your case. All you should have to do is extend the @DataParameter so that<br/>\n&gt; the data comes from another source. Again, see the gist, you&#39;d just have to<br/>\n&gt; specify a dataProviderClass.<br/>\n&gt; <br/>\n&gt; What do people think of this idea, and what do you (anuj) think also?<br/>\n&gt; <br/>\n&gt; Thanks.<br/>\n&gt; <br/>\n&gt; Matthew Farwell.<br/>\n&gt; <br/>\n&gt; 2012/8/21 Anuj &lt;anujkumar1516@...&gt;<br/>\n&gt; <br/>\n&gt; &gt; **<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt; Looks like the formatting of the above message got out of hands. So here&#39;s<br/>\n&gt; &gt; one more try ondifferent things that can be achieved with the new extension:<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt; CASE 1: Specify test data in the form of CSV file. You can choose the type<br/>\n&gt; &gt; of file containing the data:(CSV,EXCEL,XML or CUSTOM)<br/>\n&gt; &gt;<br/>\n&gt; &gt; @Theory@TestData(filePaths = { &quot;getTestData.csv&quot; }, fileType =<br/>\n&gt; &gt; FileType.CSV) //This is new annotation definedpublic void<br/>\n&gt; &gt; testGetItems(@DataProvider()Map&lt;String, String&gt; inputData) {<br/>\n&gt; &gt; .....# The Map corresponds to a single row of test data in the CSV file.<br/>\n&gt; &gt; }<br/>\n&gt; &gt;<br/>\n&gt; &gt; CASE 2: Gives user flexibility to provide its own custom loader, in case<br/>\n&gt; &gt; the framework does not support the data file :<br/>\n&gt; &gt;<br/>\n&gt; &gt; @Theory<br/>\n&gt; &gt; @TestData(filePaths = { &quot;getItemsData.dat&quot; }, fileType = FileType.CUSTOM)<br/>\n&gt; &gt; @CustomLoader(loader = MyDataLoader.class)<br/>\n&gt; &gt; public void testWithCustomLoader(@DataProvider()Map&lt;String, String&gt;<br/>\n&gt; &gt; inputData) {<br/>\n&gt; &gt; # The Map corresponds to a single row of test data in the .dat file.<br/>\n&gt; &gt; }<br/>\n&gt; &gt;<br/>\n&gt; &gt; CASE 3: Auto detects and populates user defined objects:<br/>\n&gt; &gt;<br/>\n&gt; &gt; @Theory<br/>\n&gt; &gt; @TestData(filePaths = { &quot;getItemsData.csv&quot; })<br/>\n&gt; &gt; public void testWithStrongParameters(@DataProvider()LibraryId id ,<br/>\n&gt; &gt; @DataProvider(paramName=&quot;itemid&quot;) ItemId itemId) {<br/>\n&gt; &gt; # DataProvide annotation tells the framework that the parameter&#39;s value<br/>\n&gt; &gt; should be provided by the framework. It can also take an optional paramName<br/>\n&gt; &gt; which gives more control over the data to the user.<br/>\n&gt; &gt; }<br/>\n&gt; &gt;<br/>\n&gt; &gt; OR<br/>\n&gt; &gt;<br/>\n&gt; &gt; @Theory<br/>\n&gt; &gt; @TestData(filePaths = { &quot;getItemsData.csv&quot; })<br/>\n&gt; &gt; public void testConverter(@DataProvider() Item item){<br/>\n&gt; &gt; Assert.assertNotNull(item);<br/>\n&gt; &gt; System.out.println(item.getDescription() + item.getItemId() +<br/>\n&gt; &gt; item.getItemType());<br/>\n&gt; &gt; }<br/>\n&gt; &gt;<br/>\n&gt; &gt; Hopefully the format will remain this time.<br/>\n&gt; &gt;<br/>\n&gt; &gt; Cheers!<br/>\n&gt; &gt; Anuj<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt; --- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>, &quot;Anuj&quot; &lt;anujkumar1516@&gt; wrote:<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; Hi, I am looking for some feedback into my work of extending JUnit&#39;s<br/>\n&gt; &gt; &gt; capability to perform Data Driven Testing using annotations.You can find<br/>\n&gt; &gt; &gt; the source code here :<br/>\n&gt; &gt; &gt; <a rel=\"nofollow\" target=\"_blank\" href=\"https://github.com/anujgandharv/junit-theories-ext/\">https://github.com/anujgandharv/junit-theories-ext/</a><br/>\n&gt; &gt; &gt; &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"https://github.com/anujgandharv/junit-theories-ext/\">https://github.com/anujgandharv/junit-theories-ext/</a>&gt;<br/>\n&gt; &gt; &gt; Please enter any suggestions/improvements/requests to the GitHub<br/>\n&gt; &gt; &gt; repository or main me directly at anuj.gandharv@<br/>\n&gt; &gt;<br/>\n&gt; &gt; &gt; These are some of the extensions to the existing JUnit Theories runner :<br/>\n&gt; &gt; &gt; CASE 1: Specify test data in the form of CSV file. You can choose the<br/>\n&gt; &gt; &gt; type of file containing the data:(CSV,EXCEL,XML or CUSTOM)<br/>\n&gt; &gt; &gt; @Theory@TestData(filePaths = { &quot;getTestData.csv&quot; }, fileType =<br/>\n&gt; &gt; &gt; FileType.CSV) //This is new annotation definedpublic void<br/>\n&gt; &gt; &gt; testGetItems(@DataProvider()Map&lt;String, String&gt; inputData) {<br/>\n&gt; &gt; &gt; .....# The Map corresponds to a single row of test data in the CSV<br/>\n&gt; &gt; &gt; file.<br/>\n&gt; &gt; &gt; }<br/>\n&gt; &gt; &gt; CASE 2: Gives user flexibility to provide its own custom loader, in case<br/>\n&gt; &gt; &gt; the framework does not support the data file :<br/>\n&gt; &gt; &gt; @Theory@TestData(filePaths = { &quot;getItemsData.dat&quot; }, fileType =<br/>\n&gt; &gt; &gt; FileType.CUSTOM)@CustomLoader(loader = MyDataLoader.class)public void<br/>\n&gt; &gt; &gt; testWithCustomLoader(@DataProvider()Map&lt;String, String&gt; inputData) {<br/>\n&gt; &gt; &gt; # The Map corresponds to a single row of test data in the .dat file.<br/>\n&gt; &gt; &gt; }<br/>\n&gt; &gt; &gt; CASE 3: Auto detects and populates user defined objects:<br/>\n&gt; &gt; &gt; @Theory@TestData(filePaths = { &quot;getItemsData.csv&quot; })public void<br/>\n&gt; &gt; &gt; testWithStrongParameters(@DataProvider()LibraryId id ,<br/>\n&gt; &gt; &gt; @DataProvider(paramName=&quot;itemid&quot;) ItemId itemId) { # DataProvide<br/>\n&gt; &gt; &gt; annotation tells the framework that the parameter&#39;s value should be<br/>\n&gt; &gt; &gt; provided by the framework. It can also take an optional paramName<br/>\n&gt; &gt; &gt; which gives more control over the data to the user.<br/>\n&gt; &gt; &gt; }<br/>\n&gt; &gt; &gt; OR<br/>\n&gt; &gt; &gt; @Theory@TestData(filePaths = { &quot;getItemsData.csv&quot; })public void<br/>\n&gt; &gt; &gt; testConverter(@DataProvider() Item item){ Assert.assertNotNull(item);<br/>\n&gt; &gt; &gt; System.out.println(item.getDescription() + item.getItemId() +<br/>\n&gt; &gt; &gt; item.getItemType());<br/>\n&gt; &gt; &gt; }<br/>\n&gt; &gt; &gt; As specified above, you can find the source code here :<br/>\n&gt; &gt; &gt; <a rel=\"nofollow\" target=\"_blank\" href=\"https://github.com/anujgandharv/junit-theories-ext/\">https://github.com/anujgandharv/junit-theories-ext/</a><br/>\n&gt; &gt; &gt; &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"https://github.com/anujgandharv/junit-theories-ext/\">https://github.com/anujgandharv/junit-theories-ext/</a>&gt;<br/>\n&gt; &gt; &gt; Please enter any suggestions/improvements/requests to the GitHub<br/>\n&gt; &gt; &gt; repository or main me directly at anuj.gandharv@<br/>\n&gt; &gt;<br/>\n&gt; &gt; &gt; Thanks, Anuj<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; [Non-text portions of this message have been removed]<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt;  <br/>\n&gt; &gt;<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; [Non-text portions of this message have been removed]<br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 23953, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1346144025", 
    "canDelete": false, 
    "nextInTopic": 23955, 
    "prevInTopic": 23953, 
    "headers": {
        "inReplyToHeader": "PENBT0Jrb0ZVM010QXdTVDdfU3FZa3JmUU1uRWJKVXBQaS1GWmVOaVlkLUUxSy0rXzF5d0BtYWlsLmdtYWlsLmNvbT4=", 
        "messageIdInHeader": "PGsxaTB1cCtnMGRwQGVHcm91cHMuY29tPg=="
    }
}