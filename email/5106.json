{
    "numMessagesInTopic": 9, 
    "nextInTime": 5107, 
    "senderId": "W0ljcpYs1qKIGFLMhzerS4l-2BCdjyroSUBbRQIEXmTxgjra9yLv4u9A24zKQB7G40GsPjSMghEFRkPHhI2BwpBOZK3C3AFirg", 
    "systemMessage": false, 
    "subject": "Re: [junit] Re: Testing accessors...", 
    "from": "&quot;Alexander Zynevich&quot; &lt;java@...&gt;", 
    "authorName": "Alexander Zynevich", 
    "msgSnippet": "Sirs, I am sorry in advance that I may repeat something/somebody... I think this is important point and it is also possible to be added to FAQ: many", 
    "msgId": 5106, 
    "topicId": 5102, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 106886324, 
    "messageBody": "<div id=\"ygrps-yiv-1807375888\">Sirs,<br/>\nI am sorry in advance that I may repeat something/somebody...<br/>\n<br/>\nI think this is important point and it is also possible to be added to FAQ:<br/>\n<br/>\nmany programmers writes setters in following style (let&#39;s call it IBM-style)<br/>\n<br/>\nvoid setValue(ValueType newValue)<br/>\n{<br/>\n  value=newValue;<br/>\n}<br/>\n<br/>\nwhile others preffer to do it in Sun-style:<br/>\n<br/>\nvoid setValue(ValueType value)<br/>\n{<br/>\n  this.value=value;<br/>\n}<br/>\n<br/>\nnow just imagine that while edditing your code you just pressed &quot;del&quot; key in<br/>\n&quot;void setValue(ValueType value)&quot; or made other typing mistake and got &quot;void<br/>\nsetValue(ValueType vale)&quot;<br/>\nin this case code will compile BUT &quot;this.value=value;&quot; will be equivalent to<br/>\n&quot;this.value=this.value;&quot;<br/>\nsome times such errors are very hard to find it out... If you have special<br/>\ntest case for set/get you will find problem within seconds if not you will<br/>\nfind problem only because other tests are failed...<br/>\n<br/>\nSorry, for beating the air...<br/>\n<br/>\nAlexander<br/>\n<br/>\n<blockquote><span title=\"qreply\"> ----- Original Message -----<br/>\nFrom: &quot;Mike Clark&quot; &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:mike@...\">mike@...</a>&gt;<br/>\nTo: &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>&gt;<br/>\nSent: Wednesday, June 05, 2002 4:39 PM<br/>\nSubject: [junit] Re: Testing accessors...<br/>\n<br/>\n<br/>\n&gt; I&#39;ve added J.B.&#39;s response below to the FAQ under the question &quot;Under<br/>\n&gt; what conditions should I not test get() and set() methods?&quot;.<br/>\n&gt;<br/>\n&gt; I also added an alternative view that goes something like this:<br/>\n&gt;<br/>\n&gt; ----<br/>\n&gt;<br/>\n&gt; Under what conditions should I test get() and set() methods?<br/>\n&gt;<br/>\n&gt; In general, unit tests are meant to alleviate fear that something might<br/>\n&gt; break. If a get() or set() method could reasonably break, or has in fact<br/>\n&gt; contributed to a defect, then by all means write a test for them. Be<br/>\n&gt; practical and remember to maximize your testing investment.<br/>\n&gt;<br/>\n&gt; Refer also to &quot;How simple is &#39;too simple to break&#39;?<br/>\n&gt;<br/>\n&gt; ----<br/>\n&gt;<br/>\n&gt; If there are viewpoints not represented in these entries, please feel<br/>\n&gt; free to contribute.  Perhaps we can defer all related questions to the<br/>\n&gt; FAQ in the near future.<br/>\n&gt;<br/>\n&gt; Mike<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; J. B. Rainsberger wrote:<br/>\n&gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt;Most of the time, get/set methods just can&#39;t break, and if they can&#39;t<br/>\nbreak,<br/>\n&gt; &gt;then why test them? While it is usually better to test more, there is a<br/>\n&gt; &gt;definite curve of diminishing returns on test effort versus &quot;code<br/>\ncoverage&quot;.<br/>\n&gt; &gt;Remember the maxim: &quot;Test until fear turns to boredom.&quot;<br/>\n&gt; &gt;<br/>\n&gt; &gt;Assume that the getX() method only does &quot;return x;&quot; and that the setX()<br/>\n&gt; &gt;method only does &quot;this.x = x;&quot;. If you write this test<br/>\n&gt; &gt;<br/>\n&gt; &gt;    testGetSetX() {<br/>\n&gt; &gt;        setX(23);<br/>\n&gt; &gt;        assertEquals(23, getX());<br/>\n&gt; &gt;    }<br/>\n&gt; &gt;<br/>\n&gt; &gt;then you are testing the equivalent of the following:<br/>\n&gt; &gt;<br/>\n&gt; &gt;    testGetSetX() {<br/>\n&gt; &gt;        x = 23;<br/>\n&gt; &gt;        assertEquals(23, x);<br/>\n&gt; &gt;    }<br/>\n&gt; &gt;<br/>\n&gt; &gt;or, if you prefer,<br/>\n&gt; &gt;<br/>\n&gt; &gt;    testGetSetX() {<br/>\n&gt; &gt;        assertEquals(23, 23);<br/>\n&gt; &gt;    }<br/>\n&gt; &gt;<br/>\n&gt; &gt;At this point, you are testing the Java compiler, or possibly the<br/>\n&gt; &gt;interpreter, and not your component or application. There is generally no<br/>\n&gt; &gt;need for you to do Java&#39;s testing for them.<br/>\n&gt; &gt;<br/>\n&gt; &gt;If you are concerned about whether a property has already been set at the<br/>\n&gt; &gt;point you wish to call getX(), then you want to test the constructor, and<br/>\nnot<br/>\n&gt; &gt;the getX() method. This kind of test is especially useful if you have<br/>\n&gt; &gt;multiple constructors.<br/>\n&gt; &gt;<br/>\n&gt; &gt;    testCreate() {<br/>\n&gt; &gt;        assertEquals(23, new MyClass(23).getX());<br/>\n&gt; &gt;    }<br/>\n&gt; &gt;<br/>\n&gt; &gt;&gt;    Under what conditions should I test get() and set() methods?<br/>\n&gt; &gt;&gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt;See &quot;How simple is &#39;too simple to break?&#39;&quot;<br/>\n&gt; &gt;<br/>\n&gt; &gt;[Later on...]<br/>\n&gt; &gt;<br/>\n&gt; &gt;Q. How simple is &#39;too simple to break?&#39;<br/>\n&gt; &gt;<br/>\n&gt; &gt;The general philosophy is this: if it can&#39;t break *on its own*, it&#39;s too<br/>\n&gt; &gt;simple to break.<br/>\n&gt; &gt;<br/>\n&gt; &gt;First example is the getX() method. Suppose the getX() method only<br/>\nanswers<br/>\n&gt; &gt;the value of an instance variable. In that case, getX() cannot break<br/>\nunless<br/>\n&gt; &gt;either the compiler or the interpreter is also broken. For that reason,<br/>\ndon&#39;t<br/>\n&gt; &gt;test getX(); there is no benefit. The same is true of the setX() method,<br/>\n&gt; &gt;although if your setX() method does any parameter validation or has any<br/>\nside<br/>\n&gt; &gt;effects, you likely need to test it.<br/>\n&gt; &gt;<br/>\n&gt; &gt;Next example: suppose you have written a method that does nothing but<br/>\nforward<br/>\n&gt; &gt;parameters into a method called on another object. That method is too<br/>\nsimple<br/>\n&gt; &gt;to break.<br/>\n&gt; &gt;<br/>\n&gt; &gt;    public void myMethod(final int a, final String b) {<br/>\n&gt; &gt;        myCollaborator.anotherMethod(a, b);<br/>\n&gt; &gt;    }<br/>\n&gt; &gt;<br/>\n&gt; &gt;myMethod cannot possibly break, because it does nothing: it forwards its<br/>\n&gt; &gt;input to another object and that&#39;s all.<br/>\n&gt; &gt;<br/>\n&gt; &gt;The only precondition for this method is &quot;myCollaborator != null&quot;, but<br/>\nthat<br/>\n&gt; &gt;is generally the responsibility of the constructor, and not of myMethod.<br/>\nIf<br/>\n&gt; &gt;you are concerned, add a test to verify that myCollaborator is always set<br/>\nto<br/>\n&gt; &gt;something non-null by every constructor.<br/>\n&gt; &gt;<br/>\n&gt; &gt;The only way myMethod could break would be if<br/>\nmyCollaborator#anotherMethod<br/>\n&gt; &gt;were broken. In that case, test myCollaborator, and not the current<br/>\nclass.<br/>\n&gt; &gt;<br/>\n&gt; &gt;It is true that adding tests for even these simple methods guards against<br/>\nthe<br/>\n&gt; &gt;possibility that someone refactors and makes the methods &quot;not-so-simple&quot;<br/>\n&gt; &gt;anymore. In that case, though, the refactorer needs to be aware that the<br/>\n&gt; &gt;method is now complex enough to break, and should write tests for it --<br/>\nand<br/>\n&gt; &gt;preferably before the refactoring.<br/>\n&gt; &gt;<br/>\n&gt; &gt;Another example: suppose you have a JSP and, like a good programmer, you<br/>\nhave<br/>\n&gt; &gt;removed all business logic from it. All it does is provide a layout for a<br/>\n&gt; &gt;number of JavaBeans and never does anything that could change the value<br/>\nof<br/>\n&gt; &gt;any object. That JSP is too simple to break, and since JSPs are<br/>\nnotoriously<br/>\n&gt; &gt;annoying to test, you should strive to make all your JSPs too simple to<br/>\nbreak.<br/>\n&gt; &gt;<br/>\n&gt; &gt;--<br/>\n&gt; &gt;J. B. Rainsberger,<br/>\n&gt; &gt;President, Diaspar Software Services<br/>\n&gt; &gt;Let&#39;s write software that people understand.<br/>\n&gt; &gt;<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.diasparsoftware.com/\">http://www.diasparsoftware.com/</a><br/>\n&gt; &gt;telephone: +1 416 791-8603<br/>\n&gt; &gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; [Non-text portions of this message have been removed]<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; To unsubscribe from this group, send an email to:<br/>\n&gt; <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit-unsubscribe@yahoogroups.com\">junit-unsubscribe@yahoogroups.com</a><br/>\n&gt;<br/>\n&gt;<br/>\n&gt; Your use of Yahoo! Groups is subject to <a rel=\"nofollow\" target=\"_blank\" href=\"http://docs.yahoo.com/info/terms/\">http://docs.yahoo.com/info/terms/</a><br/>\n&gt;<br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 5105, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1023287696", 
    "canDelete": false, 
    "nextInTopic": 5110, 
    "prevInTopic": 5102, 
    "headers": {
        "messageIdInHeader": "PDAwYjIwMWMyMGM5ZSQyZmQzMDVjMCRkYWJlYThjMEB6eW5ldmljaD4=", 
        "referencesHeader": "PDFBQTY5NzFGOTZGQURCNEE5NkNGNzNFNDcyOUIwNUYxNTVFNUJEQFVTRVZTMDEyLmxlaW50ZXJuYWwuY29tPiA8MjAwMjA2MDQxMDQ5NTEuTTI0ODMxQGRpYXNwYXJzb2Z0d2FyZS5jb20+IDwzQ0ZDRjBDMi4yMDMwMjA3QGNsYXJrd2FyZS5jb20+IDwyMDAyMDYwNDEyNDUzNy5NNTkyMDdAZGlhc3BhcnNvZnR3YXJlLmNvbT4gPDNDRkUxNDgzLjcwOTAyQGNsYXJrd2FyZS5jb20+"
    }
}