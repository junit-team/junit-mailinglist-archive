{
    "numMessagesInTopic": 7, 
    "nextInTime": 23364, 
    "senderId": "jERXLMO4-Yj8Rr8deJA54q4QX3cqKp3Sdh_oc3rq__L0WgCGYsMhXlikmtjlrLa7sjAnfMtGOAe2MkKYqfaSD684RdUh", 
    "systemMessage": true, 
    "subject": "Re: Unit Testing best practices", 
    "from": "&quot;Daniel&quot; &lt;dtoffe@...&gt;", 
    "authorName": "Daniel", 
    "msgSnippet": "Hi, Henrik, your answer is very complete and well thought, but right now I m doing just small personal projects and practice exercises for a course I m taking,", 
    "msgId": 23363, 
    "profile": "dtoffe", 
    "topicId": 23330, 
    "spamInfo": {
        "reason": "6", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 85419192, 
    "messageBody": "<div id=\"ygrps-yiv-700673405\">Hi,<br/>\n<br/>\n    Henrik, your answer is very complete and well thought, but right now I&#39;m doing just small personal projects and practice exercises for a course I&#39;m taking, I think that much level of detail is a bit overkill for my needs.<br/>\n<br/>\nThanks you !!<br/>\n<br/>\nDaniel<br/>\n<br/>\n<blockquote><span title=\"qreply\"> --- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>, &quot;hkaipe&quot; &lt;hkaipe@...&gt; wrote:<br/>\n&gt;<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; <br/>\n&gt; <br/>\n&gt; <br/>\n&gt; Hi Daniel<br/>\n&gt; <br/>\n&gt; I think you are right on track when you recognize that &quot;validations on the input parameters, providing defaults if the parameters are not valid&quot; will make &quot;the number of testing methods&quot; skyrocket quickly when you want to &quot;test all variations of invalid input on all three constructors&quot;.<br/>\n&gt; <br/>\n&gt; During the past ten years I have spent some time thinking over similar problems myself and the fruit is a JUnit-extension for parameterized tests - CallbackParams <a rel=\"nofollow\" target=\"_blank\" href=\"http://callbackparams.org\">http://callbackparams.org</a> - that I released as open-source a couple of months ago. When using CallbackParams for your Account example - a &quot;best practice&quot; could be ...<br/>\n&gt;  ... one test-class per constructor (similar to David&#39;s suggestion)<br/>\n&gt;  ... one enum(!) per constructor parameter (e.g. enum AccountId / enum OwnerName / enum Balance)<br/>\n&gt;  ... one enum-constant for each value you would like to test<br/>\n&gt; <br/>\n&gt; To demonstrate this I have made the class &quot;TestAccount&quot;, which is committed to the svn-repo:<br/>\n&gt; <a rel=\"nofollow\" target=\"_blank\" href=\"http://callbackparams.svn.sourceforge.net/viewvc/callbackparams/trunk/junit4-tests/src/test/java/org/callbackparams/demo/TestAccount.java?revision=18&view=markup\">http://callbackparams.svn.sourceforge.net/viewvc/callbackparams/trunk/junit4-tests/src/test/java/org/callbackparams/demo/TestAccount.java?revision=18&view=markup</a><br/>\n&gt; <br/>\n&gt; The test uses BddRunner (one of two JUnit-runner offered by CallbackParams) and has this general structure:<br/>\n&gt; <br/>\n&gt; @RunWith(Suite.class)<br/>\n&gt; @...({<br/>\n&gt;  \tTestAccount.Constructor_1.class,<br/>\n&gt;  \tTestAccount.Constructor_2.class,<br/>\n&gt;  \tTestAccount.Constructor_3.class})<br/>\n&gt; public class TestAccount {<br/>\n&gt; <br/>\n&gt;     @Retention(RetentionPolicy.RUNTIME)<br/>\n&gt;     @interface ValidationFailure {String value();}<br/>\n&gt; <br/>\n&gt; <br/>\n&gt;     @RunWith(BddRunner.class)<br/>\n&gt;     @CombineConfig(strategy=CombineCompletely.class)<br/>\n&gt;     public static class Constructor_1 {<br/>\n&gt;         Account account;<br/>\n&gt;         String accountIdConstructorArg;<br/>\n&gt;         ...<br/>\n&gt;         @When void createAccount() {<br/>\n&gt;             account = new Account(accountIdConstructorArg);<br/>\n&gt;         }<br/>\n&gt; <br/>\n&gt; \t@Then void verifyDefaults() {...}<br/>\n&gt; <br/>\n&gt;         enum AccountId {<br/>\n&gt;             @ValidationFailure(...) ACCOUNT_ID_NULL(null),<br/>\n&gt;             @ValidationFailure(...) ACCOUNT_ID_EMPTY(&quot;&quot;),<br/>\n&gt;             ACCOUNT_ID_VALID(&quot;123456789-0&quot;),<br/>\n&gt;             @ValidationFailure(...) ACCOUNT_ID_INVALID(&quot;HM?&quot;);<br/>\n&gt;             ...<br/>\n&gt;             @Given void setupAccountIdConstructorArg(Constructor_1 test) {...}<br/>\n&gt;             @Then void verifyAccountId(Account account) {...}<br/>\n&gt;         }<br/>\n&gt;     }<br/>\n&gt; <br/>\n&gt; <br/>\n&gt;     public static class Constructor_2 extends Constructor_1 {<br/>\n&gt;         String ownerNameConstructorArg;<br/>\n&gt; <br/>\n&gt;         @When @Override void createAccount() {<br/>\n&gt;             account = new Account(accountIdConstructorArg, ownerNameConstructorArg);<br/>\n&gt;         }<br/>\n&gt; <br/>\n&gt;         @Then @Override void verifyDefaults() {...}<br/>\n&gt; <br/>\n&gt;         enum OwnerName {<br/>\n&gt;             ...<br/>\n&gt;             @Given void setupOwnerNameConstructorArg(Constructor_2 test) {...}<br/>\n&gt;             @Then void verifyOwnerName(Account account) {...}<br/>\n&gt;         }<br/>\n&gt;     }<br/>\n&gt; <br/>\n&gt; <br/>\n&gt;     public static class Constructor_3 extends Constructor_2 {<br/>\n&gt;         Double balanceConstructorArg;<br/>\n&gt;         ...<br/>\n&gt;         enum Balance {<br/>\n&gt;             ...<br/>\n&gt;         }<br/>\n&gt;     }<br/>\n&gt; }<br/>\n&gt; <br/>\n&gt; Unlike traditional parameterized tests the parameter values are not primitive - instead they are enum constants, which each has one @Given-method - for setting up the constructor argument that the enum class concerns - and one @Then-method - for verifying the resulting account. (There is no test-method that calls these methods - that is taken care of under-the-hood by BddRunner.) Please note that it is possible for individual enum-constants to override methods and this is what the constants OWNER_NULL and BALANCE_NULL do in order to verify that the null-argument results in the proper default value.<br/>\n&gt; <br/>\n&gt; My test-example has four constants per enum, i.e. there are four different values tested for each constructor parameter. Each test will pick exactly one enum-constant from each of its nested enum-classes. This means that Constructor_1 will produce four tests - one for each AccountId-constant. Constructor_2 produces 16 tests - one for each combination of OwnerName and AccountId, where the enum AccountId will be available since it is nested by the super-class! Thereafter Constructor_3 will produce one test for each possible combination of AccountId, OwnerName and Balance etc ... This will result in a total of 84 tests, which will be named like this:<br/>\n&gt; <br/>\n&gt; Test-class TestAccount$Constructor_1$BDD$ (4 tests)<br/>\n&gt;   test[ACCOUNT_ID_NULL]<br/>\n&gt;   test[ACCOUNT_ID_EMPTY]<br/>\n&gt;   test[ACCOUNT_ID_VALID]<br/>\n&gt;   test[ACCOUNT_ID_INVALID]<br/>\n&gt; <br/>\n&gt; Test-class TestAccount$Constructor_2$BDD$ (16 tests)<br/>\n&gt;   test[ACCOUNT_ID_NULL, OWNER_DEFAULT]<br/>\n&gt;   test[ACCOUNT_ID_NULL, OWNER_NULL]<br/>\n&gt;   test[ACCOUNT_ID_NULL, OWNER_VALID]<br/>\n&gt;   test[ACCOUNT_ID_NULL, OWNER_NAME_INVALID]<br/>\n&gt;   test[ACCOUNT_ID_EMPTY, OWNER_DEFAULT]<br/>\n&gt;   ...<br/>\n&gt;   test[ACCOUNT_ID_INVALID, OWNER_NAME_INVALID]<br/>\n&gt; <br/>\n&gt; Test-class TestAccount$Constructor_3$BDD$ - (64 tests)<br/>\n&gt;   test[ACCOUNT_ID_NULL, OWNER_DEFAULT, BALANCE_DEFAULT]<br/>\n&gt;   test[ACCOUNT_ID_NULL, OWNER_DEFAULT, BALANCE_NULL]<br/>\n&gt;   test[ACCOUNT_ID_NULL, OWNER_DEFAULT, BALANCE_10000]<br/>\n&gt;   test[ACCOUNT_ID_NULL, OWNER_DEFAULT, BALANCE_NEGATIVE]<br/>\n&gt;   test[ACCOUNT_ID_NULL, OWNER_NULL, BALANCE_DEFAULT]<br/>\n&gt;   ...<br/>\n&gt;   test[ACCOUNT_ID_INVALID, OWNER_NAME_INVALID, BALANCE_NEGATIVE]<br/>\n&gt; <br/>\n&gt; So instead of having &quot;one single thing in each unit test&quot; we now have ~one single thing in each enum-constant~ and no test-method. For the &quot;all variations of invalid input on all three constructors&quot;-thing - CallbackParams handles it by combining the enum-constants.<br/>\n&gt; <br/>\n&gt; I may be somewhat biased :-) but from how you describe your intentions I think CallbackParams is what fits your needs.<br/>\n&gt; <br/>\n&gt; For more information on BddRunner: <a rel=\"nofollow\" target=\"_blank\" href=\"http://callbackparams.org/part1-maintain.html#bdd\">http://callbackparams.org/part1-maintain.html#bdd</a><br/>\n&gt; <br/>\n&gt; The annotation @ValidationFailure is used to annotate each enum-constant that is expected to cause an exception. It is part of a Rule-based pattern that is further described here:<br/>\n&gt; <a rel=\"nofollow\" target=\"_blank\" href=\"http://callbackparams.org/part2-validate.html\">http://callbackparams.org/part2-validate.html</a><br/>\n&gt; <br/>\n&gt; Greetings<br/>\n&gt; /Henrik Kaipe<br/>\n&gt; <br/>\n&gt; --- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>, &quot;Daniel&quot; &lt;dtoffe@&gt; wrote:<br/>\n&gt; &gt;<br/>\n&gt; &gt; Hi all,<br/>\n&gt; &gt; <br/>\n&gt; &gt;     I&#39;m rather new to unit testing and after reading about best practices on the net and some attempts on my own, I still have doubts, hope this is a right place to ask.<br/>\n&gt; &gt;     Let&#39;s say I have an Account class with three fields, accountId, ownerName and balance. This class has three constructors:<br/>\n&gt; &gt; <br/>\n&gt; &gt; Account(String accountId)<br/>\n&gt; &gt; Account(String accountId, String ownerName)<br/>\n&gt; &gt; Account(String accountId, String ownerName, Double balance)<br/>\n&gt; &gt; <br/>\n&gt; &gt;     and these constructors have to do some validations on the input parameters, providing defaults if the parameters are not valid.<br/>\n&gt; &gt;     Now, let&#39;s say I want to test all variations of invalid input on all three constructors, for example:<br/>\n&gt; &gt; <br/>\n&gt; &gt; Account(null)<br/>\n&gt; &gt; Account(&quot;&quot;, null, 1575.0)<br/>\n&gt; &gt; <br/>\n&gt; &gt;     I&#39;ve learned that a best practice is to test one single thing in each unit test. If I write my test as.<br/>\n&gt; &gt; <br/>\n&gt; &gt; testConstructor1AccountIdNull<br/>\n&gt; &gt; testConstructor1AccountIdEmpty<br/>\n&gt; &gt; testConstructor1AccountIdExampleValue<br/>\n&gt; &gt; etc,<br/>\n&gt; &gt; <br/>\n&gt; &gt;     the number of testing methods skyrockets quickly.<br/>\n&gt; &gt;     So my question is, am I doing it wrong, is there any other simpler best practice to test all variations of input values ?<br/>\n&gt; &gt;     I&#39;ve seen the @Parameter annotation in JUnit 4.x, can I use it with multiple constructors and data sets in one unit testing class, or must I spread it into one class for each constructor and data array definition ?<br/>\n&gt; &gt; <br/>\n&gt; &gt; Thanks in advance,<br/>\n&gt; &gt; <br/>\n&gt; &gt; Daniel<br/>\n&gt; &gt;<br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 23362, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1301572374", 
    "canDelete": false, 
    "nextInTopic": 23376, 
    "prevInTopic": 23350, 
    "headers": {
        "inReplyToHeader": "PGltbm5ucSttaXU1QGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PGluMXB1bSs5ZXZiQGVHcm91cHMuY29tPg=="
    }
}