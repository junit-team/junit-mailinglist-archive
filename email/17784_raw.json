{
    "numMessagesInTopic": 287, 
    "nextInTime": 17785, 
    "senderId": "3z1Fw8-hRvRTOa3rOG8_Z-N4N9kjZL-c3Y-fqGt-hAxPZqa_IySdXmIbFISeuutMBiWUqqW0XSZdvMJN6X8TcSIvfXhjCUXEXvlv5hdVfOI", 
    "systemMessage": false, 
    "subject": "Re: Test-friendly, but not caller-friendly?", 
    "from": "Robert Martin &lt;UncleBob@...&gt;", 
    "authorName": "Robert Martin", 
    "msgSnippet": "... Sorry, sometimes I forget about Java s dumb rules about where you can have static methods and where you can t.  Anyway, this works in Java and amounts to", 
    "msgId": 17784, 
    "rawEmail": "Return-Path: &lt;unclebob@...&gt;\r\nX-Sender: unclebob@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (qmail 51529 invoked from network); 5 Sep 2006 00:56:04 -0000\r\nReceived: from unknown (66.218.66.217)\n  by m32.grp.scd.yahoo.com with QMQP; 5 Sep 2006 00:56:04 -0000\r\nReceived: from unknown (HELO cliff.objectmentor.com) (67.153.232.124)\n  by mta2.grp.scd.yahoo.com with SMTP; 5 Sep 2006 00:56:03 -0000\r\nReceived: from [192.168.1.3] ([::ffff:76.16.89.49])\n  (AUTH: LOGIN robertcmartin, SSL: TLSv1/SSLv3,128bits,RC4-SHA)\n  by cliff.objectmentor.com with esmtp; Mon, 04 Sep 2006 19:55:58 -0500\r\nMime-Version: 1.0 (Apple Message framework v752.2)\r\nTo: junit@yahoogroups.com\r\nMessage-Id: &lt;BCAADD39-3408-48F9-BFC5-AC6D06727C35@...&gt;\r\nDate: Mon, 4 Sep 2006 19:55:53 -0500\r\nX-Mailer: Apple Mail (2.752.2)\r\nX-eGroups-Msg-Info: 1:0:0:0\r\nFrom: Robert Martin &lt;UncleBob@...&gt;\r\nSubject: Re: Test-friendly, but not caller-friendly?\r\nX-Yahoo-Group-Post: member; u=85922638; y=MDkQJ86xv_Fnp1UJFKKbKhRype2VRjEdGP1IkpGx10K7Cgv7PQ\r\nX-Yahoo-Profile: rmartinoma\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\n\r\n\n&gt; Robert Martin wrote:\n&gt;\n&gt; &gt; It&#39;s not. Overuse of factories is an abomination. So *IF* I thought\n&gt; &gt; an interface would help, I would simply prefer:\n&gt; &gt;\n&gt; &gt; Document doc = Document.newDocument();\n&gt;\n&gt; But you can&#39;t do that with an interface. At a minimum you need\n&gt;\n&gt; Document doc = Factory.newDocument();\n\nSorry, sometimes I forget about Java&#39;s dumb rules about where you can  \nhave static methods and where you can&#39;t.  Anyway, this works in Java  \nand amounts to the same thing:\n\ninterface Document extends Cloneable {\n   public static Document prototype = null;\n   ...\n}\n\nDocument doc = Document.prototype.clone();\n\nMake sure &quot;main&quot; sets the Document.prototype variable to the  \nprototypical Document derivative.\n\n&gt;\n&gt; &gt; The simplicity of interfaces vs concrete classes comes from\n&gt; &gt; dependencies. Let&#39;s say we have some concrete class named\n&gt; &gt; MyDocument, and it has lots and lots of methods. Users of this class\n&gt; &gt; depend on all these methods even if they don&#39;t call them. If I make\n&gt; &gt; a change to MyDocument it can affect all the callers to the extent\n&gt; &gt; that they all have to be recompiled and redeployed. (Yes, you can\n&gt; &gt; play the game and try to figure out whether or not the class really\n&gt; &gt; and truly needs to be recompiled, but that way lay madness.)\n&gt;\n&gt; In Java, if the public interface of the class doesn&#39;t change, you  \n&gt; don;t\n&gt; need to recompile clients. In fact, even if you only add things to the\n&gt; public interface of the class, you don&#39;t need to recompile clients.\n\nNot quite true.  It is possible to add a method to the public  \ninterface of a java class that makes previous calls to similar  \nmethods ambiguous.   For example:\n\npublic class Y {\n   public static void main(String[] args) {\n     X x = new X();\n     x.f(1);\n   }\n}\n\npublic class X {\n   public void f(double d) {\n     System.out.println(&quot;d = &quot; + d);\n   }\n\n//  public void f(int i) {\n//    System.out.println(&quot;i = &quot; + i);\n//  }\n}\n\nAdding the second f function without recompiling Y can lead to the  \nwrong function being called.\n\n&gt; In\n&gt; fact, you only need to recompile clients if the public interface  \n&gt; changes\n&gt; in such a way that the clients need to be rewritten.\n\nTrue, except when it isn&#39;t.  Anyway, like I said, you can play the  \ngame that way if you like; but it&#39;s not foolproof.  Anyway, most IDEs  \nand build systems are pretty aggressive about recompiling if they  \nthink something might have changed.  This can make it difficult to  \nplay the game.\n\n&gt;\n&gt; &gt; If I interpose one or more interfaces then suddenly the callers\n&gt; &gt; depend ONLY on the methods in the interfaces that they use; and  \n&gt; those\n&gt; &gt; interfaces can be *very* sparse.\n&gt;\n&gt; If I have a class that depends on only two methods in the library  \n&gt; class,\n&gt; then any changes beyond those two methods and the class signature  \n&gt; itself\n&gt; are irrelevant to the client, and do not require recompilation. You do\n&gt; not need to interpose an interface to get this benefit. Dynamic  \n&gt; binding\n&gt; gives this to you automatically.\n\nThat&#39;s the theory.  In a language like Ruby it works 100% of the  \ntime.  In a language like Java it works 99% of the time.\n\n&gt; Now in a language like C++ that links\n&gt; statically, it may be a very different story. But in Java the clients\n&gt; depend only on the methods in the class that they actually use. A  \n&gt; public\n&gt; change to a method the client actually uses requires rewriting and\n&gt; recompilation, but so does a change to such a method in an interface.\n&gt; Interfaces add nothing to this.\n&gt;\n&gt; &gt; Even if there is only one\n&gt; &gt; interface, and that interface has all the methods of MyDocument I  \n&gt; can\n&gt; &gt; still swap out MyDocument for some other implementation or some Mock\n&gt; &gt; implementation. I can also add new methods to MyDocument without\n&gt; &gt; forcing recompilation and redeployment of the callers.\n&gt;\n&gt; Again, if MyDocument is a class you can still add new methods to\n&gt; MyDocument without forcing recompilation and redeployment of the\n&gt; callers. This has nothing to do with interfaces and everything to do\n&gt; with dynamic linking. (And again, I&#39;m talking about Java here. It  \n&gt; can be\n&gt; different in other languages.)\n\nLet me put it to you another way.  Module A depends on Module B, but  \nonly if you call the A.f method.  I ship you a new version of Module  \nA but I don&#39;t give you the latest module B because you don&#39;t call the  \nf method.  Are you happy?  Or are you going to ask me for module B  \nanyway, just in case...?  Or would you rather I give you an interface  \nfor Module A that does not have the f method?\n\n\n----\nRobert C. Martin (Uncle Bob)  | email: unclebob@...\nObject Mentor Inc.            | blog:  www.butunclebob.com\nThe Agile Transition Experts  | web:   www.objectmentor.com\n800-338-6716                  |\n\n\n\n\n\n\n[Non-text portions of this message have been removed]\n\n\n", 
    "profile": "rmartinoma", 
    "topicId": 17266, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 85922638, 
    "prevInTime": 17783, 
    "contentTrasformed": false, 
    "postDate": "1157417753", 
    "canDelete": false, 
    "nextInTopic": 17785, 
    "prevInTopic": 17783, 
    "headers": {
        "messageIdInHeader": "PEJDQUFERDM5LTM0MDgtNDhGOS1CRkM1LUFDNkQwNjcyN0MzNUBvYmplY3RtZW50b3IuY29tPg=="
    }
}