{
    "numMessagesInTopic": 23, 
    "nextInTime": 22544, 
    "senderId": "xhelCnCRhWdhLIkshFfflO0b_h13I4F1OLSolyqgqwrx3XEY-yKzQLbuuqcPIUbtMnVI8SK9tCLY2Dl7loJE_VHT", 
    "systemMessage": false, 
    "subject": "Re: [junit] Re: @DataPoints called several times for Theories", 
    "from": "David Saff &lt;david@...&gt;", 
    "authorName": "David Saff", 
    "msgSnippet": "After further thought, the ParameterSupplier class is even better for this kind of thing: public abstract class ParameterSupplier { public abstract", 
    "msgId": 22543, 
    "rawEmail": "Return-Path: &lt;david.saff@...&gt;\r\nX-Sender: david.saff@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nX-Received: (qmail 17515 invoked from network); 15 Mar 2010 03:55:37 -0000\r\nX-Received: from unknown (66.196.94.106)\n  by m2.grp.sp2.yahoo.com with QMQP; 15 Mar 2010 03:55:37 -0000\r\nX-Received: from unknown (HELO mail-pz0-f178.google.com) (209.85.222.178)\n  by mta2.grp.re1.yahoo.com with SMTP; 15 Mar 2010 03:55:37 -0000\r\nX-Received: by pzk8 with SMTP id 8so2391999pzk.29\n        for &lt;junit@yahoogroups.com&gt;; Sun, 14 Mar 2010 20:55:16 -0700 (PDT)\r\nMIME-Version: 1.0\r\nX-Received: by 10.141.22.16 with SMTP id z16mr5318243rvi.139.1268625316746; Sun, \n\t14 Mar 2010 20:55:16 -0700 (PDT)\r\nIn-Reply-To: &lt;4f7da6b91003142029t433633dci348c7da639dad10@...&gt;\r\nReferences: &lt;58dba2251002180943q238dd8dv11ab48736321e178@...&gt;\n\t &lt;hlkif2+3mte@...&gt;\n\t &lt;58dba2251003121544p3cd7dd28h1a899ce657f66ad3@...&gt;\n\t &lt;4f7da6b91003142029t433633dci348c7da639dad10@...&gt;\r\nDate: Sun, 14 Mar 2010 23:55:15 -0400\r\nX-Google-Sender-Auth: 0fc497be2bb04f2f\r\nMessage-ID: &lt;4f7da6b91003142055j84a0faw5599476808f61425@...&gt;\r\nTo: junit@yahoogroups.com\r\nCc: Shin Hwei Tan &lt;stan6@...&gt;, Sang Y Baik &lt;sybaik2@...&gt;\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Transfer-Encoding: quoted-printable\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: David Saff &lt;david@...&gt;\r\nSubject: Re: [junit] Re: @DataPoints called several times for Theories\r\nX-Yahoo-Group-Post: member; u=341876227; y=K4NawgR7xoUPyWzVHBXVNkFwlZhBN4GJOOcp-i4mAS4\r\nX-Yahoo-Profile: dsaff\r\n\r\nAfter further thought, the ParameterSupplier class is even better for\nthis =\r\nkind of thing:\n\npublic abstract class ParameterSupplier {\n\tpublic abstract =\r\nList&lt;PotentialAssignment&gt;\ngetValueSources(ParameterSignature sig);\n}\n\nThus:=\r\n\n\n@RunWith(Theories.class)\n  public class TestMutable {\n\n  @DataSupplier pu=\r\nblic static OneTypeSupplier&lt;Mutable&gt; copyMutable =3D\nCopies.of(new Mutable(=\r\n));\n\n   //...\n}\n\nThis would allow a supplier to supply zero, one, or many i=\r\nnputs to a\nparameter signature.  Here&#39;s a supplier for all ints from -10 to=\r\n 10:\n\n@DataSupplier public static OneTypeSupplier&lt;Integer&gt; ints =3D\nInts.be=\r\ntween(-10, 10);\n\nHere&#39;s one that supplies null for any type that can take t=\r\nhem:\n\n@DataSupplier public static ParameterSupplier nullsEverywhere =3D\nNul=\r\nls.forAllObjectTypes();\n\nAnd something crazy and experimental that will kee=\r\np pumping out values\nuntil half a second has passed:\n\n@DataSupplier public =\r\nstatic ParameterSupplier timeLimited =3D\nExploreValueSpace.timeLimitedMilli=\r\ns(500);\n\n(This one would require the return type from\nParameterSupplier#get=\r\nValueSources to be Iterable, which I think would\nbe a good idea anyway)\n\nAn=\r\nd one that combines many other suppliers, for easy sharing &#39;twixt\ntest clas=\r\nses:\n\n@DataSupplier public static ParameterSupplier combined =3D new\nComboS=\r\nupplier(timeLimited, nullsEverywhere, ints, copyMutable);\n\nThus, in another=\r\n class:\n\n@DataSupplier public static ParameterSupplied reused =3D FirstClas=\r\ns.combined;\n\nThis begins to approach the &quot;Rule&quot; threshhold for triggering a=\r\n lot of\nvery plausible ideas with only small changes to interface and\nimple=\r\nmentation.  Shin, Sang, would you like to recast your patch to\ninclude this=\r\n interface contribution?\n\n   David Saff\n\n@RunWith(Theories.class)\n&gt; =A0 pub=\r\nlic class TestMutable {\n&gt;\n&gt; =A0 @DataPointSource public static PotentialAss=\r\nignment&lt;Mutable&gt; =3D\n&gt; Copy.ofMutable(new Mutable());\nOn Sun, Mar 14, 2010 =\r\nat 11:29 PM, David Saff &lt;david@...&gt; wrote:\n&gt; Brett,\n&gt;\n&gt; If developer 1=\r\n needs a fresh data point created every time, and\n&gt; developer 2 needs to re=\r\n-use an expensive-to-create immutable data\n&gt; point, I definitely want to ma=\r\nke it as easy as possible for both to do\n&gt; what they need to do. =A0Just to=\r\n be clear, do you agree the below would\n&gt; work with the current implementat=\r\nion of Theories? =A0It&#39;s four lines\n&gt; more of boilerplate, but not totally =\r\nintractable, in my humble\n&gt; opinion:\n&gt;\n&gt; =A0@RunWith(Theories.class)\n&gt; =A0 =\r\npublic class TestMutable {\n&gt;\n&gt; =A0 private static Mutable createdOnce =3D n=\r\new Mutable();\n&gt;\n&gt; =A0 @DataPoint\n&gt; =A0 public static Mutable mutable() {\n&gt; =\r\n=A0 =A0 return Copy.copy(createdOnce);\n&gt; =A0 }\n&gt;\n&gt; =A0 @Theory\n&gt; =A0 public=\r\n static testMutate(Mutable a) {\n&gt; =A0 =A0 a.mutate();\n&gt; =A0 }\n&gt;\n&gt; =A0 @Theo=\r\nry\n&gt; =A0 public static testNotMutated(Mutable a) {\n&gt; =A0 =A0 assertFalse(a.=\r\nisMutated());\n&gt; =A0 }\n&gt; =A0}\n&gt;\n&gt; I think though, that requiring both the fi=\r\neld and the method to be\n&gt; there in the class could restrict the ability to=\r\n share data and\n&gt; concepts. =A0What would you think of allowing fields or m=\r\nethods to\n&gt; return PontentialAssignment, the type of named references to da=\r\nta\n&gt; values used in the Theories runner? =A0Then we could have:\n&gt;\n&gt;\n&gt; =A0@R=\r\nunWith(Theories.class)\n&gt; =A0 public class TestMutable {\n&gt;\n&gt; =A0 @DataPointS=\r\nource public static PotentialAssignment&lt;Mutable&gt; =3D\n&gt; Copy.ofMutable(new M=\r\nutable());\n&gt;\n&gt; =A0 @Theory\n&gt; =A0 public static testMutate(Mutable a) {\n&gt; =\r\n=A0 =A0 a.mutate();\n&gt; =A0 }\n&gt;\n&gt; =A0 @Theory\n&gt; =A0 public static testNotMuta=\r\nted(Mutable a) {\n&gt; =A0 =A0 assertFalse(a.isMutated());\n&gt; =A0 }\n&gt; =A0}\n&gt;\n&gt; H=\r\nere, I&#39;m guessing about the typing on PotentialAssignment and the\n&gt; name of=\r\n the DataPointSource annotation, but perhaps the idea is clear?\n&gt;\n&gt; =A0 Dav=\r\nid Saff\n&gt;\n&gt; On Fri, Mar 12, 2010 at 6:44 PM, Brett Daniel &lt;brettdaniel@gmai=\r\nl.com&gt; wrote:\n&gt;&gt; The undergrads I am advising recently pushed a patch that =\r\naddresses the\n&gt;&gt; issue of mutable data points.\n&gt;&gt;\n&gt;&gt;\n&gt;&gt; http://github.com/s=\r\ntan6/junit/commit/dcfa3c41446c469a4edc7513e9e7a9b610b04020\n&gt;&gt;\n&gt;&gt; The patch =\r\nallows developers to define &quot;copy strategies&quot; that duplicate\n&gt;&gt; marked data=\r\n points before every theory execution. In this way, every\n&gt;&gt; execution rece=\r\nives a pristine data point, which removes the problems caused\n&gt;&gt; when a the=\r\nory mutates data points. This is orthogonal to datapoint\n&gt;&gt; (re)creation, b=\r\nut I think copy strategies may help address the bug that\n&gt;&gt; Berin found.\n&gt;&gt;=\r\n\n&gt;&gt; The patch creates a new, optional &quot;copyStrategy&quot; parameter for the\n&gt;&gt; @=\r\nDataPoint and @DataPoints annotations. If the developer wants to copy data\n=\r\n&gt;&gt; points, he or she sets the parameter to a class implementing a new\n&gt;&gt; Co=\r\npyStrategy interface.\n&gt;&gt;\n&gt;&gt; Here is an example:\n&gt;&gt;\n&gt;&gt; =A0@RunWith(Theories.=\r\nclass)\n&gt;&gt; =A0 =A0public class TestMutable {\n&gt;&gt;\n&gt;&gt; =A0 =A0@DataPoint(copyStr=\r\nategy =3D MutableWithCopyStrategy.class)\n&gt;&gt; =A0 =A0public static Mutable mu=\r\ntable =3D new Mutable();\n&gt;&gt;\n&gt;&gt; =A0 =A0@Theory\n&gt;&gt; =A0 =A0public static testM=\r\nutate(Mutable a) {\n&gt;&gt; =A0 =A0 =A0a.mutate();\n&gt;&gt; =A0 =A0}\n&gt;&gt;\n&gt;&gt; =A0 =A0@Theo=\r\nry\n&gt;&gt; =A0 =A0public static testNotMutated(Mutable a) {\n&gt;&gt; =A0 =A0 =A0assert=\r\nFalse(a.isMutated());\n&gt;&gt; =A0 =A0}\n&gt;&gt; =A0}\n&gt;&gt;\n&gt;&gt; In the current implementati=\r\non of JUnit, the second theory may fail because\n&gt;&gt; the first theory mutates=\r\n the datapoint. With a copy strategy enabled, both\n&gt;&gt; theories receive a ne=\r\nw value.\n&gt;&gt;\n&gt;&gt; Strategies can do almost anything: clone the data point, cal=\r\nl a factory\n&gt;&gt; method, or--as in the following implementation--instantaiate=\r\n a new object\n&gt;&gt; with a copy constructor.\n&gt;&gt;\n&gt;&gt; =A0public class MutableWith=\r\nCopyStrategy implements CopyStrategy {\n&gt;&gt; =A0 =A0public Object copyDataPoin=\r\nt(Object toCopy) throws Exception {\n&gt;&gt; =A0 =A0 =A0return new Mutable((Mutab=\r\nle)toCopy);\n&gt;&gt; =A0 =A0}\n&gt;&gt; =A0}\n&gt;&gt;\n&gt;&gt; There are several benefits to this im=\r\nplementation. First, the new parameter\n&gt;&gt; is completely optional; if it is =\r\nomitted, the theory runner behaves as it\n&gt;&gt; always has. Second, it doesn&#39;t =\r\nrequire modifying the data point&#39;s class (for\n&gt;&gt; example, to add a copy con=\r\nstructor or clone method). Most importantly, it\n&gt;&gt; makes it clear to the te=\r\nster that without a copy strategy one theory\n&gt;&gt; execution can impact anothe=\r\nr.\n&gt;&gt;\n&gt;&gt; I have CC&#39;d the two students in this email. Please direct any ques=\r\ntions to\n&gt;&gt; them.\n&gt;&gt;\n&gt;&gt; Brett\n&gt;&gt;\n&gt;&gt; On Thu, Feb 18, 2010 at 5:28 PM, Berin =\r\n&lt;berin.loritsch@...&gt; wrote:\n&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; I agree with your prognos=\r\nis, about fresh data points for testing the\n&gt;&gt;&gt; theories. That is precisely=\r\n why I proposed reading them once, and cloning\n&gt;&gt;&gt; them (making a copy) as =\r\nneeded for each theory. With that approach we even\n&gt;&gt;&gt; get the protection f=\r\nrom mutated data points when you use the @DataPoint to\n&gt;&gt;&gt; mark a static fi=\r\neld.\n&gt;&gt;&gt;\n&gt;&gt;&gt; Cloning is a much quicker operation, does not execute any cons=\r\ntructors. It\n&gt;&gt;&gt; merely copies the contents of the object memory verbatim.\n=\r\n&gt;&gt;&gt;\n&gt;&gt;&gt; With the current implementation, if you are not prepared for the\n&gt;&gt;=\r\n&gt; combinatorial affect of 60 data points combined with 60 data points for e=\r\nach\n&gt;&gt;&gt; theory there is a major disconnect. The majority of the overhead in=\r\n this\n&gt;&gt;&gt; particular scenario has to do with creating objects (with the add=\r\nitional\n&gt;&gt;&gt; overhead of doing it by reflection).\n&gt;&gt;&gt;\n&gt;&gt;&gt; When I created onl=\r\ny one instance of each class instead of two, the\n&gt;&gt;&gt; performance was twice =\r\nas fast (i.e. 37 seconds down to about 16 seconds).\n&gt;&gt;&gt;\n&gt;&gt;&gt; Essentially the=\r\n number of times your @DataPoints method is called depends\n&gt;&gt;&gt; on the numbe=\r\nr of parameters in your @Theory and how many theories you have.\n&gt;&gt;&gt; Essenti=\r\nally the formula for my theory (ha, ha) of the execution is like\n&gt;&gt;&gt; this:\n=\r\n&gt;&gt;&gt;\n&gt;&gt;&gt; N^(p-1) + 1\n&gt;&gt;&gt;\n&gt;&gt;&gt; where:\n&gt;&gt;&gt;\n&gt;&gt;&gt; N is the number of data points r=\r\neturned by the method\n&gt;&gt;&gt; p is the number of parameters\n&gt;&gt;&gt; and the + 1 rep=\r\nresents the run where the data point is read the first time\n&gt;&gt;&gt;\n&gt;&gt;&gt; So for =\r\n60 data points it is run 61 times for two parameters. With three\n&gt;&gt;&gt; parame=\r\nters it would be called 3601 times. I have to verify with three\n&gt;&gt;&gt; paramet=\r\ners. The theory is called N^p times for sure and that is expected.\n&gt;&gt;&gt;\n&gt;&gt;&gt; =\r\nWith the above formula, the mapping of number of calls to parameters for 60=\r\n\n&gt;&gt;&gt; data points would be:\n&gt;&gt;&gt;\n&gt;&gt;&gt; 1 -&gt; 2 (I know this is wrong which gives=\r\n me doubts on the formula)\n&gt;&gt;&gt; 2 -&gt; 61\n&gt;&gt;&gt; 3 -&gt; 3601\n&gt;&gt;&gt; 3 -&gt; 216001\n&gt;&gt;&gt;\n&gt;&gt;=\r\n&gt; Essentially when the Assignments class needs to make the combinations, it=\r\n\n&gt;&gt;&gt; will collect the data points initially for each theory. It then calls =\r\nthe\n&gt;&gt;&gt; data points again for each existing data point it collected from th=\r\ne first\n&gt;&gt;&gt; read. With a third parameter it would take all those combinatio=\r\nns again, to\n&gt;&gt;&gt; add all the permutations for the next round.\n&gt;&gt;&gt;\n&gt;&gt;&gt; I mig=\r\nht be wrong and the real formula would be like this:\n&gt;&gt;&gt;\n&gt;&gt;&gt; N^0 + N^1 ... =\r\n+ N^(p-1)\n&gt;&gt;&gt;\n&gt;&gt;&gt; If this is the correct formula, then if you have 60 data =\r\npoints the number\n&gt;&gt;&gt; of times the method is called would map to the number=\r\n of parameters like\n&gt;&gt;&gt; this:\n&gt;&gt;&gt;\n&gt;&gt;&gt; 1 -&gt; 1\n&gt;&gt;&gt; 2 -&gt; 61\n&gt;&gt;&gt; 3 -&gt; 3661\n&gt;&gt;&gt; =\r\n4 -&gt; 219661\n&gt;&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; --- In junit@yahoogroups.com &lt;junit%40yahoogroups.c=\r\nom&gt;, Brett Daniel\n&gt;&gt;&gt; &lt;brettdaniel@...&gt; wrote:\n&gt;&gt;&gt; &gt;\n&gt;&gt;&gt; &gt; Berin,\n&gt;&gt;&gt; &gt;\n&gt;&gt;&gt;=\r\n &gt; When a theory mutates data points, it might be beneficial to recreate\n&gt;&gt;=\r\n&gt; &gt; the data point for every theory invocation. Doing so prevents one\n&gt;&gt;&gt; &gt;=\r\n theory execution from affecting others. I wrote about this issue in\n&gt;&gt;&gt; &gt; =\r\nthe following weblog post:\n&gt;&gt;&gt; &gt;\n&gt;&gt;&gt; &gt; http://www.brettdaniel.com/archives/=\r\n2009/09/24/200845/\n&gt;&gt;&gt; &gt;\n&gt;&gt;&gt; &gt; You are correct, though, that copying would =\r\navoid some of the overhead\n&gt;&gt;&gt; &gt; in calling datapoint methods. It is intere=\r\nsting you mention this idea,\n&gt;&gt;&gt; &gt; because I am currently overseeing two st=\r\nudents who for their senior\n&gt;&gt;&gt; &gt; thesis project are implementing framework=\r\n for copying datapoints. I\n&gt;&gt;&gt; &gt; will post more information to the mailing =\r\nlist as the project\n&gt;&gt;&gt; &gt; continues.\n&gt;&gt;&gt; &gt;\n&gt;&gt;&gt; &gt; Brett\n&gt;&gt;&gt; &gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;=\r\n\n&gt;&gt;\n&gt;&gt; [Non-text portions of this message have been removed]\n&gt;&gt;\n&gt;&gt;\n&gt;&gt;\n&gt;&gt; --=\r\n----------------------------------\n&gt;&gt;\n&gt;&gt; Yahoo! Groups Links\n&gt;&gt;\n&gt;&gt;\n&gt;&gt;\n&gt;&gt;\n&gt;\n=\r\n\n", 
    "profile": "dsaff", 
    "topicId": 22425, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 341876227, 
    "prevInTime": 22542, 
    "contentTrasformed": false, 
    "postDate": "1268625315", 
    "canDelete": false, 
    "nextInTopic": 22544, 
    "prevInTopic": 22542, 
    "headers": {
        "inReplyToHeader": "PDRmN2RhNmI5MTAwMzE0MjAyOXQ0MzM2MzNkY2kzNDhjN2RhNjM5ZGFkMTBAbWFpbC5nbWFpbC5jb20+", 
        "messageIdInHeader": "PDRmN2RhNmI5MTAwMzE0MjA1NWo4NGEwZmF3NTU5OTQ3NjgwOGY2MTQyNUBtYWlsLmdtYWlsLmNvbT4=", 
        "referencesHeader": "PDU4ZGJhMjI1MTAwMjE4MDk0M3EyMzhkZDhkdjExYWI0ODczNjMyMWUxNzhAbWFpbC5nbWFpbC5jb20+CSA8aGxraWYyKzNtdGVAZUdyb3Vwcy5jb20+CSA8NThkYmEyMjUxMDAzMTIxNTQ0cDNjZDdkZDI4aDFhODk5Y2U2NTdmNjZhZDNAbWFpbC5nbWFpbC5jb20+CSA8NGY3ZGE2YjkxMDAzMTQyMDI5dDQzMzYzM2RjaTM0OGM3ZGE2MzlkYWQxMEBtYWlsLmdtYWlsLmNvbT4="
    }
}