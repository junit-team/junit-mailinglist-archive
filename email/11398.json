{
    "numMessagesInTopic": 1, 
    "nextInTime": 11399, 
    "senderId": "9l0iUPdS2BOEopolPZl02GimFDc2_F3DPLN7kVcg-lT-EW6aTYMAPvsSFUXm54jOxwzcL8VUa7uhm_YXWvbiJuyL7CEHSXqA", 
    "systemMessage": false, 
    "subject": "Help regarding new instance of test object every test", 
    "from": "&quot;cypherfox&quot; &lt;cypherfox@...&gt;", 
    "authorName": "cypherfox", 
    "msgSnippet": "Greetings, So I wanted to create a suite of tests against a message management class that talks to a server (IMAP in my case).  So there are methods like: ", 
    "msgId": 11398, 
    "profile": "cypherfox", 
    "topicId": 11398, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 174888704, 
    "messageBody": "<div id=\"ygrps-yiv-990186612\">Greetings,<br/>\nSo I wanted to create a suite of tests against a message management<br/>\nclass that talks to a server (IMAP in my case).  So there are methods<br/>\nlike:<br/>\n<br/>\ncreateUser(...)<br/>\ncreateMessage(...)<br/>\nreadMessage(...)<br/>\ndeleteMessage(...)<br/>\ndeleteUser(...)<br/>\n<br/>\nHowever, these tests (this is where it gets complex) are being run<br/>\nunder around a hundred threads.  So the message id that comes back is<br/>\nnot generally predictable, nor should I care what it is during<br/>\ncompilation.  The tests themselves care, however, as I&#39;ll describe.<br/>\n<br/>\nMy test class consists of a number of seperate tests (many more than<br/>\nabove), each testing one of the calls.  However, I need a certain<br/>\namount of &#39;state&#39; between each call, so I know (for example) what the<br/>\nmessage id that was created was, so that I can read it, and then<br/>\ndelete it, validating that the content is correct, not just that the<br/>\ncalls succeed.  (I need more state than this for tracking comment ids,<br/>\nto determine that they&#39;re right, and everything, but the simplest case<br/>\nis the message id.)<br/>\n<br/>\nI discovered, to my chagrin, that the sample testing code (and all the<br/>\n&#39;use this class&#39; test functions) appear to create a new test object<br/>\nevery time it calls the next test function.<br/>\n<br/>\nMy first solution, when building the tests at first, while I was<br/>\nwriting the actual functions, was to build a static member that said<br/>\nwhat message id had been returned, and another for the server<br/>\nconnection, since the idea wasn&#39;t to test re-opening the connection<br/>\n&#39;n&#39; times where &#39;n&#39; is the number of test methods written.  Of course,<br/>\nthese failed miserably when I started running a hundred threads, as<br/>\nthe statics were being overwritten constantly.  (It was a &#39;DUH!&#39;<br/>\nmoment, complete with very red face...)<br/>\n<br/>\nMy current solution sucks equally, though.  I extracted the<br/>\ntest-calling to an object of its own, which creates an object of the<br/>\nappropriate type (storageTest in this case), and calls each of the<br/>\ntests itself.  If any of the tests fail, the &#39;uber test&#39; object fails.<br/>\n Unfortunately, there&#39;s no way to identify WHICH test failed, because<br/>\nthey are being called &#39;by hand&#39; in the uber test.  It also appears I<br/>\ncan&#39;t merge TestResults back in any reasonable way, so the threading<br/>\nresults are an &#39;all or nothing&#39; result, which really doesn&#39;t help at<br/>\nall if things fail.  (Which they have at times, and my debugging has<br/>\nbeen reduced to &#39;duhhhhh...println?&#39; at that point.)<br/>\n<br/>\nFor the multithreading, I&#39;m using code based on a<br/>\nMultiThreadedTestCase class that I saw up online (iirc it&#39;s based on<br/>\nthe one I found on java.net), but it doesn&#39;t have any solution for the<br/>\nproblem of Results merging back together.<br/>\n<br/>\nOptimally, I&#39;d like the following, and since some very smart people<br/>\nspecifically didn&#39;t implement them, what I guess I&#39;m looking for here<br/>\nis to have it explained why these aren&#39;t a good idea:<br/>\n<br/>\nThe ability to create a test that creates the object once, runs<br/>\nsetUp() once, iterates over all the test*() methods on an object, and<br/>\nthen tearDown() once.  This differs from the one-setup/one-teardown<br/>\ndescribed in the FAQ in that the object is not re-created every test<br/>\ncall, it&#39;s re-used.  Personally, it seems to me this allows for<br/>\ntesting to mirror actual use a lot better.  What am I missing?<br/>\n<br/>\n(minor) The ability to name a result set (so that merged results don&#39;t<br/>\nblur together too much), and (major) merge result sets together. <br/>\n(Perhaps as simple as &#39;resultSet.append(latestSet)&#39;.)<br/>\n<br/>\nA third, and less necessary (but still very useful imo) feature would<br/>\nbe to be able to do something like this (putting it all together):<br/>\n<br/>\nTestSuite once = new TestSuite();<br/>\nTestSuite many = new TestSuite();<br/>\nTestSuite last = new TestSuite();<br/>\nMyTestClass mtc = new MyTestClass();<br/>\nTestResult results;<br/>\nonce.add(mtc, &quot;testCreateUser&quot;);<br/>\nresults = once.run();<br/>\n<br/>\nmany.add(mtc, &quot;testWriteMessage&quot;);<br/>\nmany.add(mtc, &quot;testReadMessage&quot;);<br/>\nmany.add(mtc, &quot;testDeleteMessage&quot;);<br/>\n<br/>\nfor(i = 0; i&lt;20; i++) results.append(many.run());<br/>\n<br/>\nlast.add(mtc, &quot;testDeleteUser&quot;);<br/>\n<br/>\nresults.append(last.run());<br/>\n<br/>\nNow picture a test process that kicks off a hundred threads, each<br/>\ndoing that, where &#39;results&#39; on each thread gets put into a static<br/>\nresult set, and then when all the threads are reaped, a &#39;main&#39; test,<br/>\naccumulates all the result sets into one complete one, and returns it.<br/>\n<br/>\nNice?<br/>\n<br/>\nSo...<br/>\n<br/>\nWhat have I missed, and/or why is some JUnit functionality like this a<br/>\nbad idea?<br/>\n<br/>\n--  Morgan Schweers</div>", 
    "prevInTime": 11397, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1089427344", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PGNjbmwyZys3cWpnQGVHcm91cHMuY29tPg=="
    }
}