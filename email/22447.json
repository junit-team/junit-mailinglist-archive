{
    "numMessagesInTopic": 1, 
    "nextInTime": 22448, 
    "senderId": "WkJPKFY3YHJd7w7iaV8au9P5_CCzKLGuKu7rymshsF5AZVFN92cDlCLbaHUk9ByR4y8h5Qh5qzgCuTmaXtuAcsoFNhhvTPYBWp8SfZPM3VHFxiWH2rFJ", 
    "systemMessage": false, 
    "subject": "Vote for Discrete Theories", 
    "from": "&quot;Loritsch, Berin C.&quot; &lt;berin.loritsch@...&gt;", 
    "authorName": "Loritsch, Berin C.", 
    "msgSnippet": "A while back I posted some changes I would like to see to make using Theories to test interface contracts more useful.  Essentially, this includes recording", 
    "msgId": 22447, 
    "profile": "bloritsch", 
    "topicId": 22447, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 428096731, 
    "messageBody": "<div id=\"ygrps-yiv-1039742700\">A while back I posted some changes I would like to see to make using<br/>\nTheories to test interface contracts more useful.  Essentially, this<br/>\nincludes recording each run of the theory as a separate test.  I&#39;ve<br/>\nprepared a patch to make it possible, and to get it applied I need your<br/>\nsupport.<br/>\n<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://github.com/KentBeck/junit/issues#issue/78\">http://github.com/KentBeck/junit/issues#issue/78</a><br/>\n<br/>\n<br/>\nThe way it works is that you mark the theory you want to be recorded<br/>\nseparately like this:<br/>\n<br/>\n@DataPoints<br/>\npublic static int[] fibonacciSeries() {<br/>\n    return new int[] {1,2,3,5,8,13};<br/>\n}<br/>\n<br/>\n@Theory(runDiscretely=true)<br/>\npublic void myTheory(int data) {<br/>\n    // do the testing<br/>\n}<br/>\n<br/>\nIf you have 6 data points, your test results will have 6 tests recorded<br/>\nlike this:<br/>\nmyTheory[1] = passed<br/>\nmyTheory[2] = passed<br/>\nmyTheory[3] = failed<br/>\nmyTheory[5] = passed<br/>\nmyTheory[8] = failed<br/>\nmyTheory[13] = passed<br/>\n<br/>\nThe advantage of this approach is that each failure is recorded<br/>\nseparately.  When you are evaluating a number of implementations of the<br/>\ninterface, you can find all the failures in one pass instead of fixing<br/>\none failure to reveal another.<br/>\n<br/>\nAdditionally, the value in the square brackets can be customized with<br/>\nthe toString() method of your objects under test.  The test names are<br/>\nbuilt with String.valueOf() on the data point value (handles null as<br/>\nwell).  This works well when you dynamically build the data points in a<br/>\nmethod like the example I provided above.  Without this solution, the<br/>\nonly clue is in the exception thrown which gives you the name of the<br/>\n@DataPoints method (fibonnacciSeries) and the index ([2]) with the first<br/>\nfailure above.  The patch I have does not remove this functionality, so<br/>\nyou have both solutions available.  The discrete test name includes the<br/>\nString value of the object and the exception thrown gives you the name<br/>\nof the data point and index (if applicable).<br/>\n<br/>\nIf you believe that this will be helpful, vote for the issue at the<br/>\nbeginning of the email.  If you want to try it out, you can get it from<br/>\ngithub here:<br/>\n<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://github.com/bloritsch/junit\">http://github.com/bloritsch/junit</a><br/>\n<br/>\n<br/>\n<br/>\n<br/>\n[Non-text portions of this message have been removed]</div>", 
    "prevInTime": 22446, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1266516459", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PDc1RjVFRDhBNUE1NTM2NDZBNDZFMDBFNkVDODU0RkEzMDQ0NjkyOENAdmFmZjAxLW1haWwwMS5hZC5nZC1haXMuY29tPg=="
    }
}