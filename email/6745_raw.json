{
    "numMessagesInTopic": 7, 
    "nextInTime": 6746, 
    "senderId": "H0of6UZGR4YVisolDQ7_mcK3Y-uyKGKTF5UBHQ6p1rGtB0cfyAAQ9pDNphsSkZ8VJGsvaIatnZy10Wlj20M2EjdRb6NquWM5sYDf7VSZh9bu_V9Z", 
    "systemMessage": false, 
    "subject": "Re: [junit] Tests naming", 
    "from": "&quot;J. B. Rainsberger&quot; &lt;jbr@...&gt;", 
    "authorName": "J. B. Rainsberger", 
    "msgSnippet": "Kirill!  ... be ... Usually there are three kinds of flows: 1. The usual flow 2. Alternate usual flows 3. Error flows I use the term use case", 
    "msgId": 6745, 
    "rawEmail": "Return-Path: &lt;jbr@...&gt;\r\nX-Sender: jbr@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (EGP: mail-8_2_3_0); 26 Jan 2003 20:02:43 -0000\r\nReceived: (qmail 42550 invoked from network); 26 Jan 2003 20:02:43 -0000\r\nReceived: from unknown (66.218.66.218)\n  by m10.grp.scd.yahoo.com with QMQP; 26 Jan 2003 20:02:43 -0000\r\nReceived: from unknown (HELO fep03-mail.bloor.is.net.cable.rogers.com) (66.185.86.73)\n  by mta3.grp.scd.yahoo.com with SMTP; 26 Jan 2003 20:02:42 -0000\r\nReceived: from quincy ([24.42.96.247])\n          by fep03-mail.bloor.is.net.cable.rogers.com\n          (InterMail vM.5.01.05.06 201-253-122-126-106-20020509) with ESMTP\n          id &lt;20030126200237.PVVH121195.fep03-mail.bloor.is.net.cable.rogers.com@quincy&gt;\n          for &lt;junit@yahoogroups.com&gt;; Sun, 26 Jan 2003 15:02:37 -0500\r\nMessage-ID: &lt;200301261502360219.007DA35B@...&gt;\r\nIn-Reply-To: &lt;20030126100028.GA6278@...&gt;\r\nReferences: &lt;20030125194902.GA12329@...&gt;\n &lt;200301251504490331.0110A0B3@...&gt;\n &lt;20030126100028.GA6278@...&gt;\r\nX-Mailer: Calypso Version 3.30.00.00 (4)\r\nDate: Sun, 26 Jan 2003 15:02:36 -0500\r\nTo: junit@yahoogroups.com\r\nSubject: Re: [junit] Tests naming\r\nContent-Type: text/plain; charset=&quot;KOI8-R&quot;\r\nX-Authentication-Info: Submitted using SMTP AUTH LOGIN at fep03-mail.bloor.is.net.cable.rogers.com from [24.42.96.247] using ID &lt;srainsberger5790@...&gt; at Sun, 26 Jan 2003 15:02:37 -0500\r\nFrom: &quot;J. B. Rainsberger&quot; &lt;jbr@...&gt;\r\nReply-To: jbr@...\r\nX-Yahoo-Group-Post: member; u=89240252\r\nX-Yahoo-Profile: nails762\r\n\r\nKirill!\n\n&lt;snip /&gt;\n&gt;&gt;&gt; Generally there is one test per use case scenario (different flow\n&gt;&gt;&gt; through the use case). Choosing to write more or fewer tests should\nbe\n&gt;&gt;&gt; done thoughtfully.\n&gt;&gt;\n&gt;&gt; In my experience, there are several alternative flows for a ordinary\n&gt;&gt; use case. And I see reasonable to test at least two of them: basic\n&gt;&gt; flow and error flow. What do you think?\n\nUsually there are three kinds of flows:\n\n1. The usual flow\n2. Alternate usual flows\n3. Error flows\n\nI use the term &quot;use case scenario&quot; to mean a path through a use case\nwith many flows. Each &quot;flow&quot; is a use case scenario. I believe that\nthis is the standard UML term. When I say &quot;use case scenario&quot;, it is\nnow clear what I mean.\n\nGenerally, the goal is to write one Customer Test per use case\nscenario. There may even be additional tests, depending on the number\nof different representative data points along the way.\n\nI prioritize as follows:\n\n1. Usual flow test\n2. Fatal error flow tests\n3. Normal alternative flow tests\n4. Non-fatal error flow tests\n5. Others\n\nIf there are, for example, 20 scenarios for a use case, then I need to\nsit down and decide whether the use case is too big.\n\n \n&gt;&gt;&gt; &gt; - each test scenario is placed into single class with appropriate\n&gt;&gt;&gt; name.\n&gt;&gt;&gt; \n&gt;&gt;&gt; Each use case scenario is a test. Test classes should almost always\n&gt;&gt;&gt; evolve based around a fixture, not some other arbitrary\norganization\n&gt;&gt;&gt; mechanism. A given use case may be implemented as its own Customer\nTest\n&gt;&gt;&gt; class, but it is usually better to let the organization of tests\ninto\n&gt;&gt;&gt; TestCase implementations depend on shared fixture requirements.\n&gt;&gt;\n&gt;&gt; But we can share fixtures using inheritance as well. I have two\npoints\n&gt;&gt;here:\n&gt;&gt;\n&gt;&gt; - for a complicated test case it may be better to keep it in a\nseparate\n&gt;&gt;class.\n&gt;&gt; - It is easier to get full list of existing functional tests if we\nput\n&gt;&gt; each test case into a single class. Getting the list is quite usual\n&gt;&gt; task requested by QA department or customer (or I&#39;m wrong here?)\n\nCertainly this is a good idea. There must be a way to present the list\nof currently-implemented Customer Tests to groups like QA. Dividing the\ntests among classes is one way to achieve this. Some kind of xDoclet\nthing would be another. (Step in, Mr. Gemkow, to provide some\ninformation here.)\n\n&gt;&gt;&gt; &gt;2. For Unit tests:\n&gt;&gt;&gt; &gt; - test package shall be the same as for the production code, \n&gt;&gt;&gt; &gt; but it is better to use a different source tree.\n&gt;&gt;&gt; &gt; - for simple classes (such as value objects) it is OK to name\n&gt;&gt;&gt; &gt; test classes after the name of the class under test \n&gt;&gt;&gt; &gt; (like UTestFooBar or FooBarTest). Names of test methods,\n&gt;&gt;&gt; &gt; in its turn, may include the name of the tested method.\n&gt;&gt;&gt; &gt; - for complex classes, which require a complex fixture to be set,\n&gt;&gt;&gt; &gt; test case class shall be named using fixture description. \n&gt;&gt;&gt; &gt; (The issue was discussed previously on this list).\n&gt;&gt;&gt; &gt; Test method name in this case shall describe the tested\nbehaviour.\n&gt;&gt;&gt; \n&gt;&gt;&gt; The last point is the general case, and the previous points are\nspecial\n&gt;&gt;&gt; cases when the tests (not the code under test) are very simple.\n&gt;&gt;\n&gt;&gt; Agreed. The issue here is to fugure out proper fixture class when\nyou \n&gt;&gt; want to add a new test (for instance, when you find a bug). The task\n\n&gt;&gt; may become more complicated if you never seen the code before and\nthere\n&gt;&gt; are nobody to ask (bad things happen). I see two possible solutions:\n&gt;&gt;\n&gt;&gt; - Use IDE features to find usages of tested code (if you have such\nIDE)\n&gt;&gt; - Make a error in the production code and see which test breaks.\n\nIf you cannot figure out where to add the new test, then you can find\nthe test that breaks by breaking the production code; however, that\nassumes that you know what production code you need to change in order\nto add the feature. This may not be the case, and certainly is not\nalways (often?) the case when test-driving the new feature.\n\nIf I am in that situation and I cannot find a test fixture to match my\ncurrent needs, then I build a new one and let the team refactor it as\nthey come across it. Eventually, someone will feel the pain of not\nhaving the right test fixture and will find the problem.\n\n&gt;&gt;&gt; &gt;3. For Integration Tests:\n&gt;&gt;&gt; &gt; - I suggest, names of Integration tests must differ from Unit\n&gt;&gt;&gt; tests.\n&gt;&gt;&gt; &gt; Usually, integration tests run longer, and consequently, more\n&gt;&gt;&gt; seldom. \n&gt;&gt;&gt; &gt; That&#39;s why it is convinient to name them differently. One may\nname\n&gt;&gt;&gt; \n&gt;&gt;&gt; &gt; unit tests using UTest prefix, anf Integration tests using ITest\n&gt;&gt;&gt; &gt;prefix.\n&gt;&gt;&gt; \n&gt;&gt;&gt; On a past project, we used tag interfaces to distinguish Programmer\n&gt;&gt;&gt; Tests from Customer Tests. This made it easy to write a TestRunner\nthat\n&gt;&gt;&gt; picked one or the other or both when building a test suite. You may\n&gt;&gt;&gt; find this technique useful.\n&gt;&gt;\n&gt;&gt; I saw an article where static variable with specific value was used \n&gt;&gt; to mark a test and TestSuite class used reflection to include only \n&gt;&gt; tests with specific value of the variable. It is quite close to your\n&gt;&gt; approach.\n&gt;&gt;\n&gt;&gt; What for me, I use ant to build/run my test suites. That&#39;s why I \n&gt;&gt; suggest class naming approach.\n\nCertainly a class naming convention works very well with Ant&#39;s\nJUnit:batchtest task.\n\n&gt;&gt;&gt; Also, place the different kinds of tests in different packages in\norder\n&gt;&gt;&gt; to reduce the number of naming collisions.\n&gt;&gt;\n&gt;&gt; Sorry, I don&#39;t see your point clearly. Are you talking about unit\ntests,\n&gt;&gt; functional tests?\n\nYes. :)\n\nI mean place CTs in one package and PTs in another.\n\n&gt;&gt;&gt; I have to say that your list of points is excellent and should be\n&gt;&gt;&gt; turned into a short article on the subject.\n&gt;&gt;\n&gt;&gt; Thank you very much. Actually, I thought about it and I&#39;ll possibly\n&gt;&gt; try to write one.\n\nI am more than willing to edit it, if you need some help.\n\nTake care.\n\n\nJ. B. Rainsberger,\nPresident, Diaspar Software Services\nLet&#39;s write software that people understand.\nhttp://www.diasparsoftware.com/\ntelephone: +1 416 791-8603\nAll correspondence (c) 2002 Diaspar Software Services.\nIf you want to use it, just ask; don&#39;t steal.\n\n\n", 
    "profile": "nails762", 
    "topicId": 6735, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 89240252, 
    "prevInTime": 6744, 
    "contentTrasformed": false, 
    "postDate": "1043611356", 
    "canDelete": false, 
    "nextInTopic": 6753, 
    "prevInTopic": 6741, 
    "headers": {
        "inReplyToHeader": "PDIwMDMwMTI2MTAwMDI4LkdBNjI3OEBxdWVlbi5hY3RpbWluZC5jb20+", 
        "messageIdInHeader": "PDIwMDMwMTI2MTUwMjM2MDIxOS4wMDdEQTM1QkBzbXRwLnltLnBodWIubmV0LmNhYmxlLnJvZ2Vycy5jb20+", 
        "referencesHeader": "PDIwMDMwMTI1MTk0OTAyLkdBMTIzMjlAcXVlZW4uYWN0aW1pbmQuY29tPiA8MjAwMzAxMjUxNTA0NDkwMzMxLjAxMTBBMEIzQHNtdHAueW0ucGh1Yi5uZXQuY2FibGUucm9nZXJzLmNvbT4gPDIwMDMwMTI2MTAwMDI4LkdBNjI3OEBxdWVlbi5hY3RpbWluZC5jb20+"
    }
}