{
    "numMessagesInTopic": 19, 
    "nextInTime": 16754, 
    "senderId": "tTu_UgBSP2bwh5owdyBvrSU8IcZrsca597-gzwtYnYc5QnYJwWRQ5MeGDKsLSTH0fQX9ab8C4VuYP3cdalI6A4rid_eE7mCEAY7yZ0Uw6g", 
    "systemMessage": false, 
    "subject": "Re: [junit] Re: JUnit vs. Agitator", 
    "from": "&quot;J. B. Rainsberger&quot; &lt;jbrains@...&gt;", 
    "authorName": "J. B. Rainsberger", 
    "msgSnippet": "... ...not to mention that JUnit costs a lot less then Agitator! (I couldn t resist. :) ) Brian Marick talks about how customers (or Product Directors, to use", 
    "msgId": 16753, 
    "profile": "nails762", 
    "topicId": 16720, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 127224993, 
    "messageBody": "<div id=\"ygrps-yiv-1056616087\">frogstar wrote:<br/>\n<blockquote><span title=\"ireply\"> &gt; --- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>, &quot;Shane Mingins&quot; &lt;shane.mingins@...&gt; wrote:<br/>\n&gt;  &gt;<br/>\n&gt;  &gt; Or do you see Agitator complementing JUnit in the same way whether<br/>\n&gt; you are<br/>\n&gt;  &gt; using TTD or not?<br/>\n&gt;  &gt;<br/>\n&gt;  &gt; My current thinking is the two tools solve slightly different<br/>\n&gt; problems ...<br/>\n&gt;  &gt; or they address testing is different ways.<br/>\n&gt; ...<br/>\n&gt;  &gt; Anyhow at the moment I am thinking that developers should<br/>\n&gt;  &gt; start with JUnit or JUnit + Agitator and not simply just Agitator.<br/>\n&gt;  &gt;<br/>\n&gt;  &gt; Your thoughts?<br/>\n&gt;  &gt;<br/>\n&gt; <br/>\n&gt; Hi Shane,<br/>\n&gt; <br/>\n&gt; I&#39;m not Alberto but I&#39;ll give you my take on it.  Short answer is I<br/>\n&gt; think Agitator & JUnit are complementary TDD or no. (I&#39;ll leave it to<br/>\n&gt; someone else to make the point that of course you should use TDD.  I<br/>\n&gt; agree with them, but that isn&#39;t your question.)<br/>\n&gt; <br/>\n&gt; Longer answer is that when you use JUnit TDD there are (at least) two<br/>\n&gt; different kinds of value you get, design and correctness. It is the<br/>\n&gt; correctness aspect that Robert Martin is talking about when he<br/>\n&gt; compares TDD to double entry bookkeeping. It answers the question<br/>\n&gt; &quot;does my algorithm work? does input a combined with input b give me<br/>\n&gt; exactly output c?&quot; JUnit tests give you this kind of confidence.<br/>\n&gt; <br/>\n&gt; Agitator is more about limits and bounds and did your algorithm, which<br/>\n&gt; you already know works correctly on the happy path, unexpectedly blow<br/>\n&gt; up in some cases. Or leave the object in an illegal state? Or return a<br/>\n&gt; non-sensical value? or... Agitation is also good for &quot;does input of<br/>\n&gt; category A with input of category B always give me output of category<br/>\n&gt; C?&quot; If I were looking for a word to compare to correctness I&#39;d<br/>\n&gt; probably have to choose robustness.<br/>\n&gt; <br/>\n&gt; So would I recommend JUnit + Agitator over just simply Agitator?  Heck<br/>\n&gt; yeah! and I&#39;ve already done so many times on (both in person and on my<br/>\n&gt; blog) already.  :)<br/>\n<br/>\n </span></blockquote>...not to mention that JUnit costs a lot less then Agitator! (I couldn&#39;t <br/>\nresist. :) )<br/>\n<br/>\nBrian Marick talks about how customers (or Product Directors, to use his <br/>\nmost recent term for the role) are good at identifying business value <br/>\nand testers are good at identifying business loss. This means that <br/>\nwithout testers, you end up with a system that does good things, but <br/>\ncrumbles under the slightest bit of bad input or user malice. Testers <br/>\nare there to help identify situations where the current product can be <br/>\nbrought to its knees, whether intentionally or unintentionally. Testers <br/>\nstop us from shipping a product with $2M of value and a potential $20M <br/>\nsecurity hole. I see Agitator having a similar role at the technical level.<br/>\n<br/>\nTDD practitioners are good at identifying technical value (clean code <br/>\nthat does the right thing with the right input) and JUnit is a key tool <br/>\nfor that purpose. Agitator can help identify technical loss: boundary <br/>\ncases that might be of interest to the programmer and might represent <br/>\ntechnical holes other modules can exploit to hurt the system. This is <br/>\nhow I imagine using Agitator in my practice.<br/>\n<br/>\nHow does that sound?<br/>\n-- <br/>\nJ. B. (Joe) Rainsberger :: <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.jbrains.info\">http://www.jbrains.info</a><br/>\nYour guide to software craftsmanship<br/>\nJUnit Recipes: Practical Methods for Programmer Testing<br/>\n2005 Gordon Pask Award for contribution Agile Software Practice</div>", 
    "prevInTime": 16752, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1149011655", 
    "canDelete": false, 
    "nextInTopic": 16754, 
    "prevInTopic": 16748, 
    "headers": {
        "inReplyToHeader": "PGU1Z2xwdSszcmFiQGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PDQ0N0M4NkM3LjgwNDAzMDVAcm9nZXJzLmNvbT4=", 
        "referencesHeader": "PGU1Z2xwdSszcmFiQGVHcm91cHMuY29tPg=="
    }
}