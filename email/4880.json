{
    "numMessagesInTopic": 46, 
    "nextInTime": 4881, 
    "senderId": "JJ7qrv41gbISaMsgmGHZinesR2cCNCJIMr165bgN-6tL1ohWIebDEtmG-RcQ-vS6uEZgexnI7_mAWuc88SVjlrfBiGslWq13ZlOiVBBP", 
    "systemMessage": false, 
    "subject": "RE: [junit] black box or white box?", 
    "from": "&quot;Berin Loritsch&quot; &lt;bloritsch@...&gt;", 
    "authorName": "Berin Loritsch", 
    "msgSnippet": "... Ok.  I am not guessing.  What I posted are my observations on the way I develop.  With sufficiently componentized software, your only contract that you can", 
    "msgId": 4880, 
    "profile": "bloritsch", 
    "topicId": 4836, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 64910131, 
    "messageBody": "<div id=\"ygrps-yiv-482009317\"><blockquote><span title=\"ireply\">&gt; From: Johannes Link [mailto:<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:john.link@...\">john.link@...</a>] <br/>\n&gt; <br/>\n&gt; &gt;<br/>\n&gt; &gt; In reality, you *can* have the best of both worlds.  The <br/>\n&gt; issue at hand <br/>\n&gt; &gt; is that a general test case excercises all the contracts that the <br/>\n&gt; &gt; public interface has.  A contract is a guarantee that the <br/>\n&gt; class must <br/>\n&gt; &gt; satisfy.<br/>\n&gt; &gt;<br/>\n&gt; &gt; [...]<br/>\n&gt; &gt; If what you are talking about is different than what I just <br/>\n&gt; described, <br/>\n&gt; &gt; perhaps it is because we&#39;re not speaking the same language?<br/>\n&gt; <br/>\n&gt; Maybe, let me summarize in my language:<br/>\n&gt; What you say is that one can have sufficiently stable <br/>\n&gt; software and sufficient coverage with test cases that <br/>\n&gt; consider the external contracts only. What I say is that one <br/>\n&gt; cannot go beyond a certain level of quality, i.e. below a <br/>\n&gt; certain MTBF, without implementation-aware test cases. As <br/>\n&gt; long as your &quot;sufficiently stable&quot; is below that level, <br/>\n&gt; everything&#39;s fine. My guess is that this can be achieved for <br/>\n&gt; most application fields. However, I&#39;m also guessing that one <br/>\n&gt; can be testing more efficiently (less testing effort for same <br/>\n&gt; quality) with looking at the implementation than without <br/>\n&gt; looking at it.<br/>\n<br/>\n </span></blockquote>Ok.  I am not guessing.  What I posted are my observations on<br/>\nthe way I develop.  With sufficiently componentized software,<br/>\nyour only contract that you can *trust* is the external contracts.<br/>\nIf you ever code the the internal contracts, using assumptions<br/>\nthat may not hold up in future versions, then you will *always*<br/>\nintroduce bugs into your system.  Those bugs will manifest themselves<br/>\nin the MTBF scenario above.<br/>\n<br/>\nThe difference between what you are describing and what I do<br/>\ncan be overcome by the quality of the contracts used to describe<br/>\nthe interface.  For example, if the interface to the object requires<br/>\nthat methods are called in a certain order, you have to test that<br/>\nthey are.  I have created Mock Objects that masquerade as one of<br/>\nthese types of objects and then test that an exception is thrown<br/>\nwhen the order is violated.  That is an external contract--not<br/>\nan internal one.<br/>\n<br/>\nThe contracts which are internal, and therefore fragile are tests<br/>\nfor external artifacts or internal state that does not affect the<br/>\nexternal contract.  For example, if we had an object storage component<br/>\nthat stored an object to the filesystem we might write a test to<br/>\nmake sure the file was written with the correct name.  However<br/>\nif we changed the implementation to store many objects in one<br/>\nfile, the test becomes invalid even though the component lives<br/>\nup to its external contracts.  Even more radical would be if we<br/>\nchanged the storage medium completely.  As to internal state,<br/>\nif we know that this implementation has seven states (with a<br/>\nprotected accessor so that there is a hook for the test to get<br/>\nthe state), and we determine that one of those states is not<br/>\nnecessary--we invalidate the test when we remove the state.<br/>\n<br/>\nMy point is this: the external contracts have to be strong enough<br/>\nto provide standard guarantees to all clients of the code.  Those<br/>\nguarantees are well documented (usually in the javadocs).  This frees<br/>\nyou to change the implementation details without worrying about<br/>\nbreaking the rest of the system.  If, by using the external contracts<br/>\nof the system, we can break a piece of code, then we add the testcase<br/>\nthat reenacts that scenario so that we catch it as a regression test.<br/>\n<br/>\nThe test writing process becomes iterative because it is practically<br/>\nimpossible to know every testcase ahead of time.  The initial testcases<br/>\nwill excersize the known contracts and is a simple sanity check.  The<br/>\nmore detailed ones come later.<br/>\n<br/>\nI have two examples of this approach--which works.<br/>\n<br/>\n1) Buffer<br/>\n<br/>\nAvalon Excalibur Collections sub-sub-project has a new class of<br/>\ncollection called a Buffer.  There are several reasons to use a<br/>\nList as a Buffer, but we found we could optimize the List even<br/>\nmore if we did not provide indexed access to the objects in the<br/>\nbuffer (which is not the point of a buffer).  We wrote the<br/>\ntestcases to ensure what we put in is what we got out.  However,<br/>\nsomeone uncovered that under a specific scenario that the buffer<br/>\nwould lose an object.  I asked that person to give me a testcase<br/>\ndemonstrating the phenomenon.  The testcase did not make any<br/>\nassumptions to the internals of the Buffer!  It was by the normal<br/>\nuse case that the problem showed up.  It turned out to be a bug<br/>\nin the resizing algorithm for the buffer.  We incorporated the<br/>\ntestcase into the normal testing.  That bug will not reappear.<br/>\n<br/>\n2) CLI<br/>\n<br/>\nAvalon Excalibur CLI sub-sub-project has a set of classes that<br/>\nparse the command line arguments in an easy manner.  The utility<br/>\nallows you to iterate through the commands with a switch to set<br/>\nthe parameters.  However, someone found that with a certain<br/>\ncombination of command line parameters the CLI package went into<br/>\nan infinite loop.  We added the testcase, and found the bug in<br/>\nshort order.<br/>\n<br/>\nThat is why I maintain that you can have sufficient testing<br/>\nwithout excercizing the internals of a piece of code.  There are<br/>\ntwo axioms that you have to use in order to make the approach<br/>\nsuccessful:<br/>\n<br/>\n* NEVER assume anything about the internals.  Any code that uses<br/>\n  assumptions _*will*_ break.<br/>\n<br/>\n* USE sufficiently strong external contracts to ensure the proper<br/>\n  usage of a type of object.  The contracts should be loose enough<br/>\n  to encourage different implementation details, but strong enough<br/>\n  to be quantifiably tested.</div>", 
    "prevInTime": 4879, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1020693825", 
    "canDelete": false, 
    "nextInTopic": 4881, 
    "prevInTopic": 4878, 
    "headers": {
        "inReplyToHeader": "PDAwMGQwMWMxZjNmZCQyNDQ1OTU2MCQ0NmVjOTAzZUBoYWliYWNoPg==", 
        "messageIdInHeader": "PDAwMDYwMWMxZjUwNiRkOTA0ZTRiMCRhYzAwYThjMEBHYWJyaWVsPg=="
    }
}