{
    "numMessagesInTopic": 55, 
    "nextInTime": 13531, 
    "senderId": "3GeEiNXQDrV1w_XCbnTF4T8VszX8uzhgJEL4TyGzk2gEPAQztya4aVv-7sel4WGwNG2B0Ldl9rlpmORXl3TFVJp3E7CyqJXRDw", 
    "systemMessage": false, 
    "subject": "RE: [junit] Re: DbUnit & ORM", 
    "from": "John Smith &lt;haefeleuser@...&gt;", 
    "authorName": "John Smith", 
    "msgSnippet": "... J.B. Rainsberger wrote in his book that there are some developers who prefer to test the real thing (Integration Test) and other developers prefer to use", 
    "msgId": 13530, 
    "profile": "haefeleuser", 
    "topicId": 13451, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 174752849, 
    "messageBody": "<div id=\"ygrps-yiv-1116807017\">--- Cedric Beust &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:cbeust@...\">cbeust@...</a>&gt; wrote:<br/>\n<blockquote><span title=\"ireply\"> &gt; &gt; From: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a><br/>\n&gt; [mailto:<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>] On <br/>\n&gt; Don&#39;t get me wrong, I&#39;m not opposed to the idea of<br/>\n&gt; mock objects, but it<br/>\n&gt; seems to me that if you want to do more than unit<br/>\n&gt; testing with JUnit (which<br/>\n&gt; is a mistake in my opinion), you are *forced* to use<br/>\n&gt; mock objects.  It&#39;s<br/>\n&gt; just the only way to solve this problem.<br/>\n&gt; <br/>\n&gt; Mock objects are a fine solution if you have other<br/>\n&gt; alternatives and after<br/>\n&gt; you considered them all, mock objects came out as<br/>\n&gt; the best solution, but<br/>\n&gt; they come at a price (well, two prices:  the one I<br/>\n&gt; just mentioned and the<br/>\n&gt; fact that you need to maintain two parallel<br/>\n&gt; hierarchies).<br/>\n<br/>\n </span></blockquote>J.B. Rainsberger wrote in his book that there are some<br/>\ndevelopers who prefer to test the &quot;real thing&quot;<br/>\n(Integration Test) and other developers prefer to use<br/>\nMock Objects. I think he wrote in his book that he<br/>\nprefers what he calls &quot;Programmer Tests&quot; or &quot;Object<br/>\nTests&quot;.<br/>\n<br/>\nWe have to use mock objects. Our tests are very data<br/>\ndriven. It would take too much time to set up the test<br/>\ndata for each test. Besides this, it would be too much<br/>\nwork for a test. So we started to use mock objects. We<br/>\ndon&#39;t want to test the public methods which the method<br/>\nunder test uses indirectly, because they must have<br/>\ntheir own tests. We don&#39;t need to test these methods<br/>\nagain indirectly. The main reason for not doing it is<br/>\nbecause it takes too much time (programming and<br/>\nperformance).<br/>\n<br/>\nFor example, we have a service called<br/>\n&quot;SupplierArticleInformation.getReplacementTime(...)&quot;.<br/>\nThe real object needs a lot of data in the database to<br/>\noperate. If I use a mock object for<br/>\nSupplierArticleInformation I don&#39;t have to create all<br/>\nthat data. I simply manipulate the method to return a<br/>\nvalue without looking into the database.<br/>\n<br/>\nThis makes tests run much faster, which especially in<br/>\nbig projects like ours is very important. And the<br/>\ntests are easier to understand and maintain. Some<br/>\npeople think &quot;one dataset for all tests&quot; would solve<br/>\nthe problem, but it wouldn&#39;t in my opinion. This would<br/>\nresult in an error prone &quot;Spaghetti test data set&quot;. If<br/>\nall tests are based on this &quot;one dataset for all<br/>\ntests&quot;, then modifying these dataset for new tests can<br/>\nbreak existing tests. The dataset would become more<br/>\nand more unpredictable and thus unmaintainable.<br/>\n<br/>\nI only looked shortly at EasyMock. It doesn&#39;t require<br/>\nto create mock object classes because it uses the Java<br/>\nProxy. This is better than to write or code generate<br/>\nmock object classes.<br/>\n<br/>\nSo for applications which are heavily data driven,<br/>\nmock objects provide a lot of benefit in my eyes.<br/>\n<br/>\nIf the unit tests are good, then I think only few<br/>\nerrors can occur. A pragmatic test suite doesn&#39;t test<br/>\neverything. So maybe we could say that we don&#39;t<br/>\nautomate integration tests? I am just at the beginning<br/>\nof thinking about the importance of integration tests.<br/>\nThis is my first (radical) idea...<br/>\n<br/>\nCedric, I didn&#39;t examine TestNG yet. So you maybe have<br/>\nimplemented my suggestion already. I want to suggest<br/>\nto support ignoring tests. Like: 1 test failed, 10<br/>\ntests skipped, 2 tests ignored. Sometimes you want a<br/>\ntest to set to ignore because all tests need to pass.<br/>\nYou can comment it, but then you might forget about<br/>\nit. So I think a test framework should provide support<br/>\nfor ignoring tests.<br/>\n<br/>\n<br/>\n\t\t<br/>\nYahoo! Mail<br/>\nStay connected, organized, and protected. Take the tour:<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://tour.mail.yahoo.com/mailtour.html\">http://tour.mail.yahoo.com/mailtour.html</a></div>", 
    "prevInTime": 13529, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1116226595", 
    "canDelete": false, 
    "nextInTopic": 13532, 
    "prevInTopic": 13529, 
    "headers": {
        "inReplyToHeader": "NjY2Nw==", 
        "messageIdInHeader": "PDIwMDUwNTE2MDY1NjM1LjQwNDM4LnFtYWlsQHdlYjYwMDE5Lm1haWwueWFob28uY29tPg=="
    }
}