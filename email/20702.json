{
    "numMessagesInTopic": 7, 
    "nextInTime": 20703, 
    "senderId": "DmEIqWGJW4-aEXT97OG3SJ-FfJ8Q6hp52eBnp9KxFpJoeO71CNt9EChwF8X0hcOffybC6rBvca0LTP7ZqqRolki5i2fxiG1j2m0nd46qqGhmldQm", 
    "systemMessage": false, 
    "subject": "Re: [junit] Newbie wants to take some JUnit group. Some basic questions.", 
    "from": "&quot;Joakim Ohlrogge&quot; &lt;joakim.ohlrogge@...&gt;", 
    "authorName": "Joakim Ohlrogge", 
    "msgSnippet": "Hi, The problems you describe are problems that are common to run into when unittesting. I found for me that things started to become easier when I finally let", 
    "msgId": 20702, 
    "profile": "j0hlrogge", 
    "topicId": 20700, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 261856052, 
    "messageBody": "<div id=\"ygrps-yiv-1911151216\">Hi,<br/>\n<br/>\nThe problems you describe are problems that are common to run into<br/>\nwhen unittesting. I found for me that things started to become easier<br/>\nwhen I finally let go and let my tests drive the design. When I say<br/>\ndrive the design I don&#39;t mean &quot;let the tests open up my current<br/>\ndesign&quot;. I find that when I let the tests drive I am pushed to find<br/>\nmore abstractions in order to test. For instance in your ftp example<br/>\nyou can see it as anything that gives you a stream (not saying that<br/>\nthis is the best way to go in your particular case but for the sake of<br/>\nillustrating). While the ftp connection will need stuff like username,<br/>\npassword and some URL to give you the stream, to some part of the code<br/>\nit is just a stream. That part of the code can be tested with any<br/>\nstream, like ByteArray[Input/Output]Stream.<br/>\n<br/>\nYour schedule mechanism, like cron, will send an event at a given<br/>\ntime. To some part of the code that is just an event that was<br/>\ntriggered by something, if it is actually a cron-job then the event<br/>\nmight be the application-start. My point is, the event can be<br/>\ntriggered by whatever you like, including your unittests and your code<br/>\ndoesn&#39;t need to know (for the most part).<br/>\n<br/>\nThe actual creation of the FTP stream might require some parameters<br/>\nthat may be read from a configurationfile, the commandline or<br/>\nwhatever. So to some factory of ftp-connections they are relevant and<br/>\nmay be injected or read but to other parts of the system it&#39;s just a<br/>\nfactory (or context, or...).<br/>\n<br/>\nI find that asking the question, &quot;what does this code not have to know<br/>\nabout?&quot; helps me.<br/>\n<br/>\nI know that what I wrote is not rocket-science and that I&#39;m probably<br/>\nkicking in open doors but I thought in the worst case I would be the<br/>\nonly one learning something by kicking them in.<br/>\n<br/>\nHope this helps anyone.<br/>\n/J<br/>\n<br/>\n<blockquote><span title=\"qreply\"> On Mon, Jul 21, 2008 at 9:18 PM, serethos_0 &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:Serethos@...\">Serethos@...</a>&gt; wrote:<br/>\n&gt; Hello!<br/>\n&gt;<br/>\n&gt; I am an quite experienced programmer but new to the philosophy of unit<br/>\n&gt; testing. An issue I want to change.<br/>\n&gt; I read some articles and took some orientation on Frank Westphal&#39;s<br/>\n&gt; very good book about that topic. But in practice, I always run into<br/>\n&gt; similar problems, which seem to disturb my view of unit testing. So<br/>\n&gt; some thought and questions I would like to discuss.<br/>\n&gt;<br/>\n&gt; 1. Recently I read that a unit test is no one if you have to touch<br/>\n&gt; network, db or filesystem. I understand the point that these accesses<br/>\n&gt; really can slow the tests down and usually need extra work of<br/>\n&gt; configuration, but how to avoid this?<br/>\n&gt; An example of my daily work. I have quite a common task: Fetch some<br/>\n&gt; xmls from an ftp server, parse the content and map it into db and vice<br/>\n&gt; versa. So the business logic is quite thin. More important is good<br/>\n&gt; exception handling and the transport of all data in the right structures.<br/>\n&gt;<br/>\n&gt; Actually the slowdown of a real ftp transport and the configuration<br/>\n&gt; and injection overhead of the db-connection is a major drawback. But<br/>\n&gt; on the other hand I see no good way to mock the behaviour of these<br/>\n&gt; endpoints.<br/>\n&gt; I could try to mock a database, but how to test, if an sql-statement<br/>\n&gt; is correct (especially for a wider range of queries)?<br/>\n&gt; It also is a very hard work to write stubs or mocks, which can answer<br/>\n&gt; with all error-states an ftp-server/network can generate (timeout,<br/>\n&gt; access denied, authentication etc) to test the correct error handling<br/>\n&gt; of my code.<br/>\n&gt;<br/>\n&gt; 2. Another question points to a basic principle of unit testing: the<br/>\n&gt; opening of a class in small and public methods. I see an advantage in<br/>\n&gt; the possibility to inject every aspect of a class (manually or e.g.<br/>\n&gt; via spring) and the code can benefit from a better readability through<br/>\n&gt; a chain of self-explanatory method calls.<br/>\n&gt; But in some cases I want to hide implementation details from the user.<br/>\n&gt; Taking my Importer/Exporter example a second time, it is more a cron<br/>\n&gt; script than an application: Doing a defined job in a robust and<br/>\n&gt; understandable manner but neither designed as a basis for wide<br/>\n&gt; enhancements nor for ultimate flexibility.<br/>\n&gt; So there are methods which start the whole work of an importer over<br/>\n&gt; the whole lifecycle (connect, fetch data, map data etc). Methods,<br/>\n&gt; which are necessary for getting the object in a usable state (e.g.<br/>\n&gt; connection established) are hidden away. To ensure that there must be<br/>\n&gt; the correct state before executing the main task I can lead the user<br/>\n&gt; with parameterized constructors (e.g. MyImporter(host, port)).<br/>\n&gt; To say it more generally I think that it is a common way to restrict<br/>\n&gt; the use of classes which need to be handled in correct order because<br/>\n&gt; of their state. This saves a lot of additional exception handling<br/>\n&gt; (e.g. executing before connecting).<br/>\n&gt; But following this thought it gets very hard to isolate testing units.<br/>\n&gt; Even when I separate the tasks within the class to units (connecting,<br/>\n&gt; disconnecting etc) they would be not accessible and would need to be<br/>\n&gt; tested from within.<br/>\n&gt;<br/>\n&gt; This is only a very simple and not a perfect example but I think my<br/>\n&gt; point should be clear. I hope that some of you take some time to read<br/>\n&gt; it. I really would appreciate some thoughts!<br/>\n&gt;<br/>\n&gt; <br/>\n<br/>\n<br/>\n<br/>\n-- <br/>\n-----------------------------------------------------<br/>\nJoakim Ohlrogge<br/>\nAgical AB<br/>\nVästerlånggatan 79, 2 tr<br/>\n111 29 Stockholm, SWEDEN<br/>\n<br/>\nMobile: +46-708-754004<br/>\nBlog: johlrogge.wordpress.com<br/>\nE-mail: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:joakim.ohlrogge@...\">joakim.ohlrogge@...</a> </span></blockquote></div>", 
    "prevInTime": 20701, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1216713381", 
    "canDelete": false, 
    "nextInTopic": 20703, 
    "prevInTopic": 20701, 
    "headers": {
        "inReplyToHeader": "PGc2Mm5lYis1NWl0QGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PGI5ZWU1ZTQxMDgwNzIyMDA1NnIzMWU2YTcyMXNkODgwYTdkYzg5ODM2NDI1QG1haWwuZ21haWwuY29tPg==", 
        "referencesHeader": "PGc2Mm5lYis1NWl0QGVHcm91cHMuY29tPg=="
    }
}