{
    "numMessagesInTopic": 80, 
    "nextInTime": 18630, 
    "senderId": "9ujv8hVj51NMmE_RteLDx9p6fdZmsgmErRxOj2dFwfB5iw3Uf_N4KBdxpiCoMvsxUwzdO8LCIYjzoJKFysxLJdv0nu88EQ", 
    "systemMessage": false, 
    "subject": "Re: [junit] 100%% Method Testing and Generating Unit Tests", 
    "from": "Ole Ersoy &lt;ole_ersoy@...&gt;", 
    "authorName": "Ole Ersoy", 
    "msgSnippet": "CÃ©dric, Excellent example old Chap. So a branch is something that takes the code down a certain path. if ( a  10 ) is a branch. I think we agree that it s", 
    "msgId": 18629, 
    "profile": "ole_ersoy", 
    "topicId": 18605, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 98908154, 
    "messageBody": "<div id=\"ygrps-yiv-2066577628\">CÃ©dric,<br/>\n<br/>\nExcellent example old Chap.<br/>\n<br/>\nSo a branch is something that takes the code down a<br/>\ncertain path.<br/>\n<br/>\nif ( a &gt; 10 )<br/>\n<br/>\nis a branch.<br/>\n<br/>\nI think we agree that it&#39;s possible to enumerate the<br/>\nentire set of branches.<br/>\n<br/>\nSo for instance <br/>\n<br/>\na &gt; 10<br/>\n<br/>\na &lt; 10 <br/>\n<br/>\na = 10<br/>\n<br/>\nrepresents 3 different paths.<br/>\n<br/>\nAnd if I could switch it up <br/>\nwith something like this instead:<br/>\n<br/>\na &gt; 10 && b &lt; 5<br/>\n<br/>\na &lt; 10 <br/>\n<br/>\na = 10<br/>\n<br/>\nI could enumerate the test set like I did for my<br/>\nsimple example by <br/>\nassuming edge points / the max allowable values for a<br/>\nand b (Incidentally in my simple example I did not<br/>\ntest values greater than the max allowable values,<br/>\nwhich I should have)<br/>\n<br/>\nSo now we have test input data set:<br/>\n<br/>\na                     b<br/>\n-------------------------------------<br/>\n11                    4<br/>\n9                     4<br/>\n10                    4<br/>\naBiggest              4<br/>\naBiggest+1            4<br/>\naSmallest             4<br/>\naSmallest-1           4<br/>\n<br/>\n11                    5<br/>\n9                     5<br/>\n10                    5<br/>\naBiggest              5<br/>\naBiggest+1            5<br/>\naSmallest             5<br/>\naSmallest-1           5<br/>\n<br/>\n11                    bMax<br/>\n9                     bMax<br/>\n10                    bMax<br/>\naMax                  bMax<br/>\naMax+1                bMax<br/>\naMin                  bMax<br/>\naMin-1                bMax<br/>\n<br/>\netc. with bMin and bMin-1<br/>\n<br/>\nThat&#39;s not so bad...<br/>\n<br/>\nYour ipod can do that in 5 nanoseconds.<br/>\n<br/>\nBut these are just the inputs.<br/>\n<br/>\nWe also have to generate the outputs.<br/>\n<br/>\nWhich is also easy to do and we would use the <br/>\nmethod to calculate them.  This assumes that there<br/>\nare no constraints on the output.  Lets just say that<br/>\nthe output is just an int<br/>\nc.<br/>\n<br/>\nSuppose c can only be 1 or 2.<br/>\n<br/>\nWell, that implies further constraints on the inputs,<br/>\nso we have to go back and reconstrain.<br/>\n<br/>\nHowever in this example c can be anything, so we just<br/>\ncalculate the possible outputs.<br/>\n<br/>\nThen we run it through testing.<br/>\n<br/>\nNow we could test <br/>\n<br/>\na = 22<br/>\na = 23<br/>\n<br/>\netc.<br/>\n<br/>\nbut that would be silly since we assume that<br/>\nsince we passed values through our enumerated branch<br/>\nlist, that represent the beginning and end of the<br/>\nrange of allowed values and even the points external<br/>\nto that range, we covered everything.<br/>\n<br/>\nSo now I can look at my generated test code<br/>\nand see all the inputs, the expected outputs,<br/>\nand run the tests.<br/>\n<br/>\nI personally would like this since it does a lot of<br/>\nthe grunt work for me.<br/>\n<br/>\nIt&#39;s possible to have a method<br/>\nwith a gazillion variables and paths...<br/>\n<br/>\nbut I would think that that would be a ripe case for<br/>\nrefactoring, because it&#39;s tricky to test :-)<br/>\n<br/>\nAs a matter of fact...it would be nice to have<br/>\nsomething that enumerates the branches and generates a<br/>\nreport on which methods has a number of branches over<br/>\na certain limit...for code refactoring and maintenance<br/>\npurposes.<br/>\n<br/>\nCheers,<br/>\n- Ole<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n--- CÃ©dric Beust â  &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:cbeust@...\">cbeust@...</a>&gt; wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; On 1/3/07, Ole Ersoy &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:ole_ersoy@...\">ole_ersoy@...</a>&gt; wrote:<br/>\n&gt; &gt;<br/>\n&gt; &gt; We first have to agree on what 100% means.<br/>\n&gt; &gt;<br/>\n&gt; &gt; I provided a very simple example in the earlier<br/>\n&gt; post.<br/>\n&gt; &gt;<br/>\n&gt; &gt; The example gives a 100% tested tested method<br/>\n&gt; example,<br/>\n&gt; &gt; given that the assumptions hold.<br/>\n&gt; &gt;<br/>\n&gt; &gt; This example can be entirely generated using<br/>\n&gt; DataType<br/>\n&gt; &gt; meta data.<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; Yes, but your example is too simple since it only<br/>\n&gt; contains one branch (most<br/>\n&gt; examples extolling the virtues of code coverage have<br/>\n&gt; this flaw :-)).<br/>\n&gt; <br/>\n&gt; 100% coverage means you should cover all the<br/>\n&gt; possible branches of your code,<br/>\n&gt; which is impossible to achieve in practice.  Even<br/>\n&gt; when code coverage tools<br/>\n&gt; report 100% coverage (hardly ever happens in my<br/>\n&gt; experience), they are still<br/>\n&gt; lying to you.<br/>\n&gt; <br/>\n&gt; Consider the following simple code:<br/>\n&gt; <br/>\n&gt; public URL createUrl(int a, int b) {<br/>\n&gt; <br/>\n&gt; try {<br/>\n&gt;   if (a == 0 || b == 0) {<br/>\n&gt;   }<br/>\n&gt; <br/>\n&gt;   if (c == 0 && d == 0) {<br/>\n&gt;   }<br/>\n&gt; }<br/>\n&gt; catch(IOException ex) {<br/>\n&gt; }<br/>\n&gt; catch(MalformedURLException ex) {<br/>\n&gt; }<br/>\n&gt; <br/>\n&gt; 100% coverage for this code means something like<br/>\n&gt; 2*2*2*2 = 16 test cases<br/>\n&gt; (I&#39;m approximating, but you get the idea).<br/>\n&gt; <br/>\n&gt; Do you really feel it&#39;s useful to write 16 test<br/>\n&gt; cases for these 6 lines of<br/>\n&gt; code?<br/>\n&gt; <br/>\n&gt; Wouldn&#39;t you be better off black-box testing this<br/>\n&gt; function instead, and<br/>\n&gt; ignore the screams of complaint from your code<br/>\n&gt; coverage tool?<br/>\n&gt; <br/>\n&gt; -- <br/>\n&gt; Cédric<br/>\n&gt; <a rel=\"nofollow\" target=\"_blank\" href=\"http://testng.org\">http://testng.org</a><br/>\n&gt; <br/>\n&gt; <br/>\n&gt; [Non-text portions of this message have been<br/>\n&gt; removed]<br/>\n&gt; <br/>\n&gt; <br/>\n<br/>\n<br/>\n </span></blockquote>__________________________________________________<br/>\nDo You Yahoo!?<br/>\nTired of spam?  Yahoo! Mail has the best spam protection around <br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://mail.yahoo.com\">http://mail.yahoo.com</a></div>", 
    "prevInTime": 18628, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1167856444", 
    "canDelete": false, 
    "nextInTopic": 18630, 
    "prevInTopic": 18628, 
    "headers": {
        "inReplyToHeader": "PGI4NmI2YTljMDcwMTAzMTEzMW8xM2QyNGYxZXFjNzQ3ZWVlODRhNTI0N2NlQG1haWwuZ21haWwuY29tPg==", 
        "messageIdInHeader": "PDkzMDQ4OC43MTIwLnFtQHdlYjYwNzE1Lm1haWwueWFob28uY29tPg=="
    }
}