{
    "numMessagesInTopic": 13, 
    "nextInTime": 23637, 
    "senderId": "b7XDNiZOGrJkBm1IjcHgdV8J__rh-XRq5rQWV1AEVgBt9oWLXxQUV9Bl9a6ITkWfHXtWZc9aaYpfhebpGSb7gHdshoFlqhAopytiINrpmbLcyVi_xcfvQ7o", 
    "systemMessage": false, 
    "subject": "Feature request: @Assumes", 
    "from": "Stephen Connolly &lt;stephen.alan.connolly@...&gt;", 
    "authorName": "Stephen Connolly", 
    "msgSnippet": "Note: I have also posted this to junit-devel@lists.sourceforge.net but I think that wider input could be beneficial Consider the case where you are testing a", 
    "msgId": 23636, 
    "profile": "stephenalanconnolly", 
    "topicId": 23636, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 458231986, 
    "messageBody": "<div id=\"ygrps-yiv-790277693\">Note: I have also posted this to <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit-devel@...\">junit-devel@...</a> but<br/>\nI think that wider input could be beneficial<br/>\n<br/>\nConsider the case where you are testing a List class...<br/>\n<br/>\nwe have<br/>\n<br/>\npublic class ListTest {<br/>\n<br/>\n @Test<br/>\n public void newListIsEmpty() {<br/>\n   assertThat(new List().isEmpty(), is(true);<br/>\n }<br/>\n<br/>\n @Test<br/>\n public void newListHasSizeZero() {<br/>\n   assertThat(new List().size(), is(0));<br/>\n }<br/>\n<br/>\n @Test<br/>\n public void addPutsAnElementIntoAnEmptyList() {<br/>\n   List l = new List();<br/>\n   l.add(new Object());<br/>\n   assertThat(l.isEmpty(), is(false));<br/>\n }<br/>\n<br/>\n @Test<br/>\n public void addIncreasesSizeOfPopulatedListByOne() {<br/>\n   List l = new List();<br/>\n   l.add(new Object());<br/>\n   int s = l.size();<br/>\n   l.add(new Object());<br/>\n   assertThat(l.size(), is(s + 1));<br/>\n }<br/>\n<br/>\n}<br/>\n<br/>\nWe now want to add some tests of the delete functionality... but the<br/>\nreality is that until/unless some of the preceding tests are passing,<br/>\nthe tests for delete are meaningless. We could have a perfectly<br/>\nfunctional List.delete() method but until such time as the above tests<br/>\nare passing, there is no way to tell that the method does not work.<br/>\n<br/>\nNow I could code my tests like such<br/>\n<br/>\n @Test<br/>\n public void deleteIsANoOpOnEmptyList() {<br/>\n   List l = new List();<br/>\n   assumeThat(l.isEmpty(), is(true));<br/>\n   l.delete(new Object());<br/>\n }<br/>\n<br/>\nBut all that I am doing is repeating code from the preceding tests,<br/>\nhaving changed all those tests&#39; assertThat(...)s into assumeThat(...)s<br/>\n<br/>\nThat does not seem agile to me, copy & paste & search & replace... ban<br/>\ncode smell there<br/>\n<br/>\nI would much rather be able to annotate the tests with an @Assumes<br/>\nannotation that indicates that the test assumes that the specified<br/>\ntests are passing, e.g.<br/>\n<br/>\n @Test<br/>\n @Assumes(&quot;newListIsEmpty&quot;)<br/>\n public void deleteIsANoOpOnEmptyList() {<br/>\n   List l = new List();<br/>\n   l.delete(new Object());<br/>\n }<br/>\n<br/>\n @Test<br/>\n @Assumes({&quot;newListIsEmpty&quot;,&quot;addPutsAnElementIntoAnEmptyList&quot;)<br/>\n public void deleteRemovesAnElement() {<br/>\n   List l = new List();<br/>\n   Object o = new Object();<br/>\n   l.add(o);<br/>\n   l.delete(o);<br/>\n   assertThat(l.isEmpty(), is(true));<br/>\n }<br/>\n<br/>\nIn fact in my initial example of tests, there are some additional<br/>\nassumptions that I didn&#39;t make explicit<br/>\n<br/>\n<br/>\n @Test<br/>\n @Assumes(&quot;newListIsEmpty&quot;)<br/>\n public void addPutsAnElementIntoAnEmptyList() {<br/>\n   ...<br/>\n }<br/>\n<br/>\nand<br/>\n<br/>\n @Test<br/>\n @Assumes({&quot;newListIsEmpty&quot;,&quot;addPutsAnElementIntoAnEmptyList&quot;)<br/>\n public void addIncreasesSizeOfPopulatedListByOne() {<br/>\n   ...<br/>\n }<br/>\n<br/>\nNow you could get some of this functionality via a TestRule...<br/>\n<br/>\nYou could watch tests to see if they pass, and skip tests annotated<br/>\nwith the annotation if assumed functionality is failing, but that<br/>\nwould result in sporadic failures of, e.g. deleteRemovesAnElement<br/>\nbecause of the failing newListIsEmpty being executed _after_<br/>\ndeleteRemovesAnElement rather than before.<br/>\n<br/>\nThe simple point is that the test result of deleteRemovesAnElement is<br/>\nmeaningless until its assumptions are true, and while I could code the<br/>\nassumptions with assumeThat(..)s C&P&S&R is even worse than C&P.<br/>\n<br/>\nAnother alternative to @Assumes would be to invoke the assumed<br/>\nmethod(s) at the start of the test, e.g.<br/>\n<br/>\n @Test<br/>\n public void deleteRemovesAnElement() {<br/>\n   newListIsEmpty(); // verify assumed functionality<br/>\n   addPutsAnElementIntoAnEmptyList();  // verify assumed functionality<br/>\n   ...<br/>\n }<br/>\n<br/>\nThat gets rid of the C&P&S&R, but there are two issues with that:<br/>\n<br/>\n 1. We have to manually invoke any setup/tearDown methods, including<br/>\nall those of the rules that the test class has... very messy<br/>\n<br/>\n 2. The test fails when the assumed test fails. In actuality we can<br/>\nsay nothing at all about whether deleteRemovesAnElement if a<br/>\nnewListIsEmpty is not passing... yes we could code the test<br/>\ndifferently, but that is just moving our assumptions somewhere else.<br/>\n<br/>\nI am sure that there are others out there who feel there is a point 3...<br/>\n<br/>\n 3. We already ran those tests why waste time running them again?<br/>\n<br/>\nWell the answer to 3 is that these are UNIT tests which should be very<br/>\nfast, so what is the harm...<br/>\n<br/>\nSo, in my view, best practice unit testing needs the ability to mark<br/>\ntests as assuming that other tests are passing, so that those tests<br/>\ncan be skipped when the assumptions are known to be failing or<br/>\nskipped. [This is a deliberately loaded criteria... if the<br/>\norg.junit.runner.Request does not include the assumed test, then that<br/>\ntest is neither known failing or known skipped, so we can run the test<br/>\nand output a warning that the failure may be because of assumed<br/>\nfunctionality... the use case of executing one and only one test<br/>\nrepeatedly until you get that test passing]<br/>\n<br/>\nThe annotation would have implications on test sorting, as any assumed<br/>\ntests would have to always happen before the assuming tests (as long<br/>\nas the assumed tests are in the org.junit.runner.Request)<br/>\n<br/>\nAlso might have to be two annotations, e.g.<br/>\n<br/>\n@Assumes(methodNames)<br/>\n@AssumesClasses(classes)<br/>\n<br/>\nthough in my view the @AssumesClasses is less critical, as these are<br/>\nUNIT tests and each test class should be independent to a large<br/>\nextent. However I am willing to consider that some people may have<br/>\nmany test classes for one class under test, one test class containing<br/>\nall the tests of the constructors, another testing the Add methods,<br/>\netc. in which case an @AssumesClasses annotation makes sense.<br/>\n<br/>\nWhere tests contain a circular dependency, fail/error both tests<br/>\n<br/>\nOk, let the critique begin!<br/>\n<br/>\n-Stephen<br/>\n<br/>\nP.S.<br/>\n<br/>\nI pinged Kent with an earlier version of this idea... but I think that<br/>\nhe missed the point about eliminating C&P&S&R that this feature would<br/>\nprovide because I didn&#39;t frame the idea correctly...<br/>\n<br/>\n---------- Forwarded message ----------<br/>\nFrom: &quot;Kent Beck&quot;<br/>\nDate: 13 Sep 2011 17:11<br/>\nSubject: Re: JUnit and test dependencies<br/>\nTo: &quot;Stephen Connolly&quot;<br/>\n<br/>\nStephen,<br/>\n<br/>\nThank you for articulating your idea so clearly. The short answer is that<br/>\nno, we don&#39;t plan to support dependencies. If I have tests that are slow<br/>\nenough that I care about dependencies, my most productive option is<br/>\ngenerally to work on the design of the software until the tests are fast<br/>\nenough that I no longer care. That said, my voice is only one of many. The<br/>\nlonger answer is that I encourage you to post your idea on the JUnit mailing<br/>\nlist for community discussion.<br/>\n<br/>\nRegards,<br/>\n<br/>\nKent<br/>\n<br/>\n<blockquote><span title=\"qreply\"> On Sep 13, 2011, at 8:32 AM, Stephen Connolly wrote:<br/>\n<br/>\n&gt; Kent,<br/>\n&gt;<br/>\n&gt; Are there any plans for JUnit to support some test dependencies, such as:<br/>\n&gt;<br/>\n&gt; public class OnlyRunTestsThatMakeSenseTest {<br/>\n&gt;<br/>\n&gt;  @Test<br/>\n&gt;  public void basicFunctionalityWorks() {<br/>\n&gt;    ...<br/>\n&gt;  }<br/>\n&gt;<br/>\n&gt;  @Test<br/>\n&gt;  @AssumesPasses(&quot;basicFunctionalityWorks&quot;)<br/>\n&gt;  public void advancedFunctionalityWorks() {<br/>\n&gt;    ...<br/>\n&gt;  }<br/>\n&gt;<br/>\n&gt;  @Test<br/>\n&gt;  @AssumesPasses(&quot;basicFunctionalityWorks&quot;)<br/>\n&gt;  public void basicFunctionalityWorksWithBevel() {<br/>\n&gt;    ...<br/>\n&gt;  }<br/>\n&gt;<br/>\n&gt;  @Test<br/>\n&gt;<br/>\n @AssumesPasses({&quot;basicFunctionalityWorksWithBevel&quot;,&quot;advancedFunctionalityWorks&quot;})<br/>\n&gt;  public void advancedFunctionalityWorksWithBevel() {<br/>\n&gt;    ...<br/>\n&gt;  }<br/>\n&gt;<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; In the above example, no matter what sorting is applied,<br/>\n&gt; basicFunctionalityWorks will always be run first, and the other three<br/>\n&gt; tests will only be run if basicFunctionalityWorks passed.<br/>\n&gt;<br/>\n&gt; I see the above being completely in the spirit of unit testing, the<br/>\n&gt; point with the above is that the @Before and @After&#39;s will be run<br/>\n&gt; around each method, you are just saying that there is no point even<br/>\n&gt; trying to test the advanced functionality when the basic functionality<br/>\n&gt; is broken, skip those tests which we know cannot pass. That allows the<br/>\n&gt; person writing advancedFunctionalityWorks to power through the setup<br/>\n&gt; that depends on the basic functionality and not have to litter their<br/>\n&gt; advanced test with asserts that are redundant because of the basic<br/>\n&gt; functionality. Those people who are relying on side-effects should<br/>\n&gt; really, for unit tests at least, be invoking the method who&#39;s<br/>\n&gt; side-effects they depend on directly within their test method, rather<br/>\n&gt; than relying on accidental ordering.<br/>\n&gt;<br/>\n&gt; Having said that, a second feature that I think would be good is<br/>\n&gt; something like a @RunAfter and/or @RunBefore which would ensure that<br/>\n&gt; the test method is run in sequence even if the before or after tests<br/>\n&gt; fail/are skipped. with @RunAfter and @RunBefore I still think the<br/>\n&gt; @Before and @After methods should be invoked in-between, this would be<br/>\n&gt; moving towards more of a general purpose testing framework as opposed<br/>\n&gt; to being unit-testing focused, but JUnit is just too good ;-)<br/>\n&gt;<br/>\n&gt; Thoughts?<br/>\n&gt;<br/>\n&gt; -Stephen </span></blockquote></div>", 
    "prevInTime": 23635, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1315994535", 
    "canDelete": false, 
    "nextInTopic": 23638, 
    "prevInTopic": 0, 
    "headers": {
        "inReplyToHeader": "PENBK25Qbk13YmZOdnhiaHFqV1Z5WFc3VUR0MlZNNVR6d1d6d0FpUkphSGtLcm5Iem14UUBtYWlsLmdtYWlsLmNvbT4=", 
        "messageIdInHeader": "PENBK25Qbk15UVB3X2htQjVQWmpZNXRPN0xkaFN2WEprYjdObjlKRlpyZUIxVnk1UDhvd0BtYWlsLmdtYWlsLmNvbT4=", 
        "referencesHeader": "PENBK25Qbk13YmZOdnhiaHFqV1Z5WFc3VUR0MlZNNVR6d1d6d0FpUkphSGtLcm5Iem14UUBtYWlsLmdtYWlsLmNvbT4="
    }
}