{
    "numMessagesInTopic": 13, 
    "nextInTime": 23643, 
    "senderId": "KS8NEIBAq7GUFTjsmq0wtnbC4RwAtS7mOaqpo8yEMGrjOxu4vnTQMIV5s_2nhlJGbg18XqR5fGW_pzqua3VNMxbHSxhWlBiJ2KmVlvAWqpx7aituq-kBw34", 
    "systemMessage": false, 
    "subject": "Re: Feature request: @Assumes", 
    "from": "Stephen Connolly &lt;stephen.alan.connolly@...&gt;", 
    "authorName": "Stephen Connolly", 
    "msgSnippet": "... As a proof of concept, implementing as a custom runner is fine, but ultimately it would need some hooks that can feed back to Request.sort(...) as, IIUC,", 
    "msgId": 23642, 
    "profile": "stephenalanconnolly", 
    "topicId": 23636, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 458231986, 
    "messageBody": "<div id=\"ygrps-yiv-2136442644\">On Wednesday, 14 September 2011, David Saff wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Stephen,<br/>\n&gt;<br/>\n&gt; I can see how this could be useful.  It shouldn&#39;t be too hard to try<br/>\n&gt; it out as a custom runner:<br/>\n&gt; - subclass BlockJUnit4ClassRunner<br/>\n&gt; - override computeTestMethods to order the methods based on assumptions<br/>\n&gt; - override methodBlock to notice when tests fail, and use that to mark<br/>\n&gt; assumption failures on later tests.<br/>\n&gt;<br/>\n&gt; Would you be interested in contributing something like this to<br/>\n&gt; junit.contrib?<br/>\n&gt;<br/>\n&gt;<br/>\n </span></blockquote>As a proof of concept, implementing as a custom runner is fine, but<br/>\nultimately it would need some hooks that can feed back to Request.sort(...)<br/>\nas, IIUC, that applies after the Runner&#39;s sorting and this would really be<br/>\nenforcing restrictions on the final order.<br/>\n<br/>\nWhere do I git clone and send the pull request for junit.contrib or is that<br/>\njust a package space in the standard junit git repo?<br/>\n<br/>\n-Stephen<br/>\n<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;   David Saff<br/>\n&gt;<br/>\n&gt; On Wed, Sep 14, 2011 at 6:02 AM, Stephen Connolly<br/>\n&gt; &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:stephen.alan.connolly@...\">stephen.alan.connolly@...</a> &lt;javascript:;&gt;&gt; wrote:<br/>\n&gt; &gt; Note: I have also posted this to <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit-devel@...\">junit-devel@...</a> but<br/>\n&gt; &gt; I think that wider input could be beneficial<br/>\n&gt; &gt;<br/>\n&gt; &gt; Consider the case where you are testing a List class...<br/>\n&gt; &gt;<br/>\n&gt; &gt; we have<br/>\n&gt; &gt;<br/>\n&gt; &gt; public class ListTest {<br/>\n&gt; &gt;<br/>\n&gt; &gt;  @Test<br/>\n&gt; &gt;  public void newListIsEmpty() {<br/>\n&gt; &gt;    assertThat(new List().isEmpty(), is(true);<br/>\n&gt; &gt;  }<br/>\n&gt; &gt;<br/>\n&gt; &gt;  @Test<br/>\n&gt; &gt;  public void newListHasSizeZero() {<br/>\n&gt; &gt;    assertThat(new List().size(), is(0));<br/>\n&gt; &gt;  }<br/>\n&gt; &gt;<br/>\n&gt; &gt;  @Test<br/>\n&gt; &gt;  public void addPutsAnElementIntoAnEmptyList() {<br/>\n&gt; &gt;    List l = new List();<br/>\n&gt; &gt;    l.add(new Object());<br/>\n&gt; &gt;    assertThat(l.isEmpty(), is(false));<br/>\n&gt; &gt;  }<br/>\n&gt; &gt;<br/>\n&gt; &gt;  @Test<br/>\n&gt; &gt;  public void addIncreasesSizeOfPopulatedListByOne() {<br/>\n&gt; &gt;    List l = new List();<br/>\n&gt; &gt;    l.add(new Object());<br/>\n&gt; &gt;    int s = l.size();<br/>\n&gt; &gt;    l.add(new Object());<br/>\n&gt; &gt;    assertThat(l.size(), is(s + 1));<br/>\n&gt; &gt;  }<br/>\n&gt; &gt;<br/>\n&gt; &gt; }<br/>\n&gt; &gt;<br/>\n&gt; &gt; We now want to add some tests of the delete functionality... but the<br/>\n&gt; &gt; reality is that until/unless some of the preceding tests are passing,<br/>\n&gt; &gt; the tests for delete are meaningless. We could have a perfectly<br/>\n&gt; &gt; functional List.delete() method but until such time as the above tests<br/>\n&gt; &gt; are passing, there is no way to tell that the method does not work.<br/>\n&gt; &gt;<br/>\n&gt; &gt; Now I could code my tests like such<br/>\n&gt; &gt;<br/>\n&gt; &gt;  @Test<br/>\n&gt; &gt;  public void deleteIsANoOpOnEmptyList() {<br/>\n&gt; &gt;    List l = new List();<br/>\n&gt; &gt;    assumeThat(l.isEmpty(), is(true));<br/>\n&gt; &gt;    l.delete(new Object());<br/>\n&gt; &gt;  }<br/>\n&gt; &gt;<br/>\n&gt; &gt; But all that I am doing is repeating code from the preceding tests,<br/>\n&gt; &gt; having changed all those tests&#39; assertThat(...)s into assumeThat(...)s<br/>\n&gt; &gt;<br/>\n&gt; &gt; That does not seem agile to me, copy & paste & search & replace... ban<br/>\n&gt; &gt; code smell there<br/>\n&gt; &gt;<br/>\n&gt; &gt; I would much rather be able to annotate the tests with an @Assumes<br/>\n&gt; &gt; annotation that indicates that the test assumes that the specified<br/>\n&gt; &gt; tests are passing, e.g.<br/>\n&gt; &gt;<br/>\n&gt; &gt;  @Test<br/>\n&gt; &gt;  @Assumes(&quot;newListIsEmpty&quot;)<br/>\n&gt; &gt;  public void deleteIsANoOpOnEmptyList() {<br/>\n&gt; &gt;    List l = new List();<br/>\n&gt; &gt;    l.delete(new Object());<br/>\n&gt; &gt;  }<br/>\n&gt; &gt;<br/>\n&gt; &gt;  @Test<br/>\n&gt; &gt;  @Assumes({&quot;newListIsEmpty&quot;,&quot;addPutsAnElementIntoAnEmptyList&quot;)<br/>\n&gt; &gt;  public void deleteRemovesAnElement() {<br/>\n&gt; &gt;    List l = new List();<br/>\n&gt; &gt;    Object o = new Object();<br/>\n&gt; &gt;    l.add(o);<br/>\n&gt; &gt;    l.delete(o);<br/>\n&gt; &gt;    assertThat(l.isEmpty(), is(true));<br/>\n&gt; &gt;  }<br/>\n&gt; &gt;<br/>\n&gt; &gt; In fact in my initial example of tests, there are some additional<br/>\n&gt; &gt; assumptions that I didn&#39;t make explicit<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt;  @Test<br/>\n&gt; &gt;  @Assumes(&quot;newListIsEmpty&quot;)<br/>\n&gt; &gt;  public void addPutsAnElementIntoAnEmptyList() {<br/>\n&gt; &gt;    ...<br/>\n&gt; &gt;  }<br/>\n&gt; &gt;<br/>\n&gt; &gt; and<br/>\n&gt; &gt;<br/>\n&gt; &gt;  @Test<br/>\n&gt; &gt;  @Assumes({&quot;newListIsEmpty&quot;,&quot;addPutsAnElementIntoAnEmptyList&quot;)<br/>\n&gt; &gt;  public void addIncreasesSizeOfPopulatedListByOne() {<br/>\n&gt; &gt;    ...<br/>\n&gt; &gt;  }<br/>\n&gt; &gt;<br/>\n&gt; &gt; Now you could get some of this functionality via a TestRule...<br/>\n&gt; &gt;<br/>\n&gt; &gt; You could watch tests to see if they pass, and skip tests annotated<br/>\n&gt; &gt; with the annotation if assumed functionality is failing, but that<br/>\n&gt; &gt; would result in sporadic failures of, e.g. deleteRemovesAnElement<br/>\n&gt; &gt; because of the failing newListIsEmpty being executed _after_<br/>\n&gt; &gt; deleteRemovesAnElement rather than before.<br/>\n&gt; &gt;<br/>\n&gt; &gt; The simple point is that the test result of deleteRemovesAnElement is<br/>\n&gt; &gt; meaningless until its assumptions are true, and while I could code the<br/>\n&gt; &gt; assumptions with assumeThat(..)s C&P&S&R is even worse than C&P.<br/>\n&gt; &gt;<br/>\n&gt; &gt; Another alternative to @Assumes would be to invoke the assumed<br/>\n&gt; &gt; method(s) at the start of the test, e.g.<br/>\n&gt; &gt;<br/>\n&gt; &gt;  @Test<br/>\n&gt; &gt;  public void deleteRemovesAnElement() {<br/>\n&gt; &gt;    newListIsEmpty(); // verify assumed functionality<br/>\n&gt; &gt;    addPutsAnElementIntoAnEmptyList();  // verify assumed functionality<br/>\n&gt; &gt;  &gt; ------------------------------------<br/>\n&gt; &gt;<br/>\n&gt; &gt; Yahoo! Groups Links<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; ------------------------------------<br/>\n&gt;<br/>\n&gt; Yahoo! Groups Links<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n<br/>\n<br/>\n </span></blockquote>[Non-text portions of this message have been removed]</div>", 
    "prevInTime": 23641, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1316030831", 
    "canDelete": false, 
    "nextInTopic": 23643, 
    "prevInTopic": 23640, 
    "headers": {
        "inReplyToHeader": "PENBQ2o4QnVPbjVlRm1OZlN4UC1SelYzck0zMzFWZUQwRUhTX2ZPendFbVBibmpUdVU2QUBtYWlsLmdtYWlsLmNvbT4=", 
        "messageIdInHeader": "PENBK25Qbk14UnpwWDFZY2gzWWhNX0g0eHo5cEN5MERPRERqbnhNN0xMUFhUdm5yYnQ2Z0BtYWlsLmdtYWlsLmNvbT4=", 
        "referencesHeader": "PENBK25Qbk13YmZOdnhiaHFqV1Z5WFc3VUR0MlZNNVR6d1d6d0FpUkphSGtLcm5Iem14UUBtYWlsLmdtYWlsLmNvbT4JPENBK25Qbk15UVB3X2htQjVQWmpZNXRPN0xkaFN2WEprYjdObjlKRlpyZUIxVnk1UDhvd0BtYWlsLmdtYWlsLmNvbT4JPENBQ2o4QnVPbjVlRm1OZlN4UC1SelYzck0zMzFWZUQwRUhTX2ZPendFbVBibmpUdVU2QUBtYWlsLmdtYWlsLmNvbT4="
    }
}