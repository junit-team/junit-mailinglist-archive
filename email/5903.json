{
    "numMessagesInTopic": 38, 
    "nextInTime": 5904, 
    "senderId": "rU4fO3bywXhfWFiAzEFmjKkLV7aOJ4sOt8ckout6IwpWSfA0gtOWZ5scSipcTOY9KQn5PclHXogY3bHW6V7EgqNmF8atRA0cJdHyKA", 
    "systemMessage": false, 
    "subject": "Re: [junit] Do JUnit internals suck?!?", 
    "from": "Berin Loritsch &lt;bloritsch@...&gt;", 
    "authorName": "Berin Loritsch", 
    "msgSnippet": "... For these methods, that really isn t too much of a problem. ... right. ... The TestMethodInvoker is the Command pattern I am talking about.  The ", 
    "msgId": 5903, 
    "profile": "bloritsch", 
    "topicId": 5875, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 64910131, 
    "messageBody": "<div id=\"ygrps-yiv-486764601\">Mark Meyers wrote:<br/>\n<blockquote><span title=\"ireply\"> &gt; <br/>\n&gt;&gt;-----Original Message-----<br/>\n&gt;&gt;From: Berin Loritsch [mailto:<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:bloritsch@...\">bloritsch@...</a>]<br/>\n&gt;&gt;...<br/>\n&gt;&gt;<br/>\n&gt;&gt;Another issue I have is that while JUnit defines the Test interface,<br/>\n&gt;&gt;it only really expects the TestCase base class.  It is unclear how<br/>\n&gt;&gt;the Test interface interacts with the system.  Sometimes I would much<br/>\n&gt;&gt;rather work with my own base class that is completely separate from<br/>\n&gt;&gt;JUnit.  The Assert class should be made a static utility clasee, not<br/>\n&gt;&gt;a base class as well.  That would allow us to work with the assert<br/>\n&gt;&gt;methods from any class something like this is much better:<br/>\n&gt;&gt;<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; class Xxx extends Assert implements Test ?<br/>\n&gt; Never tried it though...<br/>\n&gt; <br/>\n&gt; <br/>\n&gt;&gt;Assert.isTrue( myObject.rocks() );<br/>\n&gt;&gt;<br/>\n&gt;&gt;than this:<br/>\n&gt;&gt;<br/>\n&gt;&gt;assertTrue( myObject.rocks() );<br/>\n&gt;&gt;<br/>\n&gt;&gt;...<br/>\n&gt;&gt;<br/>\n&gt;&gt;What I would like to see is the following:<br/>\n&gt;&gt;<br/>\n&gt;&gt;* Explicit use of interfaces--make the contracts clear, and code the<br/>\n&gt;&gt;   test runners/collectors to use the interfaces and not the base<br/>\n&gt;&gt;   classes.  If there are different contracts with a type of <br/>\n&gt;&gt;test/suite,<br/>\n&gt;&gt;   then it needs a new interface.<br/>\n&gt;&gt;<br/>\n&gt;&gt;* Making Assert into a set of static utilities so that we don&#39;t have<br/>\n&gt;&gt;   to inherit it to make it useful.<br/>\n&gt;&gt;<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; That is the case already:<br/>\n&gt; <br/>\n&gt; public class Assert...    <br/>\n&gt;     static public void assertTrue(boolean condition){<br/>\n&gt;         assertTrue(null, condition);<br/>\n&gt;     }<br/>\n&gt;     static public void fail(String message)...<br/>\n&gt; <br/>\n&gt; The downside is of course not being able to override those methods...<br/>\n&gt; (redefining assertTrue(String, boolean) will not change behavior of<br/>\n&gt; assertTrue(boolean) as with instance methods)<br/>\n<br/>\n </span></blockquote>For these methods, that really isn&#39;t too much of a problem.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; <br/>\n&gt; <br/>\n&gt;&gt;...<br/>\n&gt;&gt;* Explicit declaration of the TestCase being the Leaf of the <br/>\n&gt;&gt;model, not<br/>\n&gt;&gt;   a branch (as it is now treated).  A different interface <br/>\n&gt;&gt;for TestSuite<br/>\n&gt;&gt;   and TestCase will help.<br/>\n&gt;&gt;<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; When writing tests, it is very usefull to group related tests together in a<br/>\n&gt; single java file . <br/>\n<br/>\n </span></blockquote>right.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; It may be clearer on the &quot;internals&quot; side if there would be a<br/>\n&gt; TestMethodInvoker class that takes a TestCase and a Method and invokes the<br/>\n&gt; method on the instance. <br/>\n&gt; You could get rid of the TestCase(String nameThatIsReallyAMethodName)<br/>\n&gt; constructor. The constructor is most definitely confusing to novice users.<br/>\n&gt; And they are encouraged to put setUp code in the constructor. It is there<br/>\n&gt; anyway, not so the setUp method.<br/>\n&gt; The TestSuite and TestMethodInvoker would participate in the composite<br/>\n&gt; pattern, the TestCase could then just be collection of test methods (and no<br/>\n&gt; longer implement Test, behavior extracted to TestMethodInvoker ).<br/>\n&gt; Is that a good idea ?<br/>\n&gt; Downside is backward compatibility, of course...<br/>\n<br/>\n<br/>\n </span></blockquote>The TestMethodInvoker is the Command pattern I am talking about.  The<br/>\nTestMethodInvoker would be able to be constructed like this:<br/>\n<br/>\npublic class TestMethodInvoker implements Test<br/>\n{<br/>\n     private final Class m_klass;<br/>\n     private final Method m_method;<br/>\n<br/>\n     public TestMethodInvoker( Class klass, Method method )<br/>\n     {<br/>\n         m_klass = klass;<br/>\n         m_method = method;<br/>\n     }<br/>\n<br/>\n     public TestResult run() throws Exception<br/>\n     {<br/>\n         // do stuff with the TestResult...<br/>\n<br/>\n         Object instance = null;<br/>\n         try<br/>\n         {<br/>\n             instance = m_klass.newInstance();<br/>\n         }<br/>\n         catch ( Exception e )<br/>\n         {<br/>\n             // legacy code<br/>\n             Constructor const = m_klass.getConstructor( new Class[]<br/>\n                           { String.class } );<br/>\n<br/>\n             instance = const.newInstance( new Object[]<br/>\n                      { &quot;Change to empty constructor please&quot; } );<br/>\n         }<br/>\n<br/>\n         Object result = m_method.invoke( instance,<br/>\n                         new Class[]{}, new Object[] {} );<br/>\n     }<br/>\n}<br/>\n<br/>\nOr something along those lines.  The esoteric reflection logic<br/>\nis nicely encapsulated, and there is no need for the String<br/>\nconstructor.  It does not change the way you write tests, nor<br/>\ndoes it fail if you only have the String constructor.<br/>\n<br/>\nThe Invoker you have there is sort of a &quot;Delegate&quot;, but it allows<br/>\nyou to have a new Class from a new ClassLoader for each Invoker,<br/>\njust like now.  There is less confusion over what is what.<br/>\n<br/>\n<br/>\n-- <br/>\n<br/>\n&quot;They that give up essential liberty to obtain a little temporary safety<br/>\n  deserve neither liberty nor safety.&quot;<br/>\n                 - Benjamin Franklin</div>", 
    "prevInTime": 5902, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1033569897", 
    "canDelete": false, 
    "nextInTopic": 5904, 
    "prevInTopic": 5902, 
    "headers": {
        "messageIdInHeader": "PDNEOUIwNjY5LjQwMjA0MDNAYXBhY2hlLm9yZz4=", 
        "referencesHeader": "PEM0NTBEOTY2NjRDQkQzMTE4MkI2MDBBMEM5NzY2OEIxNjQ4MUE4QENBU0UwNTI+"
    }
}