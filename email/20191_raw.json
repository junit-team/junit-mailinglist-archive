{
    "numMessagesInTopic": 9, 
    "nextInTime": 20192, 
    "senderId": "xtbHFB_JbEpu-esNNjzhQcDLgJ2eMZB8YStIw6JjwnxdTnV6JLMa7mZBQiWLEpizszWlmLXDcEFMs1fwOeEfIWb9ZP2jRADYdkaV17lnB7ng_j8", 
    "systemMessage": false, 
    "subject": "Re: [junit] Ideas for testing large methods..", 
    "from": "&quot;Andrew McDonagh&quot; &lt;andrewmcdonagh@...&gt;", 
    "authorName": "Andrew McDonagh", 
    "msgSnippet": "... Hi I agree, although in these situations I tend to favour a slightly different approach... Leaning on the Compiler/Refactorer to make the large method", 
    "msgId": 20191, 
    "rawEmail": "Return-Path: &lt;andrewmcdonagh@...&gt;\r\nX-Sender: andrewmcdonagh@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nX-Received: (qmail 65518 invoked from network); 24 Dec 2007 16:41:23 -0000\r\nX-Received: from unknown (66.218.67.97)\n  by m52.grp.scd.yahoo.com with QMQP; 24 Dec 2007 16:41:23 -0000\r\nX-Received: from unknown (HELO py-out-1112.google.com) (64.233.166.178)\n  by mta18.grp.scd.yahoo.com with SMTP; 24 Dec 2007 16:41:23 -0000\r\nX-Received: by py-out-1112.google.com with SMTP id u77so3191479pyb.3\n        for &lt;junit@yahoogroups.com&gt;; Mon, 24 Dec 2007 08:41:22 -0800 (PST)\r\nX-Received: by 10.64.27.13 with SMTP id a13mr8363088qba.53.1198514481663;\n        Mon, 24 Dec 2007 08:41:21 -0800 (PST)\r\nX-Received: by 10.65.110.14 with HTTP; Mon, 24 Dec 2007 08:41:21 -0800 (PST)\r\nMessage-ID: &lt;35c507d30712240841h2c277448n1e2744f5ccd022fe@...&gt;\r\nDate: Mon, 24 Dec 2007 16:41:21 +0000\r\nTo: junit@yahoogroups.com\r\nIn-Reply-To: &lt;17fa53d0712240244p55927fb9icdd516adadd8dddd@...&gt;\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Transfer-Encoding: 7bit\r\nContent-Disposition: inline\r\nReferences: &lt;fkg6ed+ssi0@...&gt;\n\t &lt;17fa53d0712240244p55927fb9icdd516adadd8dddd@...&gt;\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: &quot;Andrew McDonagh&quot; &lt;andrewmcdonagh@...&gt;\r\nSubject: Re: [junit] Ideas for testing large methods..\r\nX-Yahoo-Group-Post: member; u=283773244; y=sEnYXCJII2zjRfHn47Pu5PZ2mOVPJxFA7LZ0Ad_CpXW-2YxVu_4g7A\r\nX-Yahoo-Profile: andy_ipaccess\r\n\r\nOn 24/12/2007, Nat Pryce &lt;nat.pryce@...&gt; wrote:\n&gt;\n&gt;\n&gt;\n&gt;\n&gt;\n&gt;\n&gt; On 21/12/2007, edu_kumar &lt;sarat.beesa@...&gt; wrote:\n&gt;  &gt;  My problem is that i&#39;ve a really huge method,which calls several small\n&gt;  &gt;  methods ( methods so small, they&#39;re just getters for member\n&gt;  &gt;  variables), If i have to unit test this method, i&#39;ve to make sure all\n&gt;  &gt;  the small methods that it subsequently invoke, work as they&#39;re\n&gt;  &gt;  expected. But all my member variables get initialized seperately in a\n&gt;  &gt;  different method which is of no relation with the BIG method I wanted\n&gt;  &gt;  to test in the first place.\n&gt;  ....\n&gt;  &gt;  Can I test my method without worrying about the initialization of my\n&gt;  &gt;  object&#39;s data, by mocking the results of all my getter methods ?\n&gt;  &gt;  I tried using Jmock for creating mocks in my test case, but it fails\n&gt;  &gt;  because the mock object only knows what exactly I wanted to mock but\n&gt;  &gt;  nothing more than that. All my application logic is present in\n&gt;  &gt;  &#39;MyClass&#39; object not in its mock.\n&gt;  &gt;\n&gt;  &gt;  How can I achieve this using Jmock ?\n&gt;\n&gt;  This is not what jMock is designed for.  Mock Objects are used to test\n&gt;  how the object under test affects its environment by sending commands\n&gt;  to other objects.  They are not for testing the implementation details\n&gt;  of what goes on *inside* the object under test.\n&gt;\n&gt;  In your description of what you&#39;re trying to test, you described\n&gt;  trying to test a method.  That to me is a smell.  It would be better\n&gt;  to think about testing the *object*, not individual methods.\n&gt;\n&gt;  To write a test for an object you need to answer questions like: What\n&gt;  does the object do? What messages do I send the object to make it\n&gt;  perform the behaviour I am testing? What resources does it need\n&gt;  perform that behaviour?  What other objects does it need to talk to?\n&gt;  Are those objects internal implementation details, or peers of the\n&gt;  object under test?\n&gt;\n&gt;  If you can answer those questions, you can easily work out which\n&gt;  objects should be mocked out, and which should be hidden within the\n&gt;  object under test.\n&gt;\n&gt;  The other smell is that the method is huge, and has complicated\n&gt;  dependencies on initialisation methods.  It sounds as if the class\n&gt;  needs to be divided into smaller, simpler objects that can be more\n&gt;  easily unit tested and that define proper constructors.\n&gt;\n&gt;  To do that without an extensive suite of unit tests, I would first\n&gt;  write some integration or system tests that cover the behaviour of the\n&gt;  class. I would then pull behaviour out of the big class into smaller\n&gt;  classes, writing those smaller classes test-first.  The system tests\n&gt;  would give me some confidence that my refactoring had not broken\n&gt;  everything.  Writing the new classes test-first would drive out a less\n&gt;  coupled design that would be easier to maintain in the future.\n&gt;\n&gt;  --Nat\n&gt;\n\nHi\n\nI agree, although in these situations I tend to favour a slightly\ndifferent approach...\n\nLeaning on the Compiler/Refactorer to make the large method testable,\nwithout having to create integration /system tests. I do this as I\noften find there&#39;s as much problems creating these higher order tests\nas there is in creating targeted unit tests.\n\nTo start off, I&#39;d look at the method and use the IDEs builtin auto\nrefactorings: extract method and  rename.  These two refactoring will\nallow me to take a single large method and break it into smaller more\nlogical methods. These methods must follow a single responsibility\nconcept. Plus as eclipse has done it for me and the compiler continues\nto compile without error, its virtually risk free of introducing a\ndefect - you just have to take your time.\n\nI&#39;d deliberately create smaller public methods, instead of private\nmethods, so that I can write a unit test for them.  However, I don&#39;t\ngo over board with this...my aim to to make the large method testable,\nthen worry about the right design that should be used.\n\nOnce I have the original large method doing nothing but calling other\npublic methods, in a certain order, I&#39;m done.  At this point I doubt I\neven have a test for the original method, but I will have at least one\ntest for each of the other new methods.\n\nThe real benefit of this approach comes about when we take the next\nstep, one of refactoring the design.  Once we have a series of public\nmethods, its fair easy to see that some of them should belong to\nanother new class, rather than the original class.\n\nI&#39;ve often found that when performing this retro fitting of unit tests\nto legacy(*) code that there was more than one class hidden within the\noriginal. By doing these small steps of leaningon the compiler and\nrefactor IDE, then adding unit tests, then refactoring again, I can\nchange the design of a large method into an altogether more testable\nOO design.\n\nAndrew\n\n", 
    "profile": "andy_ipaccess", 
    "topicId": 20180, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 283773244, 
    "prevInTime": 20190, 
    "contentTrasformed": false, 
    "postDate": "1198514481", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 20190, 
    "headers": {
        "inReplyToHeader": "PDE3ZmE1M2QwNzEyMjQwMjQ0cDU1OTI3ZmI5aWNkZDUxNmFkYWRkOGRkZGRAbWFpbC5nbWFpbC5jb20+", 
        "messageIdInHeader": "PDM1YzUwN2QzMDcxMjI0MDg0MWgyYzI3NzQ0OG4xZTI3NDRmNWNjZDAyMmZlQG1haWwuZ21haWwuY29tPg==", 
        "referencesHeader": "PGZrZzZlZCtzc2kwQGVHcm91cHMuY29tPgkgPDE3ZmE1M2QwNzEyMjQwMjQ0cDU1OTI3ZmI5aWNkZDUxNmFkYWRkOGRkZGRAbWFpbC5nbWFpbC5jb20+"
    }
}