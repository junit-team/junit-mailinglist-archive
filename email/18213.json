{
    "numMessagesInTopic": 45, 
    "nextInTime": 18214, 
    "senderId": "bGy6hGqE0wwvHQYGXuvirALxwsjUIkScZ0MKYgdqnukq55Jvch3tZoKfo8fxSn90jJtj_Fq1WIB3C8wjer_z26_RitSu5Ec-qphrwSQI", 
    "systemMessage": false, 
    "subject": "Can anyone help me see how to usefully work with JUnit in a big project, please?", 
    "from": "&quot;Tracey Annison&quot; &lt;TAnnison@...&gt;", 
    "authorName": "Tracey Annison", 
    "msgSnippet": "Hiya! This is an interesting list, full of lots of helpful technical tips - great stuff. I ve been having a browse around, but I don t seem to see anyone with ", 
    "msgId": 18213, 
    "profile": "traceyannison", 
    "topicId": 18213, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 132563212, 
    "messageBody": "<div id=\"ygrps-yiv-1729452727\">Hiya! This is an interesting list, full of lots of helpful technical <br/>\ntips - great stuff. <br/>\n<br/>\nI&#39;ve been having a browse around, but I don&#39;t seem to see anyone with <br/>\nthe same questions as me... which is probably a sign that I&#39;m on the <br/>\nwrong track somehow! :) <br/>\nI know this is a long post, but I can&#39;t see how to explain it any <br/>\nshorter - sorry. <br/>\n<br/>\n<br/>\nI&#39;m pretty new to programming, and Java terminology isn&#39;t my strong <br/>\npoint, so my apologies if I mis-word things badly. I&#39;m working on a <br/>\nfairly large project involving providing web services via SOAP and <br/>\nGUI access via JSP&#39;s to data entities, allowing database input and <br/>\nupdate on many tables. <br/>\nHere&#39;s how I (roughly) understand it, for a given &quot;Thing&quot; entity : <br/>\n===========================================<br/>\n * We have a concrete Domain object for our entity, (ConcreteThing) <br/>\nwith an interface above it (Thing). This has all the various <br/>\nproperties (Name, Number, etc - some entities have 150 or more) and <br/>\ngetters & setters for them that do basic validation, and use a DTO to <br/>\nget & set the actual data. The object also has validation methods <br/>\nthat cross-check the values against various other entities, using <br/>\ntheir DAO&#39;s.<br/>\n * Each domain object uses a persistence DTO class (ThingDTO) which <br/>\nholds all the various properties for the Thing, and has simple <br/>\ngetters & setters for them. The ConcreteThing class calls these in <br/>\nit&#39;s getters & setters. <br/>\n * Each data entity also has a ThingDAO class, with methods like <br/>\nCreateThing, SaveThing, DeleteThing, etc to actually handle the <br/>\nreading & writing of the data to the database tables, with <br/>\nstandardised interfaces to allow easy access. It uses SQLMapClient <br/>\nand SQL scripts to do this, passing around the ThingDTO, and also <br/>\nuses other DAO&#39;s when it creates a new ConcreteThing. The ThingDAO is <br/>\nitself used by other Domain objects, to test validation, etc. <br/>\n * For each Web Service, we have a ThingService class that offers <br/>\nmethods to the user, like GetThing, DeleteThing, GetAllThings, etc, <br/>\nusing the ThingDAO to do the work. It also uses a simple <br/>\nSOAPBeanThing that is used to return values to them. The <br/>\nSOAPBeanThing holds the Thing&#39;s properties, in a simplified format <br/>\nsuitable for sending via SOAP. (ie a Date rather than a YearMonthDay, <br/>\netc) Using Axis lets us make this easily available to the outside <br/>\nworld.<br/>\n * We also have a MVC layer, with FormControllers, Validators, <br/>\nActions, etc, and JSP&#39;s & such to go along with it, also using the <br/>\nThingDAO, but it&#39;s all much of a muchness.<br/>\n * We use Spring to tie all this together, injecting the various <br/>\nitems where they&#39;re needed, except for the concrete classes, where <br/>\nthey&#39;re sent as part of the constructor. And we have all sorts of <br/>\nother cool tools, like Subversion and Ant and CruiseControl for <br/>\nautomatic testing and all that, but I don&#39;t think it&#39;s relevant...<br/>\n===========================================<br/>\nSo - this is all cool! Lots of layers, but it all works, and each bit <br/>\ndoes a nice understandable chunk of work, and they talk to each other <br/>\nfine. Plus we have some tools to help us generate the repetitive <br/>\nstuff, so that speeds it up a bit.<br/>\n<br/>\nSo why have I wibbled on about all this? Because we&#39;re using JUnit <br/>\nand JMock, too! And I&#39;m having trouble with it. Technically, it works <br/>\nfine, but it takes ages, is really fragile and doesn&#39;t seem to give <br/>\nme much useful. <br/>\nI&#39;m sure it&#39;s because I&#39;m doing it all wrong somehow...<br/>\n<br/>\n<br/>\n<br/>\nThe testing code is much, much larger than the actual code, quite <br/>\ncomplex, and doesn&#39;t seem to show up a lot of issues for the time & <br/>\neffort it takes to write. Just to get one of these objects to test <br/>\ntakes a huge amount of setup code, making & calling in lots of Mock <br/>\nobjects (typically DAO&#39;s) and specifying what they should do (with <br/>\nstubs and expects), and so on. To keep it all standardised and down <br/>\nto a minimum, I typically define them all at the start, and make a <br/>\nsetUp method to get them built (though I&#39;m told this isn&#39;t a good <br/>\nidea by some) but it&#39;s still very large. <br/>\nIn some cases, the setup for a test can be about 200 lines or more at <br/>\nthe start, and a setUp method of 400 lines or more as well. To test <br/>\none Service (under 2,000 lines of code for 7 methods using 80 <br/>\nproperties) that simply offers a standard set of <br/>\nGet/Create/Update/Delete methods on an entity, the tests run over 5 <br/>\nfiles to a total length of 30,000 lines! In order to get test <br/>\ncoverage above 80%, there&#39;s a large amount of test code that simply <br/>\nchecks that the gets/sets work... which most of the time they can&#39;t <br/>\nhelp but do anyway. <br/>\n<br/>\nTests overall are 5 to 10 times larger than the code they test, and <br/>\nincredibly fragile. The simplest change in the code of one class, <br/>\noften resulting in a tiny change in operation that causes no actual <br/>\nissues, breaks large numbers of tests all over the place. <br/>\nI know that the idea is to test a single class in isolation, but I <br/>\ndon&#39;t see how to do that, when they need each other to do their work. <br/>\nFor example, I can&#39;t check that the policy number on my new claim is <br/>\nvalid without using the policy DAO to check it. I can&#39;t get a new <br/>\nClaim without using the getClaim method on my DAO. So I have to <br/>\neither set it up (almost impossible) or Mock it and specify exactly <br/>\nall the methods I&#39;ll use and all their parameters and their <br/>\nresponses, and so on.<br/>\nChanging the type of some commonly used properties in several <br/>\nentities from Integer to BigDecimal took my colleague a fortnight, <br/>\nand a big chunk of this time was fixing JUnits. <br/>\n<br/>\nIn the last year of my work, JUnit has shown up a total of 5 actual <br/>\nbugs, all bar one of which would have come out immediately in <br/>\nfunctional testing, yet has taken maybe a third of my time. <br/>\nI&#39;ve just gotta be doing it wrong... but I don&#39;t know how to do it <br/>\nright!<br/>\n<br/>\n<br/>\n<br/>\nThe other problem for me is that I can&#39;t get my head around how to do <br/>\nTDD with this sort of structure. <br/>\n<br/>\nI can&#39;t write a test without having all the objects I need, and <br/>\nknowing exactly what parameters I need in the new methods, and <br/>\nprecisely what methods with what parameters will get called on the <br/>\nother objects, and so on & so forth. Which won&#39;t even compile until <br/>\nit&#39;s all there & working. And even then, it&#39;s likely to go through <br/>\nseveral iterations of changes (oh, no, I need to check this thing as <br/>\nwell, using this other DAO, and now I need to work this out as well, <br/>\nusing that data from over there, and so on), so that even if I could <br/>\ndo it, I&#39;d end up writing this huge thing four times over. <br/>\nI can understand it more from a functional viewpoint than anything <br/>\nelse - &quot;this is the result I want, have I got it yet?&quot;. But to set up <br/>\na JUnit/JMock test doesn&#39;t seem to me to really ask that - it asks <br/>\nmore about how (in detail) I got to that result. <br/>\n<br/>\nI&#39;m completely bewildered by how anyone writing anything larger than <br/>\n100 lines or so gets a benefit from doing this. You clearly ARE, but <br/>\nI just don&#39;t understand how... I must be missing something!<br/>\n<br/>\n<br/>\n<br/>\nSo, given the sort of work we&#39;re doing, and the kind of structure <br/>\nI&#39;ve tried to describe, can anyone out there tell me how I&#39;ve gone so <br/>\nfar off track here? Or give me some real examples of quick, useful <br/>\ntest classes on stuff like this? <br/>\nI just KNOW that I must be doing it all wrong, but I can&#39;t seem to <br/>\nfind any real-world examples of how to do it right on this scale. Any <br/>\nhelp would be gratefully recieved! <br/>\n<br/>\n<br/>\nThanks VERY much,<br/>\nCheers, <br/>\nTracey</div>", 
    "prevInTime": 18212, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1161771165", 
    "canDelete": false, 
    "nextInTopic": 18216, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PGVobmRhdCtxM2NjQGVHcm91cHMuY29tPg=="
    }
}