{
    "numMessagesInTopic": 10, 
    "nextInTime": 9688, 
    "senderId": "4SfyNqPKCcNvwIiJ7J0uiehhQPGNPbjDmixVrXNOLAaYNGC376JsVSlHOM_YiNi-sXL0rC4-gsPJJ3ZU0SQIhQE98-V2c6r2wyu2L6g", 
    "systemMessage": false, 
    "subject": "Re: Re: How to write a Mock Class for a 3rd party class where the contructor are private", 
    "from": "Chad Woolley &lt;lists@...&gt;", 
    "authorName": "Chad Woolley", 
    "msgSnippet": "... I m not completely sure what you mean.  I think that you mean writing your mocks along with your tests, and building/refactoring them as you progressively", 
    "msgId": 9687, 
    "profile": "thewoolleyman", 
    "topicId": 9649, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 142650165, 
    "messageBody": "<div id=\"ygrps-yiv-1440855790\">Steve Freeman wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; My one caveat is that this makes mocking a testing technique, so it&#39;s <br/>\n&gt; good for working with external libraries. How do you get the (asserted) <br/>\n&gt; benefits of mocks as a design technique for new code?<br/>\n<br/>\n </span></blockquote>I&#39;m not completely sure what you mean.  I think that you mean writing <br/>\nyour mocks along with your tests, and building/refactoring them as you <br/>\nprogressively flesh out your design (as has been discussed recently on <br/>\nthe test driven development mailing list).<br/>\n<br/>\nIn any case, I think that you are pointing out what I perceive to be the <br/>\nmajor drawback of any dynamic mock approach (virtual mocks or dynamic <br/>\nproxies).  This drawback is reusability.  If you mock everything on a <br/>\nper-call basis, then this is obviously specific to the current test <br/>\nscenario.  You can&#39;t reuse this &quot;mock&quot; in another test which may reqire <br/>\nthe mocking of completely different calls to the object.<br/>\n<br/>\nWith a &quot;real&quot; mock/fake object (one that is actually a compiled class), <br/>\n  you can define default behaviors (return values / parameter <br/>\nvalidations) which will always be used no matter what context you use <br/>\nthe object in.<br/>\n<br/>\nIt looks like DynaMock is working towards an innovative solution to this <br/>\nproblem, in the form of &quot;default return stubs&quot; <br/>\n(<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.mockobjects.com/wiki/ChangesInNatsBranch)\">http://www.mockobjects.com/wiki/ChangesInNatsBranch)</a>.<br/>\n<br/>\nWith this approach, I can see that dynamic/virtual mocks can possibly <br/>\nachieve the same reusability benefits as &quot;real&quot; mocks.  This could be <br/>\ndone by &quot;pre-configuring&quot; dynamic/virtual mock objects which are <br/>\nreusable across tests.  In other words, defining what should happen for <br/>\neach possible method call on the object, regardless of the current context.<br/>\n<br/>\nIf this were made easy to do, then I can see dynamic/virtual mocks being <br/>\n  indistinguishable from &quot;real&quot; mocks in terms of functionality.  You <br/>\ncan still use an interface-driven design process, except it would be <br/>\nwithout the interfaces.<br/>\n<br/>\nI&#39;m still trying to get the concept of interface driven design, so I may <br/>\nbe off base.  Let me know what you think.<br/>\n<br/>\n-- Chad</div>", 
    "prevInTime": 9686, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1066169823", 
    "canDelete": false, 
    "nextInTopic": 9690, 
    "prevInTopic": 9672, 
    "headers": {
        "inReplyToHeader": "PDEwNjYxMzA5MzcuOTQ0Ljk1OTI0Lm0xMkB5YWhvb2dyb3Vwcy5jb20+", 
        "messageIdInHeader": "PDNGOEM3NURGLjEwMTA1MDdAdGhld29vbGxleXdlYi5jb20+", 
        "referencesHeader": "PDEwNjYxMzA5MzcuOTQ0Ljk1OTI0Lm0xMkB5YWhvb2dyb3Vwcy5jb20+"
    }
}