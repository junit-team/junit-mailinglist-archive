{
    "numMessagesInTopic": 14, 
    "nextInTime": 22654, 
    "senderId": "gJJhKRIuiyiJUkpcQC7IDFnscgzr1ABMLfvaQV21Y7t9_YPGqe8nTFcCokqfOkBW7vpnilLjerLoyvq9aIFteBhnmyViVfhA15NbGekT8LU", 
    "systemMessage": false, 
    "subject": "Re: Class-level @Rule", 
    "from": "&quot;yme0987654321&quot; &lt;yme0987654321@...&gt;", 
    "authorName": "yme0987654321", 
    "msgSnippet": "... I really don t perceive that as excessive boilerplate. YMMV. ... Test instantiation is yes, but I would expect a ClassRule to provide a hook into the", 
    "msgId": 22653, 
    "profile": "yme0987654321", 
    "topicId": 22627, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 386557907, 
    "messageBody": "<div id=\"ygrps-yiv-176369332\"><blockquote><span title=\"ireply\">&gt; On 28/04/10 00:36, yme0987654321 wrote:<br/>\n&gt; &gt; Hi Max,<br/>\n&gt; &gt; <br/>\n&gt; &gt; I guess my question is other than the syntactical sugar, what does a<br/>\n&gt; &gt; class level rule gain for you? I would expect it to be something more<br/>\n&gt; &gt; than a way of avoiding that kind of boilerplate.<br/>\n&gt; <br/>\n&gt; I just explained that in my previous reply. When the boilerplate that is<br/>\n&gt; avoided is so excessive, the syntactic sugar itself becomes a valuable<br/>\n&gt; feature.<br/>\n<br/>\n </span></blockquote>I really don&#39;t perceive that as excessive boilerplate. YMMV.<br/>\n <br/>\n<blockquote><span title=\"ireply\"> &gt; &gt; As an example of the kind of thing I think a class rule would enable,<br/>\n&gt; &gt; is that it might allow the rule to dynamically pass values to the<br/>\n&gt; &gt; test class&#39;s constructor based on some dynamic criteria (say a souped<br/>\n&gt; &gt; up version of Parameterized)<br/>\n&gt; <br/>\n&gt; No. Test class instantiation occurs per-method, not per-class, thus<br/>\n&gt; class-level is not where it can be changed.<br/>\n<br/>\n </span></blockquote>Test instantiation is yes, but I would expect a ClassRule to provide a hook into the instance generation process (although for the whole class, not each case at a time).<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; &gt; or perhaps change the runner that will run the tests,<br/>\n&gt; <br/>\n&gt; No. The Runner is what invokes the rules, so rules can&#39;t change the runner.<br/>\n<br/>\n </span></blockquote>Just like the ExpectedException rule intercepts the Statement and replaces it with its own, a ClassRule can intercept the Runner and replace it with its own (possibly).<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; &gt; Something that is not possible with an @BeforeClass<br/>\n&gt; &gt; or @AfterClass annotation.<br/>\n&gt; <br/>\n&gt; The ability to package a common class-level setup/teardown behaviour and<br/>\n&gt; re-use it in many places is what rules provide over embedded<br/>\n&gt; before/after methods. That&#39;s very useful by itself, and they don&#39;t have<br/>\n&gt; to do anything more to justify their existence.<br/>\n<br/>\n </span></blockquote>Hmm, I guess we have to agree to disagree on that one.</div>", 
    "prevInTime": 22652, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1272489748", 
    "canDelete": false, 
    "nextInTopic": 22672, 
    "prevInTopic": 22649, 
    "headers": {
        "inReplyToHeader": "PDRCRDgxRDhBLjEwNDA4MDBAZjJzLmNvbT4=", 
        "messageIdInHeader": "PGhyYTh1aytrYWRxQGVHcm91cHMuY29tPg=="
    }
}