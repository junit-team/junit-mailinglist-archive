{
    "numMessagesInTopic": 2, 
    "nextInTime": 860, 
    "senderId": "9XREpU5S1p13zbEMRo8zLp5pyaD7wF5YzaNv357_cgbmJXJVZ722Vo8U74_ox6S6SaHtnjAlbFXhxLPjWhuWxjv2xH8mzQ", 
    "systemMessage": false, 
    "subject": "Re: [junit] an assert for testing a ResultSet", 
    "from": "&quot;Chas Schley&quot; &lt;chas@...&gt;", 
    "authorName": "Chas Schley", 
    "msgSnippet": "At Zhanra, we require that each of our JDBC layer objects have 3 constructors.  The first one stuffs a row into the database based on a set of supplied values.", 
    "msgId": 859, 
    "topicId": 858, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 0, 
    "messageBody": "<div id=\"ygrps-yiv-688284029\">At Zhanra, we require that each of our JDBC layer objects have 3<br/>\nconstructors.  The first one stuffs a row into the database based on a set<br/>\nof supplied values.  The second one slurps up a database row based on the<br/>\nsupplied key values.  The third instantiates the object based on a SQL<br/>\nresult set.  The latter 2 constructors speak up when an underlying data<br/>\nelement is missing (i.e., missing from the result set).  When you know the<br/>\nkey values for a particular row, use the 2nd constructor.  When you know<br/>\nsome but not all of the key values, or have an ad-hoc SQL query, use the 3rd<br/>\nconstructor.<br/>\n<br/>\nAny class can issue a SQL query that returns one or more rows.  Using a<br/>\ncombination of these 3 constructors,  we can run just about any arbitrary<br/>\nSQL query from anywhere (including our tests) and convert the results into<br/>\nthe objects that our business logic understands.  Call<br/>\nassertIsNotNull(Object) on the newly constructed object to verify that the<br/>\ndatabase has your data.<br/>\n<br/>\nAdmittedly, managing constructors in the JDBC layer is a coding policy and<br/>\nnot a testing technique, but it achieves the same result.  Further, it<br/>\npushes some responsibility for testability onto the developers and makes our<br/>\ntest cases easier to write (since you can assume the existence of a given<br/>\nset of constructors with a known format and function).  Test authors simply<br/>\nlearn the database keys and the JDBC layer becomes intuitive.<br/>\n<br/>\nCheers,<br/>\n<br/>\n_chas_<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; From: &quot;Jason Trip&quot; &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:jason_trip@...\">jason_trip@...</a>&gt;<br/>\n&gt; Sent: Friday, March 30, 2001 11:23 AM<br/>\n&gt; Subject: [junit] an assert for testing a ResultSet<br/>\n&gt;<br/>\n<br/>\n&gt; I have a lot of tests that need to assert that data was inserted in our<br/>\n&gt; database.  Does anyone have a better way than to get a ResultSet and loop<br/>\n&gt; through with a bunch of assert statements?<br/>\n&gt;<br/>\n&gt; I thought it might be cool to have an assert that lets you pass a<br/>\n </span></blockquote>resultset,<br/>\n<blockquote><span title=\"ireply\"> &gt; a number of expected records, and a two-dimensional array of expected<br/>\n </span></blockquote>values<br/>\n<blockquote><span title=\"qreply\"> &gt; (if it could handle the data types correctly)...any other thoughts? </span></blockquote></div>", 
    "prevInTime": 858, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "985991125", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 858, 
    "headers": {
        "messageIdInHeader": "PDA1NjIwMWMwYjk2OCQ1MTY1YjA1MCQ2NDY2NjQwYUB6aGFucmEuY29tPg==", 
        "referencesHeader": "PE5FQkJKRUNQRk1MSE9CQkJLTkxLT0VCQ0NGQUEuamFzb25fdHJpcEBjcm9zc2NvbW1lcmNlLmNvbT4="
    }
}