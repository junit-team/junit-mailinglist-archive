{
    "numMessagesInTopic": 23, 
    "nextInTime": 9726, 
    "senderId": "U46cBEBJ8LfMpd28OAXxMe_Lmh0GbZ7Czvl9I1DzQGSnup071vBFEqhorFft0xpDytBlL19I3lMaCiQAIXbHLXQEq609aUxkPZUJRi3J2s3kniaqTCrHKqAX", 
    "systemMessage": false, 
    "subject": "RE: [junit] Re: How to test private methods, its urgent", 
    "from": "&quot;Michael Silverstein&quot; &lt;msilverstein@...&gt;", 
    "authorName": "Michael Silverstein", 
    "msgSnippet": "My opinion is that if you want to make it possible for others to extend your framework in ways that haven t anticipated you don t make your methods private,", 
    "msgId": 9725, 
    "topicId": 9699, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 62742148, 
    "messageBody": "<div id=\"ygrps-yiv-203825013\">My opinion is that if you want to make it possible for others to extend<br/>\nyour framework in ways that haven&#39;t anticipated you don&#39;t make your<br/>\nmethods private, but you do add in enough &#39;buyer beware&#39; documentation<br/>\nto indicate methods that probably should be private and may be<br/>\ndangerous. Something like a @private javadoc tag would be plenty. Its up<br/>\nto the person who extends the framework to decide whether to take on the<br/>\nrisk of calling those methods, and the maintenance headaches that may<br/>\nfollow. It usually helps if the source for the methods is available as<br/>\nwell.<br/>\n<br/>\nAs an example, I extended JUnit for load testing to distribute tests on<br/>\nmultiple machines, execute them in parallel  and then collate the<br/>\nresults on a central machine. It was pretty easy to do except for<br/>\nseveral private methods that made things very difficult. This was a year<br/>\nago so I don&#39;t remember the specifics. I could have created my own<br/>\nversion of JUnit with the private methods made public but then I would<br/>\nhave had to maintain and ship my own version of JUnit, which was not an<br/>\noption. <br/>\n<br/>\nFor another example, I worked on a GUI capture/playback tool for<br/>\nSmalltalk. This required accessing a lot of internal widget methods. Had<br/>\nthose methods been private the task would probably have been impossible.<br/>\nInstead we accepted the risk and went ahead. When a new release of<br/>\nSmalltalk comes out we have to re-test with it and make some adjustments<br/>\nbecause of our use of private methods but it is all very containable.<br/>\n<br/>\nOn the other hand, if you don&#39;t anticipate anyone is going to extend<br/>\nyour framework or you don&#39;t want anyone to extend it then it makes sense<br/>\nto make methods private. For example, if your business model is built on<br/>\nyour being the only one capable of extending a system to meet your<br/>\ncustomers specific needs, you don&#39;t want to make it too easy for them to<br/>\nextend the system.<br/>\n<br/>\n-----------------------------<br/>\nMike Silverstein<br/>\nSilverMark, Inc.<br/>\nThe Object Testing Company<br/>\nwww.javatesting.com<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; -----Original Message-----<br/>\n&gt; From: David Vydra [mailto:david@...] <br/>\n&gt; Sent: Sunday, October 19, 2003 11:53 AM<br/>\n&gt; To: junit@yahoogroups.com<br/>\n&gt; Subject: Re: [junit] Re: How to test private methods, its urgent<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; Michael,<br/>\n&gt; I usually like your approach, however according to this <br/>\n&gt; article, http://www.artima.com/intv/nonvirtual.html, C# <br/>\n&gt; creators propose that methods should not be made <br/>\n&gt; automatically overridable. I suppose we can do the same in <br/>\n&gt; java with the &#39;final&#39; modifier. Do you think there is any <br/>\n&gt; merit to this strategy for large, long-lived systems? Any <br/>\n&gt; other opinions? Regards, David www.testdriven.com<br/>\n&gt; <br/>\n&gt; ----- Original Message ----- <br/>\n&gt; From: &quot;Michael Silverstein&quot; &lt;msilverstein@...&gt;<br/>\n&gt; To: &lt;junit@yahoogroups.com&gt;<br/>\n&gt; Sent: Thursday, October 16, 2003 6:49 PM<br/>\n&gt; Subject: RE: [junit] Re: How to test private methods, its urgent<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; &gt; &gt; -----Original Message-----<br/>\n&gt; &gt; &gt; From: Danijel Arsenovski [mailto:darsenovski@...]<br/>\n&gt; &gt; &gt; Sent: Thursday, October 16, 2003 4:00 PM<br/>\n&gt; &gt; &gt; To: junit@yahoogroups.com<br/>\n&gt; &gt; &gt; Subject: RE: [junit] Re: How to test private methods, its urgent<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; Hello Michael,<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt;Private methods are difficult to test because, after <br/>\n&gt; all, they&#39;re <br/>\n&gt; &gt; &gt; &gt;private. If you adopt a convention that API methods are only<br/>\n&gt; &gt; &gt; presented<br/>\n&gt; &gt; &gt; &gt;via Java Interfaces instead of concrete classes then you <br/>\n&gt; don&#39;t care <br/>\n&gt; &gt; &gt; &gt;about the way the implementers of the Interfaces are<br/>\n&gt; &gt; &gt; written. You can<br/>\n&gt; &gt; &gt; &gt;then make non-API methods within the concrete <br/>\n&gt; implementation public <br/>\n&gt; &gt; &gt; &gt;without implying that they are themselves API methods.<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; I am not sure I follow, but as I can see this only works if you <br/>\n&gt; &gt; &gt; never plan to extend your clases, or leave them to be extended. I <br/>\n&gt; &gt; &gt; guess that in your case only thing visible from the outside are <br/>\n&gt; &gt; &gt; interfaces. If you write frameworks, it is difficult to get by <br/>\n&gt; &gt; &gt; without inheritance. Inheritance breaks encapsulation, keeping <br/>\n&gt; &gt; &gt; methods private helps encapsulate things. Also, I am not <br/>\n&gt; shure what <br/>\n&gt; &gt; &gt; you mean by &quot;without implying&quot;, generally you &quot;make <br/>\n&gt; statement&quot; with <br/>\n&gt; &gt; &gt; your code, any other method yo imply something (comments, <br/>\n&gt; &gt; &gt; documentation etc...) is superfluous.<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; Regards,<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; Danijel Arsenovski<br/>\n&gt; &gt;<br/>\n&gt; &gt; On the contrary, I think this approach makes it easier to extend <br/>\n&gt; &gt; frameworks. I believe that in the general case, there is no <br/>\n&gt; reason to <br/>\n&gt; &gt; make methods in classes private if their API methods are <br/>\n&gt; only accessed <br/>\n&gt; &gt; by clients via Interface methods.<br/>\n&gt; &gt;<br/>\n&gt; &gt; Here&#39;s an example of what I mean:<br/>\n&gt; &gt;<br/>\n&gt; &gt; Let&#39;s assume we have class MyClass that implements interface <br/>\n&gt; &gt; MyInterface, with methods: public int x(){<br/>\n&gt; &gt;   // return an answer based on y() and z()<br/>\n&gt; &gt; }<br/>\n&gt; &gt; private int y() {...}<br/>\n&gt; &gt; private int z() {...}<br/>\n&gt; &gt;<br/>\n&gt; &gt; And Interface MyInterface with method:<br/>\n&gt; &gt; public int x()<br/>\n&gt; &gt;<br/>\n&gt; &gt; We observe that:<br/>\n&gt; &gt;<br/>\n&gt; &gt; - MyInterface serves to &#39;publish&#39; the API method x().<br/>\n&gt; &gt;<br/>\n&gt; &gt; - Any client of MyClass will only see it in terms of<br/>\n&gt; &gt;<br/>\n&gt; &gt; - We have the choice of testing public method x() by constructing a <br/>\n&gt; &gt; test that &#39;talks&#39; to either MyClass or MyInterface.<br/>\n&gt; &gt;<br/>\n&gt; &gt; - If we have other concrete implementors of MyInterface it <br/>\n&gt; makes sense <br/>\n&gt; &gt; to write the test to talk to MyInterface rather than directly to <br/>\n&gt; &gt; implementors to they can be swapped in and tested.<br/>\n&gt; &gt;<br/>\n&gt; &gt; - x() returns a value based on values returned by private <br/>\n&gt; methods y() <br/>\n&gt; &gt; and z().<br/>\n&gt; &gt;<br/>\n&gt; &gt; - Methods y() and z() may be private for no other reason than that <br/>\n&gt; &gt; they are not part of the public API interface of MyClass <br/>\n&gt; and that the <br/>\n&gt; &gt; developer did not anticipate that anyone would ever need to <br/>\n&gt; use them <br/>\n&gt; &gt; in extending the framework.<br/>\n&gt; &gt;<br/>\n&gt; &gt; Continuing:<br/>\n&gt; &gt; Let&#39;s say<br/>\n&gt; &gt;  - we want to extend MyClass with MyClass2 that implements <br/>\n&gt; method int <br/>\n&gt; &gt; q().<br/>\n&gt; &gt;  - we want to override x() so that it uses methods y(),  <br/>\n&gt; z(), and q() <br/>\n&gt; &gt; to calculate its return value.<br/>\n&gt; &gt;<br/>\n&gt; &gt; We have a problem: MyClass2 does not have visibility to private <br/>\n&gt; &gt; methods<br/>\n&gt; &gt; y() and z().<br/>\n&gt; &gt;<br/>\n&gt; &gt; If private methods y() and z() were made public there would be no <br/>\n&gt; &gt; adverse effect on the publication of API methods because <br/>\n&gt; users of the <br/>\n&gt; &gt; class would only see those methods published via MyInterface.<br/>\n&gt; &gt;<br/>\n&gt; &gt; We have the question of whether it is *safe* to use y() and <br/>\n&gt; z(). Since <br/>\n&gt; &gt; they are not published as part of the API via MyInterface it may be <br/>\n&gt; &gt; considered too risky to use them. This can be solved with <br/>\n&gt; some notes <br/>\n&gt; &gt; in the javadoc.<br/>\n&gt; &gt;<br/>\n&gt; &gt; Methods that really are too risky to use outside of the <br/>\n&gt; class itself <br/>\n&gt; &gt; can always be made private but I would hope that this is <br/>\n&gt; the exception <br/>\n&gt; &gt; and not the rule.<br/>\n&gt; &gt;<br/>\n&gt; &gt; The developer creating the extension can make the decision based on <br/>\n&gt; &gt; those notes whether they are willing to accept fhe risk of using <br/>\n&gt; &gt; methods that may not continue to behave the same way or <br/>\n&gt; even exist in <br/>\n&gt; &gt; the future. At least they have that choice. If they have a <br/>\n&gt; good set of <br/>\n&gt; &gt; tests then changes to those methods in the future will be exposed <br/>\n&gt; &gt; readily enough.<br/>\n&gt; &gt;<br/>\n&gt; &gt; Conclusion<br/>\n&gt; &gt; ----------<br/>\n&gt; &gt; If the purpose of making methods private is to indicate <br/>\n&gt; that they are <br/>\n&gt; &gt; not part of a class&#39;s API a better way is to encourage users of the <br/>\n&gt; &gt; class to program to a Java Interface instead. When you make methods <br/>\n&gt; &gt; private it makes the class more difficult to test and <br/>\n&gt; short-circuits <br/>\n&gt; &gt; the efforts of people who might need to extend the framework in <br/>\n&gt; &gt; unanticipated ways.<br/>\n&gt; &gt;<br/>\n&gt; &gt; -----------------------------<br/>\n&gt; &gt; Mike Silverstein<br/>\n&gt; &gt; SilverMark, Inc.<br/>\n&gt; &gt; The Object Testing Company<br/>\n&gt; &gt; www.javatesting.com<br/>\n<br/>\n </span></blockquote>---<br/>\nOutgoing mail is certified Virus Free.<br/>\nChecked by AVG anti-virus system (http://www.grisoft.com).<br/>\nVersion: 6.0.528 / Virus Database: 324 - Release Date: 10/16/2003</div>", 
    "prevInTime": 9724, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1066614399", 
    "canDelete": false, 
    "nextInTopic": 9731, 
    "prevInTopic": 9724, 
    "headers": {
        "inReplyToHeader": "PDAwNDMwMWMzOTY1OSQwNTk5ODlmMCQ2NDAxYThjMEBYUDE+", 
        "messageIdInHeader": "PDAwMWMwMWMzOTZhYyQwMTgwYjdhMCQ2NDAxYThjMEBsYXRpdHVkZTAxPg=="
    }
}