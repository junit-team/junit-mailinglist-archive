{
    "numMessagesInTopic": 5, 
    "nextInTime": 19775, 
    "senderId": "_Btc1vE26qNlOPremafsc9BS2nx1UkPRds8io4wViycCZ12HVNiQtVDiMcRqjAnFOcoxj4uGHx4HqFT9oXLjgv97", 
    "systemMessage": false, 
    "subject": "Re: [junit] Re: Junit4 new features ?", 
    "from": "&quot;David Saff&quot; &lt;saff@...&gt;", 
    "authorName": "David Saff", 
    "msgSnippet": "Roger, Thanks for thinking this through. ... My first instinct is to do this with a listener, which appears more configurable. ... Have you seen Filters?  They", 
    "msgId": 19774, 
    "rawEmail": "Return-Path: &lt;david.saff@...&gt;\r\nX-Sender: david.saff@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (qmail 59810 invoked from network); 21 Aug 2007 11:15:22 -0000\r\nReceived: from unknown (66.218.66.68)\n  by m41.grp.scd.yahoo.com with QMQP; 21 Aug 2007 11:15:22 -0000\r\nReceived: from unknown (HELO wx-out-0506.google.com) (66.249.82.239)\n  by mta11.grp.scd.yahoo.com with SMTP; 21 Aug 2007 11:15:21 -0000\r\nReceived: by wx-out-0506.google.com with SMTP id i28so1424697wxd\n        for &lt;junit@yahoogroups.com&gt;; Tue, 21 Aug 2007 04:15:16 -0700 (PDT)\r\nDKIM-Signature: a=rsa-sha1; c=relaxed/relaxed;\n        d=gmail.com; s=beta;\n        h=domainkey-signature:received:received:message-id:date:from:sender:to:subject:in-reply-to:mime-version:content-type:content-transfer-encoding:content-disposition:references:x-google-sender-auth;\n        b=LB/rhBQepL3bgJKHakq9Pb0myZ6+tAqGD9RUxln9Fj2NyvuZsOwqehGI0/8FraQ/GdWTan+bGvXTxL7Cosm4GkplmQ4uA5mIerRlhFFGlhO3fqGlMwHJNTjgmEOHeFw8MLjBVDL3PXxuZGKKsoNVkYHM0wab38KZZ/UAQLsQtxU=\r\nReceived: by 10.90.29.18 with SMTP id c18mr1667752agc.1187694915915;\n        Tue, 21 Aug 2007 04:15:15 -0700 (PDT)\r\nReceived: by 10.90.93.19 with HTTP; Tue, 21 Aug 2007 04:15:15 -0700 (PDT)\r\nMessage-ID: &lt;4f7da6b90708210415x3de1b73ch6ad19ba0cd7ab9b9@...&gt;\r\nDate: Tue, 21 Aug 2007 07:15:15 -0400\r\nTo: junit@yahoogroups.com\r\nIn-Reply-To: &lt;fachqe+eb2i@...&gt;\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Transfer-Encoding: 7bit\r\nContent-Disposition: inline\r\nReferences: &lt;fa55ct+dpkr@...&gt; &lt;fachqe+eb2i@...&gt;\r\nX-Google-Sender-Auth: 2c2c4cd2fa39a51f\r\nX-eGroups-Msg-Info: 1:0:0:0\r\nFrom: &quot;David Saff&quot; &lt;saff@...&gt;\r\nSubject: Re: [junit] Re: Junit4 new features ?\r\nX-Yahoo-Group-Post: member; u=139771899; y=e8VFqrPf-O5JFcn5uaM98Ndd-TlaBFTVlHB8j4ghlnY\r\nX-Yahoo-Profile: dsaff\r\n\r\nRoger,\n\nThanks for thinking this through.\n\nOn 8/20/07, Roger Chen @ RevZoom &lt;coderobochen@...&gt; wrote:\n&gt; &gt; Me and another colleague at work looked at the Junit sources and felt\n&gt; &gt; we should do the failure recording in\n&gt; &gt; org.junit.runner.notification.RunNotifier#fireTestFailure() method.\n&gt; &gt; That would allow any runner to be able to get a list of failed\n&gt; &gt; testcases in an XML or a plain text file.\n\nMy first instinct is to do this with a listener, which appears more\nconfigurable.\n\n&gt; &gt; To re-run the failed tests, we were envisioning a custom test runner\n&gt; &gt; and/or modification to the Ant Junit task (since we use Ant heavily)\n&gt; &gt; that would take a flag to pick up the failed test XML/text file from\n&gt; &gt; a known location ($HOME/.junit/failed-tests.xml for e.g.) and re-run\n&gt; them.\n\nHave you seen Filters?  They should enable re-running failed tests\nwithout a separate custom runner.\n\n&gt; &gt; &gt; 2) I&#39;ve heard of wanting to only instantiate a test class once (you\n&gt; &gt; &gt; can do that in JUnit, see\n&gt; &gt; &gt; http://tech.groups.yahoo.com/group/junit/message/19159).  Is that what\n&gt; &gt; &gt; you&#39;re looking for, or is there another advantage in having non-static\n&gt; &gt; &gt; @BeforeClass, etc?\n&gt; &gt; &gt;\n&gt; &gt;\n&gt; &gt; Yes, consider the following usage pattern we see in our testing:\n&gt; &gt;\n&gt; &gt;   @BeforeClass(\n&gt; &gt;   public void setup() throws IOException {\n&gt; &gt;\n&gt; &gt;     String cname = getClass().getPackage().getName();\n&gt; &gt;     String rd = cname.replace(&#39;.&#39;, &#39;/&#39;);\n&gt; &gt;     File f = MyEnv.getRootDir();\n&gt; &gt;\n&gt; &gt;\n&gt; &gt;     File newRd = new File(f, &quot;/tests/unit/src/java/&quot;+rd);\n&gt; &gt;     MyEnv.setRootDir(newRd.getCanonicalPath());\n&gt; &gt;     MyEnv.setLogPropsFile(newRd.getCanonicalPath()+&quot;/log.properties&quot;);\n&gt; &gt;     setupModules();\n&gt; &gt;   }\n&gt; &gt;\n&gt; &gt; This works nicely with TestNG as the beforeClass non-static method can\n&gt; &gt; be used to determine the current testclass name. In the above snippet\n&gt; &gt; the class name is use to construct the path to the log.properties\n&gt; &gt; (every test class has its own properties file)\n&gt; &gt;\n&gt; &gt; With Juni4 we are forced to use @Before to get the non-static behavior.\n\nI appears you primarily want to write before-class configuration in a\nsuperclass, and have it operate a little differently for each\nsubclass.  (I&#39;m assuming that setupModules is too expensive to run\nmultiple times?)  In TestNG, since there&#39;s only a single instance of\neach test class, that&#39;s the natural place to do this configuration.\nIn JUnit, there are many instances of each test class, so a different\nsyntax would be necessary.  Can you open a feature request with a\nsuggested syntax?\n\n&gt; &gt; The reason I like the dependency model is basically software layering.\n&gt; &gt;   If a module or subsystem is failing unit tests I want to exclude\n&gt; &gt; subsystems or modules that are consumer of the &#39;bad&#39; modules. Prior to\n&gt; &gt;  Junit4 assumptions we were using the pattern of invoking test method\n&gt; &gt; B (if it was a prerequisite for A) again in the test method A:\n&gt; &gt;\n&gt; &gt;  void testMethodA() { ..}\n&gt; &gt;  void testMethod B() {\n&gt; &gt;    testMethodA();\n&gt; &gt;    .. now the code for N..\n&gt; &gt;   }\n&gt; &gt;\n&gt; &gt; For some of the methods that have a non-trivial execution time it\n&gt; &gt; would be great to:\n&gt; &gt;\n&gt; &gt; 1) Avoid re-running them as part of assumptions check again and again\n&gt; &gt; 2) Skip the methods that would fail for sure because of dependent\n&gt; &gt; methods failing\n\nImagine you could set a flag when a test failed.  In another test, you\ncould assume the flag had not been set.  Would that be a sufficient\nAPI?\n\nIn all of these cases, I&#39;m mindful of Kent and Erich&#39;s initial\nstrategy.  It&#39;s valuable to be able to hold all of JUnit in your head,\nso that when looking through someone else&#39;s failing test, you can\nconcentrate on the test and the code, and not a new, unfamiliar\nfeature of JUnit.  So there&#39;s a &quot;burden of proof&quot; for each new\nfeature.  Will it add enough ease of test writing for enough people to\noutweigh the added complexity of test reading?\n\n   David\n\n", 
    "profile": "dsaff", 
    "topicId": 19748, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 139771899, 
    "prevInTime": 19773, 
    "contentTrasformed": false, 
    "postDate": "1187694915", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 19768, 
    "headers": {
        "inReplyToHeader": "PGZhY2hxZStlYjJpQGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PDRmN2RhNmI5MDcwODIxMDQxNXgzZGUxYjczY2g2YWQxOWJhMGNkN2FiOWI5QG1haWwuZ21haWwuY29tPg==", 
        "referencesHeader": "PGZhNTVjdCtkcGtyQGVHcm91cHMuY29tPiA8ZmFjaHFlK2ViMmlAZUdyb3Vwcy5jb20+"
    }
}