{
    "numMessagesInTopic": 2, 
    "nextInTime": 20049, 
    "senderId": "j_7N2RIKnaXsScs3TVvGMqJxITreb5bPcL3mMPy0Oy1LV5wI1ZYBQKI1mAzdIFlVoOcp7hIvyWO5FQMy_fWokL-vf-BD9nSo0WTFNdQ", 
    "systemMessage": true, 
    "subject": "Collecting tests at run-time.", 
    "from": "&quot;Buddha Buck&quot; &lt;blaisepascal@...&gt;", 
    "authorName": "Buddha Buck", 
    "msgSnippet": "We discovered something disheartening from a testing standpoint:  our development and production environments are different in ways which can, and do, change", 
    "msgId": 20048, 
    "profile": "buddhabuck", 
    "topicId": 20048, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 189428691, 
    "messageBody": "<div id=\"ygrps-yiv-682025672\">We discovered something disheartening from a testing standpoint:  our<br/>\ndevelopment and production environments are different in ways which can, and<br/>\ndo, change the manner of execution of our project.  As such, we&#39;d like to<br/>\nrun our unit tests as part of the execution of our final product, and not<br/>\njust through our IDE.<br/>\n<br/>\nWe develop using Eclipse 3.3, using the JUnit4 plugin.  We compile for<br/>\nproduction and acceptance testing using the JET Excelsior ahead-of-time<br/>\ncompiler, which is Java SE 5 compatible.  There are occasions when we have<br/>\nrun into SE6/SE5 compatibility problems but they had a tendency to cause the<br/>\ncompile to fail, not cause incorrect execution, so we didn&#39;t worry much<br/>\nabout it.<br/>\n<br/>\nWe started using the XStream XML serialization library. In its default mode<br/>\nof operation, it actually tests to see what JVM and what libraries it is<br/>\nrunning with to determine what execution mode it wants to run in -- with<br/>\ncertain JVMs, it can use different APIs for increased performance and<br/>\ncapabilities.  In our development environment, it was able to run in<br/>\n&quot;enhanced mode&quot; because it was using a recognized JVM (Sun Java 1.6).  In<br/>\nour production environment, it did not detect a &quot;blessed&quot; JVM, and ran in<br/>\n&quot;pure java mode&quot;.  Our product passed all tests, but failed badly when<br/>\npushed to our Customer because our tests didn&#39;t catch that it wasn&#39;t in<br/>\nenhanced mode.<br/>\n<br/>\nI saw from the JUnit 4 API that it is possible to directly run a testrunner<br/>\non a class, invoking all the tests in the class.  The @...()<br/>\nannotation (and the @RunWith annotation) allows one to make test suites<br/>\nwhich consist of several classes, allowing one invocation of the testrunner<br/>\nto cover all the classes in the suite.  Those techniques seem suited to<br/>\nallowing us to run the tests using our production JVM.  But those seem to<br/>\nrequire manual updating of the class lists in order to add new classes.<br/>\n<br/>\nThe problem is that we currently have over 500 tests, spread among many<br/>\nclasses in many packages.  I see a maintenance nightmare using @<br/>\nSuite.classes() because everytime we add a test class (which we do<br/>\nroutinely) we&#39;d have to manually find a suite to add it to.  I don&#39;t see a<br/>\nway to conveniently say &quot;for all classes in this package (or package<br/>\nhierarchy), run the unit tests&quot;.<br/>\n<br/>\nIs there a way to do what we want that isn&#39;t  a maintenance nightmare?<br/>\n<br/>\n<br/>\n[Non-text portions of this message have been removed]</div>", 
    "prevInTime": 20047, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1193955337", 
    "canDelete": false, 
    "nextInTopic": 20049, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PGYyYmRhYWExMDcxMTAxMTUxNWk2NGU4MDJlOHlmZWI5OWY1ZTEzYTI0MDcwQG1haWwuZ21haWwuY29tPg=="
    }
}