{
    "numMessagesInTopic": 3, 
    "nextInTime": 14777, 
    "senderId": "KJx0fg-nXzVDz5wVmFpeCGqkrOk0gHHtyC3d7VhfIiNulBVUy309WEzJ2ZFmaSNmc4h9ZMnTcQZg9Ai42neFqFAFCynhEDtv", 
    "systemMessage": false, 
    "subject": "RE: [junit] JUnit 4 API layers for IDE support and test-flavor developers", 
    "from": "&quot;Kent Beck&quot; &lt;kentb@...&gt;", 
    "authorName": "Kent Beck", 
    "msgSnippet": "Wes, I ve read your message several times. I get the feeling that if I understood it, I would be in a much better position to finish JUnit 4. It would help me ", 
    "msgId": 14776, 
    "profile": "kentlbeck", 
    "topicId": 13980, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 173198504, 
    "messageBody": "<div id=\"ygrps-yiv-774463227\">Wes,<br/>\n<br/>\nI&#39;ve read your message several times. I get the feeling that if I understood<br/>\nit, I would be in a much better position to finish JUnit 4. It would help me<br/>\nif you would go through your steps below and make concrete proposals where<br/>\nyou can. The problem we are grappling with at the moment is specifying<br/>\nsuites of tests. We&#39;d like the specification to be in source code, be<br/>\ndeclarative if possible, compose nicely, and communicate their intent<br/>\nclearly. We tried attaching annotations to packages (via package-info.java),<br/>\nbut the annotations don&#39;t seem to be available if the compiled code is<br/>\nstored in files and directories instead of a JAR file, so that won&#39;t work.<br/>\n<br/>\nSincerely yours,<br/>\n<br/>\nKent Beck<br/>\nThree Rivers Institute<br/>\n<br/>\n<blockquote><span title=\"qreply\"> &gt; -----Original Message-----<br/>\n&gt; From: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a> [mailto:<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>] On <br/>\n&gt; Behalf Of wesisberg<br/>\n&gt; Sent: Saturday, June 18, 2005 4:00 AM<br/>\n&gt; To: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a><br/>\n&gt; Subject: [junit] JUnit 4 API layers for IDE support and <br/>\n&gt; test-flavor developers<br/>\n&gt; <br/>\n&gt; Hi all (and Kent in particular) -<br/>\n&gt; <br/>\n&gt; Kent has said in the original JUnit 4 thread:<br/>\n&gt; <br/>\n&gt; &gt; The theme of JUnit 4 is to encourage more developers <br/>\n&gt; &gt; to write more tests by further simplifying JUnit.<br/>\n&gt; <br/>\n&gt; and <br/>\n&gt; <br/>\n&gt; &gt; AFAIK, IDEs look for subclasses of TestCase or classes implementing<br/>\n&gt; a static<br/>\n&gt; &gt; suite() method to identify tests.<br/>\n&gt; <br/>\n&gt; imho, that&#39;s a problem: IDE&#39;s are trying to support JUnit tests<br/>\n&gt; directly.  As another design goal for JUnit 4, I&#39;d recommend making <br/>\n&gt; it easy for IDE support developers and test flavor developers as<br/>\n&gt; well as for test developers.  That means getting IDE&#39;s out of the<br/>\n&gt; business of running tests directly.<br/>\n&gt; <br/>\n&gt; In nearly every job I encounter pressure to make tests runnable<br/>\n&gt; under JUnit because of the pervasive IDE and build support <br/>\n&gt; JUnit enjoys.  Because of the assumptions about test classes and<br/>\n&gt; tests being methods, I&#39;ve even had to generate classes using <br/>\n&gt; bytecode toolkits to trick the harness into working.  And using<br/>\n&gt; any variant of test generation entails enforcing code standards <br/>\n&gt; about what happens in static suite() methods.  <br/>\n&gt; <br/>\n&gt; I understand that you&#39;re really only concerned with making things<br/>\n&gt; easier for the test developer, but at this point with JUnit being<br/>\n&gt; the de facto standard, making it easier for domain-specific test<br/>\n&gt; flavors to run as JUnit tests would probably increase the amount<br/>\n&gt; of testing that gets done.<br/>\n&gt; <br/>\n&gt; You&#39;ve already asked for a concrete proposal for an API for<br/>\n&gt; dynamically generated tests (fair enough), but I wanted to check<br/>\n&gt; whether you really did want to be in the business of creating<br/>\n&gt; API layers for IDE/test runner support and test-flavor developers.<br/>\n&gt; You already have the layers, but they&#39;re not orthogonal because<br/>\n&gt; of shared assumptions about test identifiers, tests as methods, etc.<br/>\n&gt; <br/>\n&gt; In process order:<br/>\n&gt; <br/>\n&gt; - {Harness}: to gather test specifications, direct and track testing<br/>\n&gt;   (IDE/Ant/... support developer, command-line test deployer)<br/>\n&gt;   Without this, IDE&#39;s assume a flavor of test, the JUnit one.<br/>\n&gt; <br/>\n&gt; - {TestGatherer}: to select and order tests <br/>\n&gt;   (test deployer as user, test flavor developer as provider)<br/>\n&gt;   Without this, harness has to make test-flavor-specific assumptions<br/>\n&gt;   about test attributes/metadata and suite composition.<br/>\n&gt; <br/>\n&gt; - TestRunner/Test: to create and run each test<br/>\n&gt;   (test developer as user, test flavor developer as provider)<br/>\n&gt;   Where different flavors of tests can be adapted.<br/>\n&gt; <br/>\n&gt; - Test/TestCase: for each flavor of test <br/>\n&gt;   (test developer)<br/>\n&gt;   Here&#39;s where the JUnit model (test == Method) is but one.<br/>\n&gt; <br/>\n&gt; One harness I&#39;ve developed is in open source in the AspectJ tree.  It<br/>\n&gt; concretizes some abstractions that might be relevant:<br/>\n&gt; <br/>\n&gt; - Test specification: this describes a test (for harness selection,<br/>\n&gt; preflight, and display), and can be used by a factory to create the<br/>\n&gt; test.  Among other things, you can create data- or<br/>\n&gt; specification-driven tests and need only create one test at a time,<br/>\n&gt; which makes it easier to have suites with thousands of generated<br/>\n&gt; tests.  <br/>\n&gt; <br/>\n&gt; - Test identifier: In the AspectJ tree, we use the test title as a<br/>\n&gt; test identifier for identifying fixes (failed, now pass) or<br/>\n&gt; regressions (passed, now fail).  This would have to be a first-class<br/>\n&gt; abstraction to avoid knowing too much about test flavors.  (When<br/>\n&gt; generating tests I found it hard to map data-driven identifiers to<br/>\n&gt; method names in generated classes.  And assuming that all tests <br/>\n&gt; are always passing results in failing-test limbo: ignored<br/>\n&gt; by comment or annotation, rather than being visible and managed.)<br/>\n&gt; <br/>\n&gt; - A test run is a composite test composed of sub-runs.  The<br/>\n&gt; distinction between &quot;suite&quot; and &quot;test&quot; is collapsed.  It makes it easy<br/>\n&gt; to write standard test flavors.  For the AspectJ domain, runs are<br/>\n&gt; things like compile, weave, and run, and tests are composed of these<br/>\n&gt; steps.  Put another way, it&#39;s tests all the way down (rather than<br/>\n&gt; suite{, suite..}, test.., assert..).  This is also where<br/>\n&gt; decorators can work, since a parent can act as around advice.<br/>\n&gt; <br/>\n&gt; - Messages are associated with each run, and are ways to pass signals<br/>\n&gt; around.  The default behavior can be like JUnit asserts (abort on fail<br/>\n&gt; message), but the more useful behavior is for the parent to interpret<br/>\n&gt; expected and actual messages.  This makes it easier to reuse steps<br/>\n&gt; (e.g., database lookup - normal; database lookup (broken pipe)), and<br/>\n&gt; to have endemic logging.  (One critique I have of JUnit is that it<br/>\n&gt; assumes the developer is evaluating a test failure and can re-run the<br/>\n&gt; test (or that the stack trace is sufficient); messages make it easy<br/>\n&gt; for another developer or for build folks to identify things like setup<br/>\n&gt; failures.)<br/>\n&gt; <br/>\n&gt; - keywords are simply text associated with a test (cf JavaTest). <br/>\n&gt; These make it very easy to self-name and anoint tests, and to select<br/>\n&gt; tests based on unions, intersections, etc.  Annotations can be one<br/>\n&gt; source for these. <br/>\n&gt; <br/>\n&gt; - Sandbox is a place for temporary junk, encoding good TDD practice.<br/>\n&gt; (In the AspectJ harness it also provides shared state, so, e.g., the<br/>\n&gt; compiler can set the classpath used when running the class). <br/>\n&gt; However...)<br/>\n&gt; <br/>\n&gt; (This is by no means to say the AspectJ harness is a model for JUnit;<br/>\n&gt; it&#39;s feature-driven and not for general use.)<br/>\n&gt; <br/>\n&gt; Two other things not in the harness:<br/>\n&gt; <br/>\n&gt; - World (in the weaver). For expressly-shared state.  <br/>\n&gt; <br/>\n&gt; - a thread&#39;s current messages, sandbox, test (i.e., chain of tests),<br/>\n&gt; and world might all be accessible via a threadlocal, so IDE/harnesses<br/>\n&gt; can provide real-time or snapshot information.  Elsewhere I&#39;ve called<br/>\n&gt; variants of this the test context.<br/>\n&gt; <br/>\n&gt; This is  a more ambitious project than upgrading JUnit to simplify <br/>\n&gt; the test developer&#39;s work using annotations and static imports, so<br/>\n&gt; I&#39;m assuming you&#39;re not interested in all of it, but might be <br/>\n&gt; interested in concrete/code proposals for categories/keywords and<br/>\n&gt; factories.  However, I figured now&#39;s the time to ask!<br/>\n&gt; <br/>\n&gt; Wes </span></blockquote></div>", 
    "prevInTime": 14775, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1126588972", 
    "canDelete": false, 
    "nextInTopic": 14781, 
    "prevInTopic": 13980, 
    "headers": {
        "inReplyToHeader": "PGQ5MHVydCtpOTFyQGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PEUxRUYzRzQtMDAwNExDLUZuQHNtdHBhdXRoMDMubWFpbC5hdGwuZWFydGhsaW5rLm5ldD4="
    }
}