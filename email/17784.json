{
    "numMessagesInTopic": 287, 
    "nextInTime": 17785, 
    "senderId": "2uuFrHUFk3wSl5imY5TM4jOHZ7aL0nh2b41s12zr94Papc04aYL77h1M2hbFjwG05vdqZZEyUQ7K_zRi-7dFgD5rJhvFKv9JMj1BsR1VAoo", 
    "systemMessage": false, 
    "subject": "Re: Test-friendly, but not caller-friendly?", 
    "from": "Robert Martin &lt;UncleBob@...&gt;", 
    "authorName": "Robert Martin", 
    "msgSnippet": "... Sorry, sometimes I forget about Java s dumb rules about where you can have static methods and where you can t.  Anyway, this works in Java and amounts to", 
    "msgId": 17784, 
    "profile": "rmartinoma", 
    "topicId": 17266, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 85922638, 
    "messageBody": "<div id=\"ygrps-yiv-611733677\"><blockquote><span title=\"ireply\">&gt; Robert Martin wrote:<br/>\n&gt;<br/>\n&gt; &gt; It&#39;s not. Overuse of factories is an abomination. So *IF* I thought<br/>\n&gt; &gt; an interface would help, I would simply prefer:<br/>\n&gt; &gt;<br/>\n&gt; &gt; Document doc = Document.newDocument();<br/>\n&gt;<br/>\n&gt; But you can&#39;t do that with an interface. At a minimum you need<br/>\n&gt;<br/>\n&gt; Document doc = Factory.newDocument();<br/>\n<br/>\n </span></blockquote>Sorry, sometimes I forget about Java&#39;s dumb rules about where you can  <br/>\nhave static methods and where you can&#39;t.  Anyway, this works in Java  <br/>\nand amounts to the same thing:<br/>\n<br/>\ninterface Document extends Cloneable {<br/>\n   public static Document prototype = null;<br/>\n   ...<br/>\n}<br/>\n<br/>\nDocument doc = Document.prototype.clone();<br/>\n<br/>\nMake sure &quot;main&quot; sets the Document.prototype variable to the  <br/>\nprototypical Document derivative.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;<br/>\n&gt; &gt; The simplicity of interfaces vs concrete classes comes from<br/>\n&gt; &gt; dependencies. Let&#39;s say we have some concrete class named<br/>\n&gt; &gt; MyDocument, and it has lots and lots of methods. Users of this class<br/>\n&gt; &gt; depend on all these methods even if they don&#39;t call them. If I make<br/>\n&gt; &gt; a change to MyDocument it can affect all the callers to the extent<br/>\n&gt; &gt; that they all have to be recompiled and redeployed. (Yes, you can<br/>\n&gt; &gt; play the game and try to figure out whether or not the class really<br/>\n&gt; &gt; and truly needs to be recompiled, but that way lay madness.)<br/>\n&gt;<br/>\n&gt; In Java, if the public interface of the class doesn&#39;t change, you  <br/>\n&gt; don;t<br/>\n&gt; need to recompile clients. In fact, even if you only add things to the<br/>\n&gt; public interface of the class, you don&#39;t need to recompile clients.<br/>\n<br/>\n </span></blockquote>Not quite true.  It is possible to add a method to the public  <br/>\ninterface of a java class that makes previous calls to similar  <br/>\nmethods ambiguous.   For example:<br/>\n<br/>\npublic class Y {<br/>\n   public static void main(String[] args) {<br/>\n     X x = new X();<br/>\n     x.f(1);<br/>\n   }<br/>\n}<br/>\n<br/>\npublic class X {<br/>\n   public void f(double d) {<br/>\n     System.out.println(&quot;d = &quot; + d);<br/>\n   }<br/>\n<br/>\n//  public void f(int i) {<br/>\n//    System.out.println(&quot;i = &quot; + i);<br/>\n//  }<br/>\n}<br/>\n<br/>\nAdding the second f function without recompiling Y can lead to the  <br/>\nwrong function being called.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; In<br/>\n&gt; fact, you only need to recompile clients if the public interface  <br/>\n&gt; changes<br/>\n&gt; in such a way that the clients need to be rewritten.<br/>\n<br/>\n </span></blockquote>True, except when it isn&#39;t.  Anyway, like I said, you can play the  <br/>\ngame that way if you like; but it&#39;s not foolproof.  Anyway, most IDEs  <br/>\nand build systems are pretty aggressive about recompiling if they  <br/>\nthink something might have changed.  This can make it difficult to  <br/>\nplay the game.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;<br/>\n&gt; &gt; If I interpose one or more interfaces then suddenly the callers<br/>\n&gt; &gt; depend ONLY on the methods in the interfaces that they use; and  <br/>\n&gt; those<br/>\n&gt; &gt; interfaces can be *very* sparse.<br/>\n&gt;<br/>\n&gt; If I have a class that depends on only two methods in the library  <br/>\n&gt; class,<br/>\n&gt; then any changes beyond those two methods and the class signature  <br/>\n&gt; itself<br/>\n&gt; are irrelevant to the client, and do not require recompilation. You do<br/>\n&gt; not need to interpose an interface to get this benefit. Dynamic  <br/>\n&gt; binding<br/>\n&gt; gives this to you automatically.<br/>\n<br/>\n </span></blockquote>That&#39;s the theory.  In a language like Ruby it works 100% of the  <br/>\ntime.  In a language like Java it works 99% of the time.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Now in a language like C++ that links<br/>\n&gt; statically, it may be a very different story. But in Java the clients<br/>\n&gt; depend only on the methods in the class that they actually use. A  <br/>\n&gt; public<br/>\n&gt; change to a method the client actually uses requires rewriting and<br/>\n&gt; recompilation, but so does a change to such a method in an interface.<br/>\n&gt; Interfaces add nothing to this.<br/>\n&gt;<br/>\n&gt; &gt; Even if there is only one<br/>\n&gt; &gt; interface, and that interface has all the methods of MyDocument I  <br/>\n&gt; can<br/>\n&gt; &gt; still swap out MyDocument for some other implementation or some Mock<br/>\n&gt; &gt; implementation. I can also add new methods to MyDocument without<br/>\n&gt; &gt; forcing recompilation and redeployment of the callers.<br/>\n&gt;<br/>\n&gt; Again, if MyDocument is a class you can still add new methods to<br/>\n&gt; MyDocument without forcing recompilation and redeployment of the<br/>\n&gt; callers. This has nothing to do with interfaces and everything to do<br/>\n&gt; with dynamic linking. (And again, I&#39;m talking about Java here. It  <br/>\n&gt; can be<br/>\n&gt; different in other languages.)<br/>\n<br/>\n </span></blockquote>Let me put it to you another way.  Module A depends on Module B, but  <br/>\nonly if you call the A.f method.  I ship you a new version of Module  <br/>\nA but I don&#39;t give you the latest module B because you don&#39;t call the  <br/>\nf method.  Are you happy?  Or are you going to ask me for module B  <br/>\nanyway, just in case...?  Or would you rather I give you an interface  <br/>\nfor Module A that does not have the f method?<br/>\n<br/>\n<br/>\n----<br/>\nRobert C. Martin (Uncle Bob)  | email: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:unclebob@...\">unclebob@...</a><br/>\nObject Mentor Inc.            | blog:  www.butunclebob.com<br/>\nThe Agile Transition Experts  | web:   www.objectmentor.com<br/>\n800-338-6716                  |<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n[Non-text portions of this message have been removed]</div>", 
    "prevInTime": 17783, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1157417753", 
    "canDelete": false, 
    "nextInTopic": 17785, 
    "prevInTopic": 17783, 
    "headers": {
        "messageIdInHeader": "PEJDQUFERDM5LTM0MDgtNDhGOS1CRkM1LUFDNkQwNjcyN0MzNUBvYmplY3RtZW50b3IuY29tPg=="
    }
}