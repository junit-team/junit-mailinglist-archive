{
    "numMessagesInTopic": 20, 
    "nextInTime": 23959, 
    "senderId": "LeSHVt67i8t6y8ciYFkhG3Tv7ZZTHG1lObcbUoSMzQ70OwshywVmHP88RU4kmwmMsUQuummV0K9qeRRI9_PoZFmZm37Hu9nHYA", 
    "systemMessage": false, 
    "subject": "Re: Feedback Required | Extending Junit to perform Data Driven Testing", 
    "from": "&quot;Anuj&quot; &lt;anujkumar1516@...&gt;", 
    "authorName": "Anuj", 
    "msgSnippet": "Het Matthew, I think my previous mail got lost as I cannot see it being delivered to the group even after 3 hours. So here is my response once again: 1)", 
    "msgId": 23958, 
    "profile": "anujkumar1516", 
    "topicId": 23950, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 353028991, 
    "messageBody": "<div id=\"ygrps-yiv-19626934\">Het Matthew,<br/>\n<br/>\nI think my previous mail got lost as I cannot see it being delivered to the group even after 3 hours.<br/>\nSo here is my response once again:<br/>\n<br/>\n1) Parameterized runner does not work in a way that I was talking about DataLoader below. It has the drawback that if you provide a single set of test data for multiple methods, it will pass all the test data to all the methods. Have a look at this blog post for more clarification of the Parameterized Runner and its drawback: <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.kumaranuj.com/2012/08/junits-parameterized-runner-and-data.html\">http://www.kumaranuj.com/2012/08/junits-parameterized-runner-and-data.html</a><br/>\n<br/>\n2) I feel a new runner would be a better approach although I do not know what all feature set will this runner support.<br/>\n<br/>\n3) I feel it is easier and also simpler if we get rid of the whole idea of providing method names. I say this because in real world scenario, no two test methods will have exactly the same set of test data. Thus the name of the method should suffice instead of asking the user to explicitly specify the method name in the annotation. But thats just my approach.<br/>\n<br/>\nI feel this requires more input from the community.<br/>\n<br/>\nCheers!<br/>\nAnuj<br/>\n<br/>\n<blockquote><span title=\"qreply\"> --- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>, Matthew Farwell &lt;matthew@...&gt; wrote:<br/>\n&gt;<br/>\n&gt; Sorry for any misunderstanding, I agree that there are parts which need to<br/>\n&gt; be clarified. See my responses inline:<br/>\n&gt; <br/>\n&gt; 2012/8/28 Anuj &lt;anujkumar1516@...&gt;<br/>\n&gt; <br/>\n&gt; &gt; **<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt; Hi Matthew,<br/>\n&gt; &gt; Sorry for replying late. I was caught up in a lot of other stuff.<br/>\n&gt; &gt; I saw the proposal for @DataProvider and it looks a good start, but IMHO<br/>\n&gt; &gt; it might not turn out to be a great one. Here are some reasons why I feel<br/>\n&gt; &gt; such apprehension:<br/>\n&gt; &gt;<br/>\n&gt; &gt; 1)The annotation currently is applied per method, which means that if<br/>\n&gt; &gt; there is a single class providing the input test data for 10 test methods,<br/>\n&gt; &gt; the user has to apply the annotation over each test method. This seems<br/>\n&gt; &gt; undesirable as it promotes duplicacy within the test class. Moreover,<br/>\n&gt; &gt; running each test method would mean extra processing, which can be avoided<br/>\n&gt; &gt; by making the annotation support ElementType.TYPE as well. I have a similar<br/>\n&gt; &gt; annotation(@DataLoader)in my test framework, EasyTest that supports such a<br/>\n&gt; &gt; behavior.(<br/>\n&gt; &gt; <a rel=\"nofollow\" target=\"_blank\" href=\"https://github.com/anujgandharv/easytest/blob/master/src/main/java/org/easytest/annotation/DataLoader.java\">https://github.com/anujgandharv/easytest/blob/master/src/main/java/org/easytest/annotation/DataLoader.java</a><br/>\n&gt; &gt; )<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; If you have a single set of data which applies to all of the test methods,<br/>\n&gt; then you can use the current implementation of Parameterized. My point was<br/>\n&gt; that I wish to have two methods which have separate sets of data, so<br/>\n&gt; therefore I have to specify the DataProvider multiple times. Unless of<br/>\n&gt; course, you&#39;re suggesting that if we specify @DataProvider at class level,<br/>\n&gt; it has the same effect as the current Parameterized? I wouldn&#39;t object to<br/>\n&gt; that.<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; &gt; 2)It is not clear from the discussion which JUnit Runner will support this<br/>\n&gt; &gt; annotation: Parameterized or Theories or there would be a new Runner.<br/>\n&gt; &gt;<br/>\n&gt; I was planning to modify Parameterized, but a new runner would be<br/>\n&gt; acceptable.<br/>\n&gt; <br/>\n&gt; &gt;<br/>\n&gt; &gt; 3)It would be nice if we give some sense of direction to the user<br/>\n&gt; &gt; regarding the structure of DataProviderClass and the method it supports.<br/>\n&gt; &gt; So, something like :<br/>\n&gt; &gt;<br/>\n&gt; &gt; Class&lt;? extends Provider&gt; dataProviderClass() default EmptyProvider.class;<br/>\n&gt; &gt;<br/>\n&gt; &gt; Again, forcing people to use an interface for the external classes was my<br/>\n&gt; first thought. However, since we&#39;re specifying the name of the method in<br/>\n&gt; our DataProvider (if dataProviderClass is not specified), why not be able<br/>\n&gt; to specify it in the dataProviderClass? The main difference would be that<br/>\n&gt; the method would need to be static in our class, whereas in the<br/>\n&gt; dataProviderClass it could be non-static.<br/>\n&gt; <br/>\n&gt; 3)I somehow get the feeling(and it could be simply me and if that is the<br/>\n&gt; &gt; case, please ignore me) that the aspect of performing Data Driven Testing<br/>\n&gt; &gt; should be given more time, and proper thought should be put in around its<br/>\n&gt; &gt; design and the way it will be made available to the end users. I feel we<br/>\n&gt; &gt; should not rush into developing a feature focusing a single use<br/>\n&gt; &gt; case/requirement, rather we should try to first gather and understand all<br/>\n&gt; &gt; the aspects of Data Driven Testing and then develop that requirement as a<br/>\n&gt; &gt; whole rather than in pieces.<br/>\n&gt; &gt;<br/>\n&gt; <br/>\n&gt; I&#39;m not rushing, that&#39;s why I&#39;m asking the question on the junit mailing<br/>\n&gt; list :-) However, I think this is a generalization of the current usage of<br/>\n&gt; Parameterized, and this would be useful, to me at least.<br/>\n&gt; <br/>\n&gt; Thanks.<br/>\n&gt; <br/>\n&gt; Matthew.<br/>\n&gt; <br/>\n&gt; &gt;<br/>\n&gt; &gt; I would be much more beneficial to the community as a whole.<br/>\n&gt; &gt;<br/>\n&gt; &gt; Thanks,<br/>\n&gt; &gt; Anuj<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt; --- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>, Matthew Farwell &lt;matthew@&gt; wrote:<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; Hello,<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; Sorry this took so long to get back to you, but I was trying to get my<br/>\n&gt; &gt; &gt; thoughts together.<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; I don&#39;t believe that the suggestion below fits in with the current JUnit<br/>\n&gt; &gt; &gt; philospohy, so doesn&#39;t belong in the junit core library. Specifically, I<br/>\n&gt; &gt; &gt; don&#39;t think CSV/Excel/XML parsing belongs in JUnit, so I agree with your<br/>\n&gt; &gt; &gt; decision to write it as an extension rather than as part of junit core.<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; However, I do believe that we can add stuff to JUnit core in order to<br/>\n&gt; &gt; allow<br/>\n&gt; &gt; &gt; people to do this sort of thing more easily, and maybe help you with your<br/>\n&gt; &gt; &gt; code as well.<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; I often have the following problem: I&#39;ve got a class Foo in which I&#39;m<br/>\n&gt; &gt; &gt; testing multiple methods (foo#addInts & foo#addStrings). So I create a<br/>\n&gt; &gt; &gt; single class to test the two. But if either of these methods are better<br/>\n&gt; &gt; &gt; tested using parameterized, then I can&#39;t do it because I have to define<br/>\n&gt; &gt; the<br/>\n&gt; &gt; &gt; constructor. So, what I would propose is to have a @DataProvider<br/>\n&gt; &gt; annotation<br/>\n&gt; &gt; &gt; which specifies a method to call which returns a collection of data for<br/>\n&gt; &gt; &gt; this particular method. The test method is called for each item in the<br/>\n&gt; &gt; &gt; list. See <a rel=\"nofollow\" target=\"_blank\" href=\"https://gist.github.com/3471426\">https://gist.github.com/3471426</a> for a short proposal. I think<br/>\n&gt; &gt; &gt; this would be fairly easy to do.<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; I also think this would be extensible in another framework, specifically<br/>\n&gt; &gt; in<br/>\n&gt; &gt; &gt; your case. All you should have to do is extend the @DataParameter so that<br/>\n&gt; &gt; &gt; the data comes from another source. Again, see the gist, you&#39;d just have<br/>\n&gt; &gt; to<br/>\n&gt; &gt; &gt; specify a dataProviderClass.<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; What do people think of this idea, and what do you (anuj) think also?<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; Thanks.<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; Matthew Farwell.<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; 2012/8/21 Anuj &lt;anujkumar1516@&gt;<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; **<br/>\n&gt; &gt;<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; Looks like the formatting of the above message got out of hands. So<br/>\n&gt; &gt; here&#39;s<br/>\n&gt; &gt; &gt; &gt; one more try ondifferent things that can be achieved with the new<br/>\n&gt; &gt; extension:<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; CASE 1: Specify test data in the form of CSV file. You can choose the<br/>\n&gt; &gt; type<br/>\n&gt; &gt; &gt; &gt; of file containing the data:(CSV,EXCEL,XML or CUSTOM)<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; @Theory@TestData(filePaths = { &quot;getTestData.csv&quot; }, fileType =<br/>\n&gt; &gt; &gt; &gt; FileType.CSV) //This is new annotation definedpublic void<br/>\n&gt; &gt; &gt; &gt; testGetItems(@DataProvider()Map&lt;String, String&gt; inputData) {<br/>\n&gt; &gt; &gt; &gt; .....# The Map corresponds to a single row of test data in the CSV<br/>\n&gt; &gt; file.<br/>\n&gt; &gt; &gt; &gt; }<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; CASE 2: Gives user flexibility to provide its own custom loader, in<br/>\n&gt; &gt; case<br/>\n&gt; &gt; &gt; &gt; the framework does not support the data file :<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; @Theory<br/>\n&gt; &gt; &gt; &gt; @TestData(filePaths = { &quot;getItemsData.dat&quot; }, fileType =<br/>\n&gt; &gt; FileType.CUSTOM)<br/>\n&gt; &gt; &gt; &gt; @CustomLoader(loader = MyDataLoader.class)<br/>\n&gt; &gt; &gt; &gt; public void testWithCustomLoader(@DataProvider()Map&lt;String, String&gt;<br/>\n&gt; &gt; &gt; &gt; inputData) {<br/>\n&gt; &gt; &gt; &gt; # The Map corresponds to a single row of test data in the .dat file.<br/>\n&gt; &gt; &gt; &gt; }<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; CASE 3: Auto detects and populates user defined objects:<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; @Theory<br/>\n&gt; &gt; &gt; &gt; @TestData(filePaths = { &quot;getItemsData.csv&quot; })<br/>\n&gt; &gt; &gt; &gt; public void testWithStrongParameters(@DataProvider()LibraryId id ,<br/>\n&gt; &gt; &gt; &gt; @DataProvider(paramName=&quot;itemid&quot;) ItemId itemId) {<br/>\n&gt; &gt; &gt; &gt; # DataProvide annotation tells the framework that the parameter&#39;s value<br/>\n&gt; &gt; &gt; &gt; should be provided by the framework. It can also take an optional<br/>\n&gt; &gt; paramName<br/>\n&gt; &gt; &gt; &gt; which gives more control over the data to the user.<br/>\n&gt; &gt; &gt; &gt; }<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; OR<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; @Theory<br/>\n&gt; &gt; &gt; &gt; @TestData(filePaths = { &quot;getItemsData.csv&quot; })<br/>\n&gt; &gt; &gt; &gt; public void testConverter(@DataProvider() Item item){<br/>\n&gt; &gt; &gt; &gt; Assert.assertNotNull(item);<br/>\n&gt; &gt; &gt; &gt; System.out.println(item.getDescription() + item.getItemId() +<br/>\n&gt; &gt; &gt; &gt; item.getItemType());<br/>\n&gt; &gt; &gt; &gt; }<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; Hopefully the format will remain this time.<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; Cheers!<br/>\n&gt; &gt; &gt; &gt; Anuj<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; --- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>, &quot;Anuj&quot; &lt;anujkumar1516@&gt; wrote:<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt; Hi, I am looking for some feedback into my work of extending JUnit&#39;s<br/>\n&gt; &gt; &gt; &gt; &gt; capability to perform Data Driven Testing using annotations.You can<br/>\n&gt; &gt; find<br/>\n&gt; &gt; &gt; &gt; &gt; the source code here :<br/>\n&gt; &gt; &gt; &gt; &gt; <a rel=\"nofollow\" target=\"_blank\" href=\"https://github.com/anujgandharv/junit-theories-ext/\">https://github.com/anujgandharv/junit-theories-ext/</a><br/>\n&gt; &gt; &gt; &gt; &gt; &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"https://github.com/anujgandharv/junit-theories-ext/\">https://github.com/anujgandharv/junit-theories-ext/</a>&gt;<br/>\n&gt; &gt; &gt; &gt; &gt; Please enter any suggestions/improvements/requests to the GitHub<br/>\n&gt; &gt; &gt; &gt; &gt; repository or main me directly at anuj.gandharv@<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt; These are some of the extensions to the existing JUnit Theories<br/>\n&gt; &gt; runner :<br/>\n&gt; &gt; &gt; &gt; &gt; CASE 1: Specify test data in the form of CSV file. You can choose the<br/>\n&gt; &gt; &gt; &gt; &gt; type of file containing the data:(CSV,EXCEL,XML or CUSTOM)<br/>\n&gt; &gt; &gt; &gt; &gt; @Theory@TestData(filePaths = { &quot;getTestData.csv&quot; }, fileType =<br/>\n&gt; &gt; &gt; &gt; &gt; FileType.CSV) //This is new annotation definedpublic void<br/>\n&gt; &gt; &gt; &gt; &gt; testGetItems(@DataProvider()Map&lt;String, String&gt; inputData) {<br/>\n&gt; &gt; &gt; &gt; &gt; .....# The Map corresponds to a single row of test data in the CSV<br/>\n&gt; &gt; &gt; &gt; &gt; file.<br/>\n&gt; &gt; &gt; &gt; &gt; }<br/>\n&gt; &gt; &gt; &gt; &gt; CASE 2: Gives user flexibility to provide its own custom loader, in<br/>\n&gt; &gt; case<br/>\n&gt; &gt; &gt; &gt; &gt; the framework does not support the data file :<br/>\n&gt; &gt; &gt; &gt; &gt; @Theory@TestData(filePaths = { &quot;getItemsData.dat&quot; }, fileType =<br/>\n&gt; &gt; &gt; &gt; &gt; FileType.CUSTOM)@CustomLoader(loader = MyDataLoader.class)public void<br/>\n&gt; &gt; &gt; &gt; &gt; testWithCustomLoader(@DataProvider()Map&lt;String, String&gt; inputData) {<br/>\n&gt; &gt; &gt; &gt; &gt; # The Map corresponds to a single row of test data in the .dat file.<br/>\n&gt; &gt; &gt; &gt; &gt; }<br/>\n&gt; &gt; &gt; &gt; &gt; CASE 3: Auto detects and populates user defined objects:<br/>\n&gt; &gt; &gt; &gt; &gt; @Theory@TestData(filePaths = { &quot;getItemsData.csv&quot; })public void<br/>\n&gt; &gt; &gt; &gt; &gt; testWithStrongParameters(@DataProvider()LibraryId id ,<br/>\n&gt; &gt; &gt; &gt; &gt; @DataProvider(paramName=&quot;itemid&quot;) ItemId itemId) { # DataProvide<br/>\n&gt; &gt; &gt; &gt; &gt; annotation tells the framework that the parameter&#39;s value should be<br/>\n&gt; &gt; &gt; &gt; &gt; provided by the framework. It can also take an optional paramName<br/>\n&gt; &gt; &gt; &gt; &gt; which gives more control over the data to the user.<br/>\n&gt; &gt; &gt; &gt; &gt; }<br/>\n&gt; &gt; &gt; &gt; &gt; OR<br/>\n&gt; &gt; &gt; &gt; &gt; @Theory@TestData(filePaths = { &quot;getItemsData.csv&quot; })public void<br/>\n&gt; &gt; &gt; &gt; &gt; testConverter(@DataProvider() Item item){ Assert.assertNotNull(item);<br/>\n&gt; &gt; &gt; &gt; &gt; System.out.println(item.getDescription() + item.getItemId() +<br/>\n&gt; &gt; &gt; &gt; &gt; item.getItemType());<br/>\n&gt; &gt; &gt; &gt; &gt; }<br/>\n&gt; &gt; &gt; &gt; &gt; As specified above, you can find the source code here :<br/>\n&gt; &gt; &gt; &gt; &gt; <a rel=\"nofollow\" target=\"_blank\" href=\"https://github.com/anujgandharv/junit-theories-ext/\">https://github.com/anujgandharv/junit-theories-ext/</a><br/>\n&gt; &gt; &gt; &gt; &gt; &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"https://github.com/anujgandharv/junit-theories-ext/\">https://github.com/anujgandharv/junit-theories-ext/</a>&gt;<br/>\n&gt; &gt; &gt; &gt; &gt; Please enter any suggestions/improvements/requests to the GitHub<br/>\n&gt; &gt; &gt; &gt; &gt; repository or main me directly at anuj.gandharv@<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt; Thanks, Anuj<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt; [Non-text portions of this message have been removed]<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; [Non-text portions of this message have been removed]<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt;  <br/>\n&gt; &gt;<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; [Non-text portions of this message have been removed]<br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 23957, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1346163821", 
    "canDelete": false, 
    "nextInTopic": 23959, 
    "prevInTopic": 23957, 
    "headers": {
        "inReplyToHeader": "PENBT0Jrb0ZYdzhvV3JfVDNoUEtlUGFPUzhrOUthMj0wY2JhbT1idStLVTVocXBVa1NrUUBtYWlsLmdtYWlsLmNvbT4=", 
        "messageIdInHeader": "PGsxaWs5ZCs2cHI5QGVHcm91cHMuY29tPg=="
    }
}