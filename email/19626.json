{
    "numMessagesInTopic": 48, 
    "nextInTime": 19627, 
    "senderId": "hR60vhTpa9DmzGfHkuDUHQ2WmKubtdTaZtNaBL_iS94-bvBNyeeLF48KhINboBoAqjbuC3S_uK7W8rHbp0kGRPJ3S8jwkCEg", 
    "systemMessage": false, 
    "subject": "[junit] Re: Test Grouping/Partitioning", 
    "from": "&quot;Kent Beck&quot; &lt;kentb@...&gt;", 
    "authorName": "Kent Beck", 
    "msgSnippet": "All, It seems clear to me that some sort of test classification scheme is a reasonable thing to add to JUnit. However, rather than simply copy one of the", 
    "msgId": 19626, 
    "profile": "kentlbeck", 
    "topicId": 19521, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 173198504, 
    "messageBody": "<div id=\"ygrps-yiv-914347619\">All,<br/>\n <br/>\nIt seems clear to me that some sort of test classification scheme is a<br/>\nreasonable thing to add to JUnit. However, rather than simply copy one of<br/>\nthe models out there we&#39;re going to go back to first principles and try to<br/>\nderive a model for classification that is concise, useful, flexible, and,<br/>\nabove all, easy to use.<br/>\n <br/>\nI&#39;ve heard two purposes for classification:<br/>\n  * Performance<br/>\n  * Assumptions<br/>\n <br/>\nPerformance<br/>\n <br/>\nIf you have tests that run for longer than your attention span (my limits<br/>\nare 1 second for the inner loop of programming and 10 minutes for<br/>\nintegration), running a subset of the tests can give you some assurance that<br/>\nthe software is working. Classification is one way to reduce test run<br/>\ntime--just this one test, all tests in this class, all tests in this<br/>\npackage, all tests labeled &quot;quick&quot;, etc.<br/>\n <br/>\nThere are other ways of reducing test run time. For example, you could have<br/>\na runner that runs 1 second worth of the tests that have failed most<br/>\nrecently or a runner that runs half a second of recently failed tests plus<br/>\nhalf a second of randomly selected tests.<br/>\n <br/>\nIn the end I think the systemic solution to test run times is to improve<br/>\ndesign and testing techniques to dramatically increase the assurance/CPU<br/>\ncycle ratio. <br/>\n <br/>\nI remember a friend&#39;s story of an early project that used tests extensively.<br/>\nAfter three years they had a carefully tuned suite that took ten minutes to<br/>\nrun. When the test runtime increased beyond ten minutes, they would work on<br/>\nthe design of the system and/or the design of the tests to improve the<br/>\nassurance/CPU cycle ratio and get the runtime back under ten minutes. Then<br/>\nmost of the original team left. <br/>\n <br/>\nA few years later my friend was shown the system. The programmer proudly<br/>\nexplained that the test suites now took 24 hours to run, even though the<br/>\nsystem had grown little in functionality. They had stopped paying attention<br/>\nto designing for testability. Every time they added a new axis of<br/>\nvariability they blindly ran the cross product of the existing tests with<br/>\nall the alternatives for the new axis. Yes they had more tests, but A/C had<br/>\ndropped by several orders of magnitude.<br/>\n <br/>\nIn short, I see using classification to reduce test runtime as a bandage<br/>\nmasking the real problem which is low A/C. Using classification to reduce<br/>\ntest runtime really is a hack and I hope people will continue working to<br/>\nimprove design for testability. We will still provide some classification<br/>\nmechanism, but that doesn&#39;t make it not a hack.<br/>\n <br/>\nAssumptions<br/>\n <br/>\nThe second reason I&#39;ve heard for classification is to avoid a slew of<br/>\nmisleadingly failing tests. If my development machine doesn&#39;t have access to<br/>\nthe database, then if I run the database tests I&#39;ll get a bunch of failures<br/>\neven though the system is really working (or, to be more precise, I don&#39;t<br/>\nhave any information about whether the system is really working or not).<br/>\n <br/>\nClassification is one way to express assumptions. When I say &quot;@Test(groups =<br/>\n{&quot;database&quot;})&quot; I have declared something about this test. However, this<br/>\nexpression seems limited and error-prone to me. I&#39;d prefer to have the power<br/>\nof a programming language to express my assumptions.<br/>\n <br/>\nIn the JUnit 4.4 you can use assumeThat() to express assumptions. For<br/>\nexample, you can say:<br/>\n <br/>\npublic class DatabaseTest {<br/>\n  @BeforeClass public static void isDatabaseAccessible() {<br/>\n    User result= Database.login(&quot;kent&quot;);<br/>\n    assumeThat(not(isError(result));<br/>\n  }<br/>\n  ...<br/>\n}<br/>\n <br/>\nThis is a bit of a workaround because runner don&#39;t yet handle failed<br/>\nassumptions as anything other than successful tests, but it gives you a<br/>\nricher language to express assumptions than a textual classification scheme.<br/>\n <br/>\nThe Point<br/>\n <br/>\nSo now the point of this long post. Are there other uses of classification<br/>\nthat I&#39;ve missed? Is the above way of expressing assumptions (or something<br/>\nderived from it like an explicit @Assumption) sufficient?<br/>\n <br/>\nRegards,<br/>\n <br/>\nKent Beck<br/>\nThree Rivers Institute<br/>\n<br/>\n<br/>\n[Non-text portions of this message have been removed]</div>", 
    "prevInTime": 19625, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1185489508", 
    "canDelete": false, 
    "nextInTopic": 19627, 
    "prevInTopic": 19624, 
    "headers": {
        "messageIdInHeader": "PDAwMzEwMWM3Y2ZkNSRhZmY1ZTU2MCQ2NzAxYThjMEBrZW50c3BhdmlsaW9uPg=="
    }
}