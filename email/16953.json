{
    "numMessagesInTopic": 31, 
    "nextInTime": 16954, 
    "senderId": "ukMIfBt_8Ab3ZNmFaqmgWpdgTmkJ21cNDykoRstD63EJ-ha004S1U8KsgqsjyatdE_6udqAiK2whjkum-Suygp5T1ZJyC2T2UDiV0UjOuYIX", 
    "systemMessage": true, 
    "subject": "Re: [junit] Multiple assertions per test", 
    "from": "&quot;Brett L. Schuchert&quot; &lt;schuchert@...&gt;", 
    "authorName": "Brett L. Schuchert", 
    "msgSnippet": "Stephen, In your example (testing an expensive external resource), here s how I d test it if I really didn t want to call it once per test (using JUnit 4, but", 
    "msgId": 16953, 
    "profile": "schuchert", 
    "topicId": 16876, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 162568887, 
    "messageBody": "<div id=\"ygrps-yiv-780061287\">Stephen,<br/>\n <br/>\nIn your example (testing an expensive external resource), here&#39;s how I&#39;d test it if I really didn&#39;t want to call it once per test (using JUnit 4, but this can be done in 3.8.1):<br/>\n <br/>\npublic class Foo {<br/>\n <br/>\n   private static Object expensiveResult;<br/>\n   private Object perTestExpensiveResultCopy;<br/>\n <br/>\n   @BeforeClass <br/>\n   public static void performExpensiveCall() {<br/>\n      // call expensive external resource and store result<br/>\n     expensiveResult = externalResource.call();<br/>\n   }<br/>\n <br/>\n   // now for test isolation<br/>\n   @Before<br/>\n   public void setup() {<br/>\n      perTestExpensiveResultCopy = expensiveResult.clone(); // or some such thing to copy it<br/>\n   }<br/>\n <br/>\n   @After<br/>\n    public void cleanup() {<br/>\n       // any necessary cleanup<br/>\n       perTestExpensiveResultCopy = null;<br/>\n    }<br/>\n <br/>\n   @Test<br/>\n    public void test1() {<br/>\n       // use perTestExpensiveResultCopy<br/>\n       assertTrue(...)<br/>\n    }<br/>\n <br/>\n   @Test<br/>\n    public void test2() {<br/>\n       // use perTestExpensiveResultCopy<br/>\n       assertTrue(...)<br/>\n    }<br/>\n  }<br/>\n <br/>\nA unit test should test one thing. Let&#39;s say you WANT to get multiple results. What&#39;s the UI for that? And besides the UI, what&#39;s even the point? We&#39;re trying to write tests in a way that requires nearly 0 human interaction. If you can get multiple results from a test, it seems you&#39;d need a person to process those results rather than the computer. It goes counter to AUTOMATION and moves towards more human intervention.<br/>\n <br/>\nThe original example was later answered well by someone else. Make testOrder() three tests instead of one. You get the results you want, though you do have to write a few more lines of code. The additional lines of code give you the chance to make your tests more self documenting. Imagine if, given the original example, it had instead been written:<br/>\n <br/>\npublic void testSuccess_ReverseOrder() {<br/>\n   assertEquals( 9, Largest.largest( new int[] {9,8,7}));<br/>\n}<br/>\n <br/>\npublic void testSuccess_InOrder() {<br/>\n   assertEquals( 9, Largest.largest( new int[] {7, 8, 9}));<br/>\n}<br/>\n <br/>\npublic void testSuccess_NoOrder() {<br/>\n   assertEquals( 9, Largest.largest( new int[] {6, 3, 4 ,8, 9, 1, 2, 4, 5}));<br/>\n}<br/>\n <br/>\npublic void testSuccess_MultipleLargest() {<br/>\n   assertEquals( 9, Largest.largest( new int[] {6, 3, 4 ,8, 9, 1, 2, 9, 5}));<br/>\n}<br/>\n <br/>\n// Note, in the original test this assert would have failed. It should have been written<br/>\n// in a way that would not fail but still assert what should happen<br/>\npublic void testFailure_DoesNotMatch() {<br/>\n   assertNotEqual( 44, Largest.largest( new int[] {8,9,7}));<br/>\n}<br/>\n <br/>\nAnd so on... The name of the test states the intent of the test. I don&#39;t have to read the code to figure out the intention of what is being tested.<br/>\n <br/>\nThe original example should have been written as follows:<br/>\npublic void testOrder() {<br/>\n   assertEquals( 9, Largest.largest( new int[] {9,8,7}));<br/>\n   assertNotEqual( 44, Largest.largest( new int[] {8,9,7}));<br/>\n   assertNotEqual( 32, Largest.largest( new int[] {7,8,9}));<br/>\n}<br/>\n<br/>\nNow I have seen cases where I have a long test with several asserts and I want to know what all is failing so I can fix them all. However:<br/>\nThis is not often a problem<br/>\nIt is more of a hassle than a problem<br/>\nFixing one thing might change the later results anyway, so there&#39;s no general way to address this problem<br/>\nIf it really is a hassle to keep rerunning my test, then maybe I need to refactor it so it is not so costly to run and test<br/>\nWhat about the case where I have a server-side test? How about using Spring and IoC to make the test runnable inside or outside of a container?<br/>\n <br/>\nI can think of a combination of things that would make this feature nice:<br/>\nExisting system that I cannot change (too big, too political, ...)<br/>\nServer-side test<br/>\nServer takes a while to start up<br/>\nI have to restart the sever every time I make a change<br/>\nI have a big test with lots of asserts<br/>\nIn this situation, getting all the failures would be handy. If it really is a problem, I&#39;d consider writing some temporary scaffolding in support of the test. Say the test retrieves some object, makes changes and then performs validation. I&#39;d write some quick code to grab the object, serialize it, then write a test to test the serialized version of the object. Maybe I&#39;d even keep that test around. If I&#39;m worried about schema migration, either hard-code a serialVersionUID or use XML, or pick your externalization technology. I&#39;d make another test that gets to what I want to test that can run quickly.<br/>\n <br/>\nBrett<br/>\n----- Original Message ----<br/>\nFrom: Stephen Smith &lt;steve@...&gt;<br/>\nTo: junit@yahoogroups.com<br/>\nSent: Sunday, June 18, 2006 6:12:11 AM<br/>\nSubject: Re: [junit] Multiple assertions per test<br/>\n<br/>\n<br/>\nIs there any situation in which multiple assertions per test can be <br/>\njustified? For example, talking to an expensive external resource that <br/>\ncan&#39;t easily be mocked (e.g. third party hardware)?<br/>\n--<br/>\nStephen Smith, MEng (Wales).<br/>\nhttp://www.stephen- smith.co. uk/<br/>\n<br/>\nJ. B. Rainsberger wrote:<br/>\n<blockquote><span title=\"ireply\"> &gt; Chaudhary, Harsh wrote:<br/>\n&gt; <br/>\n&gt;&gt; Is there a way in jUnit to override the failfast behavior e.g. my code<br/>\n&gt;&gt; looks like:<br/>\n&gt;&gt;<br/>\n&gt;&gt; public void testOrder() {<br/>\n&gt;&gt;<br/>\n&gt;&gt; assertEquals( 9, Largest.largest( new int[] {9,8,7}));<br/>\n&gt;&gt;<br/>\n&gt;&gt; assertEquals( 44, Largest.largest( new int[] {8,9,7}));<br/>\n&gt;&gt;<br/>\n&gt;&gt; assertEquals( 32, Largest.largest( new int[] {7,8,9}));<br/>\n&gt;&gt;<br/>\n&gt;&gt; }<br/>\n&gt;&gt;<br/>\n&gt;&gt; I know the 2nd and 3rd asserts would fail. I want to see both results as<br/>\n&gt;&gt; having failed in my results. But jUnit just stops at the first failure.<br/>\n&gt;&gt;<br/>\n&gt;&gt; Is there any way to change this behavior?<br/>\n&gt; <br/>\n&gt; This is a FAQ. Google &quot;JUnit multiple assertions per test&quot;. I explain <br/>\n&gt; the reasons why JUnit isn&#39;t built this way in _JUnit Recipes_ and a <br/>\n&gt; number of us have re-written that answer dozens of times in this mailing <br/>\n&gt; list, so check the archives.<br/>\n&gt; <br/>\n&gt; The short version: No, you can&#39;t, and you shouldn&#39;t, because those are 3 <br/>\n&gt; different tests.<br/>\n&gt; <br/>\n&gt; For the longer version, search the web.<br/>\n&gt; <br/>\n&gt; Take care.<br/>\n<br/>\n<br/>\n <br/>\n<br/>\n </span></blockquote>[Non-text portions of this message have been removed]</div>", 
    "prevInTime": 16952, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1150648297", 
    "canDelete": false, 
    "nextInTopic": 16955, 
    "prevInTopic": 16951, 
    "headers": {
        "inReplyToHeader": "PDQ0OTUzNTBCLjIwMDA0MDZAc3RlcGhlbi1zbWl0aC5jby51az4=", 
        "messageIdInHeader": "PDIwMDYwNjE4MTYzMTM3LjM0MTYxLnFtYWlsQHdlYjU0MTE0Lm1haWwueWFob28uY29tPg=="
    }
}