{
    "numMessagesInTopic": 11, 
    "nextInTime": 6729, 
    "senderId": "0YaU44XhhA61i6MyYhULnmtZ3ms-XHeXMFQU88FY694c3xhbupm3dXL41LNHYyscEQERGPVwqNc8-KsO0ftvR_CEEFM_9V0qPBxz", 
    "systemMessage": false, 
    "subject": "Re: [junit] Re: Test first? or Stub first?", 
    "from": "Curt Sampson &lt;yahoo_sucks@...&gt;", 
    "authorName": "Curt Sampson", 
    "msgSnippet": "... Well, for me the measure is pretty easy. I no longer spend ten minutes working out the interface for a class only to discover that it s a nice interface,", 
    "msgId": 6728, 
    "profile": "cjstokyo", 
    "topicId": 6697, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 110189933, 
    "messageBody": "<div id=\"ygrps-yiv-799341138\">On Thu, 23 Jan 2003, J. B. Rainsberger wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; &gt;But in the end, I guess you believe in test-first programming or you<br/>\n&gt; don&#39;t.<br/>\n&gt;<br/>\n&gt; Not necessarily. There&#39;s no TDD licence. You can do it sometimes and<br/>\n&gt; not other times. I only wish that those who choose this approach<br/>\n&gt; measure the difference between the two.<br/>\n<br/>\n </span></blockquote>Well, for me the measure is pretty easy. I no longer spend ten minutes<br/>\nworking out the interface for a class only to discover that it&#39;s a nice<br/>\ninterface, but not the interface I need.<br/>\n<br/>\nIn fact, quite often these days, I find myself practicing &quot;test-second,<br/>\nimplementation-third&quot; programming. I&#39;ll be in the middle of programming<br/>\na servlet, and I&#39;ll realize I need to be able to find, say, a Foo object<br/>\nbased on the current IP address of the request. At that point, I&#39;ll just<br/>\nmake up, on the spot, the most convenient interface for that, and use<br/>\nit, even though that interface, and possibly not even the object I&#39;m<br/>\nusing, exists.<br/>\n<br/>\nAfter I&#39;ve finished coding my little routine, the actual code that gets<br/>\nand uses the foo object is written and right in front of me, so I know<br/>\nthe interface. Unfortunately, at this point I can&#39;t test because my<br/>\nFoo stuff doesn&#39;t exist. So then I code up enough of Foo (usually just<br/>\na mock object with specific behaviour) to let me test the routine I&#39;m<br/>\nworking on, and work out some way to get it into the routine I&#39;m working<br/>\non during unit testing. Now I can test the method I&#39;m working on, and<br/>\nmake any changes necessary for it to pass. (This may change the Foo<br/>\ninterface as well.) Eventually my current little bit of work is done and<br/>\ntested, even though the code it depends on doesn&#39;t even exist yet!<br/>\n<br/>\nAfter all this is done, I can then go and create the Foo thingie that<br/>\nreally should exist based on the code that uses it. So I write up tests<br/>\nbased on the code, and then code and test the Foo thingie itself.<br/>\n<br/>\nI&#39;ve found many advantages to this approach:<br/>\n<br/>\n1. It lets you concentrate on and finish one thing at a time, rather<br/>\nthan getting into a big &quot;stack&quot; of things, where you are constantly<br/>\npushing down the current activity to start a new one. This means that<br/>\nin a limited amount of time, you can complete two things rather than<br/>\nhalf-complete four, and you don&#39;t suffer from the &quot;now where was I?&quot;<br/>\nproblem when you &quot;pop the stack.&quot;<br/>\n<br/>\n2. Interfaces are worked out where they need to be worked out, in the<br/>\nusers of that interface. Speculative coding is reduced.<br/>\n<br/>\n3. When you get to testing an interface, the tests tend to be easier to<br/>\nwork out, because you&#39;ve got all the examples of how the inteface is<br/>\nused right in front of you.<br/>\n<br/>\n4. Tests are localized to particular classes and areas of code, rather<br/>\nthan depending on other classes and areas of code working correctly.<br/>\n<br/>\n5. The need for test coverage is reduced, because you can not write<br/>\ntests for functionality you never use. (This needs to be applied with<br/>\ncaution, of course; if your interface offers unused functionality and<br/>\nyou&#39;ve not tested it, someone else later might use that functionality,<br/>\nassuming it&#39;s tested, and run into bugs. But then again, it&#39;s not good<br/>\npractice for interfaces to offer functionality that&#39;s not used, anyway.)<br/>\n<br/>\nI used to be a very bottom-up programmer, but the speed and ease of this<br/>\ntop-down approach has completely converted me. I now write probably one<br/>\nhalf to one third the amount of code I used to write to get equivalant<br/>\nfunctionality in an application. My customers really appreciate this.<br/>\n<br/>\ncjs<br/>\n-- <br/>\nCurt Sampson  &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:cjs@...\">cjs@...</a>&gt;   +81 90 7737 2974   <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.netbsd.org\">http://www.netbsd.org</a><br/>\n    Don&#39;t you know, in this new Dark Age, we&#39;re all light.  --XTC</div>", 
    "prevInTime": 6727, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1043471891", 
    "canDelete": false, 
    "nextInTopic": 6768, 
    "prevInTopic": 6709, 
    "headers": {
        "inReplyToHeader": "PDIwMDMwMTIzMTY1MzUzMDMxNS4wMDZGOTYxM0BzbXRwLnltLnBodWIubmV0LmNhYmxlLnJvZ2Vycy5jb20+", 
        "messageIdInHeader": "PFBpbmUuTkVCLjQuNTEuMDMwMTI1MTQwMjU1MC41OTZAYW5nZWxpYy5jeW5pYy5uZXQ+", 
        "referencesHeader": "PDNFMkU3MzY0LjI2OTY0LjM1MEFEQ0Bsb2NhbGhvc3Q+IDxQaW5lLk5FQi40LjUxLjAzMDEyNDAxMTQyNDAuNTQ3QGFuZ2VsaWMuY3luaWMubmV0PiA8MjAwMzAxMjMxNjUzNTMwMzE1LjAwNkY5NjEzQHNtdHAueW0ucGh1Yi5uZXQuY2FibGUucm9nZXJzLmNvbT4="
    }
}