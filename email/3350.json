{
    "numMessagesInTopic": 19, 
    "nextInTime": 3351, 
    "senderId": "fUKCiuVH6VR-C6rI7CATZU_CJo5maQEGrDgwU_WvAAkDJF2S91ZHqYHhkjDiBrG47Drud_qPjwOUhtLBxt18nXxU2iEHSEYAb7zfdD-RtYa99YG5-XPUvB39", 
    "systemMessage": false, 
    "subject": "Making JUnit more pluggable for add-ons", 
    "from": "&quot;Michael Silverstein&quot; &lt;msilverstein@...&gt;", 
    "authorName": "Michael Silverstein", 
    "msgSnippet": "Problem statement ... I am adding some additional profiling and metrics to JUnit test execution. In order to do this I need to plug in to JUnit in such a way", 
    "msgId": 3350, 
    "topicId": 3350, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 0, 
    "messageBody": "<div id=\"ygrps-yiv-459462461\">Problem statement<br/>\n-----------------<br/>\nI am adding some additional profiling and metrics to JUnit test execution.<br/>\nIn order to do this I need to plug in to JUnit in such a way as to perform<br/>\nsome operations before and after test execution, and to extend the test<br/>\nresults to contain the new metrics. Presently the framework does not allow<br/>\nme to do this without altering it.<br/>\n<br/>\nProcess<br/>\n-------<br/>\nI can either graft a new branch on to the JUnit source tree that contains<br/>\nvarious extensions built in and give it a new name (like JUnit XYZ or<br/>\nwhatever) or provide some tweaks to the present framework that satisfy my<br/>\nneeds in the hope they are accepted as part of the next version. The purpose<br/>\nof this email is to start a discussion about this so that whatever changes<br/>\nare necessary fit in with the architectural spirit of JUnit and are suitable<br/>\nfor inclusion in a base release. If possible, I&#39;d like to wrap this up and<br/>\nmake it publicly available by the end of the year.<br/>\n<br/>\nNote: I realize test cases are the recognized currency for articulating new<br/>\nfunctionality, so once there is agreement in principle to an approach, I can<br/>\nprovide test cases to provide more detail.<br/>\n<br/>\nWrapping test execution<br/>\n-----------------------<br/>\nI need to be able to start profiling immediately before a user test starts<br/>\nand end profiling immediately afterward. One approach is to wrap the user<br/>\ntest class that is presently instantiated in<br/>\njunit.runner.BaseTestRunner.getTest(String) with a TestDecorator subclass<br/>\ninstance that manages profiling during test execution. Creating the<br/>\ndecorator sounds like a job for factory method [Gamma95].<br/>\n<br/>\nExtending the results<br/>\n---------------------<br/>\nThis is presently not easy because all the various test runners (subclasses<br/>\nof BaseTestRunner) implement their own createTestResult() method, where the<br/>\nreference to the TestResult class is hard coded. I&#39;d like to be able to<br/>\nspecify that dynamically as well. This also sounds like a job for factory<br/>\nmethod [Gamma95].<br/>\n<br/>\nToward a unified pluggable configuration approach<br/>\n-------------------------------------------------<br/>\nA possible approach is to employ the abstract factory pattern [Gamma95]<br/>\nwhere the concrete factory class contains factory methods for the above<br/>\nclasses and others, is specified in the preferences file or elsewhere. This<br/>\nsort of architectural change would substantially enable the sort of<br/>\npluggability that I&#39;m after.<br/>\n<br/>\nSome questions and observations about the framework<br/>\n---------------------------------------------------<br/>\nHaving spent some time digging into JUnit I have the following questions and<br/>\ncomments:<br/>\n<br/>\n- The preferences file is read in more than one place:<br/>\n  - junit.runner.BaseTestRunner.readPreferences()<br/>\n  - junit.runner.TestCaseClassLoader.readExcludedPackages()<br/>\n  I could be wrong but it seems like this is redundant execution, especially<br/>\nsince the preferences is kept in a static variable.<br/>\n<br/>\n- The preferences (junit.runner.BaseTestRunner.fPreferences) is static. It<br/>\nstrikes me that this hampers testability of the framework because it makes<br/>\nit difficult to isolate the framework preferences from the preferences for<br/>\ninstances of framework classes under test.<br/>\n<br/>\n- The TestResult class provides semantics for running and stopping tests.<br/>\nThis seems like a stretch for a results class, which I would imagine is<br/>\nprimarily a container for execution metrics and other downstream<br/>\ninformation.<br/>\n<br/>\n- The TestRunner variants are very tied to presentation layer. I see this<br/>\nhas been discussed at length in the past so I won&#39;t belabor it.<br/>\n<br/>\n- It seems that since all the methods in junit.framework.Assert are static<br/>\nand it does not hold any state, there is really no need to make this class<br/>\nthe root of all tests, except for the convenience of not prefixing assertion<br/>\nmethods with &#39;junit.framework.Assert&#39;. I&#39;m sure I&#39;m missing something here.<br/>\n<br/>\nReferences<br/>\n----------<br/>\n[Gamma95] Erich Gamma et al. &quot;Design Patterns - Elements of Rusable<br/>\nObject-Oriented Software&quot;, Addison-Wesley, Reading, MA, 1995.<br/>\n<br/>\n^^^^^^^^^^^^^^^^^^^^^^^^^<br/>\nMike Silverstein<br/>\nSilverMark, Inc.<br/>\nThe object testing company<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.silvermark.com\">http://www.silvermark.com</a></div>", 
    "prevInTime": 3349, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1006885017", 
    "canDelete": false, 
    "nextInTopic": 3351, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PE5EQkJKRUZLTURHRklCRUtLRUxFQ0VCT0RKQUEubXNpbHZlcnN0ZWluQHNpbHZlcm1hcmsuY29tPg=="
    }
}