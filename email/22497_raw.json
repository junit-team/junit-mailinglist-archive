{
    "numMessagesInTopic": 9, 
    "nextInTime": 22498, 
    "senderId": "ub3ORjRFZ6gASAkoO3IZlDBwK1lp2AuRTq2z7z1OwWRQWuvaAY3h97enAw9KmH-4jhCPTYdhDVU0PGBB10OuhcH5ATOeZ4AWUFnW_wJjO2TVYWjK3m1e", 
    "systemMessage": false, 
    "subject": "RE: [junit] [RT] JUnit Core, Parallelism, Documentation", 
    "from": "&quot;Loritsch, Berin C.&quot; &lt;berin.loritsch@...&gt;", 
    "authorName": "Loritsch, Berin C.", 
    "msgSnippet": "Well, getting to the core, it is not very clear what is the _internal_ API and what is the _external_ API.  For something like JUnit there are actually two", 
    "msgId": 22497, 
    "rawEmail": "Return-Path: &lt;prvs=1671d1f5da=berin.loritsch@...&gt;\r\nX-Sender: prvs=1671d1f5da=berin.loritsch@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nX-Received: (qmail 28510 invoked from network); 2 Mar 2010 18:05:29 -0000\r\nX-Received: from unknown (66.196.94.106)\n  by m3.grp.sp2.yahoo.com with QMQP; 2 Mar 2010 18:05:29 -0000\r\nX-Received: from unknown (HELO camv02-relay2.casc.gd-ais.com) (192.5.164.99)\n  by mta2.grp.re1.yahoo.com with SMTP; 2 Mar 2010 18:05:29 -0000\r\nX-Received: from ([10.73.100.22])\n\tby camv02-relay2.casc.gd-ais.com with SMTP  id 5203374.16690476;\n\tTue, 02 Mar 2010 09:50:05 -0800\r\nX-Received: from vaff01-mail01.ad.gd-ais.com ([10.13.13.20]) by camv02-fes01.ad.gd-ais.com with Microsoft SMTPSVC(6.0.3790.3959);\n\t Tue, 2 Mar 2010 09:49:49 -0800\r\nX-MimeOLE: Produced By Microsoft Exchange V6.5\r\nContent-class: urn:content-classes:message\r\nMIME-Version: 1.0\r\nDate: Tue, 2 Mar 2010 12:47:22 -0500\r\nMessage-ID: &lt;75F5ED8A5A553646A46E00E6EC854FA3044B99E4@...-ais.com&gt;\r\nIn-Reply-To: &lt;4f7da6b91003020631o6f820d27kb159770c9d7ca1ca@...&gt;\r\nX-MS-Has-Attach: \r\nX-MS-TNEF-Correlator: \r\nThread-Topic: [junit] [RT] JUnit Core, Parallelism, Documentation\r\nThread-Index: Acq6FXl/tl02jSAmQjGkt8gJbj9uAwAFvNBA\r\nReferences: &lt;75F5ED8A5A553646A46E00E6EC854FA3044B97F2@...-ais.com&gt; &lt;4f7da6b91003020631o6f820d27kb159770c9d7ca1ca@...&gt;\r\nTo: &lt;junit@yahoogroups.com&gt;\r\nReturn-Path: Berin.Loritsch@...\r\nX-OriginalArrivalTime: 02 Mar 2010 17:49:49.0669 (UTC) FILETIME=[C13D3150:01CABA30]\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: &quot;Loritsch, Berin C.&quot; &lt;berin.loritsch@...&gt;\r\nSubject: RE: [junit] [RT] JUnit Core, Parallelism, Documentation\r\nX-Yahoo-Group-Post: member; u=428096731; y=9iGNTLdR_F-2kiQjKgSGy7HWtJXt-oCj7_qv5FEKqqthCYmK\r\nX-Yahoo-Profile: bloritsch\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\n\r\nWell, getting to the core, it is not very clear what is the _internal_\nAPI and what is the _external_ API.  For something like JUnit there are\nactually two external APIs to worry about:\n\n \n\n*         The API for Test Writers\n\n*         The API for IDE/tool writers\n\n \n\nThe JavaDocs do have to be very clear on what is likely to change, and\nwhat is meant to be stable.  This approach allows you to clean up cruft\nover time.\n\n \n\nThe first misstep I saw was the move from using the Description object\nto build the tree of tests to using a Plan to build the tree of tests.\nThe addChild() and getChildren() methods of the Description object are\ndeprecated, yet JUnit creates the Plan from the description object.  I\nbelieve that the new direction of using a Plan instead of a hierarchy of\ndescriptions is the correct one from a conceptual standpoint.\n\n \n\nThe API for testers is pretty well understood, and I would be very\nresistant to arbitrarily changing that.  I think most people would be as\nwell.\n\n \n\nWhat is less understood is where JUnit is designed to integrate with\nIDEs and tool vendors.  How much of the Computer/Plan/Filtering/Ordering\ndo we want to expose?  What are we confident with?  The rest, as they\nsay, making sure our internals work with that spec.  None of the\ninternals should rely on deprecated features.  Anything in the\n&quot;internal&quot; package should be considered, by definition, internal.  That\nmeans anything in there that is deprecated should be free to be removed.\n\n \n\nAt least, this is how I&#39;ve evolved libraries before (I&#39;ve worked on a\nfew Apache projects in the past). \n\n \n\n \n\nFrom: junit@yahoogroups.com [mailto:junit@yahoogroups.com] On Behalf Of\nDavid Saff\nSent: Tuesday, March 02, 2010 9:32 AM\nTo: junit@yahoogroups.com\nSubject: Re: [junit] [RT] JUnit Core, Parallelism, Documentation\n\n \n\n  \n\nBerin,\n\nThanks for this! I can&#39;t touch here on all of your ideas, so feel\nfree to repeat any points you&#39;d like to prioritize in the discussion.\n\nWith regard to deprecation, we&#39;ve definitely begun to feel the weight\nof the old code, but have indeed felt that it&#39;s not clear whether\nbeing very aggressive would be in the best interests of users: thanks\nto the fact that many users of tools like Eclipse and Maven have their\nJUnit version automatically updated without explicit intervention,\nit&#39;s easy to be the cause of breaking something that&#39;s been working\nfor years. That said, I think it is time for a little housecleaning.\nI&#39;ve mentioned to Kent that we should do a codesearch.google.com\nsmackdown, and start kicking the least-used public method or class\n&quot;off the island&quot; with each release.\n\nAs you mention, I think that the biggest obstacle to real parallelism\nis an replacement or enhancement of the BeforeClass/AfterClass idiom\nthat is well-defined outside of a single-threaded execution. As two\nexamples, (1) it&#39;s not well-defined whether a BeforeClass method\nshould be able to be run more than once per test suite execution, (2)\nit&#39;s not well-defined whether one class can correctly start before\nanother class&#39;s AfterClass method has been called.\n\nDavid\n\nOn Mon, Mar 1, 2010 at 5:17 PM, Loritsch, Berin C.\n&lt;berin.loritsch@... &lt;mailto:berin.loritsch%40gd-ais.com&gt; &gt; wrote:\n&gt; RT = Random Thought.  It&#39;s a habit I picked up from Stefano Mazzocchi\n&gt; when I used to work with him on the Cocoon project.  Essentially, it&#39;s\na\n&gt; structured brain dump based on observations of the internals of a\n&gt; project (as such it is longer than most posts).  My apologies if this\nis\n&gt; not the forum for this.\n&gt;\n&gt; == Code Maintenance Thoughts ==\n&gt;\n&gt; I&#39;ve been going through some of the JUnit Core to add some JavaDocs\n&gt; (it&#39;s in my forked copy if you want me to do a Push request), and made\na\n&gt; few observations.  I can definitely see how JUnit has begun to evolve\n&gt; over the years, and as is natural with a couple missteps along the\nway.\n&gt; It&#39;s hard to get rid of those missteps because some people may have\n&gt; extended them.  Some of the classes have been deprecated with the\n&gt; promise that they would be removed in the next revision (as of 4.4)\nand\n&gt; they are still there.  I&#39;m not saying that the current solution is a\n&gt; misstep, just that it is hard to separate the past ones from the\ncurrent\n&gt; preferred solution.\n&gt;\n&gt; Part of managing a codebase like this includes separating the public\nand\n&gt; private API.  Some of that has been done with the &quot;internal&quot; package.\n&gt; There is no reason to worry about deprecating classes and methods in\nthe\n&gt; internal package because they are not part of the public API.  But I\ndid\n&gt; notice that when some classes got moved, the old class in full was\nkept\n&gt; in the original location.  A low maintenance way of performing a move\n&gt; like that makes use of inheritance.  Essentially the newer class is\n&gt; moved so there is one maintenance location, and the deprecated class\n&gt; extends the newer class.  Kind of like how the JUnit4 runner provides\na\n&gt; preferred alias to the BlockJUnit4Runner class.\n&gt;\n&gt; Part of the core includes a nice little callback interface (the\n&gt; RunListener).  I imagine that a number of integrations make good use\nof\n&gt; this little class.  However, with the implementation as it is\ncurrently\n&gt; written, the RunListener can affect the run performance and\nparallelism\n&gt; available.  Essentially, the act of calling a method is a synchronous\n&gt; function.  That means a poorly written runner can detrimentally affect\n&gt; the performance of JUnit.  The one that is included with JUnit is\npretty\n&gt; tame, doing the absolute minimum it has to do to track the test\n&gt; progress.  However, if your tests execute slower in an IDE than with\n&gt; JUnit alone, it&#39;s probably the RunListener slowing things down.\n&gt;\n&gt; == Parallelism Thoughts ==\n&gt;\n&gt; Some of the architectural decisions in JUnit&#39;s core definitely reflect\n&gt; the synchronous nature that the tests were designed to be written.  I\n&gt; don&#39;t think there is going to be an easy solution to that problem,\n&gt; unless you stick to a test class per thread model.  More on that a bit\n&gt; latter.\n&gt;\n&gt; When designing for parallel execution of tests (the ParallelComputer\n&gt; hints at this), you usually don&#39;t want an unbounded number of threads\nto\n&gt; be executed in the system.  A fairly common approach to taming the\n&gt; thread/work apportioning beast is to use queues and worker threads.\n&gt; Essentially, each test (including the set up and tear down parts) gets\n&gt; pushed on to the queue, while the executor pops it off on the other\nside\n&gt; in another process.  Essentially the relationship to executors to work\n&gt; queues depends on whatever rules you&#39;ve set up.  For JUnit a simple\n&gt; mapping of executors to the number of processors (cores) or some\n&gt; multiple of that would be sufficient.  This model is closer to how JMS\n&gt; works without all the quality of service overhead.  As the executor\nruns\n&gt; the test, it sends notification objects to the notification queue.\n&gt; Using one line of ASCII art, the process looks like this:\n&gt;\n&gt; Classes/Suite ==&gt; Executor ==&gt; Notifier\n&gt;\n&gt; Each &quot;==&gt;&quot; represents a queue.  The notification mechanism then\nbecomes\n&gt; more like Swing events.  We could even cheat and use an Java 5 enum\nfor\n&gt; the types of events.  This provides the same interface for all the\n&gt; events, and the convenience of an enum for determining the type of\n&gt; event.  If we take this approach a step further, if we substitute a\n&gt; PriorityQueue for the first queue, we get a way to prefer some tests\n&gt; over others (e.g. using categories as a priority mechanism).\nCollecting\n&gt; the results in a separate thread than they are being executed protects\n&gt; the execution of tests from poorly written listeners.\n&gt;\n&gt; We could go to a very fine level of detail (i.e. each individual test)\n&gt; if it weren&#39;t for the class setup/tear down methods.  Those kind of\n&gt; tests would force some sort of ordering.  It&#39;s not entirely\nimpossible,\n&gt; but does require more care.\n&gt;\n&gt; Such an approach may be over-engineering things a bit, and for short\n&gt; runs of a couple hundred tests that takes less than a second to run\n&gt; definitely overkill.  However for larger projects with much larger\n&gt; execution times, it may be a way to short circuit the execution a bit.\n&gt; Essentially the win here would be the ability to execute tests while\n&gt; they are still being parsed and prepared.  That can help with things\n&gt; like Theories where collecting a large number of DataPoints can have a\n&gt; profound impact on the time it takes to run.\n&gt;\n&gt; It would be pretty easy to ensure that no more than n+2 threads are\nused\n&gt; in a system, where n = Runtime.availableProcessors().\n&gt;\n&gt;\n&gt; [Non-text portions of this message have been removed]\n&gt;\n&gt;\n&gt;\n&gt; ------------------------------------\n&gt;\n&gt; Yahoo! Groups Links\n&gt;\n&gt;\n&gt;\n&gt;\n\n\n\n\n\n[Non-text portions of this message have been removed]\n\n\n", 
    "profile": "bloritsch", 
    "topicId": 22487, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 428096731, 
    "prevInTime": 22496, 
    "contentTrasformed": false, 
    "postDate": "1267552042", 
    "canDelete": false, 
    "nextInTopic": 22498, 
    "prevInTopic": 22494, 
    "headers": {
        "inReplyToHeader": "PDRmN2RhNmI5MTAwMzAyMDYzMW82ZjgyMGQyN2tiMTU5NzcwYzlkN2NhMWNhQG1haWwuZ21haWwuY29tPg==", 
        "messageIdInHeader": "PDc1RjVFRDhBNUE1NTM2NDZBNDZFMDBFNkVDODU0RkEzMDQ0Qjk5RTRAdmFmZjAxLW1haWwwMS5hZC5nZC1haXMuY29tPg==", 
        "referencesHeader": "PDc1RjVFRDhBNUE1NTM2NDZBNDZFMDBFNkVDODU0RkEzMDQ0Qjk3RjJAdmFmZjAxLW1haWwwMS5hZC5nZC1haXMuY29tPiA8NGY3ZGE2YjkxMDAzMDIwNjMxbzZmODIwZDI3a2IxNTk3NzBjOWQ3Y2ExY2FAbWFpbC5nbWFpbC5jb20+"
    }
}