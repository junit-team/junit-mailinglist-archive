{
    "numMessagesInTopic": 80, 
    "nextInTime": 18690, 
    "senderId": "eU4esnv74u1IEB1zmd7fZ8BAM1F3E3KPy45kQKBupr-oZfbPX2nDP4TOv8vLSgcH2LgkEwQmO0__mvNW9l36dIWFrlrQrOFUEnCi-m2rJx8E8uZD", 
    "systemMessage": false, 
    "subject": "RE: [junit] 100%% Method Testing and Generating Unit Tests", 
    "from": "&quot;James P. Gunderson&quot; &lt;jgunders@...&gt;", 
    "authorName": "James P. Gunderson", 
    "msgSnippet": "Kevin: I totally agree that there are a number of reasons for developing and running tests. I think that your list is a great initial classification. I guess", 
    "msgId": 18689, 
    "profile": "jpg3u", 
    "topicId": 18605, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 193138280, 
    "messageBody": "<div id=\"ygrps-yiv-26299193\">Kevin:<br/>\n   I totally agree that there are a number of reasons for developing and running tests. I think that your list is a great initial classification. I guess my point was focused on the suggestion that the programmer writes some code, and without providing any additional information, presses the button that generates all the test cases. JB brought up the question of how much one program can &#39;reason&#39; about the behavior of another program. I agree with your observation that the ability to characterize a programs behavior is frequently needed and useful. I also agree that one package can do a lot to analyse another.<br/>\n<br/>\nAll I was pointing out is that the analyzing program only has the source code of the target software to work from. Yes, a lot can be done to make sure that that target program has no errors in it, but it is harder (without extra information) to assess whether the target code is doing the right thing.  For example, suppose I write a function to calculate the distance between to points in space. The analysis can make sure that corner cases are covered, the code has no unnecessary complexity, that all the code is reachable, and so forth. And this is really good, useful, and provides value to me the programmer.  However, if I program the distance calculation incorrectly (perhaps I calculate the manhattan distance instead of the euclidian) how does the analyzing program &#39;know&#39; that I coded the wrong function?  Without the addition of annotations, invariants, or the inclusion of test data, the analyzing program is hobbled. However, if the programmer is required to add the additional information, this violates the notion that the programmer has to do zero addtional work.<br/>\n<br/>\nNow, I would be happy to have a support system that provides all the benefits you outlined, and I would be perfectly happy to have a system that would take a small amount of additional info and demonstrate (dare we say prove) that the code I wrote is both error free and does the job I want it to. I was looking at the gap between the intent of the programmer and the function of the target software, and whether it is possible to bridge that gap without the programmer documenting the intent.<br/>\n<br/>\nJim<br/>\n<br/>\n<br/>\n+++++<br/>\nKevin Lawrence wrote:<br/>\nThere are lots of reasons why one might want to have tests. Off the<br/>\ntop of my head,<br/>\n<br/>\n- to drive the design<br/>\n- to document the design<br/>\n- to demonstrate correctness<br/>\n- to provide a safety net when changing unfamiliar code<br/>\n<br/>\nThis latter case, which Michael Feathers talks a great deal about in<br/>\nWELC, is probably one of the most common reasons that people want<br/>\nautomated tests.<br/>\n<br/>\nPutting it another way,<br/>\n<br/>\n  if I change this line of code, what other behavior will change will<br/>\nchange as a result<br/>\n<br/>\nWe ask ourselves this question every time we maintain unfamiliar code<br/>\nin an unfamiliar system without tests. The most conscientious<br/>\ndevelopers write tests before changing that line of code. Most don&#39;t.<br/>\n<br/>\nThis is such a common activity in software development that a program<br/>\nthat could characterize the behavior of another program and report<br/>\nwhen the behavior has changed would be useful wouldn&#39;t it?<br/>\n<br/>\nAs to JB&#39;s observation about whether it&#39;s possible to generate such<br/>\ntests for non-trivial programs - it&#39;s still early days for JUnit<br/>\nFactory but I think you&#39;d be surprised by what&#39;s already possible.<br/>\n<br/>\n<br/>\nKevin<br/>\n<br/>\nwww.junitfactory.com<br/>\nYou send us code. We send you tests. For free.<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n[Non-text portions of this message have been removed]</div>", 
    "prevInTime": 18688, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1168393686", 
    "canDelete": false, 
    "nextInTopic": 18690, 
    "prevInTopic": 18688, 
    "headers": {
        "messageIdInHeader": "PDVDQjFEQTkxOEQ0QzY3NDBCRTA1MUJENkZFMjJGMkI0NTJCRjFEQGV4Y2hhbmdlLTIuaW50ZXJuYWwuZWxlY3RyaWNzdG9yZXMuY29tPg=="
    }
}