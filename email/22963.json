{
    "numMessagesInTopic": 3, 
    "nextInTime": 22964, 
    "senderId": "lNruQDmrQglHjgGkseefqR88ntWKtbkFS5i-9SelZogVLTtmSTEnoN0BNs5HOyf3iZhdOX50Gk8xXnEN_IfkxHpH", 
    "systemMessage": false, 
    "subject": "Re: [junit] Fwd: Writing a test fixture for a set of many classes", 
    "from": "David Saff &lt;david@...&gt;", 
    "authorName": "David Saff", 
    "msgSnippet": "Konrad, Let s keep the discussion on the list, so others can contribute. ... It s just a plain old Java class that you write for yourself with the convenience", 
    "msgId": 22963, 
    "profile": "dsaff", 
    "topicId": 22959, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 341876227, 
    "messageBody": "<div id=\"ygrps-yiv-663446021\">Konrad,<br/>\n<br/>\nLet&#39;s keep the discussion on the list, so others can contribute.<br/>\n<br/>\n<blockquote><span title=\"qreply\"> On Mon, Sep 20, 2010 at 5:35 PM, Konrad Reiche &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:home@...\">home@...</a>&gt; wrote:<br/>\n&gt; Am 20.09.2010 23:17, schrieb David Saff:<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; Konrad,<br/>\n&gt;<br/>\n&gt; I don&#39;t know enough about your design to critique it, yet, but I&#39;m<br/>\n&gt; familiar with the things that can happen if you try to run all your<br/>\n&gt; tests against One Big Concrete Example, as you seem to be doing.<br/>\n&gt;<br/>\n&gt; Usually, in these cases, I recommend that a developer try to<br/>\n&gt; custom-build their data in each test, using only what they need. For<br/>\n&gt; example, although a single lecturer, single class, and two rooms isn&#39;t<br/>\n&gt; enough to test every available case, it&#39;s probably enough to feed to a<br/>\n&gt; simple room-assignment test, etc.<br/>\n&gt;<br/>\n&gt; In this case, if I find myself making the same chain of calls over and<br/>\n&gt; over, I sometimes write convenient factory methods in my test class,<br/>\n&gt; so my tests can look like:<br/>\n&gt;<br/>\n&gt; @Test public void scheduleRoom() {<br/>\n&gt; Scenario s = scenario(lecturer(&quot;Smith&quot;),<br/>\n&gt; schoolClass(&quot;Algebra: requires 50 seats&quot;),<br/>\n&gt; rooms(&quot;Smith Hall 100: 50 seats&quot;, &quot;Smith Hall<br/>\n&gt; 102: 20 seats&quot;))<br/>\n&gt; assertEquals(&quot;Smith Hall 102&quot;, s.getAssignments().getRoom(&quot;Algebra&quot;))<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; Good luck,<br/>\n&gt;<br/>\n&gt; David Saff<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; Hey David, this looks interesting. I thought about capsulating<br/>\n&gt; initilization, too. How isÂ  the Scenario class annotated? Is it a normal<br/>\n&gt; java class with normal methods or does it store @Test methods, too?<br/>\n<br/>\nIt&#39;s just a plain old Java class that you write for yourself with the<br/>\nconvenience methods you need.<br/>\n<br/>\n&gt; I had the feeling it is wrong to call external methods, not concerning the<br/>\n&gt; test case, or that it would violate a test paradigm.<br/>\n<br/>\nYes and no.  In general, I&#39;ve seen bad things happen if my tests call<br/>\nexternal methods that are designed for other purposes, but _happen_ to<br/>\ngive me the data or behavior I need to set up the method I really want<br/>\nto test.  They tend to get changed later, to suit their intended<br/>\npurposes, leaving the tests broken and sad.<br/>\n<br/>\nHowever, if the &quot;external&quot; method in question is something you write<br/>\nfor yourself, to kill what would otherwise be duplicated between the<br/>\ntests, or stuffed into a setUp method, I&#39;ve seen few pitfalls.<br/>\n<br/>\n&gt; What about data-driven testing, for instance linking a csv files? Though<br/>\n&gt; your approach seems more generic.<br/>\n<br/>\nSome people seem to get a lot of mileage out of this, but it seems<br/>\nthat the payoffs come when for some reason, CSV files are easier to<br/>\nedit or understand than data right there in the code.  I&#39;ve heard<br/>\nthree reasons for this:<br/>\n<br/>\n1) The people writing the tests are different than the developers.<br/>\n(Fair enough, but JUnit&#39;s a celebration of developers testing their<br/>\nown code)<br/>\n2) Data files are easier to change than code.  (I rarely find myself<br/>\nwanting to add a bunch of tests without changing _something_ about the<br/>\ntest code or the code being tested, so this is an imaginary benefit<br/>\nfor me.)<br/>\n3) The code required to set up the data is convoluted (I consider that<br/>\na challenge to make the code simpler).<br/>\n<br/>\n&gt; Another user suggested me TestNG with test dependencies and DataProvider.<br/>\n&gt; What about that?<br/>\n<br/>\nI consider trying to apply a generic data-parser to issues in test<br/>\nabstraction to be replacing one problem with two.  Others have taken<br/>\ndifferent views.<br/>\n<br/>\n   David Saff<br/>\n<br/>\n&gt;<br/>\n&gt; Best regards :)<br/>\n&gt;<br/>\n&gt; Konrad<br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 22962, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1285073326", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 22961, 
    "headers": {
        "inReplyToHeader": "PDRDOTdEM0I4LjkwOTAxMDVAcGF0aGV0aGljLmNvbT4=", 
        "messageIdInHeader": "PEFBTkxrVGluMm5LZFhSSmhSUUpPLXlTMTBKekRlUWUtckNlWnRFeENOMVo5R0BtYWlsLmdtYWlsLmNvbT4=", 
        "referencesHeader": "PDRDOTdDODQ3LjEwNTAwMDBAcGF0aGV0aGljLmNvbT4JPEFBTkxrVGlueD1LRXlfTFNlMHl4QUtqYUdBZDVXek5YPT1BMUVxWkJvbXdGREBtYWlsLmdtYWlsLmNvbT4JPDRDOTdEM0I4LjkwOTAxMDVAcGF0aGV0aGljLmNvbT4="
    }
}