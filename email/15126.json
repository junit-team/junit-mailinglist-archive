{
    "numMessagesInTopic": 47, 
    "nextInTime": 15127, 
    "senderId": "GLKN4qop2wzRUKscrFcmdfSHXj8Tl5ghtW7PvVug844-ulTis4Ff8rdUXm5EHlfnoxt2dy5V_Y-ZJATFbnSJJ528mB8", 
    "systemMessage": false, 
    "subject": "Re: [junit] Proposed parameterized test syntax for JUnit 4", 
    "from": "Eugene Kuleshov &lt;eu@...&gt;", 
    "authorName": "Eugene Kuleshov", 
    "msgSnippet": "... Let me give an example. Imagine you have a statefull facade under test with has 5 methods: first one take no params, second - one param, third - two", 
    "msgId": 15126, 
    "profile": "ekuleshov", 
    "topicId": 14820, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 150395705, 
    "messageBody": "<div id=\"ygrps-yiv-647927735\">J. B. Rainsberger wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt;   For instance, if you look at typical facade pattern, it is quite<br/>\n&gt;&gt;often that it would change different parts of the internal state but<br/>\n&gt;&gt;we still need to test it as a single entity. I am pretty sure that<br/>\n&gt;&gt;facade is not only case for this.<br/>\n&gt; <br/>\n&gt; I have to admit that I can&#39;t make the connection between this paragraph <br/>\n&gt; and the subject of this thread.<br/>\n<br/>\n </span></blockquote>   Let me give an example. Imagine you have a statefull facade under <br/>\ntest with has 5 methods: first one take no params, second - one param, <br/>\nthird - two params, etc.<br/>\n<br/>\n   Should we follow your rules and break this facade into 5 classes? <br/>\nShould we then write separate unit test class for each of those new classes?<br/>\n<br/>\n   The way I see it: there should be single test class with several <br/>\nparameterized test cases (so several parm generators) and test case <br/>\nwould test a single test. In order to keep such construction compact you <br/>\ncan move most of the code into the declarative test definition, like how <br/>\ninput should look like and what to assert on the output, then test code <br/>\nitself could just iterate trough the rules for each given test case <br/>\n(before and then after test). Unfortunately this leads to soft-typed <br/>\ndynamic bindings and evaluation and as a result practically usable only <br/>\nin completely generated tests.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; My point is pretty straightforward: we have these refactoring rules we <br/>\n&gt; often follow and we usually say that we should refactor tests like we <br/>\n&gt; refactor production code, so why wouldn&#39;t we apply these refactoring <br/>\n&gt; rules to tests?<br/>\n<br/>\n </span></blockquote>   I don&#39;t quite agree with this. Tests should be simple enough to <br/>\nrequire no refactorings at all. Applying OOP patters to the tests may <br/>\nlead to fragile test code that will require too much maintenance, <br/>\nespecially if code under test is being structurally changed.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt; &gt; Why wouldn&#39;t we follow those rules with JUnit test case classes? The<br/>\n&gt;&gt; &gt; first rule extracts common setup code into setUp() and fixture objects.<br/>\n&gt;&gt; &gt; The second splits test case classes that have multiple fixtures into<br/>\n&gt;&gt; &gt; separate test case classes. This leads to test case classes organized<br/>\n&gt;&gt; &gt; around fixtures.<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt; As for one test case per model class, that&#39;s a natural place to start,<br/>\n&gt;&gt; &gt; because it&#39;s simple, but once that test case class becomes complex,<br/>\n&gt;&gt; &gt; refactor as usual.<br/>\n&gt;&gt;<br/>\n&gt;&gt;   That usually would lead to confusion and will require special tools<br/>\n&gt;&gt;to track down all the test cases for given class.<br/>\n&gt; <br/>\n&gt; I have /never/, /ever/ wanted to track down all the tests for a given <br/>\n&gt; class. I /have/ wanted to track down all the tests for a given /method/, <br/>\n&gt; which is dirt simple in any decent IDE. (In Eclipse, I hit Ctrl+Shift+G.)<br/>\n<br/>\n </span></blockquote>   Can you then run ALL tests you found in a search view?<br/>\n   Can these results guarantee that changed method under test didn&#39;t <br/>\naffected other methods and you don&#39;t have to run all tests for them too?<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt; &gt; To say that JUnit supports or doesn&#39;t support this way of organizing<br/>\n&gt;&gt; &gt; tests sounds odd to me. I don&#39;t organize my tests a certain way; I<br/>\n&gt;&gt; &gt; refactor the tests, and that&#39;s where they tend to end up.<br/>\n&gt;&gt;<br/>\n&gt;&gt;   By the way, I believe that such freely-organized test cases will be<br/>\n&gt;&gt;affected a lot when doing massive code refactorings and/or moving<br/>\n&gt;&gt;things around classses. So, I&#39;d say it is always a tread off and has<br/>\n&gt;&gt;to be considered in a case by case base.<br/>\n&gt; <br/>\n&gt; You /believe/ this? or it&#39;s your experience? In my /experience/ it just <br/>\n&gt; isn&#39;t that much of an issue.<br/>\n<br/>\n </span></blockquote>   It could be not an issue for unit testing of the isolated classes, <br/>\nbut it is quite different if those classes have more or less complex <br/>\ndependencies (e.g. those that may be injected by IoC container in real <br/>\napp, but mocked or stubbed in a test time). That perhaps problem with <br/>\nthe toolset because such testing usually introduces lot of dynamic <br/>\ndependencies only resolved or even generated in the runtime.<br/>\n<br/>\n   regards,<br/>\n   Eugene</div>", 
    "prevInTime": 15125, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1129176352", 
    "canDelete": false, 
    "nextInTopic": 15128, 
    "prevInTopic": 15124, 
    "headers": {
        "inReplyToHeader": "PDQzNEREM0QwLjEwNTA5MDFAcm9nZXJzLmNvbT4=", 
        "messageIdInHeader": "PDQzNERERDIwLjEwNzA2QG1kLnBwLnJ1Pg==", 
        "referencesHeader": "PEUxRU5HU1ktMDAwNHd3LUFBQHNtdHBhdXRoMDUubWFpbC5hdGwuZWFydGhsaW5rLm5ldD4gPDQzNDQ0NjFELjMwNTA3MDNAbWQucHAucnU+IDw0MzQ0NjQ0Qi40MDRAbWV0YWxhYi51bmMuZWR1PiA8NDM0NTM3NzEuOTA3MDUwOUByb2dlcnMuY29tPiA8NDM0RDM1NUUuNzA2MDQwMkBtZC5wcC5ydT4gPDQzNEREM0QwLjEwNTA5MDFAcm9nZXJzLmNvbT4="
    }
}