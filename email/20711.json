{
    "numMessagesInTopic": 7, 
    "nextInTime": 20712, 
    "senderId": "rWu7WsTgj4Q1kPJWBNGpIXBPIhHVFEAOM9iv434GMgZYAczs3yrnVyx5NMN5qzO_nxp6TXoxnGksHJwn865FXhC8NEoHlXXPuB0OD0ghj_SY", 
    "systemMessage": false, 
    "subject": "Re: [junit] Newbie wants to take some JUnit group. Some basic questions.", 
    "from": "&quot;J. B. Rainsberger&quot; &lt;jbrains762@...&gt;", 
    "authorName": "J. B. Rainsberger", 
    "msgSnippet": "... It sounds like a very good place to start. I hope you have enjoyed what you ve read so far. ... I see a deeper design issue here that I want to make you", 
    "msgId": 20711, 
    "profile": "nails762", 
    "topicId": 20700, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 282027414, 
    "messageBody": "<div id=\"ygrps-yiv-185161750\">On Mon, Jul 21, 2008 at 2:18 PM, serethos_0 &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:Serethos@...\">Serethos@...</a>&gt; wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; I am an quite experienced programmer but new to the philosophy of unit<br/>\n&gt; testing. An issue I want to change.<br/>\n&gt; I read some articles and took some orientation on Frank Westphal&#39;s<br/>\n&gt; very good book about that topic. But in practice, I always run into<br/>\n&gt; similar problems, which seem to disturb my view of unit testing. So<br/>\n&gt; some thought and questions I would like to discuss.<br/>\n<br/>\n </span></blockquote>It sounds like a very good place to start. I hope you have enjoyed<br/>\nwhat you&#39;ve read so far.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; 1. Recently I read that a unit test is no one if you have to touch<br/>\n&gt; network, db or filesystem. I understand the point that these accesses<br/>\n&gt; really can slow the tests down and usually need extra work of<br/>\n&gt; configuration, but how to avoid this?<br/>\n&gt; An example of my daily work. I have quite a common task: Fetch some<br/>\n&gt; xmls from an ftp server, parse the content and map it into db and vice<br/>\n&gt; versa. So the business logic is quite thin. More important is good<br/>\n&gt; exception handling and the transport of all data in the right structures.<br/>\n<br/>\n </span></blockquote>I see a deeper design issue here that I want to make you aware of, but<br/>\nthat I don&#39;t want to tackle yet. You mention you need to fetch XML<br/>\ndocuments from an FTP server, parse the content, then map it into a<br/>\ndatabase. Already you are describing your design in terms of<br/>\nimplementation details, rather than intent. Think about /why/ you need<br/>\nto do these things while you read my more immediate advice.<br/>\n<br/>\nI find good unit tests especially important to help me design<br/>\nexception handling, which is why I design to interfaces. When I design<br/>\nto interfaces, I can more easily control how collaborators behave, and<br/>\nin particular, I can force them to throw exceptions so I can test how<br/>\nI handle those exceptions. I don&#39;t know enough about your domain to<br/>\nname these classes and methods meaningfully, so I&#39;ll choose<br/>\ngeneric-sounding names that make some sense for me for now. Feel free<br/>\nto suggest better names.<br/>\n<br/>\nTo test your Component, you need to tell a Database to<br/>\nmapContent(content), so I create an interface Database with method<br/>\nmapContent(content) and Component uses it. In this test, I want to<br/>\nknow that Component successfully handles an exception that Database<br/>\nmight throw it. Suppose if the Database throws an exception, then we<br/>\nshould write the XML documents back to a DocumentQueue for later<br/>\nprocessing. You might need to do something different, but this gives<br/>\nme enough to build a complete example.<br/>\n<br/>\n@Test public void componentShouldQueueDocumentsOnDatabaseException()<br/>\nthrows Exception {<br/>\n    Document document = new Document(....);<br/>\n<br/>\n    CollectingDocumentQueue collectingDocumentQueue = new<br/>\nCollectingDocumentQueue();<br/>\n<br/>\n    Database crashTestDummy = new Database() {<br/>\n        public void mapContent(Content content) {<br/>\n            throw new RuntimeException(&quot;I blew up on purpose!&quot;);<br/>\n        }<br/>\n    }<br/>\n<br/>\n    new Component(crashTestDummy,<br/>\ncollectingDocumentQueue).processDocument(document);<br/>\n<br/>\n    assertEquals(Collections.singletonList(document),<br/>\ncollectingDocumentQueue.getDocuments());<br/>\n}<br/>\n<br/>\nI have also introduced interface DocumentQueue with method<br/>\nenqueue(document) and implemented it with CollectingDocumentQueue<br/>\nwhich simply collects all queued documents so the test can ask about<br/>\nthem later. The production implementation of DocumentQueue might talk<br/>\nto JMS or a web service or insert the documents into a database table.<br/>\nDocument is a simple value or entity object that represents one of the<br/>\nXML documents you fetch from your FTP server. It could even be a<br/>\nsimple envelope for raw XML: you can choose.<br/>\n<br/>\nThis test has a narrow focus: when you try to process a document and<br/>\nthe database fails, queue the document for later processing. By not<br/>\ninvolving a real database I can easily simulate the database failing<br/>\nby just implementing the Database anonymously and overriding<br/>\nmapContent() to throw an exception. The production implementation of<br/>\nDatabase could wrap any database you want: object-based, SQL, flat<br/>\nfiles, XStream, anything.<br/>\n<br/>\nThe key part of the technique is that Component, the class under test,<br/>\ntakes the Database and the DocumentQueue as parameters to its<br/>\nconstructor. This way I can use stand-ins that make the test easier to<br/>\nwrite, but still connect production implementations in the<br/>\napplication. In the test, I pass in a crash test dummy Database (a<br/>\nstand-in that always throws an exception) and a spy DocumentQueue (a<br/>\nstand-in that collects information about how it was used so the test<br/>\ncan debrief it afterwards); but in production, I pass in an SQL-based<br/>\nimplementation of Database and a JMS-based implementation of<br/>\nDocumentQueue. Component can&#39;t tell the difference, and I believe it<br/>\nshouldn&#39;t care. This modularity makes both testing and supporting new<br/>\nfeatures easier.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Actually the slowdown of a real ftp transport and the configuration<br/>\n&gt; and injection overhead of the db-connection is a major drawback. But<br/>\n&gt; on the other hand I see no good way to mock the behaviour of these<br/>\n&gt; endpoints.<br/>\n<br/>\n </span></blockquote>Does the above example help you see how to do it? One common technique<br/>\nI use is &quot;mock a level higher of abstraction&quot;. Don&#39;t mock SQL, but<br/>\nrather mock data storage operations that SQL could implement.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; I could try to mock a database, but how to test, if an sql-statement<br/>\n&gt; is correct (especially for a wider range of queries)?<br/>\n<br/>\n </span></blockquote>I wrote about this extensively in chapter 10 of JUnit Recipes, and<br/>\nothers have written extensively about it as well. Here is a short<br/>\nversion:<br/>\n<br/>\nWhen testing whether you correctly move data from FTP server to<br/>\ndatabase, don&#39;t test whether you can fetch from FTP and don&#39;t test<br/>\nwhether you can INSERT into the database. Assume you can fetch() and<br/>\nassume you can INSERT, then test what happens in between. When you<br/>\nimplement your XmlDocumentSource to be an FtpServer, then try fetching<br/>\na variety of documents without worrying about what happens after<br/>\nthey&#39;ve been fetched, because you tested that elsewhere. When you<br/>\nimplement your Database to be an SqlDatabase, then try a bunch of SQL<br/>\nstatements without worrying about why you&#39;re executing those<br/>\nparticular statements, because you tested that elsewhere.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; It also is a very hard work to write stubs or mocks, which can answer<br/>\n&gt; with all error-states an ftp-server/network can generate (timeout,<br/>\n&gt; access denied, authentication etc) to test the correct error handling<br/>\n&gt; of my code.<br/>\n<br/>\n </span></blockquote>Does the database client handle the different SQL error codes<br/>\ndifferently? If not, then maybe one test throwing a generic<br/>\nSQLException will suffice.<br/>\n<br/>\nDoes the FTP client handle the different FTP errors differently? If<br/>\nnot, then maybe one test throwing a generic FTP transport exception<br/>\nwill suffice.<br/>\n<br/>\nDon&#39;t assume you have to test every kind of error separately if your<br/>\nclient always responds to errors the same way.<br/>\n<br/>\nIf, on the other hand, you do need to handle all those errors<br/>\ndifferently, then you simply have to test for them all. If you do<br/>\nless, then you&#39;re not doing your job.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; 2. Another question points to a basic principle of unit testing: the<br/>\n&gt; opening of a class in small and public methods. I see an advantage in<br/>\n&gt; the possibility to inject every aspect of a class (manually or e.g.<br/>\n&gt; via spring) and the code can benefit from a better readability through<br/>\n&gt; a chain of self-explanatory method calls.<br/>\n&gt; But in some cases I want to hide implementation details from the user.<br/>\n<br/>\n </span></blockquote>I know two basic ways to hide implementation details: private methods<br/>\nand interfaces. I prefer interfaces, since I use them to reach highly<br/>\nmodular designs anyhow.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Taking my Importer/Exporter example a second time, it is more a cron<br/>\n&gt; script than an application: Doing a defined job in a robust and<br/>\n&gt; understandable manner but neither designed as a basis for wide<br/>\n&gt; enhancements nor for ultimate flexibility.<br/>\n<br/>\n </span></blockquote>In this case, modularity makes it easier to isolate failures and<br/>\nprevent defects. I find that convincing enough, even if I don&#39;t need<br/>\nthe additional ease-of-maintenance benefits modularity gives me.<br/>\n<br/>\nIt looks like you&#39;re thinking a lot about this. Whatever you decide to<br/>\ndo, thinking carefully about it is probably a great start.<br/>\n-- <br/>\nJ. B. (Joe) Rainsberger :: <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.jbrains.ca\">http://www.jbrains.ca</a><br/>\nYour guide to software craftsmanship<br/>\nJUnit Recipes: Practical Methods for Programmer Testing<br/>\n2005 Gordon Pask Award for contribution Agile Software Practice</div>", 
    "prevInTime": 20710, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1216947623", 
    "canDelete": false, 
    "nextInTopic": 20716, 
    "prevInTopic": 20705, 
    "headers": {
        "inReplyToHeader": "PGc2Mm5lYis1NWl0QGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PGNlMTk5ZDA4MDcyNDE4MDBvNjYzNzc4YTRyNzkwYzM1MjNlYjAwYjY4Y0BtYWlsLmdtYWlsLmNvbT4=", 
        "referencesHeader": "PGc2Mm5lYis1NWl0QGVHcm91cHMuY29tPg=="
    }
}