{
    "numMessagesInTopic": 80, 
    "nextInTime": 18699, 
    "senderId": "H6_LHArUpo28qXEnR48wUrBwcHRq2vt0Ev1hQS1h2Y99RpuSIKEZsTWnKGuYxJheRVV_EsrQ-oUdd9ra0L5Nm991ZhHpUg", 
    "systemMessage": false, 
    "subject": "Re: [junit] 100%% Method Testing and Generating Unit Tests", 
    "from": "Ole Ersoy &lt;ole_ersoy@...&gt;", 
    "authorName": "Ole Ersoy", 
    "msgSnippet": "... Suppose a,b,c are int s. Further, this is a triangle so 0 ", 
    "msgId": 18698, 
    "profile": "ole_ersoy", 
    "topicId": 18605, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 98908154, 
    "messageBody": "<div id=\"ygrps-yiv-105259670\">Just a comment on this part:<br/>\n<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;This one is not<br/>\n&gt;even theoretically<br/>\n&gt;possible for a machine to do. <br/>\n <br/>\n&gt;For example, consider this method on a Triangle<br/>\n&gt;class:<br/>\n <br/>\n&gt; public boolean isIsosceles() {<br/>\n&gt;     return a == b || a == c || b == c;<br/>\n&gt; }<br/>\n&gt; <br/>\n<br/>\n </span></blockquote>Suppose a,b,c are int&#39;s.<br/>\n<br/>\nFurther, this is a triangle so <br/>\n<br/>\n0 &lt; [a,b,c]<br/>\n<br/>\nis always true.<br/>\n<br/>\nThis is an invarient constraint of the model for the<br/>\ntriangle.<br/>\n<br/>\nA good design tool should ask questions like that with<br/>\n<br/>\nrespect to the defined parameters.<br/>\n<br/>\nThen to complete enumerate the test, we define the<br/>\nfollowing points:<br/>\n<br/>\naMax bMax cMax<br/>\naMin bMin cMin<br/>\n<br/>\naMin-1 bMin-1 cMin-1<br/>\naMax+1 bMax+1 cMax+1<br/>\n<br/>\nIn range means a legal java int that respects the <br/>\nthe invarient constraint.<br/>\n<br/>\naInRange bInRange cInRange ExpectedReturnValue<br/>\n   2        2        2          true<br/>\n   2        2        3          true<br/>\n   2        3        3          true<br/>\n   3        2        2          true<br/>\n   3        3        2          true<br/>\n   3        3        3          true<br/>\n   1        2        3          false<br/>\n   3        2        1          false<br/>\n   2        3        1          false <br/>\n<br/>\n<br/>\nThen you could do the same process using<br/>\naMin, aMin=1, bMin...etc.<br/>\nfinally forming the picture of all the points<br/>\nthat are interesting.<br/>\n<br/>\nWith respect to this, <br/>\n<br/>\nif we were to add aMin bMin cMin to the <br/>\ntable above, we would be adding <br/>\n<br/>\n   1        1        1<br/>\n<br/>\nThis falls in the same pattern as the above<br/>\npoints, but the tester might find it interesting/<br/>\ncomforting just to check that point.<br/>\n<br/>\nSam goes for aMax, bMax, cMax<br/>\n<br/>\nThen for aMin-1 and aMax+1...these should<br/>\nnever be allowed to enter the test...an exception<br/>\nshould be thrown.  Thus for the enumerated set of<br/>\nthese<br/>\npossibilities, an exception is always thrown, so<br/>\nthat&#39;s what the test tests for.<br/>\n<br/>\n<br/>\nSo these points represent the 100% test.<br/>\n<br/>\nIt&#39;s possible to create tests using different<br/>\ndatapoints, but they&#39;ll follow the same pattern.<br/>\n<br/>\nSo if these tests pass, everything should pass.<br/>\n<br/>\nCheers,<br/>\n- Ole<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n--- Kevin Lawrence &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:kev.lawrence@...\">kev.lawrence@...</a>&gt; wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; On 1/9/07, Greg Irvine &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:greg.irvine@...\">greg.irvine@...</a>&gt;<br/>\n&gt; wrote:<br/>\n&gt; &gt; Kevin, I think you&#39;ve missed James&#39; point, at<br/>\n&gt; least in the snippet of his<br/>\n&gt; &gt; email you&#39;ve quoted.<br/>\n&gt; <br/>\n&gt; I think I understood his point and agreed with it. I<br/>\n&gt; was trying to<br/>\n&gt; make an additional point.<br/>\n&gt; <br/>\n&gt; &gt;<br/>\n&gt; &gt; He&#39;s saying that generating tests from existing<br/>\n&gt; code has the risk that the<br/>\n&gt; &gt; code doesn&#39;t do what it was intended but a test is<br/>\n&gt; generated to pass based<br/>\n&gt; &gt; on the incorrect code.  So you would have 100%<br/>\n&gt; test passes, which is<br/>\n&gt; &gt; incorrect against the actual expected results<br/>\n&gt; against the requirements.<br/>\n&gt; &gt;<br/>\n&gt; <br/>\n&gt; I am trying to separate the various goals of testing<br/>\n&gt; and investigate<br/>\n&gt; distinct strategies that would achieve each goal.<br/>\n&gt; <br/>\n&gt; One goal is to prevent regressions: show that, after<br/>\n&gt; a change, the<br/>\n&gt; code still does what it did before or at least show<br/>\n&gt; what behaviors<br/>\n&gt; changed (regardless of whether the code was<br/>\n&gt; previously &#39;correct&#39;). I<br/>\n&gt; think we are agreed that a machine could do this in<br/>\n&gt; principle even if<br/>\n&gt; it is difficult in practice. It still requires a<br/>\n&gt; reviewer, though, to<br/>\n&gt; decide which changes were intended and which were<br/>\n&gt; not .<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; Another goal is to demonstrate correctness:<br/>\n&gt; demonstrate that the code<br/>\n&gt; behaves correctly for all inputs. This one is not<br/>\n&gt; even theoretically<br/>\n&gt; possible for a machine to do. But a machine can make<br/>\n&gt; the job of a<br/>\n&gt; human reviewer easier by showing combinations of<br/>\n&gt; inputs and outputs<br/>\n&gt; that are &#39;likely&#39; to represent special or border<br/>\n&gt; cases.<br/>\n&gt; <br/>\n&gt; For example, consider this method on a Triangle<br/>\n&gt; class:<br/>\n&gt; <br/>\n&gt; public boolean isIsosceles() {<br/>\n&gt;     return a == b || a == c || b == c;<br/>\n&gt; }<br/>\n&gt; <br/>\n&gt; A machine might generate tests:<br/>\n&gt; <br/>\n&gt;     public void testIsIsosceles() throws Throwable {<br/>\n&gt;         boolean result = new Triangle(59, 100,<br/>\n&gt; 59).isIsosceles();<br/>\n&gt;         assertTrue(&quot;result&quot;, result);<br/>\n&gt;     }<br/>\n&gt; <br/>\n&gt;     public void testIsIsosceles1() throws Throwable<br/>\n&gt; {<br/>\n&gt;         boolean result = new Triangle(100, 59,<br/>\n&gt; 59).isIsosceles();<br/>\n&gt;         assertTrue(&quot;result&quot;, result);<br/>\n&gt;     }<br/>\n&gt; <br/>\n&gt;     public void testIsIsosceles2() throws Throwable<br/>\n&gt; {<br/>\n&gt;         boolean result = new Triangle(30, 30,<br/>\n&gt; 30).isIsosceles();<br/>\n&gt;         assertTrue(&quot;result&quot;, result);<br/>\n&gt;     }<br/>\n&gt; <br/>\n&gt; A reviewer might look at these tests and exclaim<br/>\n&gt; &quot;That&#39;s not correct!<br/>\n&gt; The last one is equilateral&quot; and amend the spec to<br/>\n&gt; exclude equilateral<br/>\n&gt; triangles from the definition of isosceles.<br/>\n&gt; <br/>\n&gt; A second attempt might amend the code to,<br/>\n&gt; <br/>\n&gt;   public boolean isIsosceles() {<br/>\n&gt;     return a == b || a == c || b == c;<br/>\n&gt;   }<br/>\n&gt; <br/>\n&gt; The existing tests would then serve as a regression<br/>\n&gt; suite. After the<br/>\n&gt; change, one of the tests (the previously incorrect<br/>\n&gt; one) would now fail<br/>\n&gt; and (we hope) the others would still pass.<br/>\n&gt; <br/>\n&gt; Assuming the tests are essentially &#39;free&#39; and that<br/>\n&gt; we can trust the<br/>\n&gt; machine to generate tests that are at least as good<br/>\n&gt; as they were<br/>\n&gt; before, we can throw all the existing tests away and<br/>\n&gt; generate new<br/>\n&gt; ones.<br/>\n&gt; <br/>\n&gt; Then we might get a test like this,<br/>\n&gt; <br/>\n&gt;     public void testIsIsosceles2() throws Throwable<br/>\n&gt; {<br/>\n&gt;         boolean result = new Triangle(36, 36,<br/>\n&gt; 36).isIsosceles();<br/>\n&gt;         assertFalse(&quot;result&quot;, result);<br/>\n&gt;     }<br/>\n&gt; <br/>\n&gt; and be happy that our method now behaves correctly.<br/>\n&gt; <br/>\n&gt; There are a lot of &#39;if&#39;s and &#39;assuming&#39;s in all that<br/>\n&gt; but, with a<br/>\n&gt; machine that could generate perfect regression tests<br/>\n&gt; in zero time, we<br/>\n&gt; might think quite differently about the value of<br/>\n&gt; tests and how we use<br/>\n&gt; them.<br/>\n&gt; <br/>\n&gt; As JB suggested, it is impossible for a program to<br/>\n&gt; prove the<br/>\n&gt; correctness of another program. Even with a<br/>\n&gt; human/machine combo it is<br/>\n&gt; difficult and tedious which is why I still write all<br/>\n&gt; of my code test<br/>\n&gt; first with TDD.<br/>\n&gt; <br/>\n&gt; TDD provides excellent regression coverage too but,<br/>\n&gt; if it&#39;s<br/>\n&gt; essentially free to generate tests to fill the gaps<br/>\n&gt; in my TDD<br/>\n&gt; coverage, why wouldn&#39;t I?<br/>\n&gt; <br/>\n&gt; The more astute reader will have guessed that the<br/>\n&gt; examples above were<br/>\n&gt; lifted directly from the demo page at<br/>\n&gt; <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.junitfactory.com/demo/\">http://www.junitfactory.com/demo/</a>   The service is<br/>\n&gt; still experimental<br/>\n&gt; and somewhat less than perfect, but I&#39;d be<br/>\n&gt; interested in getting<br/>\n&gt; feedback from the kind of people who think a lot<br/>\n&gt; about these kinds of<br/>\n&gt; things. I can send an invitation to anyone who wants<br/>\n&gt; one.<br/>\n&gt; <br/>\n&gt; Kevin<br/>\n&gt; <br/>\n&gt; <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.junitfactory.com\">http://www.junitfactory.com</a><br/>\n&gt; You send us code. We send you tests. For free.<br/>\n&gt; <br/>\n<br/>\n<br/>\n<br/>\n <br/>\n </span></blockquote>____________________________________________________________________________________<br/>\nNeed a quick answer? Get one in minutes from people who know.<br/>\nAsk your question on www.Answers.yahoo.com</div>", 
    "prevInTime": 18697, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1168460324", 
    "canDelete": false, 
    "nextInTopic": 18699, 
    "prevInTopic": 18697, 
    "headers": {
        "inReplyToHeader": "PDUxZDFiMmRlMDcwMTEwMDk0N2k0ZGM3NzUxMHA0MjE5MTkwNmNkNTFhZjBhQG1haWwuZ21haWwuY29tPg==", 
        "messageIdInHeader": "PDQxNzQxNi4zMDIwOC5xbUB3ZWI2MDcxNS5tYWlsLnlhaG9vLmNvbT4="
    }
}