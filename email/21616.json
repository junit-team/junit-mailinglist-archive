{
    "numMessagesInTopic": 10, 
    "nextInTime": 21617, 
    "senderId": "C9OoYaetJAYqc9OJ1MHvLKuTfKLq_LQLwbUdZ_rwQDY2MHYCaGkPSEMhAkR9S7mR9WaY1j_yirgqFCn87MjliuGrCdWn9gqh35dj", 
    "systemMessage": true, 
    "subject": "Re: [junit] Re: Dynamically adding test classes at test-time", 
    "from": "Miles Parker &lt;milesparker@...&gt;", 
    "authorName": "Miles Parker", 
    "msgSnippet": "... Right, but given below then the subclasses have to be known at discovery time, right? Or can we simply have the class *name* at that time? IOTW, appropos", 
    "msgId": 21616, 
    "profile": "milestravisparker", 
    "topicId": 21594, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 190960924, 
    "messageBody": "<div id=\"ygrps-yiv-1250235485\"><blockquote><span title=\"ireply\">&gt;<br/>\n&gt; &gt; day. But it doesn&#39;t look like I can use inheirit from Suite or Parent<br/>\n&gt; &gt; Runner for example because they both are looking for a class.<br/>\n&gt;<br/>\n&gt; You can actually give pass Suite a null for the parent class, and then<br/>\n&gt; a list of subclasses.<br/>\n<br/>\n </span></blockquote>Right, but given below then the subclasses have to be known at<br/>\ndiscovery time, right? Or can we simply have the class *name* at that<br/>\ntime? IOTW, appropos below, do all classes also have to be loaded at<br/>\ndiscovery time, or are we simply building an arbitrary tree for which<br/>\nthe actual test classes can be loaded and instantiated at runtime?<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; &gt; But the trick<br/>\n&gt; &gt; of course is that needs to be deferred until test run-time.<br/>\n&gt;<br/>\n&gt; Does the test discovery step _need_ to happen inside a test computation? Why?<br/>\n&gt;<br/>\n&gt; I have a feeling we have a mismatch of assumptions.<br/>\n<br/>\n </span></blockquote>Yes, or expectations. My dilemma is that it doesn&#39;t make sense for me<br/>\nto go through trying to put this kind of harness together without<br/>\nknowing wether it is possible, but it&#39;s a lot to expect that someone<br/>\nwho would actually know wether it was possible would want to take the<br/>\ntime to understand what I&#39;m trying to do. :D So the short answer is<br/>\nyes, I need or really really want this and I&#39;ve thought it through<br/>\nquite a bit. The long answer...<br/>\n<br/>\nIn a way JUnit&#39;s raison d&#39;Ãªtre is the philosophy that one should<br/>\nspecify *a priori* and statically what is expected and then check that<br/>\nthat indeed happens, right? So a lot of the architecture quite<br/>\nunderstandably carries that simplifying assumption. BUt.. it begins to<br/>\nget more confused as we add leverage through model-driven / generative<br/>\ntechniques. I&#39;m working at a bit of a meta-level here -- there are<br/>\ntests that ensure things like wether the classes are actually<br/>\ngenerated correctly and doing so with an arbitrary set of targets; but<br/>\nwe are *also* actually generating the test code that exercises that<br/>\ntarget code. There is an aspect to the code-gen process that gets<br/>\nswitched on and adds test annotations, potentially in-line asserts and<br/>\nso on either by specializing the target code generated classes or by<br/>\ncreating proxies. I want the discovery of test methods so that we<br/>\nensure coverage for newly generated model behaviors and to ease<br/>\nmaintenance.<br/>\n<br/>\nNow, the only other way that I can think of to do this is as a<br/>\ntwo-phased process. I might end up doing it this way eventually; I<br/>\ncould generate a list of class names and method names in a test suite<br/>\ngeneration step and then actually run the tests in a follow on JUnit<br/>\nprocess. So the answer to my question above is probably the real make<br/>\nor break.<br/>\n<br/>\nNow that still isn&#39;t ideal but it would be workable. Setting up the<br/>\nbuild for that would not be trivial but in principal its doable. But<br/>\nthat would still mean that in the test discovery step for the actual<br/>\ntests I will *not* have access to the *actual* test classes or methods<br/>\nand it is suspect because it relies on inspection to make sure that<br/>\nthe generated list of methods and the actual methods actually match<br/>\nup. OTOH, in the original case we are making assumptions that the<br/>\ngenerated tests actually are generated at all so there will always be<br/>\na bit of a need for inspection there as well. Interesting<br/>\nphilosophical issue I suppose.<br/>\n<br/>\n(BTW, Currently my setup works but because it al happens within a<br/>\nsingle Eclipse JUnit plugin test (and there is no simple way to chain<br/>\nthem) it ends up being a wicked boot-strapping problem; I have to load<br/>\nan older version of the tests that did work in order to launch the<br/>\nplugin that will support building the new one&#39;s. So everything works<br/>\ngreat until you have a test failure and then you have to manually<br/>\nrebuild the test environment.)</div>", 
    "prevInTime": 21615, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1242414417", 
    "canDelete": false, 
    "nextInTopic": 21651, 
    "prevInTopic": 21614, 
    "headers": {
        "inReplyToHeader": "PDRmN2RhNmI5MDkwNTE1MDcxNHc1YTgwM2U1Mng2NDVhZDU4MjM0ZmRhOWJmQG1haWwuZ21haWwuY29tPg==", 
        "messageIdInHeader": "PGZkZGZmZTQ2MDkwNTE1MTIwNm03YjNjYTQ3ZWdjYjE1ZjNmZmNjY2M0NzU3QG1haWwuZ21haWwuY29tPg==", 
        "referencesHeader": "PGd1ZDhzaityaGJkQGVHcm91cHMuY29tPiA8Z3VlYWo1KzdkbjBAZUdyb3Vwcy5jb20+CSA8ZmRkZmZlNDYwOTA1MTMwOTI2dDYzYWM1MDhkb2Q3YjEyYzc2NTY2YjE3NjlAbWFpbC5nbWFpbC5jb20+CSA8NGY3ZGE2YjkwOTA1MTQwNjEweDNmNTFjMzk0c2MwMzlhOWEyMmFjOThhZTJAbWFpbC5nbWFpbC5jb20+CSA8NTMyQTA1OTYtNTdGNi00REU5LTk4OEItNjg2N0E2MTlGODQ0QGdtYWlsLmNvbT4JIDw0ZjdkYTZiOTA5MDUxNTA3MTR3NWE4MDNlNTJ4NjQ1YWQ1ODIzNGZkYTliZkBtYWlsLmdtYWlsLmNvbT4="
    }
}