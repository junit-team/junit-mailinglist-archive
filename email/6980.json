{
    "numMessagesInTopic": 13, 
    "nextInTime": 6981, 
    "senderId": "sxGUJ7lmSuW9M_JTo9RPkzcQrAu2bivVF-bekQ4ARvFBEAY1_VLYYCSs_P4ASUsinM86zUt7rJM5UW7BND3ZuVghmY5pb0Jn9QOEgYN-m9Q1", 
    "systemMessage": false, 
    "subject": "Re: [junit] Management wants to know ...", 
    "from": "&quot;Lauren Bish&quot; &lt;developerdude@...&gt;", 
    "authorName": "Lauren Bish", 
    "msgSnippet": "... From: Jason Rogers  ... Okay, I don t know what level of testing/QA experience people on this list have, but I assume most", 
    "msgId": 6980, 
    "profile": "gs_nomad", 
    "topicId": 6975, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 117292773, 
    "messageBody": "<div id=\"ygrps-yiv-1156652278\"><blockquote><span title=\"qreply\">----- Original Message -----<br/>\nFrom: &quot;Jason Rogers&quot; &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:jacaetevha@...\">jacaetevha@...</a>&gt;<br/>\n<br/>\n<br/>\n&gt;  5. etc. (someone else chime in)<br/>\n<br/>\nOkay, I don&#39;t know what level of testing/QA experience people on this list<br/>\nhave, but I assume most members of the list are developers with little real<br/>\nexperience. Testing and QA are a somewhat different mindset after all. So<br/>\nexcuse me if I come off as somewhat pedantic.<br/>\n<br/>\nFirst, you can indeed do &quot;too much testing&quot; - or rather you can test<br/>\nineffectively and inefficiently. For example, if you have a method that<br/>\ntakes three integer arguments, &#39;arg1&#39;, &#39;arg2&#39;, and &#39;arg3&#39; - and the range<br/>\nfor those integer arguments are supposed to each be zero to one thousand<br/>\ninclusive. If I were to test this method, I would probably start with the<br/>\nfollowing simple bounds test data for each argument:<br/>\n<br/>\n-1, 0, 999, 1000, 1001<br/>\n<br/>\nI would then expand that to include -999, -1000, -1001 just to make sure<br/>\nthere wasn&#39;t some signage problem. Then I would include some magic numbers<br/>\nsuch as 255 and 256 to test variable sizes (not as applicable to Java as<br/>\nother languages, but what the hell).<br/>\n<br/>\nPretty basic testing theory right? Okay, here comes my point; what I would<br/>\nnot do is use every single data point between zero and one thousand, such as<br/>\n1, 2, 3, 4, ... 1000. That would be inefficient and most likely ineffective.<br/>\nSure you could easily test each data point for a single argument with a<br/>\nlittle bit of logic in the test code, but given that you have three<br/>\narguments, there would be one billion combinations of all positive integers.<br/>\nAssuming you could run one thousand tests per second, it would take almost<br/>\ntwelve days to run through the positive combinations alone.<br/>\n<br/>\nI am sure you have all heard of similar examples, but on a more abstract<br/>\nlevel the same principle applies; the goal of testing is to find bugs, not<br/>\nto test every possible combination of data. In most testing/QA efforts I<br/>\nhave been involved in, both as a QA Engineer and as a developer, we<br/>\ncarefully chose our test data, secnarios, suites, what have you, based on<br/>\nwhat was most likely to find a bug. We also concentrated on those areas of<br/>\ncode that we had good reason to believe were the least robust, least tested<br/>\nand the newest - i.e., for whatever reason had the most risk of being buggy.<br/>\nAlso, depending on the nature of the code and or product, we also may have<br/>\nconcentrated on code that, if it failed, would cause the most harm - e.g., I<br/>\nworked for a company that used software to collect and analyze data from HIV<br/>\nblood assays. In that case we were much less concerned about whether the<br/>\nsoftware crashed, or was user friendly, and much more concerned that the<br/>\ndata it generated, displayed, analyzed and stored was always correct. Lives<br/>\nmay have depended on correct data operations.<br/>\n<br/>\nEach software product is different with regard to the various factors that<br/>\naffect how testing is performed, but the things they all have in common are:<br/>\n<br/>\n1) You can&#39;t test everything, so you have to concentrate one the testing<br/>\nmethodologies that are most likely to find bugs.<br/>\n<br/>\n2) The earlier you test, the less costly and more effective/efficient it is<br/>\nto find a bug.<br/>\n<br/>\nSo yes, you can &quot;test too much&quot; if the testing you are doing is ineffective,<br/>\ninefficient and is not finding bugs - because it will take away time and<br/>\neffort from more productive testing methodologies. There are various metrics<br/>\nyou can use to guesstimate the points where you may just be wasting time and<br/>\neffort to test further, but you have to start your tests with well known<br/>\nbasics and work from there, and you should test early.<br/>\n<br/>\nFWIW,<br/>\nLauren<br/>\n<br/>\n=====<br/>\nLooking for an experienced Java/C++ Software Engineer?<br/>\nSee: <a rel=\"nofollow\" target=\"_blank\" href=\"http://developerdude.mystarband.net/resume.html\">http://developerdude.mystarband.net/resume.html</a> </span></blockquote></div>", 
    "prevInTime": 6979, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1045606701", 
    "canDelete": false, 
    "nextInTopic": 6981, 
    "prevInTopic": 6979, 
    "headers": {
        "messageIdInHeader": "PDAwNjkwMWMyZDc5YyQyYzM1Zjk4MCQwMzlhNDA5NEBHb3J0Pg==", 
        "referencesHeader": "PDAwMGUwMWMyZDc4YyQ5OTM2OTY4MCQ5MTljZDY4ZEBSSElOTz4="
    }
}