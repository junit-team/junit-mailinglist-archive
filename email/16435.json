{
    "numMessagesInTopic": 18, 
    "nextInTime": 16436, 
    "senderId": "bn2goHlGqgrT6PvNyILUkaU5bQMnX6VGWOrRSBEuolNOUsm8oa5JO2fK9cpQv41TWgZnfpUiO1SrIidO2ZWGQh6qIRQFvQ", 
    "systemMessage": true, 
    "subject": "Re: chosing between jmock and easymock for mocks?", 
    "from": "&quot;Tammo Freese&quot; &lt;freese@...&gt;", 
    "authorName": "Tammo Freese", 
    "msgSnippet": "Hello, ... That makes a lot of sense, since Java is typed at compile time. And every modern IDE generates the method automatically, with matching parameter", 
    "msgId": 16435, 
    "profile": "tammofreese", 
    "topicId": 16387, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 67713810, 
    "messageBody": "<div id=\"ygrps-yiv-267771052\">Hello,<br/>\n<br/>\n<blockquote><span title=\"qreply\"> --- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>, &quot;J. B. Rainsberger&quot; &lt;jbrains@...&gt; wrote:<br/>\n&gt; Still, there&#39;s a flipside to the whole &quot;can&#39;t generate a method stub&quot; <br/>\n&gt; argument. With EasyMock, if I use a faked or mocked method that doesn&#39;t <br/>\n&gt; yet exist, my test can&#39;t even compile yet! <br/>\n<br/>\nThat makes a lot of sense, since Java is typed at compile time.<br/>\nAnd every modern IDE generates the method automatically,<br/>\nwith matching parameter types and return type.<br/>\n<br/>\n&gt; When I practise TDD, I often <br/>\n&gt; design interfaces, and forcing me to generate a method stub for a method <br/>\n&gt; I might not even like yet is annoying. Keeping the methods as strings <br/>\n&gt; allows me to write the test, compile it, and even run it before I decide <br/>\n&gt; whether the interface or method signature is good enough to start <br/>\n&gt; putting into stone.<br/>\n<br/>\n1) With that method, you never see the method <br/>\n    as a real method call as in EasyMock. Compare <br/>\n<br/>\ncontrol.expectAndReturn(mock.copy(destination, source), true);   // EasyMock 1.2<br/>\n<br/>\nexpect(mock.copy(destination, source)).andReturn(true); // EasyMock 2.0 / 2.1<br/>\n<br/>\nto <br/>\n<br/>\nmock.expects(once()).method(&quot;copy&quot;).with( eq(destination), eq(source) ).will(returnValue<br/>\n(true)); // JMock<br/>\n<br/>\nIn the EasyMock examples, both show how the method <br/>\nis used copy(destination, source) and returning true.<br/>\nIt is easy to see that the parameters should be reordered,<br/>\nand with refactoring-tools, it&#39;s quite fast.<br/>\n<br/>\nIn the JMock example, it is not that easy to spot the method call, because<br/>\nthe method name is in a string, and the parameters are separated from this string.<br/>\nIt is harder to see that the parameters should be reordered,<br/>\nand as refactoring tools don&#39;t work, it&#39;s a pain - especially if<br/>\nthe method is used more than once already in the tests, you have to change<br/>\nevery single ocurrence by hand.<br/>\n<br/>\n2) Can you explain on how you test-drive a plain old java method then,<br/>\nwithout adding a body for it?<br/>\n<br/>\n<br/>\n-<br/>\nTammo Freese </span></blockquote></div>", 
    "prevInTime": 16434, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1143754408", 
    "canDelete": false, 
    "nextInTopic": 16436, 
    "prevInTopic": 16432, 
    "headers": {
        "inReplyToHeader": "PDQ0MjczQTdDLjEwMDA3MDVAcm9nZXJzLmNvbT4=", 
        "messageIdInHeader": "PGUwaGlyOCtjcmR0QGVHcm91cHMuY29tPg=="
    }
}