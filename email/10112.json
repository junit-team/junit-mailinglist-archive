{
    "numMessagesInTopic": 5, 
    "nextInTime": 10113, 
    "senderId": "Q5SyZ2eI_vWQkF-prjLZwzVr9p0DOzOLshjZSxLvlOWHiax8_4S7IupWKoJFyGPG4huRYTnI03Hkl3vPtLhLnRXr7hBm7a7T-KE", 
    "systemMessage": false, 
    "subject": "Re: [junit] newbie - how to test clases persisting to DB, mock objects in .net", 
    "from": "Kevin Klinemeier &lt;zipwow@...&gt;", 
    "authorName": "Kevin Klinemeier", 
    "msgSnippet": "... Ayup, I love this part of the mock approach. ... Not quite.  Since my jdbc (or whatever) level is a mock object rather than the real connection, I can", 
    "msgId": 10112, 
    "profile": "zipwow", 
    "topicId": 10094, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 82914509, 
    "messageBody": "<div id=\"ygrps-yiv-523243891\">--- &quot;J. B. Rainsberger&quot; &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:jbrains@...\">jbrains@...</a>&gt; wrote:<br/>\n<blockquote><span title=\"ireply\"> &gt; &gt; 2:  Test speed - This sounds minor, but its a bigger deal than you<br/>\n&gt; &gt; might think.  No database startup or connection times makes for<br/>\n&gt; much<br/>\n&gt; &gt; faster execution of unit tests.  This makes me much more likely to<br/>\n&gt; add<br/>\n&gt; &gt; a unit test, or to run old ones.<br/>\n&gt; <br/>\n&gt; In memory, these tests take 0.25 seconds less time each.<br/>\n </span></blockquote>Ayup, I love this part of the mock approach.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; &gt; 3:  Test failure cases - This is a big one.  The mock object<br/>\n&gt; approach<br/>\n&gt; &gt; can test the way your code behaves when the database fails.  I can<br/>\n&gt; have<br/>\n&gt; &gt; my mock object accept the Person query, but when it asks for<br/>\n&gt; Salary, it<br/>\n&gt; &gt; throws an exception.  This can&#39;t be done with the<br/>\n&gt; database-connected<br/>\n&gt; &gt; approach.<br/>\n&gt; <br/>\n&gt; Tell me more about this. I don&#39;t understand it.<br/>\n&gt; <br/>\n&gt; I think you mean that the tests detect problems before your JDBC<br/>\n&gt; driver <br/>\n&gt; tries to execute an obviously erroneous query. Is that right?<br/>\n<br/>\n </span></blockquote>Not quite.  Since my jdbc (or whatever) level is a mock object rather<br/>\nthan the real connection, I can write a test that checks how a piece of<br/>\ncode handles failure.  Pseudocode is probably the clearest explanation:<br/>\n<br/>\n/**<br/>\n * Tests that the in-memory transaction is properly backed out if the  <br/>\n<br/>\n * database fails during the update.  (Bug #41833)<br/>\n */<br/>\npublic void testSalaryQueryFailure() {<br/>\n<br/>\n    //create a query object that throws an exception just like a<br/>\n    //database failure<br/>\n    MockResult brokenQuery = new MockResult {<br/>\n        public getResult() {<br/>\n            throw new MyDatabaseIsDyingException();<br/>\n        }<br/>\n    };<br/>\n<br/>\n    someFramework.setResult(brokenQuery);<br/>\n    objectUnderTest.updateSalary();  //the method whose behavior <br/>\n                                     //we&#39;re testing<br/>\n    <br/>\n    testFailureState();  //checks the specifics described in test docs<br/>\n}<br/>\n<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; <br/>\n&gt; How often does it happen that data magically disappears from another <br/>\n&gt; table? I suppose it happens when someone silently adds a new foreign<br/>\n&gt; key <br/>\n&gt; constraint with &quot;cascade delete&quot;. Perhaps this shouldn&#39;t happen.<br/>\n&gt; Perhaps <br/>\n&gt; that&#39;s a different problem.<br/>\n<br/>\n </span></blockquote>Interestingly, the mock objects wouldn&#39;t catch changes to the database<br/>\nsetup that you describe.  This could be a criticism of the mock<br/>\napproach.  I lump all that in with configuration, and try very hard to<br/>\nignore it.  I&#39;ll probably carry on like that until it bites me very<br/>\nhard.<br/>\n<br/>\nThe problem I&#39;m worried about is that my code under test makes use of<br/>\nsome other code (okay, obviously).  Say I call person.removeAccount(). <br/>\nWhen I write it, removeAccount doesn&#39;t delete the person in any case. <br/>\nSometime after I&#39;ve written my test, removeAccount() is changed to<br/>\nremove the person record if it has no more accounts.  <br/>\n<br/>\nThis would certainly break my test, however, because the<br/>\nremoveAccount() method is now sending some SQL about person removal<br/>\nthat I&#39;m not expecting.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Disagree. More mock objects means more complex object construction<br/>\n&gt; (more <br/>\n&gt; parameters to constructors). This means your setUp() code is more <br/>\n&gt; complex. (I use EasyMock, so two lines of code per interface to<br/>\n&gt; mock.) <br/>\n&gt; What&#39;s neat, though, is that you spend more lines of code setting up <br/>\n&gt; objects, but verifying them is a snap. The less cohesive your objects<br/>\n&gt; <br/>\n&gt; (common with a direct-to-database design), the more hoops to jump <br/>\n&gt; through to verify a particular condition.<br/>\n&gt; <br/>\n&gt; Complex object construction is much less brittle, in general, than <br/>\n&gt; complex assertions.<br/>\n<br/>\n </span></blockquote>Maybe I should have said that the code as a whole is about the same<br/>\nsize?  I didn&#39;t do any kind of quantitative analysis, but kind of<br/>\nlooked over the code and said, &quot;Yeah, this is all doing the same<br/>\nthing.&quot;  I probably counted some of the mock setup as the same as the<br/>\nnon-mock verification.  I like your observation about verification<br/>\nbeing simple.  That alone is a strong argument in favor of the mock<br/>\napproach, as the easier things are to verify, the more likely I am to<br/>\ntest them.<br/>\n<br/>\nI want to say, too, that I&#39;ve written some of the comments as a<br/>\n&quot;connected database&quot; vs &quot;mock database objects&quot; battle.  What I think<br/>\nis closer to the truth is to mock everything you can mock, and if what<br/>\nyou have left must be tested, then and only then should you go the<br/>\nconnected database route.   Connected db is a pain, especially if you<br/>\ndon&#39;t have a database instance per developer.<br/>\n<br/>\nAnd yeah, JB, you&#39;re not alone out there.  I&#39;m hoping to write some of<br/>\nthese impressions up either as an internal document, so I&#39;ve been<br/>\nthinking a lot about this lately.<br/>\n<br/>\n-Kevin<br/>\n<br/>\n__________________________________<br/>\nDo you Yahoo!?<br/>\nProtect your identity with Yahoo! Mail AddressGuard<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://antispam.yahoo.com/whatsnewfree\">http://antispam.yahoo.com/whatsnewfree</a></div>", 
    "prevInTime": 10111, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1071696415", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 10109, 
    "headers": {
        "inReplyToHeader": "PDNGRTBCNjI4LjUwMTA4QHJvZ2Vycy5jb20+", 
        "messageIdInHeader": "PDIwMDMxMjE3MjEyNjU1LjM1MjExLnFtYWlsQHdlYjYwMzAzLm1haWwueWFob28uY29tPg=="
    }
}