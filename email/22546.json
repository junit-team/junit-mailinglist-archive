{
    "numMessagesInTopic": 23, 
    "nextInTime": 22547, 
    "senderId": "ypkGra_cPE069AMf08NmENarpN1WBh5lG61KWYY24YDjUxTijib2LZCATiK0OCo4M5ZQx70AFNS34Ofg-GtZpa_zGQSDvRJIUGNQD1fVu4Com_7_eMEl", 
    "systemMessage": false, 
    "subject": "RE: [junit] Re: @DataPoints called several times for Theories", 
    "from": "&quot;Loritsch, Berin C.&quot; &lt;berin.loritsch@...&gt;", 
    "authorName": "Loritsch, Berin C.", 
    "msgSnippet": "To put into a frame of reference, in my original post I generated two copies through reflection of the same class.  When I halved that to only one copy through", 
    "msgId": 22546, 
    "profile": "bloritsch", 
    "topicId": 22425, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 428096731, 
    "messageBody": "<div id=\"ygrps-yiv-247776039\">To put into a frame of reference, in my original post I generated two copies through reflection of the same class.  When I halved that to only one copy through reflection the time went down from 37 seconds to 16 seconds.  Part of that was a geometric reduction in instances that had to be created, but much also stemmed from the .newInstance() calls.<br/>\n<br/>\n________________________________<br/>\n<br/>\nFrom: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a> on behalf of Loritsch, Berin C.<br/>\nSent: Mon 3/15/2010 9:05 AM<br/>\nTo: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>; <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>; Shin Hwei Tan; Sang Y Baik<br/>\nSubject: RE: [junit] Re: @DataPoints called several times for Theories<br/>\n<br/>\n<br/>\n  <br/>\n<br/>\nI&#39;m still going through the patch. Is there a default CloneStrategy available? Any cloneable object (implements the Cloneable interface) will be much quicker than another copy strategy. It&#39;s also an interface and a copy strategy that comes with the JVM since before Java 2.<br/>\n<br/>\nHere&#39;s a problem I spotted in the implementation:<br/>\n<br/>\nprotected Object getCopyStrategyInvokedObject(Object value, <br/>\nClass&lt;? extends CopyStrategy&gt; copyStrategy, int index) throws CopyStrategyFailureException {<br/>\ntry {<br/>\nreturn copyStrategy.newInstance().copyDataPoint(value);<br/>\n} catch (Exception e) {<br/>\nthrow new CopyStrategyFailureException(value, index, copyStrategy.getSimpleName());<br/>\n}<br/>\n}<br/>\n<br/>\n<br/>\nInvoking copyStrategy.newInstance() for every object that needs to be copied is going to be a major performance drain. Not only are we creating more work for the garbage collector, we are going through the overhead of the reflection API to do it. You will have an order of magnitude better performance if you get your instance of the CopyStrategy first, and pass that as necessary.<br/>\n<br/>\nPerhaps another point of making the code cleaner would be to pull all the data collection stuff into its own API. It might even be able to support parameterized tests as well as theories. I imagine that was the idea behind ParameterSupplier?<br/>\n<br/>\n________________________________<br/>\n<br/>\nFrom: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a> &lt;mailto:junit%40yahoogroups.com&gt;  on behalf of Mike Forsberg<br/>\nSent: Sun 3/14/2010 12:15 PM<br/>\nTo: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a> &lt;mailto:junit%40yahoogroups.com&gt; ; Shin Hwei Tan; Sang Y Baik<br/>\nSubject: Re: [junit] Re: @DataPoints called several times for Theories<br/>\n<br/>\nPlease feel free to join the mailing list. I would find the discussion<br/>\ninteresting and wish it would not run offline.<br/>\n<br/>\nBig Mike<br/>\n<br/>\n<blockquote><span title=\"qreply\"> On Fri, Mar 12, 2010 at 6:44 PM, Brett Daniel &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:brettdaniel@...\">brettdaniel@...</a> &lt;mailto:brettdaniel%40gmail.com&gt;  &lt;mailto:brettdaniel%40gmail.com&gt; &gt; wrote:<br/>\n<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; The undergrads I am advising recently pushed a patch that addresses the<br/>\n&gt; issue of mutable data points.<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; <a rel=\"nofollow\" target=\"_blank\" href=\"http://github.com/stan6/junit/commit/dcfa3c41446c469a4edc7513e9e7a9b610b04020\">http://github.com/stan6/junit/commit/dcfa3c41446c469a4edc7513e9e7a9b610b04020</a> &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"http://github.com/stan6/junit/commit/dcfa3c41446c469a4edc7513e9e7a9b610b04020\">http://github.com/stan6/junit/commit/dcfa3c41446c469a4edc7513e9e7a9b610b04020</a>&gt;  &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"http://github.com/stan6/junit/commit/dcfa3c41446c469a4edc7513e9e7a9b610b04020\">http://github.com/stan6/junit/commit/dcfa3c41446c469a4edc7513e9e7a9b610b04020</a> &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"http://github.com/stan6/junit/commit/dcfa3c41446c469a4edc7513e9e7a9b610b04020\">http://github.com/stan6/junit/commit/dcfa3c41446c469a4edc7513e9e7a9b610b04020</a>&gt; &gt; <br/>\n&gt;<br/>\n&gt; The patch allows developers to define &quot;copy strategies&quot; that duplicate<br/>\n&gt; marked data points before every theory execution. In this way, every<br/>\n&gt; execution receives a pristine data point, which removes the problems caused<br/>\n&gt; when a theory mutates data points. This is orthogonal to datapoint<br/>\n&gt; (re)creation, but I think copy strategies may help address the bug that<br/>\n&gt; Berin found.<br/>\n&gt;<br/>\n&gt; The patch creates a new, optional &quot;copyStrategy&quot; parameter for the<br/>\n&gt; @DataPoint and @DataPoints annotations. If the developer wants to copy data<br/>\n&gt; points, he or she sets the parameter to a class implementing a new<br/>\n&gt; CopyStrategy interface.<br/>\n&gt;<br/>\n&gt; Here is an example:<br/>\n&gt;<br/>\n&gt; @RunWith(Theories.class)<br/>\n&gt; public class TestMutable {<br/>\n&gt;<br/>\n&gt; @DataPoint(copyStrategy = MutableWithCopyStrategy.class)<br/>\n&gt; public static Mutable mutable = new Mutable();<br/>\n&gt;<br/>\n&gt; @Theory<br/>\n&gt; public static testMutate(Mutable a) {<br/>\n&gt; a.mutate();<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; @Theory<br/>\n&gt; public static testNotMutated(Mutable a) {<br/>\n&gt; assertFalse(a.isMutated());<br/>\n&gt; }<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; In the current implementation of JUnit, the second theory may fail because<br/>\n&gt; the first theory mutates the datapoint. With a copy strategy enabled, both<br/>\n&gt; theories receive a new value.<br/>\n&gt;<br/>\n&gt; Strategies can do almost anything: clone the data point, call a factory<br/>\n&gt; method, or--as in the following implementation--instantaiate a new object<br/>\n&gt; with a copy constructor.<br/>\n&gt;<br/>\n&gt; public class MutableWithCopyStrategy implements CopyStrategy {<br/>\n&gt; public Object copyDataPoint(Object toCopy) throws Exception {<br/>\n&gt; return new Mutable((Mutable)toCopy);<br/>\n&gt; }<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; There are several benefits to this implementation. First, the new parameter<br/>\n&gt; is completely optional; if it is omitted, the theory runner behaves as it<br/>\n&gt; always has. Second, it doesn&#39;t require modifying the data point&#39;s class<br/>\n&gt; (for<br/>\n&gt; example, to add a copy constructor or clone method). Most importantly, it<br/>\n&gt; makes it clear to the tester that without a copy strategy one theory<br/>\n&gt; execution can impact another.<br/>\n&gt;<br/>\n&gt; I have CC&#39;d the two students in this email. Please direct any questions to<br/>\n&gt; them.<br/>\n&gt;<br/>\n&gt; Brett<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; On Thu, Feb 18, 2010 at 5:28 PM, Berin &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:berin.loritsch@...\">berin.loritsch@...</a> &lt;mailto:berin.loritsch%40gd-ais.com&gt;  &lt;mailto:berin.loritsch%40gd-ais.com&gt; &lt;berin.loritsch%40gd-ais.com&gt;&gt;<br/>\n&gt; wrote:<br/>\n&gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt; I agree with your prognosis, about fresh data points for testing the<br/>\n&gt; &gt; theories. That is precisely why I proposed reading them once, and cloning<br/>\n&gt; &gt; them (making a copy) as needed for each theory. With that approach we<br/>\n&gt; even<br/>\n&gt; &gt; get the protection from mutated data points when you use the @DataPoint<br/>\n&gt; to<br/>\n&gt; &gt; mark a static field.<br/>\n&gt; &gt;<br/>\n&gt; &gt; Cloning is a much quicker operation, does not execute any constructors.<br/>\n&gt; It<br/>\n&gt; &gt; merely copies the contents of the object memory verbatim.<br/>\n&gt; &gt;<br/>\n&gt; &gt; With the current implementation, if you are not prepared for the<br/>\n&gt; &gt; combinatorial affect of 60 data points combined with 60 data points for<br/>\n&gt; each<br/>\n&gt; &gt; theory there is a major disconnect. The majority of the overhead in this<br/>\n&gt; &gt; particular scenario has to do with creating objects (with the additional<br/>\n&gt; &gt; overhead of doing it by reflection).<br/>\n&gt; &gt;<br/>\n&gt; &gt; When I created only one instance of each class instead of two, the<br/>\n&gt; &gt; performance was twice as fast (i.e. 37 seconds down to about 16 seconds).<br/>\n&gt; &gt;<br/>\n&gt; &gt; Essentially the number of times your @DataPoints method is called depends<br/>\n&gt; &gt; on the number of parameters in your @Theory and how many theories you<br/>\n&gt; have.<br/>\n&gt; &gt; Essentially the formula for my theory (ha, ha) of the execution is like<br/>\n&gt; &gt; this:<br/>\n&gt; &gt;<br/>\n&gt; &gt; N^(p-1) + 1<br/>\n&gt; &gt;<br/>\n&gt; &gt; where:<br/>\n&gt; &gt;<br/>\n&gt; &gt; N is the number of data points returned by the method<br/>\n&gt; &gt; p is the number of parameters<br/>\n&gt; &gt; and the + 1 represents the run where the data point is read the first<br/>\n&gt; time<br/>\n&gt; &gt;<br/>\n&gt; &gt; So for 60 data points it is run 61 times for two parameters. With three<br/>\n&gt; &gt; parameters it would be called 3601 times. I have to verify with three<br/>\n&gt; &gt; parameters. The theory is called N^p times for sure and that is expected.<br/>\n&gt; &gt;<br/>\n&gt; &gt; With the above formula, the mapping of number of calls to parameters for<br/>\n&gt; 60<br/>\n&gt; &gt; data points would be:<br/>\n&gt; &gt;<br/>\n&gt; &gt; 1 -&gt; 2 (I know this is wrong which gives me doubts on the formula)<br/>\n&gt; &gt; 2 -&gt; 61<br/>\n&gt; &gt; 3 -&gt; 3601<br/>\n&gt; &gt; 3 -&gt; 216001<br/>\n&gt; &gt;<br/>\n&gt; &gt; Essentially when the Assignments class needs to make the combinations, it<br/>\n&gt; &gt; will collect the data points initially for each theory. It then calls the<br/>\n&gt; &gt; data points again for each existing data point it collected from the<br/>\n&gt; first<br/>\n&gt; &gt; read. With a third parameter it would take all those combinations again,<br/>\n&gt; to<br/>\n&gt; &gt; add all the permutations for the next round.<br/>\n&gt; &gt;<br/>\n&gt; &gt; I might be wrong and the real formula would be like this:<br/>\n&gt; &gt;<br/>\n&gt; &gt; N^0 + N^1 ... + N^(p-1)<br/>\n&gt; &gt;<br/>\n&gt; &gt; If this is the correct formula, then if you have 60 data points the<br/>\n&gt; number<br/>\n&gt; &gt; of times the method is called would map to the number of parameters like<br/>\n&gt; &gt; this:<br/>\n&gt; &gt;<br/>\n&gt; &gt; 1 -&gt; 1<br/>\n&gt; &gt; 2 -&gt; 61<br/>\n&gt; &gt; 3 -&gt; 3661<br/>\n&gt; &gt; 4 -&gt; 219661<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt; --- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a> &lt;mailto:junit%40yahoogroups.com&gt;  &lt;mailto:junit%40yahoogroups.com&gt; &lt;junit%40yahoogroups.com&gt; &lt;junit%<br/>\n&gt; 40yahoogroups.com&gt;, Brett Daniel<br/>\n&gt;<br/>\n&gt; &gt; &lt;brettdaniel@...&gt; wrote:<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; Berin,<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; When a theory mutates data points, it might be beneficial to recreate<br/>\n&gt; &gt; &gt; the data point for every theory invocation. Doing so prevents one<br/>\n&gt; &gt; &gt; theory execution from affecting others. I wrote about this issue in<br/>\n&gt; &gt; &gt; the following weblog post:<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.brettdaniel.com/archives/2009/09/24/200845/\">http://www.brettdaniel.com/archives/2009/09/24/200845/</a> &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.brettdaniel.com/archives/2009/09/24/200845/\">http://www.brettdaniel.com/archives/2009/09/24/200845/</a>&gt;  &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.brettdaniel.com/archives/2009/09/24/200845/\">http://www.brettdaniel.com/archives/2009/09/24/200845/</a> &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.brettdaniel.com/archives/2009/09/24/200845/\">http://www.brettdaniel.com/archives/2009/09/24/200845/</a>&gt; &gt; <br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; You are correct, though, that copying would avoid some of the overhead<br/>\n&gt; &gt; &gt; in calling datapoint methods. It is interesting you mention this idea,<br/>\n&gt; &gt; &gt; because I am currently overseeing two students who for their senior<br/>\n&gt; &gt; &gt; thesis project are implementing framework for copying datapoints. I<br/>\n&gt; &gt; &gt; will post more information to the mailing list as the project<br/>\n&gt; &gt; &gt; continues.<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; Brett<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt;<br/>\n&gt; [Non-text portions of this message have been removed]<br/>\n&gt;<br/>\n&gt; <br/>\n&gt;<br/>\n<br/>\n[Non-text portions of this message have been removed]<br/>\n<br/>\n[Non-text portions of this message have been removed]<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n[Non-text portions of this message have been removed] </span></blockquote></div>", 
    "prevInTime": 22545, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1268658641", 
    "canDelete": false, 
    "nextInTopic": 22547, 
    "prevInTopic": 22545, 
    "headers": {
        "messageIdInHeader": "PDc1RjVFRDhBNUE1NTM2NDZBNDZFMDBFNkVDODU0RkEzMDM3OEM3RTVAdmFmZjAxLW1haWwwMS5hZC5nZC1haXMuY29tPg==", 
        "referencesHeader": "PDU4ZGJhMjI1MTAwMjE4MDk0M3EyMzhkZDhkdjExYWI0ODczNjMyMWUxNzhAbWFpbC5nbWFpbC5jb20+PGhsa2lmMiszbXRlQGVHcm91cHMuY29tPjw1OGRiYTIyNTEwMDMxMjE1NDRwM2NkN2RkMjhoMWE4OTljZTY1N2Y2NmFkM0BtYWlsLmdtYWlsLmNvbT4gPGE1MjdmZGRmMTAwMzE0MDkxNWw3Mzc2MWVlMXI3ODFiYTIwZmM3NjhlNDJlQG1haWwuZ21haWwuY29tPiA8NzVGNUVEOEE1QTU1MzY0NkE0NkUwMEU2RUM4NTRGQTMwMzc4QzdFNEB2YWZmMDEtbWFpbDAxLmFkLmdkLWFpcy5jb20+"
    }
}