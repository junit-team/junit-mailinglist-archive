{
    "numMessagesInTopic": 5, 
    "nextInTime": 20003, 
    "senderId": "IjO117WZCp1hlp8tGc2B9fOG2qGeyEHQSdkJx3rptHB6ctO1UR4BFmciS3P6LEeDOPeuiPXSnfhylybg_cyWxDvygONbE65JiQ", 
    "systemMessage": true, 
    "subject": "Re: [junit] theory parameter suppliers", 
    "from": "Kendall Shaw &lt;queshaw@...&gt;", 
    "authorName": "Kendall Shaw", 
    "msgSnippet": "Hi, I can see the distinction you are making. I would be stating a universal truth, and supplying representative parameters. The 200 strings I was referring to", 
    "msgId": 20002, 
    "profile": "blipf", 
    "topicId": 20000, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 7710811, 
    "messageBody": "<div id=\"ygrps-yiv-622790040\">Hi,<br/>\n<br/>\nI can see the distinction you are making. I would be stating a universal<br/>\ntruth, and supplying representative parameters.<br/>\n<br/>\nThe 200 strings I was referring to was a comparison to the example using<br/>\n@Before(first=-100, last=100).<br/>\n<br/>\nIn the example, a largish number of parameters can be supplied because<br/>\nyou can describe the integers as a range. If your theory was<br/>\nparameterized by fish names, you couldn&#39;t supply a range of fish names<br/>\nusing something like: @Fish(first=new &quot;albacore&quot;, last=&quot;zingle&quot;), right?<br/>\nI wouldn&#39;t want to put 200 or so strings with fish names in them in the<br/>\nannotation.<br/>\n<br/>\nAbusing Paramaterized to state a universal true, I can supply parameters<br/>\nto my imitation theory by putting Objects in an array. I would rather<br/>\nuse Theory for my theory, I suppose.<br/>\n<br/>\nHow would you supply representative parameters to a Theory that are 200<br/>\nfile names, or 1000 different DOM nodes etc.?<br/>\n<br/>\nKendall<br/>\n<br/>\n<blockquote><span title=\"qreply\"> On Sun, 2007-10-21 at 13:50 -0400, David Saff wrote:<br/>\n&gt; Kendall,<br/>\n&gt; <br/>\n&gt; The Parameters runner and Theories runner are built to handle<br/>\n&gt; different scenarios. With a Theory, you&#39;re building a Universal<br/>\n&gt; Truth; you&#39;re stating &quot;this holds for any possible parameters (that<br/>\n&gt; meet my assumptions). Here are some example parameters.&quot; With a<br/>\n&gt; Parameters method, you&#39;re building an Answer Key; you&#39;re saying &quot;this<br/>\n&gt; holds for these values exactly, and possibly others, but I make no<br/>\n&gt; promises.&quot; Are you building an Answer Key, or stating a Universal<br/>\n&gt; Truth?<br/>\n&gt; <br/>\n&gt; That said, from a practical point of view, the ease of using each<br/>\n&gt; runner depends on how you want to specify your data--I hope that this<br/>\n&gt; limitation will lessen in future releases. Where are your 200 strings<br/>\n&gt; coming from? Thanks,<br/>\n&gt; <br/>\n&gt; David Saff<br/>\n&gt; <br/>\n&gt; On 10/20/07, Kendall Shaw &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:queshaw@...\">queshaw@...</a>&gt; wrote:<br/>\n&gt; &gt; The popper tutorial that the junit 4.4 release notes refers to shows<br/>\n&gt; &gt; an example of a parameter supplier, which allows data points for<br/>\n&gt; &gt; theories to come from parameters of an annotation:<br/>\n&gt; &gt;<br/>\n&gt; &gt; <a rel=\"nofollow\" target=\"_blank\" href=\"http://popper.tigris.org/tutorial.html\">http://popper.tigris.org/tutorial.html</a><br/>\n&gt; &gt;<br/>\n&gt; &gt; The example allows you to use the parameters of an annotation as<br/>\n&gt; &gt; parameters for the theory:<br/>\n&gt; &gt;<br/>\n&gt; &gt; @Theory public void multiplyIsInverseOfDivideWithInlineDataPoints(<br/>\n&gt; &gt; @Between(first=-100, last=100) int amount,<br/>\n&gt; &gt; @Between(first=-100, last=100) int m<br/>\n&gt; &gt; ) {<br/>\n&gt; &gt; assumeThat(m, not(0));<br/>\n&gt; &gt; assertThat(new Dollar(amount).times(m).divideBy(m).getAmount(),<br/>\n&gt; &gt; is(amount));<br/>\n&gt; &gt; }<br/>\n&gt; &gt;<br/>\n&gt; &gt; I think the parameters first and last have to be compile time<br/>\n&gt; &gt; constants, is that right? How can I I test with parameters that<br/>\n&gt; &gt; aren&#39;t constants? I wouldn&#39;t want to put 200 strings in the<br/>\n&gt; parameter<br/>\n&gt; &gt; list, for example. I could use integers like the Between annotation<br/>\n&gt; &gt; above, as indices into an array or function I guess.<br/>\n&gt; &gt;<br/>\n&gt; &gt; I used the @Parameters JUnit annotation instead for a test. From<br/>\n&gt; what<br/>\n&gt; &gt; I see so far, that looks to me like a simpler solution in general,<br/>\n&gt; &gt; than using @Theory. Is that right?<br/>\n&gt; &gt;<br/>\n&gt; &gt; Kendall<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt; Yahoo! Groups Links<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; <br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 20001, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1192992807", 
    "canDelete": false, 
    "nextInTopic": 20003, 
    "prevInTopic": 20001, 
    "headers": {
        "inReplyToHeader": "PDRmN2RhNmI5MDcxMDIxMTA1MGozMTdjNTBlNnBjYzlkZWZkOGVkNTBmYTg4QG1haWwuZ21haWwuY29tPg==", 
        "messageIdInHeader": "PDExOTI5OTI4MDcuMjM4NDYuMTYuY2FtZWxAcG9rZXkucGFjYmVsbC5uZXQ+", 
        "referencesHeader": "PDQ0QUY0NzM5LUIzOEYtNDE0RS05QTBELTU0QkI5QzgyNDNFMkBwYWNiZWxsLm5ldD4JIDw0ZjdkYTZiOTA3MTAyMTEwNTBqMzE3YzUwZTZwY2M5ZGVmZDhlZDUwZmE4OEBtYWlsLmdtYWlsLmNvbT4="
    }
}