{
    "numMessagesInTopic": 9, 
    "nextInTime": 22494, 
    "senderId": "fKT5AWEV5aTwZkIXr2gIGB9v_j5S-GfEiTDBBe-_4-JrHisCj1igtP_e9L1_XBR1jwfVHogWm3DSE8QqCWFcjECd", 
    "systemMessage": false, 
    "subject": "Re: [junit] [RT] JUnit Core, Parallelism, Documentation", 
    "from": "David Saff &lt;david@...&gt;", 
    "authorName": "David Saff", 
    "msgSnippet": "Berin, Thanks for this!  I can t touch here on all of your ideas, so feel free to repeat any points you d like to prioritize in the discussion. With regard to", 
    "msgId": 22493, 
    "profile": "dsaff", 
    "topicId": 22487, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 341876227, 
    "messageBody": "<div id=\"ygrps-yiv-1481917321\">Berin,<br/>\n<br/>\nThanks for this!  I can&#39;t touch here on all of your ideas, so feel<br/>\nfree to repeat any points you&#39;d like to prioritize in the discussion.<br/>\n<br/>\nWith regard to deprecation, we&#39;ve definitely begun to feel the weight<br/>\nof the old code, but have indeed felt that it&#39;s not clear whether<br/>\nbeing very aggressive would be in the best interests of users: thanks<br/>\nto the fact that many users of tools like Eclipse and Maven have their<br/>\nJUnit version automatically updated without explicit intervention,<br/>\nit&#39;s easy to be the cause of breaking something that&#39;s been working<br/>\nfor years.  That said, I think it is time for a little housecleaning.<br/>\nI&#39;ve mentioned to Kent that we should do a codesearch.google.com<br/>\nsmackdown, and start kicking the least-used public method or class<br/>\n&quot;off the island&quot; with each release.<br/>\n<br/>\nAs you mention, I think that the biggest obstacle to real parallelism<br/>\nis an replacement or enhancement of the BeforeClass/AfterClass idiom<br/>\nthat is well-defined outside of a single-threaded execution.  As two<br/>\nexamples, (1) it&#39;s not well-defined whether a BeforeClass method<br/>\nshould be able to be run more than once per test suite execution, (2)<br/>\nit&#39;s not well-defined whether one class can correctly start before<br/>\nanother class&#39;s AfterClass method has been called.<br/>\n<br/>\n   David<br/>\n<br/>\nOn Mon, Mar 1, 2010 at 5:17 PM, Loritsch, Berin C.<br/>\n&lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:berin.loritsch@...\">berin.loritsch@...</a>&gt; wrote:<br/>\n<blockquote><span title=\"qreply\"> &gt; RT = Random Thought.  It&#39;s a habit I picked up from Stefano Mazzocchi<br/>\n&gt; when I used to work with him on the Cocoon project.  Essentially, it&#39;s a<br/>\n&gt; structured brain dump based on observations of the internals of a<br/>\n&gt; project (as such it is longer than most posts).  My apologies if this is<br/>\n&gt; not the forum for this.<br/>\n&gt;<br/>\n&gt; == Code Maintenance Thoughts ==<br/>\n&gt;<br/>\n&gt; I&#39;ve been going through some of the JUnit Core to add some JavaDocs<br/>\n&gt; (it&#39;s in my forked copy if you want me to do a Push request), and made a<br/>\n&gt; few observations.  I can definitely see how JUnit has begun to evolve<br/>\n&gt; over the years, and as is natural with a couple missteps along the way.<br/>\n&gt; It&#39;s hard to get rid of those missteps because some people may have<br/>\n&gt; extended them.  Some of the classes have been deprecated with the<br/>\n&gt; promise that they would be removed in the next revision (as of 4.4) and<br/>\n&gt; they are still there.  I&#39;m not saying that the current solution is a<br/>\n&gt; misstep, just that it is hard to separate the past ones from the current<br/>\n&gt; preferred solution.<br/>\n&gt;<br/>\n&gt; Part of managing a codebase like this includes separating the public and<br/>\n&gt; private API.  Some of that has been done with the &quot;internal&quot; package.<br/>\n&gt; There is no reason to worry about deprecating classes and methods in the<br/>\n&gt; internal package because they are not part of the public API.  But I did<br/>\n&gt; notice that when some classes got moved, the old class in full was kept<br/>\n&gt; in the original location.  A low maintenance way of performing a move<br/>\n&gt; like that makes use of inheritance.  Essentially the newer class is<br/>\n&gt; moved so there is one maintenance location, and the deprecated class<br/>\n&gt; extends the newer class.  Kind of like how the JUnit4 runner provides a<br/>\n&gt; preferred alias to the BlockJUnit4Runner class.<br/>\n&gt;<br/>\n&gt; Part of the core includes a nice little callback interface (the<br/>\n&gt; RunListener).  I imagine that a number of integrations make good use of<br/>\n&gt; this little class.  However, with the implementation as it is currently<br/>\n&gt; written, the RunListener can affect the run performance and parallelism<br/>\n&gt; available.  Essentially, the act of calling a method is a synchronous<br/>\n&gt; function.  That means a poorly written runner can detrimentally affect<br/>\n&gt; the performance of JUnit.  The one that is included with JUnit is pretty<br/>\n&gt; tame, doing the absolute minimum it has to do to track the test<br/>\n&gt; progress.  However, if your tests execute slower in an IDE than with<br/>\n&gt; JUnit alone, it&#39;s probably the RunListener slowing things down.<br/>\n&gt;<br/>\n&gt; == Parallelism Thoughts ==<br/>\n&gt;<br/>\n&gt; Some of the architectural decisions in JUnit&#39;s core definitely reflect<br/>\n&gt; the synchronous nature that the tests were designed to be written.  I<br/>\n&gt; don&#39;t think there is going to be an easy solution to that problem,<br/>\n&gt; unless you stick to a test class per thread model.  More on that a bit<br/>\n&gt; latter.<br/>\n&gt;<br/>\n&gt; When designing for parallel execution of tests (the ParallelComputer<br/>\n&gt; hints at this), you usually don&#39;t want an unbounded number of threads to<br/>\n&gt; be executed in the system.  A fairly common approach to taming the<br/>\n&gt; thread/work apportioning beast is to use queues and worker threads.<br/>\n&gt; Essentially, each test (including the set up and tear down parts) gets<br/>\n&gt; pushed on to the queue, while the executor pops it off on the other side<br/>\n&gt; in another process.  Essentially the relationship to executors to work<br/>\n&gt; queues depends on whatever rules you&#39;ve set up.  For JUnit a simple<br/>\n&gt; mapping of executors to the number of processors (cores) or some<br/>\n&gt; multiple of that would be sufficient.  This model is closer to how JMS<br/>\n&gt; works without all the quality of service overhead.  As the executor runs<br/>\n&gt; the test, it sends notification objects to the notification queue.<br/>\n&gt; Using one line of ASCII art, the process looks like this:<br/>\n&gt;<br/>\n&gt; Classes/Suite ==&gt; Executor ==&gt; Notifier<br/>\n&gt;<br/>\n&gt; Each &quot;==&gt;&quot; represents a queue.  The notification mechanism then becomes<br/>\n&gt; more like Swing events.  We could even cheat and use an Java 5 enum for<br/>\n&gt; the types of events.  This provides the same interface for all the<br/>\n&gt; events, and the convenience of an enum for determining the type of<br/>\n&gt; event.  If we take this approach a step further, if we substitute a<br/>\n&gt; PriorityQueue for the first queue, we get a way to prefer some tests<br/>\n&gt; over others (e.g. using categories as a priority mechanism).  Collecting<br/>\n&gt; the results in a separate thread than they are being executed protects<br/>\n&gt; the execution of tests from poorly written listeners.<br/>\n&gt;<br/>\n&gt; We could go to a very fine level of detail (i.e. each individual test)<br/>\n&gt; if it weren&#39;t for the class setup/tear down methods.  Those kind of<br/>\n&gt; tests would force some sort of ordering.  It&#39;s not entirely impossible,<br/>\n&gt; but does require more care.<br/>\n&gt;<br/>\n&gt; Such an approach may be over-engineering things a bit, and for short<br/>\n&gt; runs of a couple hundred tests that takes less than a second to run<br/>\n&gt; definitely overkill.  However for larger projects with much larger<br/>\n&gt; execution times, it may be a way to short circuit the execution a bit.<br/>\n&gt; Essentially the win here would be the ability to execute tests while<br/>\n&gt; they are still being parsed and prepared.  That can help with things<br/>\n&gt; like Theories where collecting a large number of DataPoints can have a<br/>\n&gt; profound impact on the time it takes to run.<br/>\n&gt;<br/>\n&gt; It would be pretty easy to ensure that no more than n+2 threads are used<br/>\n&gt; in a system, where n = Runtime.availableProcessors().<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; [Non-text portions of this message have been removed]<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; ------------------------------------<br/>\n&gt;<br/>\n&gt; Yahoo! Groups Links<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 22492, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1267540311", 
    "canDelete": false, 
    "nextInTopic": 22494, 
    "prevInTopic": 22491, 
    "headers": {
        "inReplyToHeader": "PDc1RjVFRDhBNUE1NTM2NDZBNDZFMDBFNkVDODU0RkEzMDQ0Qjk3RjJAdmFmZjAxLW1haWwwMS5hZC5nZC1haXMuY29tPg==", 
        "messageIdInHeader": "PDRmN2RhNmI5MTAwMzAyMDYzMW82ZjgyMGQyN2tiMTU5NzcwYzlkN2NhMWNhQG1haWwuZ21haWwuY29tPg==", 
        "referencesHeader": "PDc1RjVFRDhBNUE1NTM2NDZBNDZFMDBFNkVDODU0RkEzMDQ0Qjk3RjJAdmFmZjAxLW1haWwwMS5hZC5nZC1haXMuY29tPg=="
    }
}