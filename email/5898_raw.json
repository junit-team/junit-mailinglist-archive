{
    "numMessagesInTopic": 38, 
    "nextInTime": 5899, 
    "senderId": "NS3jvSsqkKgWVHt9dmWAYe9tqBCYIhIVRKPVXsIrul1j66wXUrS_5zo3PpunXEEvJLcXpdWOxmVL-z5CFxUWL7iUemMvPvdmsV5Muw", 
    "systemMessage": false, 
    "subject": "Re: [junit] Do JUnit internals suck?!?", 
    "from": "Berin Loritsch &lt;bloritsch@...&gt;", 
    "authorName": "Berin Loritsch", 
    "msgSnippet": "... Not the typical case. ... There are some really good things, but the design is not painfully clear to the person just perusing the source code. ... There", 
    "msgId": 5898, 
    "rawEmail": "Return-Path: &lt;bloritsch@...&gt;\r\nX-Sender: bloritsch@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (EGP: mail-8_1_1_4); 2 Oct 2002 13:26:59 -0000\r\nReceived: (qmail 93265 invoked from network); 2 Oct 2002 13:26:59 -0000\r\nReceived: from unknown (66.218.66.218)\n  by m7.grp.scd.yahoo.com with QMQP; 2 Oct 2002 13:26:59 -0000\r\nReceived: from unknown (HELO www1.kc.aoindustries.com) (209.15.201.70)\n  by mta3.grp.scd.yahoo.com with SMTP; 2 Oct 2002 13:26:59 -0000\r\nReceived: from apache.org ([65.105.132.131])\n\tby www1.kc.aoindustries.com (8.11.6/8.11.0) with ESMTP id g92DQw317679\n\tfor &lt;junit@yahoogroups.com&gt;; Wed, 2 Oct 2002 08:26:58 -0500\r\nMessage-ID: &lt;3D9AF5AD.2040403@...&gt;\r\nDate: Wed, 02 Oct 2002 09:33:33 -0400\r\nUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.0; en-US; rv:1.1) Gecko/20020826\r\nX-Accept-Language: en-us, en\r\nMIME-Version: 1.0\r\nTo: junit@yahoogroups.com\r\nSubject: Re: [junit] Do JUnit internals suck?!?\r\nReferences: &lt;004c01c2689a$cc5ffc10$a23886d9@mamago&gt;\r\nContent-Type: text/plain; charset=us-ascii; format=flowed\r\nContent-Transfer-Encoding: 7bit\r\nFrom: Berin Loritsch &lt;bloritsch@...&gt;\r\nX-Yahoo-Group-Post: member; u=64910131\r\nX-Yahoo-Profile: bloritsch\r\n\r\nManuel Amago wrote:\n&gt;&gt;But I suspect that the people who discovered Design\n&gt;&gt;Patterns/XP/Refactoring might have some idea on Object \n&gt;&gt;Oriented design ;-)\n&gt; \n&gt; \n&gt; And I suspect that in that remark lies the crux of it.  The common\n&gt; topics that appear when discussing the complexity of JUnit are Suites\n&gt; and Tests, where this is just a typical instantiation of the Composite\n&gt; pattern.  The TestResult is a collecting parameter, and so on.\n\n\nNot the typical case.\n\n&gt; I am one of those people who puts JUnit forward as an example to be\n&gt; followed, and am, so far, unswayed from that position.  My views are\n&gt; based on the code for JUnit 3.7, but I can only imagine that it has\n&gt; gotten better, and not worse in the latest release.\n\nThere are some really good things, but the design is not painfully\nclear to the person just perusing the source code.\n\n\n&gt; As is usually the case when using patterns in code, to the non-initiated\n&gt; any such code may look very complex indeed, and the relationships\n&gt; between the different classes unfathomable.  The benefits for those who\n&gt; do recognise the patterns, however, is great.\n\nThere are antipatterns you have to beware of as well, one such\nantipattern is an overuse of patterns.\n\nThe crux of the issue is that we know we have TestListeners,\nTestResults, TestCases, TestRunners, and TestSuites--but the specifics\nof *how* they relate are not clear.\n\nFor example:\n\nThe TestCase is taken, and by reflection is turned into a TestSuite.  So\nis it a TestCase or a TestSuite?  That is an important distinction.\nThe Model is not readily apparent.  A stable and predictable model is\nessential to good design--esp. in this case.  I have no problem with\nsaying that a TestCollector dynamically creates a TestSuite from a\ncollection of TestCases.  That is understandable.  I do have a problem\nwith the TestCase being treated as a TestSuite though.\n\nFurthermore, sometimes there is information that needs to be\ncommunicated as to exactly *why* a test failed.  There is no clear way\nto #1 directly get with the TestResult, #2 how to use it in your tests.\nThere isn&#39;t any way to display the results of nested exceptions because\nJUnit doesn&#39;t know about them.  However there is no provided method to\nadd that support either.\n\nThe last case is that the ClassLoader hierarchy needs to be really\nthought through.  The whole issue with only letting some classes remain\nstatic for the life of a test run is an artificial constraint that\ncan cause tests to fail that normally won&#39;t.  Don&#39;t outsmart yourself\nwith the classloaders.\n\nAnother issue I have is that while JUnit defines the Test interface,\nit only really expects the TestCase base class.  It is unclear how\nthe Test interface interacts with the system.  Sometimes I would much\nrather work with my own base class that is completely separate from\nJUnit.  The Assert class should be made a static utility clasee, not\na base class as well.  That would allow us to work with the assert\nmethods from any class something like this is much better:\n\nAssert.isTrue( myObject.rocks() );\n\nthan this:\n\nassertTrue( myObject.rocks() );\n\nThe reason being that sometimes the semantics and internals of the\nway TestCase is written gets in the way of how I want to make JUnit\nwork in my environment.  By not forcing an inheritance hierarchy on\nthe user, and really using interfaces correctly, you can have more\nintelligently designed and robust systems.  Interfaces are very\nimportant to protect a system from refactoring.  If the contracts\nwith the interface hold true, the implementation can change its\ninheritance hierarchy easily.\n\nWhat I would like to see is the following:\n\n* Explicit use of interfaces--make the contracts clear, and code the\n   test runners/collectors to use the interfaces and not the base\n   classes.  If there are different contracts with a type of test/suite,\n   then it needs a new interface.\n\n* Making Assert into a set of static utilities so that we don&#39;t have\n   to inherit it to make it useful.\n\n* Explicit use of the TestResult made clear so that we can extend it\n   to recognize nested exceptions or any other system specific info that\n   would help narrow down exactly why a test failed (sometimes it isn&#39;t\n   so clear--like classloader issues).\n\n* Conversion of Tests to be run with the Command pattern.  A test is\n   a special command that must be run.  The TestRunner doesn&#39;t care what\n   it does, just that it is run.  The Method, Class, ClassLoader, test\n   name, etc. can all be encapsulated in the Command object.\n\n* Explicit declaration of the TestCase being the Leaf of the model, not\n   a branch (as it is now treated).  A different interface for TestSuite\n   and TestCase will help.\n\n-- \n\n&quot;They that give up essential liberty to obtain a little temporary safety\n  deserve neither liberty nor safety.&quot;\n                 - Benjamin Franklin\n\n\n", 
    "profile": "bloritsch", 
    "topicId": 5875, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 64910131, 
    "prevInTime": 5897, 
    "contentTrasformed": false, 
    "postDate": "1033565613", 
    "canDelete": false, 
    "nextInTopic": 5899, 
    "prevInTopic": 5897, 
    "headers": {
        "messageIdInHeader": "PDNEOUFGNUFELjIwNDA0MDNAYXBhY2hlLm9yZz4=", 
        "referencesHeader": "PDAwNGMwMWMyNjg5YSRjYzVmZmMxMCRhMjM4ODZkOUBtYW1hZ28+"
    }
}