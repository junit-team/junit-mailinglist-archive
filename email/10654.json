{
    "numMessagesInTopic": 7, 
    "nextInTime": 10655, 
    "senderId": "pQeK8zgJPy8ZBgPM2mVWbr-G9f39Qgu1HmXW2rh2V5v9c6DcaXXaNrPzOzQJJiCgzkZt3w4Tl5qX_z4Hc4iv0Z_PI2gl66Ao3hM-WvDP8g", 
    "systemMessage": false, 
    "subject": "Re: [junit] Bertrand Meyer&#39;s approach (Contract-Driven Development)", 
    "from": "&quot;J. B. Rainsberger&quot; &lt;jbrains@...&gt;", 
    "authorName": "J. B. Rainsberger", 
    "msgSnippet": "Having read the interview, I summarize Mr Meyer as follows, in three categories of statements. * TDD does not force us to consider /all/ cases, whereas DBC", 
    "msgId": 10654, 
    "profile": "nails762", 
    "topicId": 10621, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 127224993, 
    "messageBody": "<div id=\"ygrps-yiv-1657661444\">Having read the interview, I summarize Mr Meyer as follows, in three <br/>\ncategories of statements.<br/>\n<br/>\n  * TDD does not force us to consider /all/ cases, whereas DBC does<br/>\n  * We get in trouble when we don&#39;t consider all test cases<br/>\n<br/>\n  * It is possible to generate specific tests from generalized contract <br/>\nstatements; whereas it is not possible (in general) to infer the <br/>\ngeneralized contract from specific tests<br/>\n  * We ought to be generating specific tests from a generalized contract <br/>\nstatement, rather than merely writing the specific tests<br/>\n<br/>\n  * When performing TDD we ought to be choosing tests systematically<br/>\n<br/>\nThe last statement is by far the most important; so much so that it <br/>\nrenders the remaining ones as mere implementation details.  When we <br/>\nchoose the next test to write, we ought to do so /with a reason/. It&#39;s a <br/>\nlittle like playing chess: the ones who play it well play with a plan, <br/>\nand the ones who don&#39;t plan tend to lose. Where do we gain insight into <br/>\ngood, systematic ways of choosing tests? We can read books like Software <br/>\nTesting Lessons Learned or we can spend time with a skilled QA person.<br/>\n<br/>\nIf we choose the next test with a reason, then when we practise TDD, we <br/>\n/will/ consider all the cases, even without DBC to force us to do so.<br/>\n<br/>\nIf we choose the next test with a reason, then when we practise TDD, we <br/>\n/will/ choose the appropriate set of specific tests for the generalized <br/>\ncontract statement.<br/>\n<br/>\nTrue, we won&#39;t be generating those tests from some other form, but <br/>\n/that&#39;s just an implementation detail/! So we needn&#39;t go nuts with the <br/>\nargument of TDD v. DBC. They are too different ways to do the same <br/>\nthing. When writing contracts a la DBC becomes as easy as writing JUnit <br/>\ntests, then I&#39;m certainly willing to give it a try. Certainly we could <br/>\nmix the two approaches, writing contracts when it&#39;s easy to do so <br/>\n(because they can be more powerful and expressive) and writing JUnit <br/>\ntests the rest of the time.<br/>\n-- <br/>\nJ. B. Rainsberger,<br/>\nDiaspar Software Services<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.diasparsoftware.com\">http://www.diasparsoftware.com</a> :: +1 416 791-8603<br/>\nLet&#39;s write software that people understand</div>", 
    "prevInTime": 10653, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1079624074", 
    "canDelete": false, 
    "nextInTopic": 10667, 
    "prevInTopic": 10653, 
    "headers": {
        "inReplyToHeader": "PGMybzE5aCt0MHB1QGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PDQwNTlDMThBLjkwMTA1MDJAcm9nZXJzLmNvbT4=", 
        "referencesHeader": "PGMybzE5aCt0MHB1QGVHcm91cHMuY29tPg=="
    }
}