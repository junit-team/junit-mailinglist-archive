{
    "numMessagesInTopic": 9, 
    "nextInTime": 20192, 
    "senderId": "vLLZ4XQMLJSVyqatV7TSnKgQjIrZ7wZbUPrL1u7GFUfyvLznUg73bcY9PdQrfjfzGFvhKkoKteUqsrHhA7PqE_N78QraeDbA2y_7m3VV92PGJ_s", 
    "systemMessage": false, 
    "subject": "Re: [junit] Ideas for testing large methods..", 
    "from": "&quot;Andrew McDonagh&quot; &lt;andrewmcdonagh@...&gt;", 
    "authorName": "Andrew McDonagh", 
    "msgSnippet": "... Hi I agree, although in these situations I tend to favour a slightly different approach... Leaning on the Compiler/Refactorer to make the large method", 
    "msgId": 20191, 
    "profile": "andy_ipaccess", 
    "topicId": 20180, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 283773244, 
    "messageBody": "<div id=\"ygrps-yiv-1585139953\">On 24/12/2007, Nat Pryce &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:nat.pryce@...\">nat.pryce@...</a>&gt; wrote:<br/>\n<blockquote><span title=\"ireply\"> &gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; On 21/12/2007, edu_kumar &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:sarat.beesa@...\">sarat.beesa@...</a>&gt; wrote:<br/>\n&gt;  &gt;  My problem is that i&#39;ve a really huge method,which calls several small<br/>\n&gt;  &gt;  methods ( methods so small, they&#39;re just getters for member<br/>\n&gt;  &gt;  variables), If i have to unit test this method, i&#39;ve to make sure all<br/>\n&gt;  &gt;  the small methods that it subsequently invoke, work as they&#39;re<br/>\n&gt;  &gt;  expected. But all my member variables get initialized seperately in a<br/>\n&gt;  &gt;  different method which is of no relation with the BIG method I wanted<br/>\n&gt;  &gt;  to test in the first place.<br/>\n&gt;  ....<br/>\n&gt;  &gt;  Can I test my method without worrying about the initialization of my<br/>\n&gt;  &gt;  object&#39;s data, by mocking the results of all my getter methods ?<br/>\n&gt;  &gt;  I tried using Jmock for creating mocks in my test case, but it fails<br/>\n&gt;  &gt;  because the mock object only knows what exactly I wanted to mock but<br/>\n&gt;  &gt;  nothing more than that. All my application logic is present in<br/>\n&gt;  &gt;  &#39;MyClass&#39; object not in its mock.<br/>\n&gt;  &gt;<br/>\n&gt;  &gt;  How can I achieve this using Jmock ?<br/>\n&gt;<br/>\n&gt;  This is not what jMock is designed for.  Mock Objects are used to test<br/>\n&gt;  how the object under test affects its environment by sending commands<br/>\n&gt;  to other objects.  They are not for testing the implementation details<br/>\n&gt;  of what goes on *inside* the object under test.<br/>\n&gt;<br/>\n&gt;  In your description of what you&#39;re trying to test, you described<br/>\n&gt;  trying to test a method.  That to me is a smell.  It would be better<br/>\n&gt;  to think about testing the *object*, not individual methods.<br/>\n&gt;<br/>\n&gt;  To write a test for an object you need to answer questions like: What<br/>\n&gt;  does the object do? What messages do I send the object to make it<br/>\n&gt;  perform the behaviour I am testing? What resources does it need<br/>\n&gt;  perform that behaviour?  What other objects does it need to talk to?<br/>\n&gt;  Are those objects internal implementation details, or peers of the<br/>\n&gt;  object under test?<br/>\n&gt;<br/>\n&gt;  If you can answer those questions, you can easily work out which<br/>\n&gt;  objects should be mocked out, and which should be hidden within the<br/>\n&gt;  object under test.<br/>\n&gt;<br/>\n&gt;  The other smell is that the method is huge, and has complicated<br/>\n&gt;  dependencies on initialisation methods.  It sounds as if the class<br/>\n&gt;  needs to be divided into smaller, simpler objects that can be more<br/>\n&gt;  easily unit tested and that define proper constructors.<br/>\n&gt;<br/>\n&gt;  To do that without an extensive suite of unit tests, I would first<br/>\n&gt;  write some integration or system tests that cover the behaviour of the<br/>\n&gt;  class. I would then pull behaviour out of the big class into smaller<br/>\n&gt;  classes, writing those smaller classes test-first.  The system tests<br/>\n&gt;  would give me some confidence that my refactoring had not broken<br/>\n&gt;  everything.  Writing the new classes test-first would drive out a less<br/>\n&gt;  coupled design that would be easier to maintain in the future.<br/>\n&gt;<br/>\n&gt;  --Nat<br/>\n&gt;<br/>\n<br/>\n </span></blockquote>Hi<br/>\n<br/>\nI agree, although in these situations I tend to favour a slightly<br/>\ndifferent approach...<br/>\n<br/>\nLeaning on the Compiler/Refactorer to make the large method testable,<br/>\nwithout having to create integration /system tests. I do this as I<br/>\noften find there&#39;s as much problems creating these higher order tests<br/>\nas there is in creating targeted unit tests.<br/>\n<br/>\nTo start off, I&#39;d look at the method and use the IDEs builtin auto<br/>\nrefactorings: extract method and  rename.  These two refactoring will<br/>\nallow me to take a single large method and break it into smaller more<br/>\nlogical methods. These methods must follow a single responsibility<br/>\nconcept. Plus as eclipse has done it for me and the compiler continues<br/>\nto compile without error, its virtually risk free of introducing a<br/>\ndefect - you just have to take your time.<br/>\n<br/>\nI&#39;d deliberately create smaller public methods, instead of private<br/>\nmethods, so that I can write a unit test for them.  However, I don&#39;t<br/>\ngo over board with this...my aim to to make the large method testable,<br/>\nthen worry about the right design that should be used.<br/>\n<br/>\nOnce I have the original large method doing nothing but calling other<br/>\npublic methods, in a certain order, I&#39;m done.  At this point I doubt I<br/>\neven have a test for the original method, but I will have at least one<br/>\ntest for each of the other new methods.<br/>\n<br/>\nThe real benefit of this approach comes about when we take the next<br/>\nstep, one of refactoring the design.  Once we have a series of public<br/>\nmethods, its fair easy to see that some of them should belong to<br/>\nanother new class, rather than the original class.<br/>\n<br/>\nI&#39;ve often found that when performing this retro fitting of unit tests<br/>\nto legacy(*) code that there was more than one class hidden within the<br/>\noriginal. By doing these small steps of leaningon the compiler and<br/>\nrefactor IDE, then adding unit tests, then refactoring again, I can<br/>\nchange the design of a large method into an altogether more testable<br/>\nOO design.<br/>\n<br/>\nAndrew</div>", 
    "prevInTime": 20190, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1198514481", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 20190, 
    "headers": {
        "inReplyToHeader": "PDE3ZmE1M2QwNzEyMjQwMjQ0cDU1OTI3ZmI5aWNkZDUxNmFkYWRkOGRkZGRAbWFpbC5nbWFpbC5jb20+", 
        "messageIdInHeader": "PDM1YzUwN2QzMDcxMjI0MDg0MWgyYzI3NzQ0OG4xZTI3NDRmNWNjZDAyMmZlQG1haWwuZ21haWwuY29tPg==", 
        "referencesHeader": "PGZrZzZlZCtzc2kwQGVHcm91cHMuY29tPgkgPDE3ZmE1M2QwNzEyMjQwMjQ0cDU1OTI3ZmI5aWNkZDUxNmFkYWRkOGRkZGRAbWFpbC5nbWFpbC5jb20+"
    }
}