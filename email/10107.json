{
    "numMessagesInTopic": 5, 
    "nextInTime": 10108, 
    "senderId": "MLAtpY14WcDVaUluf_2k7yWGvd-w-PFQajAj44DYD0M-Zv9zrS56kfuAPdMz1QGR616KcacbKT09flIQSmwgIJ9OiGI1PvGjMWs", 
    "systemMessage": false, 
    "subject": "Re: [junit] newbie - how to test clases persisting to DB, mock objects in .net", 
    "from": "Kevin Klinemeier &lt;zipwow@...&gt;", 
    "authorName": "Kevin Klinemeier", 
    "msgSnippet": "I ve been using the mock object approach to testing with a good amount of success.  I ve used both the SQL mock objects from http://www.mockobjecst.com, and a", 
    "msgId": 10107, 
    "profile": "zipwow", 
    "topicId": 10094, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 82914509, 
    "messageBody": "<div id=\"ygrps-yiv-199901286\">I&#39;ve been using the mock object approach to testing with a good amount<br/>\nof success.  I&#39;ve used both the SQL mock objects from <br/>\nhttp://www.mockobjecst.com, and a mock implementation of our own<br/>\npersistence level.  <br/>\n<br/>\nThe main criticism of this approach is that you&#39;re not really testing<br/>\nwriting to the database.  Performance, configuration, db behavior, and<br/>\nselect statement correctness is not tested.  I don&#39;t think that<br/>\nconfiguration and performance are things that are appropriate for<br/>\ntesting in unit tests, so I ignore those points.  To the database<br/>\nbehavior question (aka &quot;actually writing to the database&quot;), I respond<br/>\nwith, &quot;I didn&#39;t write the database layer, I don&#39;t need to test it.&quot;  It<br/>\nis true that you can have unresolved bugs with problems in your SQL<br/>\nstatement (or QBE examples, in my case).  That&#39;s an admitted weakness,<br/>\nand not a small one.  If there are suggestions on that front, they&#39;re<br/>\nwelcome (see below).<br/>\n<br/>\n<br/>\nJust to clarify, (almost) all my tests run without actually accessing<br/>\nthe database.  I think this approach has these key advantages:<br/>\n<br/>\n1:  Test independence - I don&#39;t have to worry about stepping on other<br/>\ndevelopers.  (If my non-mock test creates a value, then deletes it,<br/>\nwhat happens if someone else&#39;s test it re-creates it after I&#39;ve deleted<br/>\nit, but before I&#39;ve checked for it being missing?  Trouble and<br/>\nconfusion).<br/>\n<br/>\n2:  Test speed - This sounds minor, but its a bigger deal than you<br/>\nmight think.  No database startup or connection times makes for much<br/>\nfaster execution of unit tests.  This makes me much more likely to add<br/>\na unit test, or to run old ones.<br/>\n<br/>\n3:  Test failure cases - This is a big one.  The mock object approach<br/>\ncan test the way your code behaves when the database fails.  I can have<br/>\nmy mock object accept the Person query, but when it asks for Salary, it<br/>\nthrows an exception.  This can&#39;t be done with the database-connected<br/>\napproach.<br/>\n<br/>\n4:  Test completeness - This is more true of the SQL tools, but only<br/>\nbecause they&#39;ve taken the time to write all the things I needed.  I can<br/>\ntell the SQL tools to look for the following select statements, and if<br/>\nthere is deviation, complain.  The not-so-obvious case that this caught<br/>\nfor me was multiple queries.  I had a logic problem that was causing my<br/>\ncode to ask ten times for a particular case that I only intended for it<br/>\nto ask once.<br/>\n<br/>\n4:  Test completeness - I want to say this again with another example. <br/>\nIf you have code that deletes things, you can be sure that it only<br/>\ndeletes the things you expect.  With the database-connected approach,<br/>\nyou&#39;re typically only testing that it deletes the things you expect to<br/>\nbe gone, not whether there were things that existed before that are now<br/>\nalso deleted by some side effect (like in another table you weren&#39;t<br/>\nexpecting, for example).<br/>\n<br/>\n5:  Test size unchanged - When I set out to use the mock objects, I<br/>\nexpected this to increase the size of my test code vs the<br/>\ndatabase-connected approach.  I was suprised to find that this wasn&#39;t<br/>\nthe case.  Consider the following pseudocode:<br/>\n<br/>\nsetupInitialState();<br/>\nexecuteMethodUnderTest();<br/>\nassertTrue(&quot;State not right&quot;,checkState());<br/>\ncleanupState();<br/>\n<br/>\nThis is the same type of code whether your initial state is inserting<br/>\nrecords in the database, or if it is setting up mock objects.  The only<br/>\nplace I had more code than before was in cases #3 and #4, where I was<br/>\ntesting things I was previously unable to test.<br/>\n<br/>\n-Kevin<br/>\n<br/>\n--- &quot;J. B. Rainsberger&quot; &lt;jbrains@...&gt; wrote:<br/>\n<blockquote><span title=\"ireply\"> &gt; Google &quot;Dalloway unit test database&quot; and read the article. It&#39;s a<br/>\n&gt; very <br/>\n&gt; good one.<br/>\n<br/>\n </span></blockquote>Just FYI for the original poster, its &quot;Dallaway&quot; with all a&#39;s.<br/>\n<br/>\n<br/>\n<br/>\n__________________________________<br/>\nDo you Yahoo!?<br/>\nProtect your identity with Yahoo! Mail AddressGuard<br/>\nhttp://antispam.yahoo.com/whatsnewfree</div>", 
    "prevInTime": 10106, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1071689356", 
    "canDelete": false, 
    "nextInTopic": 10109, 
    "prevInTopic": 10097, 
    "headers": {
        "inReplyToHeader": "PDNGREY2MkRBLjYwNTA5QHJvZ2Vycy5jb20+", 
        "messageIdInHeader": "PDIwMDMxMjE3MTkyOTE2Ljk1MTEucW1haWxAd2ViNjAzMDYubWFpbC55YWhvby5jb20+"
    }
}