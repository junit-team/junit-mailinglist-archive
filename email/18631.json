{
    "numMessagesInTopic": 80, 
    "nextInTime": 18632, 
    "senderId": "-iqswXLQ0Ql5Uj-_5dQIQ2Y41nrXHCHNAqfn0oBMIpycv1KwFNKreXYi-zaDcDRs69sPmTBsz1fjK7sU2VwPq7u9K4v8iPbAOanBZ2RJlxLR4QHhQyfvy07ClWOC5dHyQEMl5wg", 
    "systemMessage": false, 
    "subject": "Re: [junit] 100%% Method Testing and Generating Unit Tests", 
    "from": "&quot;=?UTF-8?Q?C=C3=A9dric_Beust_=E2=99=94_?=&quot; &lt;cbeust@...&gt;", 
    "authorName": "Cédric Beust ♔", 
    "msgSnippet": "Ole, I m not sure what point you are trying to make with this example, and it seems to me we drifted away from the point that I was making:  100% branch ", 
    "msgId": 18631, 
    "profile": "cbeust", 
    "topicId": 18605, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 199443513, 
    "messageBody": "<div id=\"ygrps-yiv-1403366275\">Ole,<br/>\n<br/>\nI&#39;m not sure what point you are trying to make with this example, and it<br/>\nseems to me we drifted away from the point that I was making:  100% branch<br/>\ncovering in your tests is an impossible goal to achieve, even if my iPod can<br/>\ntest ten lines of Java in 5 nanoseconds.<br/>\n<br/>\nHence my recommendation to let the developer exercise their judgment where<br/>\nto draw the line, and in deciding where they should cover a few branches as<br/>\nopposed to black-box testing their code.<br/>\n<br/>\n-- <br/>\nC�dric<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://testng.org\">http://testng.org</a><br/>\n<br/>\n<br/>\n<blockquote><span title=\"qreply\"> On 1/3/07, Ole Ersoy &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:ole_ersoy@...\">ole_ersoy@...</a>&gt; wrote:<br/>\n&gt;<br/>\n&gt; C�(c)dric,<br/>\n&gt;<br/>\n&gt; Excellent example old Chap.<br/>\n&gt;<br/>\n&gt; So a branch is something that takes the code down a<br/>\n&gt; certain path.<br/>\n&gt;<br/>\n&gt; if ( a &gt; 10 )<br/>\n&gt;<br/>\n&gt; is a branch.<br/>\n&gt;<br/>\n&gt; I think we agree that it&#39;s possible to enumerate the<br/>\n&gt; entire set of branches.<br/>\n&gt;<br/>\n&gt; So for instance<br/>\n&gt;<br/>\n&gt; a &gt; 10<br/>\n&gt;<br/>\n&gt; a &lt; 10<br/>\n&gt;<br/>\n&gt; a = 10<br/>\n&gt;<br/>\n&gt; represents 3 different paths.<br/>\n&gt;<br/>\n&gt; And if I could switch it up<br/>\n&gt; with something like this instead:<br/>\n&gt;<br/>\n&gt; a &gt; 10 && b &lt; 5<br/>\n&gt;<br/>\n&gt; a &lt; 10<br/>\n&gt;<br/>\n&gt; a = 10<br/>\n&gt;<br/>\n&gt; I could enumerate the test set like I did for my<br/>\n&gt; simple example by<br/>\n&gt; assuming edge points / the max allowable values for a<br/>\n&gt; and b (Incidentally in my simple example I did not<br/>\n&gt; test values greater than the max allowable values,<br/>\n&gt; which I should have)<br/>\n&gt;<br/>\n&gt; So now we have test input data set:<br/>\n&gt;<br/>\n&gt; a                     b<br/>\n&gt; -------------------------------------<br/>\n&gt; 11                    4<br/>\n&gt; 9                     4<br/>\n&gt; 10                    4<br/>\n&gt; aBiggest              4<br/>\n&gt; aBiggest+1            4<br/>\n&gt; aSmallest             4<br/>\n&gt; aSmallest-1           4<br/>\n&gt;<br/>\n&gt; 11                    5<br/>\n&gt; 9                     5<br/>\n&gt; 10                    5<br/>\n&gt; aBiggest              5<br/>\n&gt; aBiggest+1            5<br/>\n&gt; aSmallest             5<br/>\n&gt; aSmallest-1           5<br/>\n&gt;<br/>\n&gt; 11                    bMax<br/>\n&gt; 9                     bMax<br/>\n&gt; 10                    bMax<br/>\n&gt; aMax                  bMax<br/>\n&gt; aMax+1                bMax<br/>\n&gt; aMin                  bMax<br/>\n&gt; aMin-1                bMax<br/>\n&gt;<br/>\n&gt; etc. with bMin and bMin-1<br/>\n&gt;<br/>\n&gt; That&#39;s not so bad...<br/>\n&gt;<br/>\n&gt; Your ipod can do that in 5 nanoseconds.<br/>\n&gt;<br/>\n&gt; But these are just the inputs.<br/>\n&gt;<br/>\n&gt; We also have to generate the outputs.<br/>\n&gt;<br/>\n&gt; Which is also easy to do and we would use the<br/>\n&gt; method to calculate them.  This assumes that there<br/>\n&gt; are no constraints on the output.  Lets just say that<br/>\n&gt; the output is just an int<br/>\n&gt; c.<br/>\n&gt;<br/>\n&gt; Suppose c can only be 1 or 2.<br/>\n&gt;<br/>\n&gt; Well, that implies further constraints on the inputs,<br/>\n&gt; so we have to go back and reconstrain.<br/>\n&gt;<br/>\n&gt; However in this example c can be anything, so we just<br/>\n&gt; calculate the possible outputs.<br/>\n&gt;<br/>\n&gt; Then we run it through testing.<br/>\n&gt;<br/>\n&gt; Now we could test<br/>\n&gt;<br/>\n&gt; a = 22<br/>\n&gt; a = 23<br/>\n&gt;<br/>\n&gt; etc.<br/>\n&gt;<br/>\n&gt; but that would be silly since we assume that<br/>\n&gt; since we passed values through our enumerated branch<br/>\n&gt; list, that represent the beginning and end of the<br/>\n&gt; range of allowed values and even the points external<br/>\n&gt; to that range, we covered everything.<br/>\n&gt;<br/>\n&gt; So now I can look at my generated test code<br/>\n&gt; and see all the inputs, the expected outputs,<br/>\n&gt; and run the tests.<br/>\n&gt;<br/>\n&gt; I personally would like this since it does a lot of<br/>\n&gt; the grunt work for me.<br/>\n&gt;<br/>\n&gt; It&#39;s possible to have a method<br/>\n&gt; with a gazillion variables and paths...<br/>\n&gt;<br/>\n&gt; but I would think that that would be a ripe case for<br/>\n&gt; refactoring, because it&#39;s tricky to test :-)<br/>\n&gt;<br/>\n&gt; As a matter of fact...it would be nice to have<br/>\n&gt; something that enumerates the branches and generates a<br/>\n&gt; report on which methods has a number of branches over<br/>\n&gt; a certain limit...for code refactoring and maintenance<br/>\n&gt; purposes.<br/>\n&gt;<br/>\n&gt; Cheers,<br/>\n&gt; - Ole<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; --- C�(c)dric Beust ��&quot;  &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:cbeust@...\">cbeust@...</a>&gt; wrote:<br/>\n&gt;<br/>\n&gt; &gt; On 1/3/07, Ole Ersoy &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:ole_ersoy@...\">ole_ersoy@...</a>&gt; wrote:<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; We first have to agree on what 100% means.<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; I provided a very simple example in the earlier<br/>\n&gt; &gt; post.<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; The example gives a 100% tested tested method<br/>\n&gt; &gt; example,<br/>\n&gt; &gt; &gt; given that the assumptions hold.<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; This example can be entirely generated using<br/>\n&gt; &gt; DataType<br/>\n&gt; &gt; &gt; meta data.<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt; Yes, but your example is too simple since it only<br/>\n&gt; &gt; contains one branch (most<br/>\n&gt; &gt; examples extolling the virtues of code coverage have<br/>\n&gt; &gt; this flaw :-)).<br/>\n&gt; &gt;<br/>\n&gt; &gt; 100% coverage means you should cover all the<br/>\n&gt; &gt; possible branches of your code,<br/>\n&gt; &gt; which is impossible to achieve in practice.  Even<br/>\n&gt; &gt; when code coverage tools<br/>\n&gt; &gt; report 100% coverage (hardly ever happens in my<br/>\n&gt; &gt; experience), they are still<br/>\n&gt; &gt; lying to you.<br/>\n&gt; &gt;<br/>\n&gt; &gt; Consider the following simple code:<br/>\n&gt; &gt;<br/>\n&gt; &gt; public URL createUrl(int a, int b) {<br/>\n&gt; &gt;<br/>\n&gt; &gt; try {<br/>\n&gt; &gt;   if (a == 0 || b == 0) {<br/>\n&gt; &gt;   }<br/>\n&gt; &gt;<br/>\n&gt; &gt;   if (c == 0 && d == 0) {<br/>\n&gt; &gt;   }<br/>\n&gt; &gt; }<br/>\n&gt; &gt; catch(IOException ex) {<br/>\n&gt; &gt; }<br/>\n&gt; &gt; catch(MalformedURLException ex) {<br/>\n&gt; &gt; }<br/>\n&gt; &gt;<br/>\n&gt; &gt; 100% coverage for this code means something like<br/>\n&gt; &gt; 2*2*2*2 = 16 test cases<br/>\n&gt; &gt; (I&#39;m approximating, but you get the idea).<br/>\n&gt; &gt;<br/>\n&gt; &gt; Do you really feel it&#39;s useful to write 16 test<br/>\n&gt; &gt; cases for these 6 lines of<br/>\n&gt; &gt; code?<br/>\n&gt; &gt;<br/>\n&gt; &gt; Wouldn&#39;t you be better off black-box testing this<br/>\n&gt; &gt; function instead, and<br/>\n&gt; &gt; ignore the screams of complaint from your code<br/>\n&gt; &gt; coverage tool?<br/>\n&gt; &gt;<br/>\n&gt; &gt; --<br/>\n&gt; &gt; C�dric<br/>\n&gt; &gt; <a rel=\"nofollow\" target=\"_blank\" href=\"http://testng.org\">http://testng.org</a><br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt; [Non-text portions of this message have been<br/>\n&gt; &gt; removed]<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; __________________________________________________<br/>\n&gt; Do You Yahoo!?<br/>\n&gt; Tired of spam?  Yahoo! Mail has the best spam protection around<br/>\n&gt; <a rel=\"nofollow\" target=\"_blank\" href=\"http://mail.yahoo.com\">http://mail.yahoo.com</a><br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; Yahoo! Groups Links<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n<br/>\n<br/>\n[Non-text portions of this message have been removed] </span></blockquote></div>", 
    "prevInTime": 18630, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1167861000", 
    "canDelete": false, 
    "nextInTopic": 18632, 
    "prevInTopic": 18630, 
    "headers": {
        "inReplyToHeader": "PDkzMDQ4OC43MTIwLnFtQHdlYjYwNzE1Lm1haWwueWFob28uY29tPg==", 
        "messageIdInHeader": "PGI4NmI2YTljMDcwMTAzMTM0OXAyMGNiNWY0MnJlMWUwZWI4ZTc1OTlmN2U4QG1haWwuZ21haWwuY29tPg==", 
        "referencesHeader": "PGI4NmI2YTljMDcwMTAzMTEzMW8xM2QyNGYxZXFjNzQ3ZWVlODRhNTI0N2NlQG1haWwuZ21haWwuY29tPgkgPDkzMDQ4OC43MTIwLnFtQHdlYjYwNzE1Lm1haWwueWFob28uY29tPg=="
    }
}