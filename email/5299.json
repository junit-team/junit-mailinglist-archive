{
    "numMessagesInTopic": 67, 
    "nextInTime": 5300, 
    "senderId": "KKW7AiVy6bwQj__wJN1WLVkv4G4XF7-k5LNQhRqoXqYA55GqRyqPNlNWjLXI4Syj_f_damvAfoUXzp33AjWgVJa_qla4Rq4xFsyPcv_hTS9roWYf", 
    "systemMessage": false, 
    "subject": "RE: [junit] Re: distinguishing between failures and errors", 
    "from": "&quot;J. B. Rainsberger&quot; &lt;jbr@...&gt;", 
    "authorName": "J. B. Rainsberger", 
    "msgSnippet": "... Never. Intentionally undefined means, by definition, that no test case has been conceived for that codepath, let alone written. ... One should not. If", 
    "msgId": 5299, 
    "profile": "nails762", 
    "topicId": 5186, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 89240252, 
    "messageBody": "<div id=\"ygrps-yiv-2005880210\"><blockquote><span title=\"ireply\">&gt;&gt; &gt; You can&#39;t test for any particular behavior from the callee<br/>\n&gt;&gt; &gt; if the callee&#39;s behavior in the face of a null pointer is <br/>\n&gt;&gt; &gt; intentially left undefined (e.g., for flexibility in <br/>\n&gt;&gt; &gt; implementing an interface).)<br/>\n&gt;&gt; <br/>\n&gt;&gt; The callee is the class being tested, the specifics for different<br/>\n&gt;&gt; implementations could be implemented<br/>\n&gt;&gt; in specific TestCases, <br/>\n&gt;<br/>\n&gt;Why test for behavior that is (intentionally) undefined?<br/>\n<br/>\n </span></blockquote>Never. &quot;Intentionally undefined&quot; means, by definition, that no test<br/>\ncase has been conceived for that codepath, let alone written.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;Consider a method that is defined to return &quot;an instance of some <br/>\n&gt;class implementing interface I.&quot;  In that specification, the<br/>\n&gt;particular class is undefined.<br/>\n&gt;<br/>\n&gt;If your implementation currently uses a class C, why test that <br/>\n&gt;the returned instance is of class C?<br/>\n<br/>\n </span></blockquote>One should not. If the method signature is<br/>\n<br/>\n     I foo();<br/>\n<br/>\nthen the compiler guarantees that the answer to foo() is an I. No test<br/>\nis required.<br/>\n<br/>\nIn a different language, where typing is not so strong, one could<br/>\nwrite:<br/>\n<br/>\n    assertTrue( foo() instanceof I );<br/>\n<br/>\nor, if typing is not tied to a named interface, but rather a set of<br/>\nmethods:<br/>\n<br/>\n    assertTrue( foo() understands someMessage );<br/>\n<br/>\n[I use Java-like syntax for clarity. I do not imply that Java is<br/>\ninvolved.]<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;If you test for class C and treat tests as documentation, then <br/>\n&gt;that implies that a caller is allowed to depend on the fact that <br/>\n&gt;you return class C.  That is usually _not_ at all what you want.<br/>\n<br/>\n </span></blockquote>Precisely; in this case, the method signature should be<br/>\n<br/>\n    C foo();<br/>\n<br/>\nand not &quot;I foo();&quot;. Simple OO design.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt; &gt; (How can a test show that a caller is responsible for not<br/>\n&gt;&gt; &gt; depending on certain current behavior of an implementation<br/>\n&gt;&gt; &gt; that is not part of the interface contract?)<br/>\n<br/>\n </span></blockquote>It is not the job of a programmer test to think on behalf of the<br/>\nprogrammer. The programmer test is designed to codify what the<br/>\nprogrammer thinks about how code ought to behave. A programmer that<br/>\ndepends on an undocumented implementation detail -- whether documented<br/>\nby tests or words -- is taking an unnecessary risk. The programmer<br/>\nshould then write a test to codify his assumption about the code he is<br/>\nusing and hope that that test never fails. The good news is this: if<br/>\nthe undocumented implementation details ever change, the programmer<br/>\nwill know immediately and can attempt to recover from the change. Even<br/>\nbetter would have been to negotiate with the author of the other<br/>\nsoftware and nail down the behavior more.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt; It can&#39;t, the caller&#39;s TestCase should do that. And possibly <br/>\n&gt;<br/>\n&gt;What caller?  That is, no caller necessarily even exists yet. <br/>\n&gt;So no, the caller&#39;s test case cannot do that.  <br/>\n<br/>\n </span></blockquote>If no caller exists yet, then how can you ask the question?<br/>\n <br/>\n<blockquote><span title=\"ireply\"> &gt;(And how could a test case for a caller detect whether that <br/>\n&gt;caller passes a null pointer to the called method?)<br/>\n&gt;<br/>\n&gt;&gt; the callee&#39;s documentation.<br/>\n&gt;<br/>\n&gt;EXACTLY--documentation, not just tests!!!<br/>\n<br/>\n </span></blockquote>Once again: tests *are* documentation. You insist on the *need* for<br/>\nwritten documentation. I claim that it is not necessary. It may be<br/>\nuseful -- when well-written and kept up to date -- but it is not<br/>\nnecessary. Perhaps you simply need to realize that there are other<br/>\nforms of documentation than natural-language-written documentation.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt; &gt; Because tests, being code, can&#39;t relate code to external concepts.<br/>\n <br/>\n&gt;&gt; &gt; <br/>\n&gt;&gt; &gt; (A specification can say that a function f returns the<br/>\n </span></blockquote>mathematical<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt; &gt; sum of two given integers subject to the limitations of 32-bit<br/>\n&gt;&gt; &gt; signed binary arithmetic.  How can a test say something like<br/>\n </span></blockquote>that?)<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt; &gt; <br/>\n&gt;&gt; <br/>\n&gt;&gt; \ttry{<br/>\n&gt;&gt; \t    int result = instance.f(Integer.MAX_VALUE, <br/>\n&gt;&gt; Integer.MAX_VALUE);<br/>\n&gt;&gt; \t    fail(&quot;f should throw Exception when integer limits <br/>\n&gt;&gt; are met&quot;);<br/>\n&gt;&gt; \t}catch(IllegalStateException e){<br/>\n&gt;&gt; \t    assertTrue(&quot;function f returns the mathematical sum <br/>\n&gt;&gt; of two given<br/>\n&gt;&gt; integers subject to the limitations of 32-bit&quot;);<br/>\n&gt;<br/>\n&gt;Hmm.  I thought you were talking about having the test logic/behavior<br/>\n&gt;define the method behavior.<br/>\n<br/>\n </span></blockquote>This test defines part of the method&#39;s behavior, does it not?<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;You can stick documentation text in the test case code, but I don&#39;t<br/>\n&gt;think that changes the fact that it&#39;s human-parsed documentation.<br/>\n<br/>\n </span></blockquote>I do not understand what you mean in this case by &quot;human-parsed<br/>\ndocumentation.&quot; If I write something -- anything -- and you read it, it<br/>\nis trivially &quot;human-parsed&quot;: a human parsed it. That&#39;s not terribly<br/>\ninteresting in itself.<br/>\n<br/>\nYou may mean to say, &quot;You can write it as code, but I can still read it<br/>\nas words.&quot; Yes. That&#39;s one of the reasons we want easy-to-read tests:<br/>\nso humans can read them easily and understand them. But this is also<br/>\n*executable* documentation. Executable, self-verifying documentation of<br/>\nany kind is better than written documentation for the simple reason<br/>\nthat the former cannot be wrong while the latter can be wrong. One can<br/>\ntrust the former, but not the latter. I don&#39;t understand why this<br/>\nself-evident statement is such a sticking point.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;I do grant that your example shows that documentation doesn&#39;t have to <br/>\n&gt;be in some place separate from the tests.<br/>\n<br/>\n </span></blockquote>Stronger: replace &quot;doesn&#39;t have to be&quot; with &quot;ought not to be&quot;.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;Hey--I have an idea.  You know how Javadoc 1.4 can provide links to <br/>\n&gt;the source?  Maybe (ideally, fantasy-land, etc.) it could provide<br/>\n </span></blockquote>links <br/>\n<blockquote><span title=\"ireply\"> &gt;to the test case source too.<br/>\n<br/>\n </span></blockquote>That sounds like Literate programming to me.<br/>\n<br/>\nIf there were a simple correspondence between classes and test cases,<br/>\nthis would be an excellent idea; however, test cases -- when written<br/>\nwell -- may not correspond so easily to individual classes.<br/>\n<br/>\nA product roadmap should probably include the following:<br/>\n<br/>\n* A short description of the overall intent of the product. (What is<br/>\nX?)<br/>\n* High-level design diagrams: package level, probably.<br/>\n* A Javadoc of the test cases, where complex test cases are described<br/>\nwhen they cannot be broken down into simpler ones.<br/>\n<br/>\nCan anyone suggest what might be missing without throwing in the<br/>\nkitchen sink?<br/>\n<br/>\nJ. B. Rainsberger,<br/>\nPresident, Diaspar Software Services<br/>\nLet&#39;s write software that people understand.<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.diasparsoftware.com/\">http://www.diasparsoftware.com/</a><br/>\ntelephone: +1 416 791-8603<br/>\nAll correspondence (c) 2002 Diaspar Software Services.<br/>\nIf you want to use it, just ask; don&#39;t steal.</div>", 
    "prevInTime": 5298, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1025641517", 
    "canDelete": false, 
    "nextInTopic": 5300, 
    "prevInTopic": 5298, 
    "headers": {
        "inReplyToHeader": "PEQ1Nzc2RDA5RDA4NEE3NDBCNUQ3RjI5MjY2ODBGQ0YzMDEyNDdGQTNAbXVzMDAxbXVsbGV0Lm1lcmNhdG9yLmNvbT4=", 
        "messageIdInHeader": "PDIwMDIwNzAyMTYyNTE3MDczNS4wNDkxQTM0RkBzbXRwMS5zeW1wYXRpY28uY2E+", 
        "referencesHeader": "PEQ1Nzc2RDA5RDA4NEE3NDBCNUQ3RjI5MjY2ODBGQ0YzMDEyNDdGQTNAbXVzMDAxbXVsbGV0Lm1lcmNhdG9yLmNvbT4="
    }
}