{
    "numMessagesInTopic": 2, 
    "nextInTime": 6911, 
    "senderId": "aI6_sh3z5PCJ1R79e0SWPpUT3r7V7qroaX1xbjrxayPndSaoLiBPalrfY28Fb9UgqNO8vgpxay-TszYwocWHdQMEnHg-Ex5xiKK3hCJ1", 
    "systemMessage": false, 
    "subject": "Re: [junit] Making an App Testable", 
    "from": "Eric Armstrong &lt;eric.armstrong@...&gt;", 
    "authorName": "Eric Armstrong", 
    "msgSnippet": "In the JUnit group, Scott Stirling made the interesting observation that a unit-testable app is, in effect, a tracable state machine that you can drive a step", 
    "msgId": 6910, 
    "rawEmail": "Return-Path: &lt;eric.armstrong@...&gt;\r\nReceived: (qmail 62946 invoked from network); 8 Feb 2003 15:31:06 -0000\r\nReceived: from unknown (66.218.66.217)\n  by m14.grp.scd.yahoo.com with QMQP; 8 Feb 2003 15:31:06 -0000\r\nReceived: from unknown (HELO n16.grp.scd.yahoo.com) (66.218.66.71)\n  by mta2.grp.scd.yahoo.com with SMTP; 8 Feb 2003 15:31:06 -0000\r\nX-eGroups-Return: eric.armstrong@...\r\nReceived: from [66.218.67.248] by n16.grp.scd.yahoo.com with NNFMP; 08 Feb 2003 15:31:05 -0000\r\nX-Sender: eric.armstrong@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (EGP: mail-8_2_3_4); 7 Feb 2003 23:31:36 -0000\r\nReceived: (qmail 75594 invoked from network); 7 Feb 2003 23:31:36 -0000\r\nReceived: from unknown (66.218.66.217)\n  by m15.grp.scd.yahoo.com with QMQP; 7 Feb 2003 23:31:36 -0000\r\nReceived: from unknown (HELO nwkea-mail-1.sun.com) (192.18.42.13)\n  by mta2.grp.scd.yahoo.com with SMTP; 7 Feb 2003 23:31:36 -0000\r\nReceived: from ha1sca-mail1.SFBay.Sun.COM ([129.145.155.51])\n\tby nwkea-mail-1.sun.com (8.9.3+Sun/8.9.3) with ESMTP id PAA02696;\n\tFri, 7 Feb 2003 15:31:36 -0800 (PST)\r\nReceived: from sun.com (d-usca14-129-126 [129.145.129.126])\n\tby ha1sca-mail1.SFBay.Sun.COM (8.11.6+Sun/8.10.2/ENSMAIL,v2.1p1) with ESMTP id h17NVZh10916;\n\tFri, 7 Feb 2003 15:31:35 -0800 (PST)\r\nMessage-ID: &lt;3E4441D7.80A51E7E@...&gt;\r\nDate: Fri, 07 Feb 2003 15:31:35 -0800\r\nX-Mailer: Mozilla 4.8 [en] (Windows NT 5.0; U)\r\nX-Accept-Language: en\r\nMIME-Version: 1.0\r\nTo: junit@yahoogroups.com, TDD &lt;testdrivendevelopment@yahoogroups.com&gt;\r\nSubject: Re: [junit] Making an App Testable\r\nReferences: &lt;KIEHIBIOBAELJAHIPNHDMEMNCOAA.scottstirling@...&gt; &lt;3E402FC9.83455776@...&gt;\r\nContent-Type: text/plain; charset=us-ascii\r\nContent-Transfer-Encoding: 7bit\r\nFrom: Eric Armstrong &lt;eric.armstrong@...&gt;\r\nX-Yahoo-Group-Post: member; u=78994084\r\nX-Yahoo-Profile: ericsilverlight\r\nX-eGroups-Approved-By: clarkware &lt;mike@...&gt; via web; 08 Feb 2003 15:31:04 -0000\r\n\r\nIn the JUnit group, Scott Stirling made the interesting observation that\n\na unit-testable app is, in effect, a tracable state machine that you can\n\ndrive a step at a time (driving it with a pulse, or strobe, in hardware\nterms) so that you can examine the results of state-transitions and\nverify correct behavior.\n\n(I&#39;ve included a summary of his excellent post. Although this post is\ndirected to the TDD list, I&#39;ve cross-posted to the JUnit list to be sure\n\nhe is included in as much of the ensuing discussion as possible.)\n\nThe question is this: I have an existing app is that is in dire need of\nrefactoring. Clearly, I need a test suite. The need for refactoring is\nmade obvious by the fact that fixing some bugs tends to generate\nothers, so an even more important reason to create the test suite is\nto make sure that I have thought through the desired behaviors and\nhave verified that they will occur.\n\n  [For those that like specifics: The app processes web pages.\n   It could be given a file path or a URL as a starting point. In\n   either case, it must determine whether the page it has been\n   pointed to is a file, a directory, a server, or a server script, and\n   do the  appropriate thing in each case. Right now, that seemingly\n   simple start-up proposition is a mess. It needs refactoring, and\n   solid testing.]\n\nNow then, to get to the question...\n\nIt seems to me that there are two ways to convert this java app\nto &quot;state machine&quot; form, to make it unit-testable.\n    1. Convert the individual behaviors to (static?) methods, so you\n        can point-test the methods.\n\n    2. Convert the program to a co-routine, so you can return\n        from it at pre-arranged points, test state, and then continue\n        from where you left off.\n\n   Note:\n   The app is already in &quot;bean&quot; form, so it is easy to instantiate it\n   as an object in a test case. That is an underlying requirement\n   for unit-testing an app which, in this case, has already been met.\n\nI&#39;m curious about the viability and desirability of each approach,\nespecially in a Java environment. For example:\n  a. Does the functional programming approach (which I have yet\n      to adequately grasp) provide the right thought-framework for\n      designing the methods that make for a testable app?\n  b. Is co-routining realistically achievable for a java app?\n      (I can&#39;t imagine how, unless it is with some relatively ugly\n       dispatch-routine that takes an argument telling it what to\n       do next.)\n\nThen, too, there is the chicken and egg problem -- the app needs\ntests to make refactoring viable, but it needs refactoring to make\ntesting viable. So an alternative strategy is to do something like\nthe following:\n   * Define a series of exit methods that write state information to\n      a configured I/O stream. (Standard output, by default.)\n   * Condition the exits on input options.\n   * For testing, configure the application object with an internal\n      string-stream, set an option to get the appropriate exit, and\n      test that the results are as expected.\n\nAlthough the third approach does not have quite the elegance of an\napp that is designed to be testable from the ground up, it seems like\na decent alternative to test an existing app that badly needs it.\n\nI look forward to additional thoughts on the matter.\n\n&gt; Scott Stirling wrote:\n&gt;\n&gt; I&#39;ve been thinking about Test Driven Development and the question of\n&gt; what is it about it that ensures testability.\n&gt;  ....\n&gt; Obviously, a method added for no other purpose than to make a class&#39;s\n&gt; behavior more directly accessible to external tests ... enhances the\n&gt; testability of a class.\n&gt;  ....\n&gt; So how do you make things testable without corrupting the object\n&gt; design with behaviors added or modified just to make objects\n&gt; testable?  And why is it that test driven development, practiced\n&gt; religiously, will typically give you 100% statement coverage without\n&gt; adding any test-only methods to a class?\n&gt;\n&gt; I think the answer has to do with finite-state machines.  TDD is a\n&gt; methodology that results in the development of clean, working\n&gt; finite-state machines.  It works so well because the methodology of\n&gt; writing tests first drives the mental process to identify and make\n&gt; explicit, in the appropriate order of priority:\n&gt;  1. the desired outputs\n&gt;  2. the inputs and behaviors needed to transition\n&gt;     the machine from an initial or existing state\n&gt;     to desired output\n&gt;  3. the objects that compose the machine (one of the\n&gt;     least important things at first, contrary to more\n&gt;     traditional design methodology)....the naming of\n&gt;     the objects and definition of their boundaries\n&gt;     evolves as the 1st and 2nd priorities are realized.\n&gt;\n&gt; It seems the best way to build and test a finite-state machine is to\n&gt; make the inputs and outputs explicit, and to make the state\n&gt; transitions step-wise and traceable.  It&#39;s a fallout from object\n&gt; oriented programming constraints that the steps become methods in\n&gt; objects, and the traceability of the steps becomes actualized in your\n&gt; unit test methods and TestCases.\n&gt;\n&gt; After doing TDD, traceability and explicit inputs and outputs are what\n&gt; you&#39;ve built into your application and which remain, even if you take\n&gt; away the unit tests when you&#39;re done.\n&gt;\n&gt; So going back to the question of testability, I think there are some\n&gt; basic things that automatically result in testability in OOP (this\n&gt; list by no means accurate or exhaustive, and inspired by some reading\n&gt; about state machines in the testing literature, namely Beizer and\n&gt; Binder):\n&gt;   - objects or collaborations of objects modeled\n&gt;     as finite-state machines\n&gt;   - methods for making state transitions in the\n&gt;     objects themselves or in other objects\n&gt;   - explicit inputs to and outputs from methods\n&gt;   - step-wise, traceable state transitions\n&gt;\n&gt; I think these things become realized in terms of language and design\n&gt; specifics.  For example:\n&gt;   - traceability requires state transition methods\n&gt;     to be accessible for unit testing\n&gt;   - state must be verifiable via attributes or\n&gt;     methods that return state information that can be\n&gt;     used in assertions\n&gt;   - step-wise means you don&#39;t make monolithic &quot;god\n&gt;     methods&quot;, or classes that hide multiple,\n&gt;     untraceable transitions\n&gt;   - explicit inputs means that something like the\n&gt;     method below should be tuned based on the fact\n&gt;     that the Connection object is the *actual* input\n&gt;     needed for the behavior to do its thing:\n&gt;       public Object doMyThing(\n&gt;         ConnectionFactory factory,\n&gt;         String something)\n&gt;       {\n&gt;         Connection con = factory.getConnection();\n&gt;         Object o = doMyThing(con, something);\n&gt;         con.close();\n&gt;         return o;\n&gt;       }\n&gt;\n&gt; Passing in the ConnectionFactory, from this perspective, is an\n&gt; *implicit* input of a Connection, which hides the fact that what&#39;s\n&gt; really needed for the doMyThing() state transition is a Connection.\n&gt; The ConnectionFactory is extraneous to the transition enacted by the\n&gt; method.  But in case you left the signature with the ConnectionFactory\n&gt; (or Connection for that matter), a MockObject would allow you to keep\n&gt; the design &quot;pure.&quot;  (So how important is purity of design? That&#39;s\n&gt; another question.)\n\n\n\n", 
    "profile": "ericsilverlight", 
    "topicId": 6910, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 78994084, 
    "prevInTime": 6909, 
    "contentTrasformed": false, 
    "postDate": "1044660695", 
    "canDelete": false, 
    "nextInTopic": 6917, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PDNFNDQ0MUQ3LjgwQTUxRTdFQHN1bi5jb20+", 
        "referencesHeader": "PEtJRUhJQklPQkFFTEpBSElQTkhETUVNTkNPQUEuc2NvdHRzdGlybGluZ0ByY24uY29tPiA8M0U0MDJGQzkuODM0NTU3NzZAc3VuLmNvbT4="
    }
}