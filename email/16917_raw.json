{
    "numMessagesInTopic": 9, 
    "nextInTime": 16918, 
    "senderId": "TtVHWueUZnYv89KpVm_ANz6-6Plg7J3Vd2G66D29m93-bcaO371rJSTy7KcJMJZau66dOH6Tdr6Ca-L0Ly2-VpIqFmLjsrIZWsgg3jMI", 
    "systemMessage": false, 
    "subject": "Re: Deep Equals of two JavaBeans", 
    "from": "&quot;wheelerpoker&quot; &lt;wheelerpoker@...&gt;", 
    "authorName": "wheelerpoker", 
    "msgSnippet": "Thanks Joe. I think it s wise to implement the equals method properly if that s what you re saying, but I am interested in externalizing a deep comparison to", 
    "msgId": 16917, 
    "rawEmail": "Return-Path: &lt;wheelerpoker@...&gt;\r\nReceived: (qmail 9620 invoked by uid 7800); 13 Jun 2006 19:08:01 -0000\r\nX-Sender: wheelerpoker@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (qmail 71600 invoked from network); 13 Jun 2006 18:51:55 -0000\r\nReceived: from unknown (66.218.67.35)\n  by m6.grp.scd.yahoo.com with QMQP; 13 Jun 2006 18:51:55 -0000\r\nReceived: from unknown (HELO n19c.bullet.sc5.yahoo.com) (66.163.187.210)\n  by mta9.grp.scd.yahoo.com with SMTP; 13 Jun 2006 18:51:51 -0000\r\nReceived: from [66.163.187.121] by n19.bullet.sc5.yahoo.com with NNFMP; 13 Jun 2006 18:50:27 -0000\r\nReceived: from [66.218.69.2] by t2.bullet.sc5.yahoo.com with NNFMP; 13 Jun 2006 18:50:27 -0000\r\nReceived: from [66.218.66.88] by t2.bullet.scd.yahoo.com with NNFMP; 13 Jun 2006 18:50:27 -0000\r\nDate: Tue, 13 Jun 2006 18:50:26 -0000\r\nTo: junit@yahoogroups.com\r\nMessage-ID: &lt;e6n1di+8a93@...&gt;\r\nIn-Reply-To: &lt;448DCA41.3080201@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=&quot;ISO-8859-1&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\nX-Mailer: Yahoo Groups Message Poster\r\nX-Yahoo-Newman-Property: groups-compose\r\nX-eGroups-Msg-Info: 1:6:0:0\r\nFrom: &quot;wheelerpoker&quot; &lt;wheelerpoker@...&gt;\r\nSubject: Re: Deep Equals of two JavaBeans\r\nX-Yahoo-Group-Post: member; u=229401621; y=KuyCnLDKrqhejY8uHS-qOQCQM2ikGcUbkdsShWBwf6mJ54UywqyC\r\nX-Yahoo-Profile: wheelerpoker\r\nX-eGroups-Approved-By: dijdoss &lt;didoss@...&gt; via email; 13 Jun 2006 19:08:00 -0000\r\n\r\nThanks Joe. I think it&#39;s wise to implement the equals method properly\nif th=\r\nat&#39;s what you&#39;re saying, but I am interested in externalizing a\ndeep compar=\r\nison to relieve myself of having to do property-by-property\ncomparisons in =\r\nunit tests--so far, mainly DbUnit tests. I&#39;m happy with\nwhat I&#39;ve got for t=\r\nhe most part, I&#39;m just not completely satisfied\nwith the error messages it =\r\ngenerates on failure.\n\n&lt;code&gt;\nimport java.util.Collection;\nimport java.util=\r\n.Date;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.uti=\r\nl.Map;\nimport java.util.Set;\nimport java.util.SortedSet;\n\nimport junit.fram=\r\nework.Assert;\n\nimport org.apache.commons.beanutils.PropertyUtils;\nimport or=\r\ng.apache.commons.collections.CollectionUtils;\nimport org.apache.commons.col=\r\nlections.Predicate;\nimport org.apache.commons.logging.Log;\nimport org.apach=\r\ne.commons.logging.LogFactory;\n\n/**\n * Utility class for performing a deep c=\r\nomparison of two POJOs&#39;\nproperties. \n * &lt;p&gt;\n * Properties can fall into one=\r\n of three categories:\n * &lt;p&gt;\n * \n * &lt;b&gt;1. Value Types&lt;/b&gt; The following val=\r\nue types and the primitives\nthey wrap\n * (where applicable) are compared by=\r\n value.\n * &lt;ul&gt; \n *  &lt;li&gt;&lt;code&gt;java.lang.Boolean&lt;/code&gt;&lt;/li&gt;\n *  &lt;li&gt;&lt;code&gt;=\r\njava.lang.Character&lt;/code&gt;&lt;/li&gt;\n *  &lt;li&gt;&lt;code&gt;java.lang.CharSequence&lt;/code&gt;=\r\n&lt;/li&gt;\n *  &lt;li&gt;&lt;code&gt;java.lang.Number&lt;/code&gt;&lt;/li&gt;\n *  &lt;li&gt;&lt;code&gt;java.util.Da=\r\nte&lt;/code&gt;&lt;/li&gt;\n * &lt;/ul&gt;\n * This means other value types you use outside thi=\r\ns list (e.g. types \n * that represent money) are treated like POJO&#39;s--they =\r\nare deep compared\n * property-for-property. If you do not want that, you sh=\r\nould use\n * &lt;code&gt;assertDeepEquals(Object, Object, Class[])&lt;/code&gt;, and pas=\r\ns in a \n * &lt;code&gt;Class&lt;/code&gt; array of classes you want compared by value. =\r\n\n * &lt;p&gt;\n * \n * &lt;b&gt;2. POJOs&lt;/b&gt; POJOs are deep compared property-for-propert=\r\ny.\n * &lt;p&gt;\n * \n * &lt;b&gt;3. Collections&lt;/b&gt; Collections are deep-compared\nelemen=\r\nt-for-element. Any \n * properties they define are completely disregarded.\n =\r\n* &lt;p&gt;\n * The methods of this class are safe to use with object graphs\nconta=\r\nining \n * cylic references.\n * &lt;p&gt;\n * &lt;b&gt;Note that this class is not thread=\r\n-safe.&lt;/b&gt;\n */\npublic final class POJOAssert {\n\n    private static final Lo=\r\ng logger =3D LogFactory.getLog(POJOAssert.class);\n    /** for detecting cyc=\r\nles and preventing an infinite recursive loop */\n    private static final S=\r\net lookedAt =3D new HashSet();\n    private static final Class[] defaultValu=\r\neTypes;\n    private static Class[] userSpecifiedValueTypes =3D new Class[0]=\r\n;\n    \n    static {\n        defaultValueTypes =3D new Class[] {            =\r\n    \n            Date.class,\n            Number.class,\n            Characte=\r\nr.class,\n            CharSequence.class,\n            Boolean.class\n        =\r\n};\n    }\n    \n    private POJOAssert() {\n        throw new UnsupportedOpera=\r\ntionException(&quot;do not use&quot;);\n    }\n        \n    public static void assertDe=\r\nepEquals(Object expected, Object actual) {\n        doAssertDeepEquals(&quot;&quot;, e=\r\nxpected, actual);\n        lookedAt.clear();\n    }\n    \n    public static vo=\r\nid assertDeepEquals(Object expected, Object actual, \n            Class[] us=\r\nerSpecifiedValueTypes) {\n        if (userSpecifiedValueTypes =3D=3D null)\n =\r\n           throw new NullPointerException(&quot;null userSpecfiedValueTypes&quot;);\n =\r\n       \n        POJOAssert.userSpecifiedValueTypes =3D userSpecifiedValueTy=\r\npes;\n        \n        assertDeepEquals(expected, actual);\n        POJOAsser=\r\nt.userSpecifiedValueTypes =3D new Class[0];        \n    }\n    \n    private =\r\nstatic void doAssertDeepEquals(String fieldName, Object\nexpected, Object ac=\r\ntual) {\n        if (lookedAt(expected)) {\n            logger.debug(&quot;cycle d=\r\netected on &quot; + expected);\n            return;\n        }\n        \n        if=\r\n (expected =3D=3D null) {\n            Assert.assertNull(&quot;expected &quot; + field=\r\nName + &quot; null, actual\nnot null&quot;, actual);\n        } else {\n            Asse=\r\nrt.assertNotNull(&quot;expected &quot; + fieldName + &quot; not null,\nactual null&quot;, actual=\r\n);\n            \n            if (isValueProperty(expected)) {            \n  =\r\n              evaluateValueTypes(fieldName, expected, actual);\n            =\r\n} else { \n                lookedAt.add(expected);\n                \n        =\r\n        if (isArrayProperty(expected)) {                \n                  =\r\n  evaluateArrays(fieldName, (Object[])expected,\n(Object[])actual);         =\r\n           \n                } else if (isCollectionProperty(expected)) {   =\r\n         \n                    evaluateCollections(fieldName,\n(Collection)ex=\r\npected, (Collection)actual);            \n                } else if (isMapPr=\r\noperty(expected)) {            \n                    evaluateMaps(fieldName,=\r\n (Map)expected,\n(Map)actual);            \n                } else {\n        =\r\n            evaluateComplexTypes(fieldName, expected, actual);\n           \n=\r\n                }                \n            }            \n        }      =\r\n  \n    }\n    \n    // ------------- Methods that check a property&#39;s type ---=\r\n----------\n    \n    private static boolean isValueProperty(Object o) {\n    =\r\n    for (int i =3D 0; i &lt; defaultValueTypes.length; i++) {\n            if (=\r\ndefaultValueTypes[i].isInstance(o))\n                return true;\n        }\n=\r\n        \n        for (int i =3D 0; i &lt; userSpecifiedValueTypes.length; i++)=\r\n {\n            if (userSpecifiedValueTypes[i].isInstance(o))\n              =\r\n  return true;\n        }        \n        \n        return false;\n    }\n     =\r\n   \n    private static boolean isArrayProperty(Object o) {\n        return o=\r\n.getClass().isArray();\n    }\n    \n    private static boolean isCollectionPr=\r\noperty(Object o) {\n        return (o instanceof Collection);\n    }\n    \n   =\r\n private static boolean isMapProperty(Object o) {\n        return (o instanc=\r\neof Map);\n    }    \n    \n    // ------------- Methods that evaluate two pro=\r\nperties (depending\non type) -------------    \n        \n    private static v=\r\noid evaluateValueTypes(String fieldName, Object\nexpected, Object actual) {\n=\r\n        logger.debug(fieldName + &quot; [expected =3D &quot; + expected + &quot;,\nactual =\r\n=3D &quot; + actual + &quot;]&quot;);\n        Assert.assertEquals(fieldName + &quot; not equal&quot;=\r\n, expected,\nactual);        \n    }\n        \n    private static void evaluat=\r\neArrays(String fieldName, Object[]\nexpected, Object[] actual) {        \n   =\r\n     if (expected.length !=3D actual.length) {\n            Assert.fail(fiel=\r\ndName + &quot; lengths don&#39;t match&quot;);\n        }\n        \n        for (int i=3D0;=\r\n i&lt;expected.length; i++) {\n            doAssertDeepEquals(fieldName + &quot; [&quot; =\r\n+ i + &quot;]&quot;,\nexpected[i], actual[i]);\n        }\n    }\n    \n    private static=\r\n void evaluateCollections(String fieldName,\nCollection expected, Collection=\r\n actual) {\n        if ((!(expected instanceof SortedSet)) && expected insta=\r\nnceof\nSet) {\n            evaluateSets(fieldName, (Set)expected, (Set)actual=\r\n);\n        } else {\n            evaluateArrays(fieldName, expected.toArray(=\r\n),\nactual.toArray());\n        }\n    }    \n    \n    private static void eval=\r\nuateSets(String fieldName, Set expected,\nSet actual) {\n        if (expected=\r\n.size() !=3D actual.size()) {\n            Assert.fail(fieldName + &quot; lengths=\r\n don&#39;t match&quot;);\n        }\n        \n        int idx =3D 0;\n        for (Iter=\r\nator i =3D expected.iterator(); i.hasNext();) {\n            Object expected=\r\nElem =3D i.next();\n            Object actualElem =3D CollectionUtils.find(a=\r\nctual, new\nEqualPredicate(expectedElem));\n            if (actualElem =3D=3D=\r\n null) {\n                Assert.fail(fieldName + &quot; not equal&quot;);\n           =\r\n }\n            doAssertDeepEquals(fieldName + &quot; [&quot; + (idx++) + &quot;]&quot;,\nexpecte=\r\ndElem, actualElem);\n        }        \n    }\n    \n    private static void ev=\r\naluateMaps(String fieldName, Map expected,\nMap actual) {\n        Set keys =\r\n=3D expected.keySet();\n        evaluateSets(fieldName, keys, actual.keySet(=\r\n));\n        \n        for (Iterator i=3Dkeys.iterator(); i.hasNext();) {\n   =\r\n         Object key =3D i.next();\n            doAssertDeepEquals(key.toStri=\r\nng(), expected.get(key),\nactual.get(key));\n        }\n    }\n    \n    private=\r\n static void evaluateComplexTypes(String fieldName, Object\nexpected, Object=\r\n actual) {\n        Map expectedProps =3D null, actualProps =3D null;\n      =\r\n  try {\n            expectedProps =3D PropertyUtils.describe(expected);\n   =\r\n         actualProps =3D PropertyUtils.describe(actual);\n            // pre=\r\nvent infinite loop on Class.getClass(). don&#39;t have\nto worry about &#39;class&#39;\n =\r\n           // properties on POJO&#39;s being skipped because\nObject.getClass() =\r\ncan&#39;t be overriden.\n            expectedProps.remove(&quot;class&quot;);\n            =\r\nactualProps.remove(&quot;class&quot;);\n        } catch (Exception ex) {\n            l=\r\nogger.error(ex);\n            throw new RuntimeException(ex);\n        }\n    =\r\n    \n        evaluateMaps(fieldName, expectedProps, actualProps);        \n =\r\n   }            \n    \n    private static boolean lookedAt(Object o) {\n     =\r\n   Object elem =3D CollectionUtils.find(lookedAt, new\nIdentityPredicate(o))=\r\n;\n        return elem !=3D null;\n    }\n    \n    // ------------- Static inn=\r\ner classes -------------\n    \n    private static final class EqualPredicate=\r\n implements Predicate {\n        private Object object;\n        \n        pub=\r\nlic EqualPredicate(Object o) {\n            object =3D o;\n        }\n        =\r\n\n        public boolean evaluate(Object fromList) {\n            return obje=\r\nct.equals(fromList);\n        }        \n    }\n    \n    private static final =\r\nclass IdentityPredicate implements Predicate {\n        private Object objec=\r\nt;\n        \n        public IdentityPredicate(Object o) {\n            object=\r\n =3D o;\n        }\n        \n        public boolean evaluate(Object fromList)=\r\n {\n            return object =3D=3D fromList;\n        }\n    }    \n}\n&lt;/code&gt;=\r\n\n\n\n\n\n\n", 
    "profile": "wheelerpoker", 
    "topicId": 16890, 
    "spamInfo": {
        "reason": "6", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 229401621, 
    "prevInTime": 16916, 
    "contentTrasformed": false, 
    "postDate": "1150224626", 
    "canDelete": false, 
    "nextInTopic": 16940, 
    "prevInTopic": 16908, 
    "headers": {
        "inReplyToHeader": "PDQ0OERDQTQxLjMwODAyMDFAcm9nZXJzLmNvbT4=", 
        "messageIdInHeader": "PGU2bjFkaSs4YTkzQGVHcm91cHMuY29tPg=="
    }
}