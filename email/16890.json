{
    "numMessagesInTopic": 9, 
    "nextInTime": 16891, 
    "senderId": "AI2m64abBoJ-JwMUKGFQT3vJk7YwuvnMTG9oadeH_e_yrX2wMqf3wpHI7xDDCYNANbHSml2S4q7u0-eo0Kup9bor1fZjKZmfrojkrY7t", 
    "systemMessage": true, 
    "subject": "Deep Equals of two JavaBeans", 
    "from": "&quot;wheelerpoker&quot; &lt;wheelerpoker@...&gt;", 
    "authorName": "wheelerpoker", 
    "msgSnippet": "I am trying to implement an assertion that does a deep equals of two POJOs vs. using the POJOs equals methods like assertEquals(Object, Object). The code is", 
    "msgId": 16890, 
    "profile": "wheelerpoker", 
    "topicId": 16890, 
    "spamInfo": {
        "reason": "6", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 229401621, 
    "messageBody": "<div id=\"ygrps-yiv-1447020592\">I am trying to implement an assertion that does a deep equals of two<br/>\nPOJOs vs. using the POJOs&#39; equals methods like assertEquals(Object,<br/>\nObject). The code is below. It&#39;s kind of shakey and only works on<br/>\nproperties that are maps, collections, arrays, primitives, and beans<br/>\n(complex types). It attempts to thwart infinite recursion from cycles<br/>\nby caching objects in a List and performing reference equality tests.<br/>\nI&#39;ve tried to make the code thread-safe, but it&#39;s probably not. Can<br/>\nyou look and comment?<br/>\n<br/>\n<br/>\nimport java.util.ArrayList;<br/>\nimport java.util.Collection;<br/>\nimport java.util.Date;<br/>\nimport java.util.Iterator;<br/>\nimport java.util.List;<br/>\nimport java.util.Map;<br/>\nimport java.util.Set;<br/>\n<br/>\nimport junit.framework.Assert;<br/>\n<br/>\nimport org.apache.commons.beanutils.PropertyUtils;<br/>\nimport org.apache.commons.logging.Log;<br/>\nimport org.apache.commons.logging.LogFactory;<br/>\n<br/>\npublic final class AssertUtil extends Assert {<br/>\n<br/>\n    private static final Log logger = LogFactory.getLog(AssertUtil.class);<br/>\n    /** for detecting cycles and preventing infinite recursive loop */<br/>\n    private static final List referenceCache = new ArrayList();<br/>\n    <br/>\n    private AssertUtil() {<br/>\n        throw new UnsupportedOperationException(&quot;do not use&quot;);<br/>\n    }<br/>\n    <br/>\n    public static synchronized void assertDeepEquals(Object expected,<br/>\nObject actual) {<br/>\n        logger.debug(&quot;assertDeepEquals called&quot;);<br/>\n        doAssertDeepEquals(null, expected, actual);<br/>\n        logger.debug(&quot;clearing &quot; + referenceCache.size() + &quot; objects<br/>\nfrom reference cache&quot;);        <br/>\n        referenceCache.clear();<br/>\n    }<br/>\n    <br/>\n    private static void doAssertDeepEquals(String name, Object<br/>\nexpected, Object actual) {<br/>\n        if (referenceAlreadyCached(expected)) {<br/>\n            logger.debug(&quot;cycle detected on &quot; + expected);<br/>\n            return;<br/>\n        }<br/>\n        <br/>\n        if (expected == null) {<br/>\n            assertNull(&quot;expected &quot; + name + &quot; was null, but actual was<br/>\nnot&quot;, actual);<br/>\n        } else if (expected != null) {<br/>\n            assertNotNull(&quot;expected &quot; + name + &quot; was not null, but<br/>\nactual was&quot;, actual);<br/>\n            <br/>\n            // both objects guaranteed not null from now on<br/>\n            if (isSimpleProperty(expected)) {            <br/>\n                evaluateSimpleProperty(name, expected, actual);<br/>\n            } else { <br/>\n                referenceCache.add(expected);<br/>\n                if (isArrayProperty(expected)) {                <br/>\n                    evaluateArrayProperty(name, (Object[])expected,<br/>\n(Object[])actual);            <br/>\n                } else if (isCollectionProperty(expected)) {            <br/>\n                    evaluateCollectionProperty(name,<br/>\n(Collection)expected, (Collection)actual);            <br/>\n                } else if (isMapProperty(expected)) {            <br/>\n                    evaluateMapProperty((Map)expected, (Map)actual); <br/>\n          <br/>\n                } else {<br/>\n                    evaluateComplexProperty(expected, actual);            <br/>\n                }                <br/>\n            }            <br/>\n        }        <br/>\n    }<br/>\n        <br/>\n    private static void evaluateSimpleProperty(String name, Object<br/>\nexpected, Object actual) {<br/>\n        logger.debug(name + &quot; [expected = &quot; + expected + &quot;, actual = &quot;<br/>\n+ actual + &quot;]&quot;);<br/>\n        assertEquals(name + &quot; not equal&quot;, expected, actual);        <br/>\n    }<br/>\n    <br/>\n    private static void evaluateArrayProperty(String name, Object[]<br/>\nexpected, Object[] actual) {        <br/>\n        if (expected.length != actual.length)<br/>\n            fail(&quot;not the same length&quot;);        <br/>\n        for (int i=0; i&lt;expected.length; i++)<br/>\n            doAssertDeepEquals(name + &quot;[&quot; + i + &quot;]&quot;, expected[i],<br/>\nactual[i]);<br/>\n    }<br/>\n    <br/>\n    private static void evaluateCollectionProperty(String name,<br/>\nCollection expected, Collection actual) {<br/>\n        evaluateArrayProperty(name, expected.toArray(), actual.toArray());<br/>\n    }<br/>\n    <br/>\n    /** TODO perform a deep comparison of each maps&#39; keys */<br/>\n    private static void evaluateMapProperty(Map expected, Map actual) {<br/>\n        Set keys = expected.keySet();<br/>\n        if (!keys.equals(actual.keySet()))<br/>\n            fail(&quot;dissimilar keys&quot;);<br/>\n        <br/>\n        for (Iterator i=keys.iterator(); i.hasNext();) {<br/>\n            Object key = i.next();<br/>\n            doAssertDeepEquals(key.toString(), expected.get(key),<br/>\nactual.get(key));<br/>\n        }<br/>\n    }<br/>\n    <br/>\n    private static void evaluateComplexProperty(Object expected,<br/>\nObject actual) {<br/>\n        Map expectedProps = null, actualProps = null;<br/>\n        try {<br/>\n            expectedProps = PropertyUtils.describe(expected);<br/>\n            actualProps = PropertyUtils.describe(actual);<br/>\n            // not to thrilled about this, better way??<br/>\n            expectedProps.remove(&quot;class&quot;);<br/>\n            actualProps.remove(&quot;class&quot;);<br/>\n        } catch (Exception ex) {<br/>\n            ex.printStackTrace();<br/>\n            logger.error(ex);<br/>\n        }<br/>\n        <br/>\n        evaluateMapProperty(expectedProps, actualProps);        <br/>\n    }<br/>\n    <br/>\n    private static boolean isSimpleProperty(Object o) {<br/>\n        return (<br/>\n        o instanceof CharSequence || <br/>\n        o instanceof Number || <br/>\n        o instanceof Boolean || <br/>\n        o instanceof Date || <br/>\n        o instanceof Character);        <br/>\n    }<br/>\n        <br/>\n    private static boolean isArrayProperty(Object o) {<br/>\n        return o.getClass().isArray();<br/>\n    }<br/>\n    <br/>\n    private static boolean isCollectionProperty(Object o) {<br/>\n        return (o instanceof Collection);<br/>\n    }<br/>\n    <br/>\n    private static boolean isMapProperty(Object o) {<br/>\n        return (o instanceof Map);<br/>\n    }<br/>\n    <br/>\n    private static boolean referenceAlreadyCached(Object o) {<br/>\n        for (int i=0, n=referenceCache.size(); i&lt;n; i++) {<br/>\n            if (o == referenceCache.get(i)) { <br/>\n                return true;            <br/>\n            }<br/>\n        }<br/>\n        return false;<br/>\n    }<br/>\n}</div>", 
    "prevInTime": 16889, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1149798776", 
    "canDelete": false, 
    "nextInTopic": 16896, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PGU2YTFobytyOWZvQGVHcm91cHMuY29tPg=="
    }
}