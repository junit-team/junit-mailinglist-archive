{
    "numMessagesInTopic": 4, 
    "nextInTime": 6923, 
    "senderId": "h5aDORah-fAtHgJRYNVi9yn_OdBBCw9BKRMAJ6FT4bgBKNGlP35jT9MHZbMWhweNjfxHqfXVIYX6HQmciRgq6oOAfTMTXDq8zQQOAexc", 
    "systemMessage": false, 
    "subject": "Re: [junit] Testable Interface / &quot;unit&quot; (?) testing", 
    "from": "Eric Armstrong &lt;eric.armstrong@...&gt;", 
    "authorName": "Eric Armstrong", 
    "msgSnippet": "... Heck of a thought. I would expect: a) The class structure would contain the test methods, but they wouldn t be loaded in the absence of a -test flag, or", 
    "msgId": 6922, 
    "profile": "ericsilverlight", 
    "topicId": 6922, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 78994084, 
    "messageBody": "<div id=\"ygrps-yiv-1380609103\">Scott Stirling wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; ....Some of my thinking has led to a similar thought, and a<br/>\n&gt; question: like Serializable, Runnable, Cloneable, etc. I have been<br/>\n&gt; toying with what a Testable interface could do.  What would it be like<br/>\n&gt; to idiomaticize Testability as a marker interface in Java?<br/>\n&gt;<br/>\n&gt; One idea is that &quot;implements Testable&quot; could mean that a runtime flag<br/>\n&gt; could be used to enable/disable a set of test methods (a la JUnit&#39;s<br/>\n&gt; test**** method naming pattern) in classes.  Just a thought.<br/>\n<br/>\n </span></blockquote>Heck of a thought.<br/>\n<br/>\nI would expect:<br/>\n   a) The class structure would contain the test methods, but they<br/>\n       wouldn&#39;t be loaded in the absence of a -test flag, or some such.<br/>\n<br/>\n   b) With the -test option present, a framework would exist to help you<br/>\n<br/>\n        experiment with the APIs, uncovering gaps in the documentation.<br/>\n        (If I give an empty string as an argument, do I get a null<br/>\nString, an<br/>\n         empty string, or an exception?)<br/>\n<br/>\n   c) API documentation would have a link to a page containing test<br/>\n       methods that would exist only if the class was testable.<br/>\n<br/>\nSuch a thing could be really cool, self-documenting addition to<br/>\nlibraries.<br/>\n<br/>\nInterestingly, in considering such a thing, I realize that the tests<br/>\nwill tend<br/>\nto be class-based, in such a scenario, rather than package-based. That<br/>\nbrings back some previous discussions about how tests should be more<br/>\noriented towards &quot;basic operations&quot; than &quot;class methods&quot;.<br/>\n<br/>\nAnd that thought brings back the famous game show line:<br/>\n    &quot;Will the real unit testing please stand up?&quot;<br/>\n<br/>\nWhat the heck *is* unit testing, anyway? If it is &quot;class methods&quot;, then<br/>\nJUnitDoclet made sense. But if it is &quot;basic operations&quot;, isn&#39;t that more<br/>\n<br/>\nlike integration testing? Or is there a middle ground, say, as package-<br/>\nlevel operations?<br/>\n<br/>\nRight now, I&#39;m seeing &quot;unit&quot; as one or more of:<br/>\n  * method<br/>\n  * class<br/>\n  * package<br/>\n  * use case<br/>\n<br/>\nAre there any other candidates? Are any of these automatically<br/>\nruled out? What exactly does the word &quot;unit&quot; mean, in this<br/>\ncontext?</div>", 
    "prevInTime": 6921, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1044833925", 
    "canDelete": false, 
    "nextInTopic": 6926, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PDNFNDZFNjg1LkQ4NzM0RUVFQHN1bi5jb20+", 
        "referencesHeader": "PEtJRUhJQklPQkFFTEpBSElQTkhETUVBQUNQQUEuc2NvdHRzdGlybGluZ0ByY24uY29tPg=="
    }
}