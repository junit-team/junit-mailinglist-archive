{
    "numMessagesInTopic": 13, 
    "nextInTime": 7023, 
    "senderId": "PaYJQId8dqbSuM6R4TnCG8CmrE6OZ8B9wiPN3uacJ8v3_XAwDAUiTQQavnt8tMFbVZgm0XKeimrUIQmbmv48DSeI7Qoy2ROjWG09kupA", 
    "systemMessage": false, 
    "subject": "Re: [junit] Re: one-time setup", 
    "from": "Eric Armstrong &lt;eric.armstrong@...&gt;", 
    "authorName": "Eric Armstrong", 
    "msgSnippet": "Hey, Bill. Glad to hear from you again. Long time since JavaOne and JavaWorld. It s good to know that I wasn t the only one confused by the overloading of the", 
    "msgId": 7022, 
    "profile": "ericsilverlight", 
    "topicId": 6946, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 78994084, 
    "messageBody": "<div id=\"ygrps-yiv-680601837\">Hey, Bill. Glad to hear from you again.<br/>\nLong time since JavaOne and JavaWorld.<br/>\n<br/>\nIt&#39;s good to know that I wasn&#39;t the only one confused by the<br/>\noverloading of the word &quot;test&quot;. My next major hurdle is getting<br/>\na good handle on the process of TDD -- the paradigm shift<br/>\nlooks as big as shyifting into O-O thinking. (I seem to be having<br/>\nas much trouble doing it, at least.)<br/>\n<br/>\nAltima looks pretty interesting. I like the separation of reporting<br/>\nfrom testing, and the runpath idea. The short summary doesn&#39;t<br/>\nreally tell me what a recipe file is good for, though. I guess I need<br/>\nto know more about the possible &quot;run properties of a particular<br/>\nsuite&quot;, and why I would want to use them.<br/>\n<br/>\nMost of all, I&#39;m looking forward to understanding more about<br/>\nhow it &quot;can help developers create unit and conformance tests&quot;.<br/>\n<br/>\n...And to understanding more about how to do TDD well in the<br/>\nfirst place.<br/>\n<br/>\nIt&#39;s funny, on my last project I had the sudden realization that<br/>\n&quot;document-driven design&quot; (requirements gathering, really) was<br/>\nthe right way to go. And it worked. It did a dynamite job of<br/>\ngathering the requirements and generating the program&#39;s user<br/>\nguide, in tandem with the design notes. So, even while the design<br/>\nwas evolving, I knew where I needed to go. (And as additional<br/>\nquestions came up, I had a place to record the answers.)<br/>\n<br/>\nThe interesting thing, though, is that while the process &quot;works&quot;,<br/>\nI would have a very difficult time describing *how* it works.<br/>\nTDD seems a lot like that. It&#39;s something that works well when<br/>\nyou really understand it, but something that at the same time<br/>\nappears to be very difficult to describe!<br/>\n<br/>\n&quot;billvenners &quot; wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;  Eric,<br/>\n&gt;<br/>\n&gt; &gt; Somehow, I was under the impression that each test<br/>\n&gt; &gt; in a test case started with a &quot;clean slate&quot; -- that the<br/>\n&gt; &gt; setup code was re-run for each test method.<br/>\n&gt; &gt;<br/>\n&gt; &gt; But that doesn&#39;t appear to be the case. The test object<br/>\n&gt; &gt; created during setup turned out to be reused for<br/>\n&gt; &gt; subsequent tests in the test case, which caused problems<br/>\n&gt; &gt; arising from old state, until I figured it out.<br/>\n&gt; &gt;<br/>\n&gt; &gt; Now, for performance, it only makes sense that a fixture<br/>\n&gt; &gt; would be reused for each test in a test case class. So I&#39;m<br/>\n&gt; &gt; not suggesting that the implementation is wrong.<br/>\n&gt; &gt;<br/>\n&gt; For a long time my impression was that an instance of TestCase is<br/>\n&gt; created, and all test methods are invoked on that same instance. The<br/>\n&gt; reason I thought this was that it seemed like the natural way to do<br/>\n&gt; it to me, plus it justified the existence of setUp. Given fixtures<br/>\n&gt; are usually instance data, a method like setUp is needed only if you<br/>\n&gt; are going to reuse the same instance on multiple test methods, and<br/>\n&gt; some of those test methods may destroy the fixture.<br/>\n&gt;<br/>\n&gt; While looking through JUnit&#39;s source code, I discovered that JUnit<br/>\n&gt; creates a new instance for each test method when it runs. So then I<br/>\n&gt; got to wondering what setUp was really there for, because if you are<br/>\n&gt; going to create a new TestCase instance for each test method, then<br/>\n&gt; you could use the constructor to initialized the fixture.<br/>\n&gt;<br/>\n&gt; Last year I created a testing toolkit similar to JUnit, Artima<br/>\n&gt; SuiteRunner, that also serves as a JUnit runner to run JUnit test<br/>\n&gt; suites. What I ended up doing in SuiteRunner was running all the test<br/>\n&gt; methods on the same Suite instance, calling setUpFixture and<br/>\n&gt; tearDownFixture before and after each test method. SuiteRunner is<br/>\n&gt; free and open source:<br/>\n&gt;<br/>\n&gt; <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.artima.com/suiterunner/\">http://www.artima.com/suiterunner/</a><br/>\n&gt;<br/>\n&gt; I&#39;m curious if anyone out there has some kind of dependency on<br/>\n&gt; JUnit&#39;s approach of creating a new TestCase instance for each test<br/>\n&gt; method.<br/>\n&gt;<br/>\n&gt; &gt; But I read the docs at the main site, and I&#39;ve been following<br/>\n&gt; &gt; these threads for quite a while, and still I had a dead-wrong<br/>\n&gt; &gt; impression of what&#39;s going on.<br/>\n&gt; &gt;<br/>\n&gt; &gt; For example, in the FAQ, q2 &quot;How do I use a text fixture?&quot;<br/>\n&gt; &gt; says:<br/>\n&gt; &gt;    &quot;Each test runs in its own test fixture to isolate tests from the<br/>\n&gt;<br/>\n&gt; &gt;    changes made by other tests. Because the tests are isolated,<br/>\n&gt; &gt;    they can be run in any order.... The JUnit framework<br/>\n&gt; &gt;    automatically invokes the setUp() method before each test is<br/>\n&gt; &gt;    run and the tearDown() method after each test is run.&quot;<br/>\n&gt; &gt;<br/>\n&gt; &gt; Now for &quot;test&quot;, I was reading &quot;test *method*&quot;. As in testX(),<br/>\n&gt; &gt; testY(). But my recent epiphany suggests that I should have<br/>\n&gt; &gt; been reading it as &quot;test *case*&quot;, as in &quot;test-case class&quot;. And<br/>\n&gt; &gt; since the example shows a single test case class, with multiple<br/>\n&gt; &gt; test methods in it, it was easy to make that assumption.<br/>\n&gt; &gt;<br/>\n&gt; &gt; Note:<br/>\n&gt; &gt; In general, I&#39;m not much fond of the name, &quot;TestCase&quot;, because<br/>\n&gt; &gt; to me that represents a single test. Since a TestCase class can<br/>\n&gt; &gt; actually have multiple test methods, the name &quot;TestFixture&quot; is<br/>\n&gt; &gt; probably more appropriate. But be that as it may...<br/>\n&gt; &gt;<br/>\n&gt; &gt; It appears to me that the word &quot;test&quot; is badly overloaded in the<br/>\n&gt; &gt; docs, meaning at various times, test method, test case, and<br/>\n&gt; &gt; potentially even test suite.<br/>\n&gt; &gt;<br/>\n&gt; &gt; The best way to eliminate confusion that I can see is to do a<br/>\n&gt; &gt; global search on &quot;test &quot;, and replace with one of the hyphenated<br/>\n&gt; &gt; words &quot;test-method&quot;, &quot;test-case&quot;, or &quot;test-suite&quot;, as appropriate.<br/>\n&gt;<br/>\n&gt; I too was confused by JUnit&#39;s overloading of the word test. There&#39;s a<br/>\n&gt; Test interface, and a both TestCase and a TestSuite implement Tests.<br/>\n&gt; So it looks conceptually like test cases and test suites are two<br/>\n&gt; kinds of tests. But test methods also seem to be tests. I wasn&#39;t sure<br/>\n&gt; what JUnit&#39;s notion of the concept of &quot;test&quot; was by looking at the<br/>\n&gt; API or reading the articles.<br/>\n&gt;<br/>\n&gt; One thing I tried hard to do in SuiteRunner was have a clearly but<br/>\n&gt; abstractly defined notion of &quot;test.&quot; The only place the word test<br/>\n&gt; shows up in the API is in testX, testY methods and 4 Reporter<br/>\n&gt; methods: testStarting, testSucceeded, testFailed, testAborted. A test<br/>\n&gt; method is one kind of conceptual test that can be reported via the 4<br/>\n&gt; Reporter methods, but not the only kind.<br/>\n&gt;<br/>\n&gt; I also tried to be clear about what a &quot;suite&quot; was. There&#39;s a class<br/>\n&gt; Suite that represents the concept of suite, which is simply a<br/>\n&gt; collection of conceptual tests. Typically people will subclass Suite<br/>\n&gt; and add test methods -- that&#39;s one kind of suite. But once again, it&#39;s<br/>\n&gt;<br/>\n&gt; not the only kind of Suite. I have a JUnitSuite internal to the<br/>\n&gt; package that I use to run JUnit test suites. That&#39;s another kind of<br/>\n&gt; conceptual suite that is represented by a sublcass of Suite.<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;                    Yahoo! Groups Sponsor<br/>\n </span></blockquote>                        ADVERTISEMENT<br/>\n<br/>\n<br/>\n<blockquote><span title=\"qreply\"> &gt;<br/>\n&gt; To unsubscribe from this group, send an email to:<br/>\n&gt; <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit-unsubscribe@yahoogroups.com\">junit-unsubscribe@yahoogroups.com</a><br/>\n&gt;<br/>\n&gt;<br/>\n&gt; Your use of Yahoo! Groups is subject to the Yahoo! Terms of Service. </span></blockquote></div>", 
    "prevInTime": 7021, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1045888892", 
    "canDelete": false, 
    "nextInTopic": 7024, 
    "prevInTopic": 7014, 
    "headers": {
        "messageIdInHeader": "PDNFNTZGRjdDLjQ3RTEzQTI5QHN1bi5jb20+", 
        "referencesHeader": "PGIzNjBubSt2cGxrQGVHcm91cHMuY29tPg=="
    }
}