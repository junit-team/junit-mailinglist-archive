{
    "numMessagesInTopic": 6, 
    "nextInTime": 4380, 
    "senderId": "uuNH-hlAIEIIy0OogbPVFoV_SdOYXpEtnc2y_1hIkix-N0PjQOuIJqI6JFf_l5Q5JM86jpPCiZkuUiqMDXOAg8dcC4t27Fxl", 
    "systemMessage": false, 
    "subject": "RE: [junit] Stack overflow crashes GUI test runners", 
    "from": "Theodore Norvell &lt;theo@...&gt;", 
    "authorName": "Theodore Norvell", 
    "msgSnippet": "... Nevertheless JUnit does a fine job of catching, logging, and recovering from the first stack overflow.  Presumably the stack is unwound as an exception", 
    "msgId": 4379, 
    "topicId": 4356, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 105165521, 
    "messageBody": "<div id=\"ygrps-yiv-1793412522\">On Thu, 14 Mar 2002, Scott Stirling wrote:<br/>\n<blockquote><span title=\"ireply\"> &gt; StackOverFlowError is a subclass of VirtualMachineError like<br/>\n&gt; OutOfMemoryError.  VMErrors aren&#39;t expected to be caught, though you<br/>\n&gt; always can if you really want to.  The irony being that if you catch a<br/>\n&gt; VirtualMachineError, there&#39;s a good chance you won&#39;t be able to do<br/>\n&gt; anything to recover from it.  That is, if you&#39;re out of memory and you<br/>\n&gt; catch that error, an attempt to clean up, log a message or whatever will<br/>\n&gt; likely require memory, which you don&#39;t have, so you&#39;ll just get another<br/>\n&gt; error.<br/>\n<br/>\n </span></blockquote>Nevertheless JUnit does a fine job of catching, logging, and recovering<br/>\nfrom the first stack overflow.  Presumably the stack is unwound as an<br/>\nexception handler is hunted for, freeing up stack space.  It is the<br/>\nsecond stack overflow in the same suite that causes the problem. If the<br/>\nsuite only has one error, then that suite can be run multiple times.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; The JVM should never crash though, in the sense of a core dump.  If it<br/>\n&gt; does, it&#39;s likely a JVM bug.<br/>\n<br/>\n </span></blockquote>Thanks for the suggestion. This turned out to be correct. The<br/>\nJVM in question is JDK 1.3.1 for Windows.  Turning off compilation<br/>\n(option -Xint) eliminated the problem, as did using jview; JUnit<br/>\ncorrectly reported both errors under those circumstances.<br/>\n<br/>\n<blockquote><span title=\"qreply\"> On Thu, 14 Mar 2002, Eric Heikkila wrote:<br/>\n&gt; Kind of sounds like a non-issue.  Fix the stack<br/>\n&gt; overflows. ;)<br/>\n<br/>\nIf I didn&#39;t have bugs, I wouldn&#39;t need JUnit. :-)<br/>\n<br/>\nMore seriously, using JUnit did reveal the bug; it just did so in the<br/>\nrather abrupt manner of crashing.  I&#39;d prefer to see a red-line and a<br/>\nmessage.  However, you are right, it is not an issue for me.  At first I<br/>\nthought that the problem might be in the custom implementation of the Test<br/>\ninterface that I was using to bridge between JUnit and a test framework I<br/>\nam developing.  Had that been the case, I would have had an issue.  Once I<br/>\nwas able to duplicate the problem with a standard TestCase, it was clear<br/>\nthat the problem wasn&#39;t in my code, and thus not a problem for me.<br/>\nHowever the strange behaviour did suggest a bug in JUnit, which might be<br/>\nan issue of interest to those who develop JUnit.  But I should have<br/>\nthought of the possibility that it was the JVM at fault.<br/>\n<br/>\nCheers,<br/>\nTheodore Norvell </span></blockquote></div>", 
    "prevInTime": 4378, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1016237285", 
    "canDelete": false, 
    "nextInTopic": 4380, 
    "prevInTopic": 4360, 
    "headers": {
        "inReplyToHeader": "PENCMUZGMEE0NzRBRUE4NEVBMDIwNkQ1QjA1RjZBNENCOUExRTk5QFMxMDAxRVhNMDIubWFjcm9tZWRpYS5jb20+", 
        "messageIdInHeader": "PFBpbmUuU09MLjQuNDQuMDIwMzE1MDgzNDU4MC4yMTMwNS0xMDAwMDBAY2FzY2FkZS5jcy51YmMuY2E+"
    }
}