{
    "topicId": 292, 
    "postDate": "980364125", 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "from": "jakob@...", 
    "canDelete": false, 
    "replyTo": "LIST", 
    "senderId": "AoAT3v7nljZzqJZou3NQ7Wm4aIn-o3g2KAKWQIkzHvzcvd1HkLGRWpupYue56G4kMVd9TxEbQw", 
    "nextInTime": 313, 
    "userId": 0, 
    "prevInTime": 311, 
    "prevInTopic": 311, 
    "headers": {
        "inReplyToHeader": "PDk0bW1tdit1YTh0QGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PDk0bmEwdCtoc3ZiQGVHcm91cHMuY29tPg=="
    }, 
    "authorName": "jakob@jenkov.com", 
    "numMessagesInTopic": 23, 
    "msgSnippet": "Hi Tony. I think some of the other guys already told you NOT to catch AssertionFailedErrors in your production code. One reason being that it s part of JUnit s", 
    "contentTrasformed": false, 
    "msgId": 312, 
    "nextInTopic": 317, 
    "systemMessage": false, 
    "rawEmail": "Return-Path: &lt;jakob@...&gt;\r\nX-Sender: jakob@...\r\nX-Apparently-To: junit@egroups.com\r\nReceived: (EGP: mail-7_0_1_2); 24 Jan 2001 19:35:16 -0000\r\nReceived: (qmail 64265 invoked from network); 24 Jan 2001 19:22:08 -0000\r\nReceived: from unknown (10.1.10.27) by m8.onelist.org with QMQP; 24 Jan 2001 19:22:08 -0000\r\nReceived: from unknown (HELO ho.egroups.com) (10.1.2.219) by mta2 with SMTP; 24 Jan 2001 19:22:07 -0000\r\nX-eGroups-Return: jakob@...\r\nReceived: from [10.1.4.67] by ho.egroups.com with NNFMP; 24 Jan 2001 19:22:07 -0000\r\nDate: Wed, 24 Jan 2001 19:22:05 -0000\r\nTo: junit@egroups.com\r\nSubject: Re: Programming By Contract\r\nMessage-ID: &lt;94na0t+hsvb@...&gt;\r\nIn-Reply-To: &lt;94mmmv+ua8t@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Length: 10426\r\nX-Mailer: eGroups Message Poster\r\nFrom: jakob@...\r\n\r\nHi Tony.\n\nI think some of the other guys already told you NOT to catch \nAssertionFailedErrors in your production code. One reason \nbeing that it&#39;s part of JUnit&#39;s framework, and to keep test code \nand production code separate, you shouldn&#39;t use the JUnit \nclasses in your production code. The fact that you keep \ninsisting on using the Assert class make me suspicious that\nyou might have misunderstood the use of the Assert class \n(not meant as an offence!). \n\nYou want to throw an exception when the INPUT of some method is\nwrong, but AssertionFailedException should be thrown \n(in a test case) when the CODE HANDLING THE INPUT is wrong, \nnot the input data itself!!! An AssertionFailedError should be\nthrown in a test case when a tested method, provided with some input\ndoesn&#39;t behaved like you expected it to. For instance, didn&#39;t\nwrite a line to the file when the string input was &quot;simple text&quot;\n(an error in your code), or didn&#39;t throw an exception as expected\nwhen supplied with a null parameter. So, your exception signal that\nsomething in your system, either input is invalid or some other \nsystem \n(fx. a database) doesn&#39;t work. AssertionFailedError signals that your\ncode code doesn&#39;t work! Your code is then wrong and should be fixed! \n\n\n&quot;Well, how do I catch the errors then, If I can&#39;t use Assert?&quot; \n\n\nI assume that what you are using the Assert class for is as a \nguard in a method, like below:\n\npublic void someMethod(String someParameter){\n\n    Assert.assertNotNull(someParameter);\n\n}\n\nThis way you will have an AssertionFailedError thrown if \nsomeParameter is null. BUT! This is a wrong way to use the\nAssert class!!! You should NEVER use the Assert class to\ncheck if some parameter is wrong or the like. Write your\nown methods to check that, and throw a meaningful Exception\ninstead if the parameters are wrong. That&#39;ll look like\nthis:\n\npublic void someMethod(String someParameter) throws someException{\n\n    if(someParameter == null) throw new someException(\n                    &quot;someParameter is not allowed to be null!!&quot;);\n\n}\n\n\n\n\n&quot;What&#39;s the difference?&quot;\n\nWell, when you test your code, your put in Assert.assertXXX\nmethods in your test cases. When NONE of these asserts in\nyour test cases fail any more, it means that your code works\nin respect to the asserts in the test case. In other words,\nyou don&#39;t need the assert statements anymore, since you\nhave already tested that your code can handle any correct as\nwell as incorrect parameters etc. (Of course you keep the\nasserts in the test cases in case you have to change something \nin code you test, so you need to run the test cases again).\nIn other, other words again, this means that the errors that\nyour asserts are checking for, cannot occur in the tested \ncode, otherwise the test would have failed. If you still \nthink the errors that your assert is checking for could\noccur in the code, your test cases aren&#39;t thorough enough. \nWrite some additional test cases that tests that these errors\ncannot occur (that your code is able to handle it).\n\n\n\nAlright, it&#39;s example time:\n\n\nA method myProductionMethod looks like this:\n\n\npublic void doProductionAction(String paramString, int paramInt){\n\n    doSubAction1(paramString);\n    doSubAction2(paramInt);\n}\n\n\nNow you find out that your whole system will become unstable if the\nmethod doSubAction1(paramString) is called with paramString being\nnull. What you have done (I think) is to use the Assert class\nto make sure that the paramString is not null when calling \ndoSubAction1,\nlike this:\n\n\npublic void doProductionAction(String paramString, int paramInt){\n\n    Assert.assertNotNull(paramString);\n    doSubAction1(paramString);\n    doSubAction2(paramInt);\n}\n\nAnd that&#39;s what&#39;s wrong! Don&#39;t use the Assert class here. Use a simple\nif-statement instead, or create method call \n\n  checkForNull(Object) throws NullPointerException\n\nto do the job instead. Otherwise you will end up with code that \ncatches\nonly AssertionFailedError&#39;s \n\nAn if-statement could look like below:\n\npublic void doProductionAction(String paramString, int paramInt) \n                                        throws \nNullParamStringException{\n\n    if(paramString == null) throw new \n        NullParamStringException(&quot;paramString is not allowed to be \nnull&quot;);\n\n    doSubAction1(paramString);\n    doSubAction2(paramInt);\n}\n\n\n&quot;Well, what IS the difference then?&quot;. \n\n\nGood question. The difference is mostly conceptual, (Don&#39;t mix \n&quot;buggy code&quot; signals with &quot;invalid input&quot; signals) and should become \nmore obvious when we start writing a test case for the above method:\n\n\npublic void testDoProductionAction() throws Exception{\n    MyProductionObject prodObj = new MyProductionObject();\n\n    prodObj.doProductionAction(&quot;validText&quot;, 3);\n\n}\n\n\nNow, if the doProductionAction method call fails on the given input \nabove,\na MyProductionException will be thrown, and it will be caught be the \nJUnit framework and displayed as a failure. Let&#39;s assume for now, that\ngiven the String &quot;validText&quot;, and the integer 3, the method will work \nfine.\nNow, how do you know if the doProductionAction method will behave \ncorrectly\nin case paramString is null? You add a test for it, as below:\n\n\npublic void testDoProductionAction() throws Exception{\n    MyProductionObject prodObj = new MyProductionObject();\n\n    prodObj.doProductionAction(&quot;validText&quot;, 3);\n\n    try{\n        prodObject.doProductionAction(null, 3);\n        \n        //it did NOT behave correctly, an Exception was NOT thrown\n        Assert.assert(&quot;doProductionAction should have thrown a &quot; + \n                      &quot;NullParamStringException, but didn&#39;t&quot;,   \nfalse);\n\n    }catch(NullParamStringException e){\n        //it behaved correctly, an Exception was thrown!\n    }\n\n}\n\n\nNow you have a test that proves that you doProductionAction method can\nhandle a null in paramString (if the test case succeeds!). This means,\nthat had you had a assertNotNull call in your production code, for \ninstance\nafter the if-statement, IT IS NOW NOT NECESSARY ANYMORE, since the \ntest\nhas proved that a null will NEVER pass the if-statement. Perfect! And,\nthe Assert class is used for what it is really intended for, namely \nsignalling to JUnit that a test case has failed, because your code \njust \ncouldn&#39;t handle the input!\n\n&quot;But I&#39;d think it was great to get exceptions thrown in my production\ncode that shows that my code is buggy! Self checking code, lovely!!!&quot;\n\nNo you don&#39;t. Think of all the extra catch(AssertionFailedErrors e) \nclauses you would have spread out through the production code? And how\ncan you be sure that an AssertionFailedError is thrown because the\ncode has a bug? It might as well be that it was the user that typed\nsomething wrong (e.g. that input data was invalid), right? \nWhich eventually means that you have no way\nof knowing if the AssertionFailedError was thrown because of invalid \ninput or because of a bug UNTIL you get to see the users input. Once\nyou have that, hurry up writing a test case with exactly that input\nwith some Assert.assertXXX method calls in it to check that your code\ndid actually behave correctly. If not, fix the code. DON&#39;T USE\nAssert.assertXXX IN PRODUCTION CODE! It signals a bug in your code\nbut you can&#39;t be sure it really is a bug.\n\n\n\n*** Conclusion: *********************\n\nExceptions thrown by any production method:  \n-------------------------------------------\nInput was wrong, method handled it correctly (possibly) by throwing \nan exception.\nThis exception could be caught, and the user redirected to an error \npage.\n\nOf course, this may also be a sign that your code is buggy, if the\ninput given was correct/valid, and an exception was still thrown. Add \na\ntest case to test that situation if you are in doubt.\n\n\nAssertionFailedError: \n-------------------------------------------\nYour code is buggy, and should be fixed!\n\n\n*************************************\n\n\nI&#39;ll continue the example for the sake of clarity. If you&#39;ve already\ngrasped it, skip it.\n\n\n-------------------------------------------------------------\n\nNow, let&#39;s assume that the doSubAction2 will fail terribly if called \nwith negative values... You need to add a check to the \ndoProductionAction \nmethod to make sure that negative values are rejected:\n\n\n\npublic void doProductionAction(String paramString, int paramInt) \n              throws NullParamStringException, \n                     NegativeParamIntException{\n\n    if(paramString == null) throw new \n        NullParamStringException(&quot;paramString is not allowed to be \nnull&quot;);\n\n    if(paramInt &lt; 0) throw new\n        NegativeParamIntException(&quot;paramInt is not allowed to be \nnegative&quot; + \n                        &quot;paramInt was &quot; + paramInt);\n        \n\n    doSubAction1(paramString);\n    doSubAction2(paramInt);\n}\n\n\nIn your test case you&#39;d have to test it like this (last in the test \nmethod):\n\npublic void testDoProductionAction() throws Exception{\n \n   MyProductionObject prodObj = new MyProductionObject();\n\n    prodObj.doProductionAction(&quot;validText&quot;, 3);\n\n    try{\n        prodObject.doProductionAction(null, 3);\n        \n        //it did NOT behave correctly, an Exception was NOT thrown\n        Assert.assert(&quot;doProductionAction should have thrown a &quot; + \n                      &quot;NullParamStringException, but didn&#39;t&quot;,   \nfalse);\n\n    }catch(NullParamStringException e){\n        //it behaved correctly, an Exception was thrown!\n    }\n\n\n    //TEST FOR NEGATIVE paramInt VALUES !!!\n\n\n    try{\n        prodObj.doProductionAction(&quot;validText&quot;, -5);\n\n        //it did NOT behave correctly, an Exception was NOT thrown\n        Assert.assert(&quot;doProductionAction should have thrown a &quot; + \n                      &quot;NegativeParamIntException, but didn&#39;t&quot;,   \nfalse);\n\n\n    }catch(NegativeParamIntException e){\n        //Correct behaviour, exception thrown\n    }\n\n\n\n... and then you can catch and handle these exceptions in your \nproduction code like this:\n\n\n\n    try{\n\n        prodObject.doProductionMethod(someParamString, someParamInt);\n\n    }catch(NullParamStringException e){\n\n        //redirect user to error page, saying that paramString should \nbe filled out.\n\n    }catch(NegativeParamIntException e)7\n        //redirect user to error page, saying that paramInt cannot be \nnegative.\n    }\n\n}\n----------------------------------------------------------------------\n----------------------\n\n\n\n\n\n...PHEEEEEW !!!!\n\n\nI hope this helped you out, otherwise I just wasted an hour typing \nnonsense ;-)\n\n\nGood Luck,\n\nJakob Jenkov\n\n\n\n", 
    "subject": "Re: Programming By Contract"
}