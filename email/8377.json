{
    "numMessagesInTopic": 16, 
    "nextInTime": 8378, 
    "senderId": "i4vlPJJ-ZhoMxHqyNY5MV6Vzc-YlXlbHwP3cciJpNjoPcNP0UzLJq4qS7cgX8SiABm5oYxBZ-psgww7RhzfGWUMDs1XEywLeYCidtfhgoQ", 
    "systemMessage": false, 
    "subject": "RE: [junit] Re: Fork each test method?", 
    "from": "&quot;J. B. Rainsberger&quot; &lt;jbrains@...&gt;", 
    "authorName": "J. B. Rainsberger", 
    "msgSnippet": "... I don t understand how what you said is different from what I said. How is create a new runtime instance different from create a new object , since an", 
    "msgId": 8377, 
    "profile": "nails762", 
    "topicId": 8358, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 127224993, 
    "messageBody": "<div id=\"ygrps-yiv-406873635\"><blockquote><span title=\"ireply\">&gt;So said Robert DiFalco on 2003-06-17 --------------------<br/>\n&gt;&gt;&gt; I would think that the easiest way to zero out all the<br/>\n&gt;&gt;&gt; caches is to create new cache objects. <br/>\n&gt;<br/>\n&gt;No, not really. I don&#39;t expect to be able to convince you but if you<br/>\n&gt;have caches, or thread pools, or whatever that &quot;are scoped to the<br/>\n&gt;runtime instance they were created in&quot;, the easiest and in fact the most<br/>\n&gt;correct way to reinitialize them is to create a new runtime instance.<br/>\n<br/>\n </span></blockquote>I don&#39;t understand how what you said is different from what I said.<br/>\n<br/>\nHow is &quot;create a new runtime instance&quot; different from &quot;create a new object&quot;, since an object is just a runtime instance of a class? There is some nuance in what you&#39;re saying that I can&#39;t see. If you have the energy, help me understand what that is.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;The saddest thing is that there is no reason in production to &quot;zero out<br/>\n&gt;all caches&quot;. Even having such a method indicates (to me) a design flaw.<br/>\n&gt;After all, I don&#39;t expect the value of an immutable object (say an<br/>\n&gt;Integer) to suddenly change during the life of that object. <br/>\n<br/>\n </span></blockquote>I&#39;m not sure what the former has to do with the latter. I agree with your statement. This is one motivation for keeping from my objects the details of whether they are collaborating with caches. In J2EE we may want to cache the result of a JNDI lookup. One way to do this is abstract away the lookup into a generic object factory. At test time, we use an in-memory object factory; at production time, we use an object factory backed by JNDI. Everyone wins.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt;&gt; If a class uses a cache, then that class should either<br/>\n&gt;&gt;&gt; accept the cache from the outside world or be unaware<br/>\n&gt;&gt;&gt; that it&#39;s using a cache at all.<br/>\n&gt;<br/>\n&gt;You are working too hard at this. <br/>\n<br/>\n </span></blockquote>I appreciate your concern. (Not sarcasm: it&#39;s nice to know that your goal is to help, and not just puff your chest. Many others are guilty of the latter.)<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;Things seem simpler to me. For<br/>\n&gt;example, from what you say I am going to assume that you never use<br/>\n&gt;string constants in your code. <br/>\n<br/>\n </span></blockquote>Well, I never do anything the same way all the time. Everything depends. In particular, I externalize strings when it makes sense, and I don&#39;t when it doesn&#39;t. I first have to see the pattern or be told by a customer that the data in question is volatile.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;There isn&#39;t that much of a difference. I<br/>\n&gt;suppose you use a decorator that caches strings and then you make a call<br/>\n&gt;on each access of the string (possibly looking in a map?) instead of<br/>\n&gt;simply caching the constant string reference as a static final? <br/>\n<br/>\n </span></blockquote>I don&#39;t see a need for that right now. It depends whether the string needs to change. If the string doesn&#39;t need to change, then I put it in the code until I see evidence that it needs to change.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Really,<br/>\n&gt;there is no difference between that and this:<br/>\n&gt;<br/>\n&gt;class Something<br/>\n&gt;{<br/>\n&gt;     private static final Identity FOO_CLASS_ID =<br/>\n&gt;ClassRegistry.identify( Foo.class );<br/>\n&gt;<br/>\n&gt;     ...<br/>\n&gt;}<br/>\n&gt;<br/>\n&gt;FOO_CLASS_ID is scoped to the runtime instance it was created in. <br/>\n<br/>\n </span></blockquote>I think this is the big difference. I have the tendency to build classes and interfaces that collaborate with one another and let the application context (or component runtime context, whatever it is) decide how to bind runtime objects to one another. So in my code there are relatively few cases where an object manages the lifecycle of other objects.<br/>\n<br/>\nIn particular, FOO_CLASS_ID would be a parameter to Something&#39;s constructor. If the production code wants to use a ClassRegistry to get FOO_CLASS_ID, then that&#39;s cool; but if Something only depends on having a FOO_CLASS_ID, then why should it care where the FOO_CLASS_ID came from? I don&#39;t see the benefit there.<br/>\n<br/>\nYou are saying, &quot;This is the simplest place to put that code.&quot; I disagree. It&#39;s the easiest, but not necessarily the simplest. What if the application doesn&#39;t want Something to identify Foo.class as the means of getting a FOO_CLASS_ID? What if the application needs to provide that data?<br/>\n<br/>\nOf course, I can take my own advice and deal with that when it happens, but I practice TDD, and in so doing, would tend not to write the code you&#39;ve written there. No value judgment: just a difference in approach.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;It is<br/>\n&gt;immutable for the life of the runtime. These may be generated by a<br/>\n&gt;database, created by a synchronized static int, GUID generator or<br/>\n&gt;whatever. It doesn&#39;t really matter. The contract is that they are good<br/>\n&gt;for the life of the Runtime. So it makes sense to hide them just as you<br/>\n&gt;would any other immutable constant -- say a string. The only reason to<br/>\n&gt;impose a hash look up on every access is, well, I dunno. For testing?<br/>\n<br/>\n </span></blockquote>First, don&#39;t underestimate the importance of testing. Testing is damn important.<br/>\n<br/>\nYou want to Something to hide the way it gets a FOO_CLASS_ID because all that matters is the value: once Something gets the FOO_CLASS_ID, it doesn&#39;t matter how it did that. I can&#39;t argue with that. If the system only says this once, then it matters less where the system says it.<br/>\n<br/>\nHowever, I claim that by splitting Something into Something and FooClassIdFactory, I can add only a little complexity but gain the real benefit of making Something easier to test. Here is how I would do it.<br/>\n<br/>\nclass Something<br/>\n    Something()<br/>\n        this(ClassRegistry.identify(Foo.class))<br/>\n<br/>\n    Something(identity)<br/>\n        // store in instance-level variable<br/>\n<br/>\nThe default behavior of Something is to use the ClassRegistry to create FOO_CLASS_ID, but in my tests, I can just provide whatever data is easiest for the tests to provide.<br/>\n<br/>\nThis is an extremely small amount of complexity to add to gain the benefit of testing. Of course, if you don&#39;t value testing the same way I do, then you won&#39;t be moved by this. That&#39;s fine: do as you find best, as will I.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;Now, if you suddenly invalidate those identities or flush the<br/>\n&gt;ClassRegistry, you are in deep trouble. What is the simplest solution?<br/>\n&gt;&quot;Don&#39;t do that.&quot; What is the most complicated solution? &quot;Create a bunch<br/>\n&gt;of rigging that has no value save for unit tests that are unable to<br/>\n&gt;create new runtime instances on each run.&quot; Think about it. Details and<br/>\n&gt;Abstraction are one thing, this is another.<br/>\n<br/>\n </span></blockquote>You&#39;re right. This is another. This is straightforward separation of responsibilities. Something just needs an Identity. It shouldn&#39;t much matter where the Identity comes from. For that reason, Something should be willing to take whatever Identity I give it, if I want to give it one; otherwise, it can use the one it wants to use.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;For me, there is nothing<br/>\n&gt;worse than seeing designs that are overly complicated (obfuscated in<br/>\n&gt;fact) for no other reason than to serve a principle. Liskov<br/>\n&gt;Substitution, Law of Demeter, Coupling and Cohesion, Shunts, Mock<br/>\n&gt;Objects, Decorators....these are all good and wonderful things.  All<br/>\n&gt;important tools. However, they are capable of improving code or making<br/>\n&gt;code horribly obfuscated and ugly. At this point in its evolution,<br/>\n&gt;programming is much more like music than science. You can kill the feel<br/>\n&gt;of the code by being too pedantic.<br/>\n<br/>\n </span></blockquote>No argument here: I am guilty of using good tools to build bad ashtrays. We all are. We have to take care, though, not to become neo-Luddites, deciding that the tools are the reason we built bad ashtrays. That was us. We should practise with the tools.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;Google &quot;Simplicity&quot;.<br/>\n<br/>\n </span></blockquote>Sometimes people mistake simplicitly and ease. I&#39;m not saying that you&#39;re doing it, but it happens. Here is how my code tends to evolve.<br/>\n<br/>\n1. Implement a few hardcoded concrete cases.<br/>\n2. Identify the abstractions by looking at common code.<br/>\n3. Extract the abstractions into behavioral classes; push the difference into data classes.<br/>\n4. Decide whether to move the values of the data classes outside the system into data files of some sort.<br/>\nRinse and repeat, as needed.<br/>\n<br/>\nThe result is a bunch of collaborating engines and, surprisingly, less code. Also increased flexibility without obscene complexity. (Some complexity, yes; but then a system without complexity may not do much of anything useful.) I don&#39;t think that&#39;s being &quot;pedantic&quot;. When I feel that the code is becoming too complex, I have to step back away from the keyboard and think a little. I have to throw away what I&#39;ve done and try again. The result is usually better. Sometimes banging out a silly solution is a good tool to finding a better one.<br/>\n<br/>\nTake care.<br/>\n<br/>\n<br/>\nJ. B. Rainsberger,<br/>\nPresident, Diaspar Software Services<br/>\nLet&#39;s write software that people understand.<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.diasparsoftware.com/\">http://www.diasparsoftware.com/</a><br/>\ntelephone: +1 416 791-8603</div>", 
    "prevInTime": 8376, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1055894171", 
    "canDelete": false, 
    "nextInTopic": 8378, 
    "prevInTopic": 8376, 
    "headers": {
        "inReplyToHeader": "PENGRERFQjNCODcwRUUzNDZCQjU4M0QyQjA0MjBGNUFDM0I5NDkxQHNlYWJhc3MudHJpcHdpcmUuY29tPg==", 
        "messageIdInHeader": "PDIwMDMwNjE3MTk1NjExMDU5MC4wMEI3RTZERUBzc210cC5ibG9vci5pcy5uZXQuY2FibGUucm9nZXJzLmNvbT4=", 
        "referencesHeader": "PENGRERFQjNCODcwRUUzNDZCQjU4M0QyQjA0MjBGNUFDM0I5NDkxQHNlYWJhc3MudHJpcHdpcmUuY29tPg=="
    }
}