{
    "numMessagesInTopic": 7, 
    "nextInTime": 21586, 
    "senderId": "9m6EAyxaaO6V2bBbqXEdXT6Zma1LSxFDgos5_DmwRNsa5pnQIBXtvhfOaEWhO1egj2s_TgcAi0HAq2gK_n7-LX_a", 
    "systemMessage": false, 
    "subject": "Re: [junit] Non-static inner classes of test classes using enclosing \tfixtures?", 
    "from": "David Saff &lt;david@...&gt;", 
    "authorName": "David Saff", 
    "msgSnippet": "Paul, Have you looked at Theory support in JUnit  4.4?  It may not give you everything you want, but I d be curious to know how close it gets. Thanks, David", 
    "msgId": 21585, 
    "rawEmail": "Return-Path: &lt;david.saff@...&gt;\r\nX-Sender: david.saff@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nX-Received: (qmail 98960 invoked from network); 11 May 2009 15:07:11 -0000\r\nX-Received: from unknown (69.147.108.201)\n  by m1.grp.sp2.yahoo.com with QMQP; 11 May 2009 15:07:11 -0000\r\nX-Received: from unknown (HELO mail-fx0-f163.google.com) (209.85.220.163)\n  by mta2.grp.re1.yahoo.com with SMTP; 11 May 2009 15:07:10 -0000\r\nX-Received: by fxm7 with SMTP id 7so2709093fxm.39\n        for &lt;junit@yahoogroups.com&gt;; Mon, 11 May 2009 08:06:00 -0700 (PDT)\r\nMIME-Version: 1.0\r\nX-Received: by 10.239.181.16 with SMTP id k16mr568985hbg.3.1242054360755; Mon, \n\t11 May 2009 08:06:00 -0700 (PDT)\r\nIn-Reply-To: &lt;gu4f1m+kbpf@...&gt;\r\nReferences: &lt;gu4f1m+kbpf@...&gt;\r\nDate: Mon, 11 May 2009 11:06:00 -0400\r\nX-Google-Sender-Auth: 2a28a6b9aad39323\r\nMessage-ID: &lt;4f7da6b90905110806q14c881e3vb7e1defea8cc0c62@...&gt;\r\nTo: junit@yahoogroups.com\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Transfer-Encoding: quoted-printable\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: David Saff &lt;david@...&gt;\r\nSubject: Re: [junit] Non-static inner classes of test classes using enclosing \n\tfixtures?\r\nX-Yahoo-Group-Post: member; u=341876227; y=j8-LqZfNTc2OqQuObIOE0aIi2sRK88SiZmNCup2ftKE\r\nX-Yahoo-Profile: dsaff\r\n\r\nPaul,\n\nHave you looked at Theory support in JUnit &gt; 4.4?  It may not give y=\r\nou\neverything you want, but I&#39;d be curious to know how close it gets.\nThank=\r\ns,\n\n   David\n\nOn Sat, May 9, 2009 at 1:37 PM, Paul Holser &lt;pholser@...=\r\nm&gt; wrote:\n&gt; Hello JUnit,\n&gt;\n&gt; I have some abstract classes that enable a cal=\r\nler to check that classes which expose collection fields via accessor metho=\r\nds do so via the java.util.Collections#unmodifiable___() facilities. =A0Her=\r\ne are some snippets:\n&gt;\n&gt; public abstract class UnmodifiableCollectionTestSu=\r\npport&lt;T&gt; {\n&gt; =A0 =A0protected Collection&lt;T&gt; items;\n&gt; =A0 =A0private T conta=\r\ninedItem;\n&gt;\n&gt; =A0 =A0@Before\n&gt; =A0 =A0public final void initializeHarness()=\r\n {\n&gt; =A0 =A0 =A0 =A0this.items =3D newCollection();\n&gt; =A0 =A0 =A0 =A0this.c=\r\nontainedItem =3D containedItem();\n&gt;\n&gt; =A0 =A0 =A0 =A0assertFalse(&quot;need a no=\r\nn-empty collection&quot;, items.isEmpty());\n&gt; =A0 =A0 =A0 =A0assertTrue(&quot;need an=\r\n item that is in the collection&quot;, items.contains(containedItem));\n&gt; =A0 =A0=\r\n}\n&gt;\n&gt; =A0 =A0@Test(expected =3D UnsupportedOperationException.class)\n&gt; =A0 =\r\n=A0public final void shouldPreventAdd() {\n&gt; =A0 =A0 =A0 =A0// ...\n&gt; =A0 =A0=\r\n}\n&gt;\n&gt; =A0 =A0// etc...\n&gt;\n&gt; =A0 =A0protected abstract Collection&lt;T&gt; newColle=\r\nction();\n&gt;\n&gt; =A0 =A0protected abstract T newItem();\n&gt;\n&gt; =A0 =A0protected ab=\r\nstract T containedItem();\n&gt; }\n&gt;\n&gt; public abstract class UnmodifiableListTes=\r\ntSupport&lt;T&gt; extends UnmodifiableCollectionTestSupport&lt;T&gt; {\n&gt; =A0 =A0@Test(e=\r\nxpected =3D UnsupportedOperationException.class)\n&gt; =A0 =A0public final void=\r\n shouldPreventAddAtIndex() {\n&gt; =A0 =A0 =A0 =A0// ...\n&gt; =A0 =A0}\n&gt;\n&gt; =A0 =A0=\r\n// etc...\n&gt;\n&gt; =A0 =A0protected final Collection&lt;T&gt; newCollection() {\n&gt; =A0 =\r\n=A0 =A0 =A0return newList();\n&gt; =A0 =A0}\n&gt;\n&gt; =A0 =A0protected abstract List&lt;=\r\nT&gt; newList();\n&gt;\n&gt; =A0 =A0private List&lt;T&gt; list() {\n&gt; =A0 =A0 =A0 =A0return (=\r\nList&lt;T&gt;) items;\n&gt; =A0 =A0}\n&gt; }\n&gt;\n&gt; public class UnmodifiableListTest extend=\r\ns UnmodifiableListTestSupport&lt;String&gt; {\n&gt; =A0 =A0@Override\n&gt; =A0 =A0protect=\r\ned List&lt;String&gt; newList() {\n&gt; =A0 =A0 =A0 =A0return unmodifiableList(asList=\r\n(&quot;foo&quot;));\n&gt; =A0 =A0}\n&gt;\n&gt; =A0 =A0protected String newItem() {\n&gt; =A0 =A0 =A0 =\r\n=A0return &quot;bar&quot;;\n&gt; =A0 =A0}\n&gt;\n&gt; =A0 =A0protected String containedItem() {\n&gt;=\r\n =A0 =A0 =A0 =A0return &quot;foo&quot;;\n&gt; =A0 =A0}\n&gt; }\n&gt;\n&gt; I am imagining an Unmodifi=\r\nableMapTestSupport abstract class to do similar tests for unmodifiable maps=\r\n:\n&gt;\n&gt; public abstract class UnmodifiableMapTestSupport&lt;K, V&gt; {\n&gt; =A0 =A0pri=\r\nvate Map&lt;K, V&gt; entries;\n&gt; =A0 =A0private K containedKey;\n&gt; =A0 =A0private V=\r\n containedValue;\n&gt;\n&gt; =A0 =A0@Before\n&gt; =A0 =A0public final void initializeHa=\r\nrness() {\n&gt; =A0 =A0 =A0 =A0this.entries =3D newMap();\n&gt; =A0 =A0 =A0 =A0this=\r\n.containedKey =3D containedKey();\n&gt; =A0 =A0 =A0 =A0this.containedValue =3D =\r\ncontainedValue();\n&gt;\n&gt; =A0 =A0 =A0 =A0assertFalse(&quot;need a non-empty map&quot;, en=\r\ntries.isEmpty());\n&gt; =A0 =A0 =A0 =A0assertTrue(&quot;need a key that is in the ma=\r\np&quot;, entries.containsKey(containedKey));\n&gt; =A0 =A0 =A0 =A0assertTrue(&quot;need a=\r\n value that is in the map&quot;, entries.containsValue(containedValue));\n&gt; =A0 =\r\n=A0}\n&gt;\n&gt; =A0 =A0@Test(expected =3D UnsupportedOperationException.class)\n&gt; =\r\n=A0 =A0public final void shouldPreventPut() {\n&gt; =A0 =A0 =A0 =A0// ...\n&gt; =A0=\r\n =A0}\n&gt;\n&gt; =A0 =A0protected abstract Map&lt;K, V&gt; newMap();\n&gt;\n&gt; =A0 =A0protecte=\r\nd abstract K newKey();\n&gt;\n&gt; =A0 =A0protected abstract K containedKey();\n&gt;\n&gt; =\r\n=A0 =A0protected abstract V containedValue();\n&gt; }\n&gt;\n&gt; Not just would I like=\r\n to test that a map cannot be modified via its Map methods, but also I woul=\r\nd like to test that the map cannot be mutated via the keySet(), values(), a=\r\nnd entrySet() views. =A0It would be really nice if, when someone subclasses=\r\n UnmodifiableMapTestSupport, they could get an Un modifiableCollectionTestS=\r\nupport&lt;K&gt;, UnmodifiableCollectionTestSupport&lt;V&gt;, and an UnmodifiableCollect=\r\nionTestSupport&lt;Map.Entry&lt;K, V&gt;&gt; instantiated, run, and result reported on f=\r\nor the keySet(), values(), and entrySet() views of the newMap() result. =A0=\r\nOtherwise, they would have to hand-roll three more concretes of Unmodifiabl=\r\neCollectionTestSupport for testing the keySet(), values(), and entrySet() v=\r\niews of a given map.\n&gt;\n&gt; It occurred to me that inner classes of Unmodifiab=\r\nleMapTestSupport would be handy:\n&gt;\n&gt; public abstract class UnmodifiableMapT=\r\nestSupport&lt;K, V&gt; {\n&gt; =A0 =A0// ...\n&gt;\n&gt; =A0 =A0@Ignore\n&gt; =A0 =A0class KeySet=\r\nTest extends UnmodifiableCollectionTestSupport&lt;K&gt; {\n&gt; =A0 =A0 =A0 =A0protec=\r\nted K containedItem() {\n&gt; =A0 =A0 =A0 =A0 =A0 =A0return containedKey;\n&gt; =A0=\r\n =A0 =A0 =A0}\n&gt;\n&gt; =A0 =A0 =A0 =A0protected Collection&lt;K&gt; newCollection() {\n=\r\n&gt; =A0 =A0 =A0 =A0 =A0 =A0return entries.keySet();\n&gt; =A0 =A0 =A0 =A0}\n&gt;\n&gt; =\r\n=A0 =A0 =A0 =A0protected K newItem() {\n&gt; =A0 =A0 =A0 =A0 =A0 =A0return newK=\r\ney();\n&gt; =A0 =A0 =A0 =A0}\n&gt; =A0 =A0}\n&gt;\n&gt; =A0 =A0@Ignore\n&gt; =A0 =A0class Value=\r\nsTest extends UnmodifiableCollectionTestSupport&lt;V&gt; {\n&gt; =A0 =A0 =A0 =A0prote=\r\ncted V containedItem() {\n&gt; =A0 =A0 =A0 =A0 =A0 =A0return containedValue;\n&gt; =\r\n=A0 =A0 =A0 =A0}\n&gt;\n&gt; =A0 =A0 =A0 =A0protected Collection&lt;V&gt; newCollection()=\r\n {\n&gt; =A0 =A0 =A0 =A0 =A0 =A0return entries.values();\n&gt; =A0 =A0 =A0 =A0}\n&gt;\n&gt;=\r\n =A0 =A0 =A0 =A0protected V newItem() {\n&gt; =A0 =A0 =A0 =A0 =A0 =A0return nul=\r\nl;\n&gt; =A0 =A0 =A0 =A0}\n&gt; =A0 =A0}\n&gt;\n&gt; =A0 =A0@Ignore\n&gt; =A0 =A0class EntriesT=\r\nest extends UnmodifiableCollectionTestSupport&lt;Map.Entry&lt;K, V&gt;&gt; {\n&gt; =A0 =A0 =\r\n=A0 =A0protected Entry&lt;K, V&gt; containedItem() {\n&gt; =A0 =A0 =A0 =A0 =A0 =A0ret=\r\nurn new Map.Entry&lt;K, V&gt;() {\n&gt; =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0public K getKe=\r\ny() {\n&gt; =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0return containedKey;\n&gt; =A0 =\r\n=A0 =A0 =A0 =A0 =A0 =A0 =A0}\n&gt;\n&gt; =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0public V ge=\r\ntValue() {\n&gt; =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0return containedValue;\n=\r\n&gt; =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0}\n&gt;\n&gt; =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0publi=\r\nc V setValue(V value) {\n&gt; =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0throw new =\r\nUnsupportedOperationException();\n&gt; =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0}\n&gt;\n&gt; =A0=\r\n =A0 =A0 =A0 =A0 =A0 =A0 =A0public boolean equals(Object that) {\n&gt; =A0 =A0 =\r\n=A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0if (!(that instanceof Map.Entry&lt;?, ?&gt;))\n&gt; =\r\n=A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0return false;\n&gt;\n&gt; =A0 =A0 =\r\n=A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0Map.Entry&lt;?, ?&gt; other =3D (Map.Entry) that;\n=\r\n&gt; =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0return ObjectUtils.equals(getKey()=\r\n, other.getKey())\n&gt; =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0&& Objec=\r\ntUtils.equals(getValue(), other.getValue());\n&gt; =A0 =A0 =A0 =A0 =A0 =A0 =A0 =\r\n=A0}\n&gt;\n&gt; =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0public int hashCode() {\n&gt; =A0 =A0 =\r\n=A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0return ObjectUtils.hashCode(getKey()) ^ Obje=\r\nctUtils.hashCode(getValue());\n&gt; =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0}\n&gt; =A0 =A0 =\r\n=A0 =A0 =A0 =A0};\n&gt; =A0 =A0 =A0 =A0}\n&gt;\n&gt; =A0 =A0 =A0 =A0protected Collectio=\r\nn&lt;Entry&lt;K, V&gt;&gt; newCollection() {\n&gt; =A0 =A0 =A0 =A0 =A0 =A0return entries.en=\r\ntrySet();\n&gt; =A0 =A0 =A0 =A0}\n&gt;\n&gt; =A0 =A0 =A0 =A0protected Entry&lt;K, V&gt; newIt=\r\nem() {\n&gt; =A0 =A0 =A0 =A0 =A0 =A0return null;\n&gt; =A0 =A0 =A0 =A0}\n&gt; =A0 =A0}\n=\r\n&gt; }\n&gt;\n&gt; The inner classes are not static, and are @Ignore&#39;d so that the run=\r\nner doesn&#39;t report instantiation problems (non-static inner classes don&#39;t g=\r\net a zero-arg ctor, which the default runner requires). =A0I could have, sa=\r\ny, runAll() methods on each of these inner classes, and then have @Test met=\r\nhods on UnmodifiableMapTestSupport that instantiate one of the inner classe=\r\ns and call any @Befores followed by runAll() followed by any @After on them=\r\n. =A0But then, runAll() would have to be smart enough to run all the tests,=\r\n including not bailing out at the first UnsupportedOperationException. =A0A=\r\nlso, the results of running those tests would not get reported along with t=\r\nhe @Test methods of UnmodifiableMapTestSupport.\n&gt;\n&gt; Is there a cleaner way =\r\nto accomplish my goal? =A0Maybe using a special kind of Runner? =A0Am I mis=\r\nsing a more obvious solution?\n&gt;\n&gt; Thanks much.\n&gt;\n&gt; Paul Holser\n&gt;\n&gt;\n&gt;\n&gt;\n&gt; --=\r\n----------------------------------\n&gt;\n&gt; Yahoo! Groups Links\n&gt;\n&gt;\n&gt;\n&gt;\n\n", 
    "profile": "dsaff", 
    "topicId": 21578, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 341876227, 
    "prevInTime": 21584, 
    "contentTrasformed": false, 
    "postDate": "1242054360", 
    "canDelete": false, 
    "nextInTopic": 21587, 
    "prevInTopic": 21578, 
    "headers": {
        "inReplyToHeader": "PGd1NGYxbStrYnBmQGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PDRmN2RhNmI5MDkwNTExMDgwNnExNGM4ODFlM3ZiN2UxZGVmZWE4Y2MwYzYyQG1haWwuZ21haWwuY29tPg==", 
        "referencesHeader": "PGd1NGYxbStrYnBmQGVHcm91cHMuY29tPg=="
    }
}