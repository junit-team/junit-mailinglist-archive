{
    "numMessagesInTopic": 31, 
    "nextInTime": 8096, 
    "senderId": "vtRd3lsOqgI-iXXd0vzFu0iVSph2jRSW1Ht4Keh76RrFEFy6s9ASI0uYskCHE-yVrxGJv14jqHD9EAKE-mKJJ8WcCF5v", 
    "systemMessage": false, 
    "subject": "Re: [junit] OT: final", 
    "from": "Eric Vought &lt;evought@...&gt;", 
    "authorName": "Eric Vought", 
    "msgSnippet": "Just to step back in this thread a bit and perhaps bring it nearer to on-topic. ... There are a number of places where I think the use of final makes for ", 
    "msgId": 8095, 
    "rawEmail": "Return-Path: &lt;evought@...&gt;\r\nX-Sender: evought@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (EGP: mail-8_2_6_6); 16 May 2003 23:14:55 -0000\r\nReceived: (qmail 92942 invoked from network); 16 May 2003 23:14:54 -0000\r\nReceived: from unknown (66.218.66.218)\n  by m13.grp.scd.yahoo.com with QMQP; 16 May 2003 23:14:54 -0000\r\nReceived: from unknown (HELO cypress.he.net) (216.218.197.2)\n  by mta3.grp.scd.yahoo.com with SMTP; 16 May 2003 23:14:53 -0000\r\nReceived: from qlue.com (rdu26-238-035.nc.rr.com [66.26.238.35]) by cypress.he.net (8.8.6p2003-03-31/8.8.2) with ESMTP id QAA27410 for &lt;junit@yahoogroups.com&gt;; Fri, 16 May 2003 16:14:53 -0700\r\nDate: Fri, 16 May 2003 15:42:24 -0400\r\nSubject: Re: [junit] OT: final\r\nContent-Type: text/plain; charset=US-ASCII; format=flowed\r\nMime-Version: 1.0 (Apple Message framework v552)\r\nTo: junit@yahoogroups.com\r\nContent-Transfer-Encoding: 7bit\r\nIn-Reply-To: &lt;200305091307240696.009F7582@...&gt;\r\nMessage-Id: &lt;844CC0C1-87D6-11D7-8AF6-000393C30ECE@...&gt;\r\nX-Mailer: Apple Mail (2.552)\r\nFrom: Eric Vought &lt;evought@...&gt;\r\nX-Yahoo-Group-Post: member; u=77258944\r\nX-Yahoo-Profile: eric_vought\r\n\r\nJust to step back in this thread a bit and perhaps bring it nearer to \non-topic.\n\n\nOn Friday, May 9, 2003, at 13:07 US/Eastern, J. B. Rainsberger wrote:\n\n&gt; I need to re-read this when I have more time. Still, I find that \n&gt; treating most object references as immutable makes for better code. \n&gt; Again, I can&#39;t adequately express why, but I feel it.\n&gt;\nThere are a number of places where I think the use of final makes for \nbetter code and either reduces the number of unit tests necessary or \nmakes it possible to test certain conditions that would otherwise not. \nI agree that the use of final for performance reasons is seldom \neffective and often overused.\n\nOne particular use is cleaning up and solidifying the number/type of \ninterfaces a class presents:\n\nAll extensible subclasses have two distinct interfaces. They present \none interface to outside callers and one to subclasses. Thorough \ntesting requires testing both interface and making sure that a subclass \nis not able to violate the base class contracts. One uses private \nfields/methods and final to enforce this.\n\nOne rule of thumb I have found quite useful is that only abstract \nclasses should be extended. Providing an API to a subclass can be a \ncomplex thing which should not be done by accident. Following this rule \nmeans that each class has only one API; they may either be subclassed \nor instantiated but not both. Often, when one wants to subclass a \nconcrete type, one is changing behavior that is specified in the \nconcrete base class and the subclass is not really a type-of the \nsuperclass. Instead, there is an abstract class where that behavior is \nleft unspecified from which both classes inherit. This is often \npainfully obvious when one goes back to the base class to update \ntests/documentation/contracts to test/demonstrate its use in the \nsuperclass. Unfortunately, this is seldom ever done. Declaring concrete \nclasses final pushes one in the direction of doing appropriate \nrefactoring instead of blind subclassing as well as appropriately \ntesting the APIs of the classes one really wants to be extensible.\n\nGiven an abstract baseclass, using private and final liberally \ndocuments and enforces the ways that a class may be safely extended. As \na simple example, it is very common to have a method like this:\n\n/** Opens a connection. Override this in a subclass and call the base \nclass method\n   * before doing your own initialization. */\npublic void openConnection()\n{\n\t// initialize data stored in the base class\n}\n\n// in subclass:\npublic void openConnection()\n{\n     inherited::openConnection();\n     // do my own thing\n}\n\nThe problem with this is that it is very easy to screw this up in the \nsubclass. One my forget to override the method (since it is not \nabstract), one may not call the superclass method, or one may call the \nsuperclass method at the wrong time. A quick test case can create a \nsubclass which violates any number of parent contracts. A safer way is \nto combine an abstract method and a final one to enforce the proper \ncontract:\n\n// in baseclass:\n\npublic final void openConnection()\n{\n     // Do base class stuff\n\n     // Call subclass method to do subclass stuff\n     i_openConnection()\n\n     // Do more base class stuff\n}\n\nprotected abstract void i_openConnection();\n\nNow the subclass *must* override i_openConnection(), since it is \nabstract. The subclass can no longer prevent the base class code from \nbeing run at the appropriate time. The parent class cannot be gotten \naround because openConnection() is final. Now testcases can be written \nto make sure that subclasses obey the parent&#39;s contracts.\n\nOne can take the stand that methods in abstract classes should either \nbe protected/abstract, private or final. I seldom go quite that far, \nbut it is a useful point of view.\n\n\n", 
    "profile": "eric_vought", 
    "topicId": 7948, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 77258944, 
    "prevInTime": 8094, 
    "contentTrasformed": false, 
    "postDate": "1053114144", 
    "canDelete": false, 
    "nextInTopic": 8097, 
    "prevInTopic": 8025, 
    "headers": {
        "inReplyToHeader": "PDIwMDMwNTA5MTMwNzI0MDY5Ni4wMDlGNzU4MkBzc210cC5ibG9vci5pcy5uZXQuY2FibGUucm9nZXJzLmNvbT4=", 
        "messageIdInHeader": "PDg0NENDMEMxLTg3RDYtMTFENy04QUY2LTAwMDM5M0MzMEVDRUBxbHVlLmNvbT4="
    }
}