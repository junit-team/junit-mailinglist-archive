{
    "numMessagesInTopic": 11, 
    "nextInTime": 16893, 
    "senderId": "0NXjY3YpB0K5rvVbYTpqZ3EqQFLC7fz15XGEs3APItsKHfMrGC2ApIgnK33chRyrUqfe4PlzKhmK01omfpp4pSG_JrgThwFCLOrblrZwPdIk", 
    "systemMessage": true, 
    "subject": "Re: [junit] @Ignore with a time", 
    "from": "&quot;Brett L. Schuchert&quot; &lt;schuchert@...&gt;", 
    "authorName": "Brett L. Schuchert", 
    "msgSnippet": "We are working on mocking things out but it s going to take time. We ve even written some aspects with AspectJ to automatically record results from our DAO s", 
    "msgId": 16892, 
    "profile": "schuchert", 
    "topicId": 16877, 
    "spamInfo": {
        "reason": "4", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 162568887, 
    "messageBody": "<div id=\"ygrps-yiv-1798499247\">We are working on mocking things out but it&#39;s going to take time. We&#39;ve even written some aspects with AspectJ to automatically record results from our DAO&#39;s that hit MQ to cache the responses. This really speeds up our tests but it doesn&#39;t get rid of the dependencies. We basically made some bad decisions 3.5 years ago and now we&#39;re trying to move back from those decisions.<br/>\n <br/>\nThere&#39;s an underlying driver to the project. The old hardware is being phased out this year - no longer supported by manufacturer. We have been training the people at this company (moving them from COBOL to Java) and rewriting a system that&#39;s been around for 20+ years. Since there&#39;s a ticking clock and a lot of work left, doing things that don&#39;t seem to directly impact development of functional requirements is sometimes a hard sell (even though we both agree that working on tests DOES directly and positively impact the implementation of functional requirements). We follow a three week iteration cycle. Management thinks it OK to refactor at the end of the iteration AFTER you&#39;ve written the code. It&#39;s a tough mind-set to break, but we do what we can.<br/>\n <br/>\nAs for option 2... We&#39;re not following agile practices. We are not pair programming. We are not doing TDD (write one test, get it to compile, get it to run, write the next test...). We are closer to a Unified Process mentality. Use cases not user stories. Design reviews, not pair programming. Don&#39;t refactor until something is broken versus removing code smell as you go along. We do have the develops and BA&#39;s working together. We do have morning stand up meetings. Some are effective, some are just quick status reports (ineffective).<br/>\n <br/>\nNow for situation 2, what typically happens is that we write the functional code and the tests in tandem, switching off between the two. So I&#39;ll write some logic, write several tests to verify it. Back to logic, then tests. Sometimes when I&#39;m trying to work out an interface, I&#39;ll write a series of tests that effectively define my interface but do not compile. Then I&#39;ll get the tests to compile by creating the necessary classes/methods. Then I&#39;ll start working on failing tests to get them to work. Given the size of the project and the number of developers, if I bite off something that might take some time (several weeks), I want to be able to commit my work.<br/>\n <br/>\nHowever, situation 2 also occurs when I&#39;m refactoring a significant part of the system. SINCE we don&#39;t really refactor as we go but only when we can show that not doing so will adversely affect our ability to develop, sometimes our  &quot;refactorings&quot; are huge. It&#39;s not optimal. Most of the developers refer to the list of things we think we should be doing as the &quot;pile of turds&quot;. It keeps growing. Every so often we have to pull one off the pile and the pile comes tumbling down.<br/>\n<br/>\nSo let&#39;s say I&#39;m working on some subsystem. I have say 200 tests, 20 of which are breaking (typically for fringe cases). I want to commit my work. So I&#39;d do something like the following for each of these 20 tests:<br/>\n <br/>\npublic static final String IGNORE_UNTIL=&quot;6/15/2006&quot;;<br/>\n@Ignore(until=IGNORE_UNTIL)<br/>\n@Test<br/>\npublic void oneTestCase() {}<br/>\n <br/>\n@Ignore(until=IGNORE_UNTIL)<br/>\n@Test<br/>\npublic void anotherTestCase() {}<br/>\n <br/>\nEtc.<br/>\n <br/>\nI check this in. Then in my workspace, I just change the IGNORE_UNTIL to something like &quot;6/15/2005&quot;, whatever. One change, all the tests being running.<br/>\n <br/>\nI like this much better than the TimeBomb option because sometimes you have to comment out code so it won&#39;t run. With the @Ignore, JUnit takes care of that for you.<br/>\n <br/>\nI&#39;m not sold on using a string for a date versus a Date. An annotation can handle either. I think the string is an easier solution to use.<br/>\n <br/>\nHere&#39;s another idea that might even be better because it avoids the code change:<br/>\n <br/>\n@Ignore(until=&quot;6/14/2006&quot; untilOverride=&quot;SystemVar&quot;)<br/>\n@Test<br/>\npublic void myTest() {}<br/>\n <br/>\nWhen I run, I add &quot;-DSystemVar=6/15/2005&quot;.<br/>\n <br/>\nThis allows me to check in stuff. Most people will have the tests ignored. When I run the tests, they won&#39;t be ignored. No change to the code base, so it&#39;s safe to check in. If I make changes to the tests that are working, I can still check in.<br/>\n<br/>\nBrett<br/>\n----- Original Message ----<br/>\nFrom: Joakim Ohlrogge &lt;joakim.ohlrogge@...&gt;<br/>\nTo: junit@yahoogroups.com<br/>\nSent: Thursday, June 8, 2006 1:01:43 PM<br/>\nSubject: Re: [junit] @Ignore with a time<br/>\n<br/>\n<br/>\nI think ignore seems way better than someone just commenting a test out<br/>\n(something I guess we have all seen happen or, god forbid, even done<br/>\nourselves sometime in the past).<br/>\nI think that your timebomb concept seems way better than ignore for the<br/>\nreason that you will HAVE to deal with it eventually I&#39;d like that option if<br/>\nI ever use ignore since I KNOW that I will forget to change one or two of<br/>\nthem :).<br/>\n<br/>\nAbout situation 1 Iguess it is a result of system-testing I don&#39;t think<br/>\nusing some other tool than jUnit would change the fact that you do have a<br/>\ndatadependency in your system-tets that you don&#39;t own. I agree lets not have<br/>\nthe &quot;don&#39;t system test with jUnit discussion&quot;. To me it seems that it would<br/>\nbe great if you could find a way to replicate enough of the data you don&#39;t<br/>\nown to be able to run your tests but I bet you wanted that like a million<br/>\ntimes yourself and since you&#39;ve been living with that for 3 years I bet<br/>\nmocking it out is not an option either, tough one :S<br/>\n<br/>\nAbout situation 2 I have been in the situation myself many times and<br/>\nalthough I always feel I missed some baby-step I should have taken or that I<br/>\nshould have checked something in before I started on this big thingy... I<br/>\nguess checing in with ignore is better than not checking in as long as you<br/>\ndon&#39;t ruin someone elses day... One concern I have is that you say that you<br/>\nwrite seeral tests and they are failing why not one at the time, is it like<br/>\na TODO list? is that why you feel safe to check them in?<br/>\n<br/>\n/Joakim<br/>\n<br/>\n<blockquote><span title=\"qreply\"> On 6/8/06, Brett L. Schuchert &lt;schuchert@yahoo. com&gt; wrote:<br/>\n&gt;<br/>\n&gt; We use JUnit for both unit tests and some level of integration tests. We<br/>\n&gt; can have a side discussion on the merits of that, but it&#39;s a fact. We have<br/>\n&gt; right now around 60 developers working across 10 projects. All 10 projects<br/>\n&gt; share a common architecture and supporting components. I&#39;d guess we have<br/>\n&gt; around 7000 unit tests across the 10 projects. Our coverage is a bit lacking<br/>\n&gt; but I know it&#39;s helped.<br/>\n&gt;<br/>\n&gt; Here are 2 situations where we&#39;d use this:<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; Situation 1:<br/>\n&gt; Some of our tests acquire information from external systems we do not have<br/>\n&gt; control over. Those systems sometimes go through maintenance for a day or<br/>\n&gt; two or sometimes those systems clear out all of the test data and repopulate<br/>\n&gt; (I hate that we cannot own a part of the test data, but it&#39;s been a<br/>\n&gt; political issue for 3 years). When this happens, we need to update tests. It<br/>\n&gt; usually takes a 1 to 3 days to do that - often the information the test uses<br/>\n&gt; is externalized, we still have to find appropriate replacement keys. So we<br/>\n&gt; don&#39;t actually update the test, we update the data driven part of the tests.<br/>\n&gt; While that happens, other development would lose out on CI or we&#39;d have to<br/>\n&gt; disable those tests. It&#39;d be nice to just put a 3-day delay on them. Then<br/>\n&gt; they&#39;d start running again automatically. So I guess the ignore is until a<br/>\n&gt; date and after that the test continues to run.<br/>\n&gt;<br/>\n&gt; Situation 2:<br/>\n&gt; I&#39;m working on something in the trunk. I want to write tests and check in<br/>\n&gt; my work. I could work in a branch, check in all I want and then make sure to<br/>\n&gt; merge that branch back into the trunk. However, if I do that, I have to keep<br/>\n&gt; the branch up to date with the trunk and vice versa - merging in both<br/>\n&gt; directions. This is a pain. So I&#39;d rather just write several tests. Put on<br/>\n&gt; the ignore, check them in. Then take out the ignore while I continue my<br/>\n&gt; development (better yet, maybe I could set some environment variable when<br/>\n&gt; executing tests to ignore the ignore!-).<br/>\n&gt;<br/>\n&gt; We have a utility class called TimeBomb (we&#39;re still using JUnit 3.8.1).<br/>\n&gt; When we want to disable a test, we put a time bomb in the test. That test<br/>\n&gt; will eventually start to ACTIVELY fail in the near future. Here&#39;s an example<br/>\n&gt; from something else I&#39;m working on, on the side:<br/>\n&gt; http://schuchert. wikispaces. com/JUnit+ 4.x#TimeBomb<br/>\n&gt;<br/>\n&gt; Brett<br/>\n&gt;<br/>\n&gt; ----- Original Message ----<br/>\n&gt; From: Joakim Ohlrogge &lt;joakim.ohlrogge@ gmail.com&lt;joakim.ohlrogge% 40gmail.com&gt;<br/>\n&gt; &gt;<br/>\n&gt; To: junit@yahoogroups. com &lt;junit%40yahoogroup s.com&gt;<br/>\n&gt; Sent: Thursday, June 8, 2006 6:09:54 AM<br/>\n&gt; Subject: Re: [junit] @Ignore with a time<br/>\n&gt;<br/>\n&gt; I think that would address my concern that @ignore can be forgotten.<br/>\n&gt; A failing test would be a really nice reminder: &quot;ignore expired: &lt;your<br/>\n&gt; message&gt;&quot;<br/>\n&gt; I have not yet used ignore I have not seen the need, when do you typically<br/>\n&gt; need it?<br/>\n&gt;<br/>\n&gt; On 6/8/06, Brett L. Schuchert &lt;schuchert@yahoo. com&gt; wrote:<br/>\n&gt; &gt;<br/>\n&gt; &gt; I&#39;ve been working with a group for the past 3.5 years and we&#39;ve been<br/>\n&gt; &gt; using JUnit from the beginning. A while back, as the project grew,<br/>\n&gt; &gt; there were times when we would break tests (or because we had<br/>\n&gt; &gt; external dependencies that we had to wait and had not yet mocked<br/>\n&gt; &gt; things out), tests would fail for a few days before we could get to<br/>\n&gt; &gt; them.<br/>\n&gt; &gt;<br/>\n&gt; &gt; This stopped our CI, so we introduced a helper class, TimeBomb. We&#39;d<br/>\n&gt; &gt; add a call to TimeBomb with a date and the test would stop failing<br/>\n&gt; &gt; until after the provided date.<br/>\n&gt; &gt;<br/>\n&gt; &gt; It was an active way to remind us go back and fix something in a few<br/>\n&gt; &gt; days.<br/>\n&gt; &gt;<br/>\n&gt; &gt; @Ignore has a message. What about adding a date? Ignore until the<br/>\n&gt; &gt; date, after which the test will fail by throwing a runtime exception?<br/>\n&gt; &gt;<br/>\n&gt; &gt; Is that crazy?<br/>\n&gt; &gt;<br/>\n&gt; &gt; Brett<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt;<br/>\n&gt; [Non-text portions of this message have been removed]<br/>\n&gt;<br/>\n&gt; [Non-text portions of this message have been removed]<br/>\n&gt;<br/>\n&gt; <br/>\n&gt;<br/>\n<br/>\n[Non-text portions of this message have been removed]<br/>\n<br/>\n<br/>\n <br/>\n<br/>\n[Non-text portions of this message have been removed] </span></blockquote></div>", 
    "prevInTime": 16891, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1149791960", 
    "canDelete": false, 
    "nextInTopic": 16898, 
    "prevInTopic": 16889, 
    "headers": {
        "inReplyToHeader": "PGI5ZWU1ZTQxMDYwNjA4MTEwMXMxYmM0YmEzMHY1MGRmOGJiOWU4OWZkYjZAbWFpbC5nbWFpbC5jb20+", 
        "messageIdInHeader": "PDIwMDYwNjA4MTgzOTIwLjgwNjcwLnFtYWlsQHdlYjU0MTA1Lm1haWwueWFob28uY29tPg=="
    }
}