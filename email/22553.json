{
    "numMessagesInTopic": 23, 
    "nextInTime": 22554, 
    "senderId": "GiFcAHLTCfnDBPZJ_iJa64NcxCHKX_rCfMxi83fgsEqny13lUCAU_hZM8ctZHWOVMqmlS232n6s7YS4QA65r9oxF", 
    "systemMessage": false, 
    "subject": "Re: [junit] Re: @DataPoints called several times for Theories", 
    "from": "David Saff &lt;david@...&gt;", 
    "authorName": "David Saff", 
    "msgSnippet": "... I m confused who the secondary consumers are.  Can you give me a code example that requires two copy invocations? ... a and b _can_ be aliases for the same", 
    "msgId": 22553, 
    "profile": "dsaff", 
    "topicId": 22425, 
    "spamInfo": {
        "reason": "4", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 341876227, 
    "messageBody": "<div id=\"ygrps-yiv-1914697939\">On Mon, Mar 15, 2010 at 1:56 PM, Brett Daniel &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:brettdaniel@...\">brettdaniel@...</a>&gt; wrote:<br/>\n<blockquote><span title=\"ireply\"> &gt; David, Berin, and Mike,<br/>\n&gt;<br/>\n&gt; Thank you very much for the great comments. I have asked Shin Hwei and Sang<br/>\n&gt; to provide their thoughts, but until then, here are my answers to your<br/>\n&gt; specific questions (SH&S will correct me if I get anything wrong).<br/>\n&gt;<br/>\n&gt; David wrote...<br/>\n&gt;&gt; do you agree the below would work with the current implementation<br/>\n&gt;&gt; of Theories? It&#39;s four lines more of boilerplate, but not totally<br/>\n&gt; intractable<br/>\n&gt;<br/>\n&gt; You are correct that copying within a @Datapoint method would create a new<br/>\n&gt; data point as needed and would probably be a good workaround for Berin&#39;s<br/>\n&gt; bug. However, I see two drawbacks in addition to those you mention.  First,<br/>\n&gt; one would need to include the copy invocation in every @DataPoint method<br/>\n&gt; that used createdOnce. In contrast, annotating the @DataPoint itself would<br/>\n&gt; provide all consumers with pristine values.<br/>\n<br/>\n </span></blockquote>I&#39;m confused who the secondary consumers are.  Can you give me a code<br/>\nexample that requires two copy invocations?<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Second, the solution fails when<br/>\n&gt; using @DataPoints with a theory that takes multiple parameters:<br/>\n&gt;<br/>\n&gt;    private static Mutable[] createdOnce = new Mutable[] {<br/>\n&gt;        new Mutable(),<br/>\n&gt;        new Mutable() };<br/>\n&gt;<br/>\n&gt;    @DataPoints()<br/>\n&gt;    public static Mutable[] mutables() {<br/>\n&gt;        return new Mutable[] {<br/>\n&gt;                new Mutable(createdOnce[0]),<br/>\n&gt;                new Mutable(createdOnce[1])<br/>\n&gt;        };<br/>\n&gt;    }<br/>\n&gt;<br/>\n&gt;    @Theory<br/>\n&gt;    public void testNotMutated(Mutable a, Mutable b) {<br/>\n&gt;        assertFalse(a.isMutated);<br/>\n&gt;        a.mutate();<br/>\n&gt;        assertFalse(b.isMutated);<br/>\n&gt;        b.mutate();<br/>\n&gt;    }<br/>\n&gt;<br/>\n&gt; The code above fails because a and b can be aliases for the same object. It<br/>\n&gt; may of course be desirable to run a theory on identical instances, but in<br/>\n&gt; that case, the user could make that behavior explicit in another theory.<br/>\n<br/>\n </span></blockquote>a and b _can_ be aliases for the same object under the current<br/>\ndefinition of Theories.  If the developer doesn&#39;t want them to be, she<br/>\ncan say:<br/>\n<br/>\nassumeThat(a, not(b));<br/>\n<br/>\nPreventing such aliasing would be a change, rather than an<br/>\noptimization, in the current semantics of Theories.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;<br/>\n&gt; David wrote...<br/>\n&gt;&gt; What would you think of allowing fields or methods to<br/>\n&gt;&gt; return PontentialAssignment, the type of named references to data<br/>\n&gt;&gt; values used in the Theories runner?<br/>\n&gt; ...<br/>\n&gt;&gt; After further thought, the ParameterSupplier class is even better for<br/>\n&gt;&gt; this kind of thing:<br/>\n&gt;<br/>\n&gt; Do I understand correctly that you are suggesting pulling the<br/>\n&gt; PotentialAssignment array out of the internal Theory runner and making it<br/>\n&gt; available to developers? I seem to remember that Sang and Shin Hwei<br/>\n&gt; experimented with modifications to the PotentialAssignment and<br/>\n&gt; ParameterSupplier classes, but they can describe what they did better than<br/>\n&gt; I.<br/>\n<br/>\n </span></blockquote>Yes, indeed.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;<br/>\n&gt; David wrote...<br/>\n&gt;&gt; @DataPointSource public static PotentialAssignment&lt;Mutable&gt; =<br/>\n&gt;&gt; Copy.ofMutable(new Mutable());<br/>\n&gt; ...<br/>\n&gt;&gt; @DataSupplier public static OneTypeSupplier&lt;Mutable&gt; copyMutable =<br/>\n&gt;&gt; Copies.of(new Mutable());<br/>\n&gt;<br/>\n&gt; I like the idea of allowing data sources that produce things on-demand<br/>\n&gt; rather than in a pre-constructed array of values. This gets back to a brief<br/>\n&gt; discussion you and I had a long time ago about having the @DataPoints<br/>\n&gt; annotation return Iterable&lt;DataPointType&gt;. That would make things like the<br/>\n&gt; following possible:<br/>\n&gt;<br/>\n&gt;  @DataPoints<br/>\n&gt;  public static Iterable&lt;Integer&gt; ints = Ints.between(-10, 10);<br/>\n&gt;<br/>\n&gt;  @DataPoints<br/>\n&gt;  public static Iterable&lt;Mutable&gt; mutables() {<br/>\n&gt;    return Copies.of(...);<br/>\n&gt;  }<br/>\n&gt;<br/>\n&gt; I don&#39;t know if it is better to overload @DataPoints or define new<br/>\n&gt; @DataPointSupplier/@DataPointSource annotations.<br/>\n<br/>\n </span></blockquote>I think that allowing Iterable for DataPoints is a good idea on its<br/>\nown, for the reasons you say.  The @DataPointSupplier proposal is<br/>\nanother step beyond.<br/>\n<br/>\n<blockquote><span title=\"qreply\"> &gt;<br/>\n&gt; Berin wrote...<br/>\n&gt;&gt; I hope we are not introducing an interface or base class that<br/>\n&gt;&gt; would be required for the data classes to implement<br/>\n&gt;<br/>\n&gt; Absolutely not. That is one of the benefits of defining copy strategies in<br/>\n&gt; the @DataPoint annotations: the data point classes themselves remain<br/>\n&gt; unchaged.<br/>\n&gt;<br/>\n&gt; Berin wrote...<br/>\n&gt;&gt; Is there a default CloneStrategy available?<br/>\n&gt;<br/>\n&gt; Sang and Shin Hwei implemented several copy strategies, including one that<br/>\n&gt; uses clone, but they did not include them in the patch in an effort to<br/>\n&gt; reduce its size and complexity. Would it be helpful if they pushed some<br/>\n&gt; examples?<br/>\n&gt;<br/>\n&gt; Berin wrote...<br/>\n&gt;&gt; Here&#39;s a problem I spotted in the implementation:<br/>\n&gt;<br/>\n&gt; Thank you very much for looking so closely at Sang and Shin Hwei&#39;s code. I<br/>\n&gt; have asked them to address any bugs that you or others find.<br/>\n&gt;<br/>\n&gt; Brett<br/>\n&gt;<br/>\n&gt; On Mon, Mar 15, 2010 at 8:51 AM, David Saff &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:david@...\">david@...</a>&gt; wrote:<br/>\n&gt;<br/>\n&gt;&gt;<br/>\n&gt;&gt;<br/>\n&gt;&gt; On Mon, Mar 15, 2010 at 9:05 AM, Loritsch, Berin C.<br/>\n&gt;&gt; &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:berin.loritsch@...\">berin.loritsch@...</a> &lt;berin.loritsch%40gd-ais.com&gt;&gt; wrote:<br/>\n&gt;&gt; &gt; I&#39;m still going through the patch.  Is there a default CloneStrategy<br/>\n&gt;&gt; available?  Any cloneable object (implements the Cloneable interface) will<br/>\n&gt;&gt; be much quicker than another copy strategy.  It&#39;s also an interface and a<br/>\n&gt;&gt; copy strategy that comes with the JVM since before Java 2.<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt; Here&#39;s a problem I spotted in the implementation:<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt; protected Object getCopyStrategyInvokedObject(Object value,<br/>\n&gt;&gt; &gt;        Class&lt;? extends CopyStrategy&gt; copyStrategy, int index) throws<br/>\n&gt;&gt; CopyStrategyFailureException {<br/>\n&gt;&gt; &gt;      try {<br/>\n&gt;&gt; &gt;        return copyStrategy.newInstance().copyDataPoint(value);<br/>\n&gt;&gt; &gt;      } catch (Exception e) {<br/>\n&gt;&gt; &gt;        throw new CopyStrategyFailureException(value, index,<br/>\n&gt;&gt; copyStrategy.getSimpleName());<br/>\n&gt;&gt; &gt;      }<br/>\n&gt;&gt; &gt;    }<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt; Invoking copyStrategy.newInstance() for every object that needs to be<br/>\n&gt;&gt; copied is going to be a major performance drain.  Not only are we creating<br/>\n&gt;&gt; more work for the garbage collector, we are going through the overhead of<br/>\n&gt;&gt; the reflection API to do it.  You will have an order of magnitude better<br/>\n&gt;&gt; performance if you get your instance of the CopyStrategy first, and pass<br/>\n&gt;&gt; that as necessary.<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt; Perhaps another point of making the code cleaner would be to pull all the<br/>\n&gt;&gt; data collection stuff into its own API.  It might even be able to support<br/>\n&gt;&gt; parameterized tests as well as theories.  I imagine that was the idea behind<br/>\n&gt;&gt; ParameterSupplier?<br/>\n&gt;&gt;<br/>\n&gt;&gt; Sadly, ParameterSupplier only applies to one parameter at a time, but<br/>\n&gt;&gt; I could imagine a unified API that included interfaces for both.<br/>\n&gt;&gt;<br/>\n&gt;&gt; David<br/>\n&gt;&gt;<br/>\n&gt;&gt;<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt; ________________________________<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt; From: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a> &lt;junit%40yahoogroups.com&gt; on behalf of Mike<br/>\n&gt;&gt; Forsberg<br/>\n&gt;&gt; &gt; Sent: Sun 3/14/2010 12:15 PM<br/>\n&gt;&gt; &gt; To: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a> &lt;junit%40yahoogroups.com&gt;; Shin Hwei Tan; Sang<br/>\n&gt;&gt; Y Baik<br/>\n&gt;&gt; &gt; Subject: Re: [junit] Re: @DataPoints called several times for Theories<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt; Please feel free to join the mailing list. I would find the discussion<br/>\n&gt;&gt; &gt; interesting and wish it would not run offline.<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt; Big Mike<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt; On Fri, Mar 12, 2010 at 6:44 PM, Brett Daniel &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:brettdaniel@...\">brettdaniel@...</a>&lt;brettdaniel%40gmail.com&gt;&lt;mailto:<br/>\n&gt;&gt; brettdaniel%40gmail.com &lt;brettdaniel%2540gmail.com&gt;&gt; &gt; wrote:<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;&gt;<br/>\n&gt;&gt; &gt;&gt;<br/>\n&gt;&gt; &gt;&gt; The undergrads I am advising recently pushed a patch that addresses the<br/>\n&gt;&gt; &gt;&gt; issue of mutable data points.<br/>\n&gt;&gt; &gt;&gt;<br/>\n&gt;&gt; &gt;&gt;<br/>\n&gt;&gt; &gt;&gt;<br/>\n&gt;&gt; <a rel=\"nofollow\" target=\"_blank\" href=\"http://github.com/stan6/junit/commit/dcfa3c41446c469a4edc7513e9e7a9b610b04020&lt;\">http://github.com/stan6/junit/commit/dcfa3c41446c469a4edc7513e9e7a9b610b04020&lt;</a><br/>\n&gt;&gt; <a rel=\"nofollow\" target=\"_blank\" href=\"http://github.com/stan6/junit/commit/dcfa3c41446c469a4edc7513e9e7a9b610b04020\">http://github.com/stan6/junit/commit/dcfa3c41446c469a4edc7513e9e7a9b610b04020</a><br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;&gt;<br/>\n&gt;&gt; &gt;&gt; The patch allows developers to define &quot;copy strategies&quot; that duplicate<br/>\n&gt;&gt; &gt;&gt; marked data points before every theory execution. In this way, every<br/>\n&gt;&gt; &gt;&gt; execution receives a pristine data point, which removes the problems<br/>\n&gt;&gt; caused<br/>\n&gt;&gt; &gt;&gt; when a theory mutates data points. This is orthogonal to datapoint<br/>\n&gt;&gt; &gt;&gt; (re)creation, but I think copy strategies may help address the bug that<br/>\n&gt;&gt; &gt;&gt; Berin found.<br/>\n&gt;&gt; &gt;&gt;<br/>\n&gt;&gt; &gt;&gt; The patch creates a new, optional &quot;copyStrategy&quot; parameter for the<br/>\n&gt;&gt; &gt;&gt; @DataPoint and @DataPoints annotations. If the developer wants to copy<br/>\n&gt;&gt; data<br/>\n&gt;&gt; &gt;&gt; points, he or she sets the parameter to a class implementing a new<br/>\n&gt;&gt; &gt;&gt; CopyStrategy interface.<br/>\n&gt;&gt; &gt;&gt;<br/>\n&gt;&gt; &gt;&gt; Here is an example:<br/>\n&gt;&gt; &gt;&gt;<br/>\n&gt;&gt; &gt;&gt; @RunWith(Theories.class)<br/>\n&gt;&gt; &gt;&gt; public class TestMutable {<br/>\n&gt;&gt; &gt;&gt;<br/>\n&gt;&gt; &gt;&gt; @DataPoint(copyStrategy = MutableWithCopyStrategy.class)<br/>\n&gt;&gt; &gt;&gt; public static Mutable mutable = new Mutable();<br/>\n&gt;&gt; &gt;&gt;<br/>\n&gt;&gt; &gt;&gt; @Theory<br/>\n&gt;&gt; &gt;&gt; public static testMutate(Mutable a) {<br/>\n&gt;&gt; &gt;&gt; a.mutate();<br/>\n&gt;&gt; &gt;&gt; }<br/>\n&gt;&gt; &gt;&gt;<br/>\n&gt;&gt; &gt;&gt; @Theory<br/>\n&gt;&gt; &gt;&gt; public static testNotMutated(Mutable a) {<br/>\n&gt;&gt; &gt;&gt; assertFalse(a.isMutated());<br/>\n&gt;&gt; &gt;&gt; }<br/>\n&gt;&gt; &gt;&gt; }<br/>\n&gt;&gt; &gt;&gt;<br/>\n&gt;&gt; &gt;&gt; In the current implementation of JUnit, the second theory may fail<br/>\n&gt;&gt; because<br/>\n&gt;&gt; &gt;&gt; the first theory mutates the datapoint. With a copy strategy enabled,<br/>\n&gt;&gt; both<br/>\n&gt;&gt; &gt;&gt; theories receive a new value.<br/>\n&gt;&gt; &gt;&gt;<br/>\n&gt;&gt; &gt;&gt; Strategies can do almost anything: clone the data point, call a factory<br/>\n&gt;&gt; &gt;&gt; method, or--as in the following implementation--instantaiate a new<br/>\n&gt;&gt; object<br/>\n&gt;&gt; &gt;&gt; with a copy constructor.<br/>\n&gt;&gt; &gt;&gt;<br/>\n&gt;&gt; &gt;&gt; public class MutableWithCopyStrategy implements CopyStrategy {<br/>\n&gt;&gt; &gt;&gt; public Object copyDataPoint(Object toCopy) throws Exception {<br/>\n&gt;&gt; &gt;&gt; return new Mutable((Mutable)toCopy);<br/>\n&gt;&gt; &gt;&gt; }<br/>\n&gt;&gt; &gt;&gt; }<br/>\n&gt;&gt; &gt;&gt;<br/>\n&gt;&gt; &gt;&gt; There are several benefits to this implementation. First, the new<br/>\n&gt;&gt; parameter<br/>\n&gt;&gt; &gt;&gt; is completely optional; if it is omitted, the theory runner behaves as<br/>\n&gt;&gt; it<br/>\n&gt;&gt; &gt;&gt; always has. Second, it doesn&#39;t require modifying the data point&#39;s class<br/>\n&gt;&gt; &gt;&gt; (for<br/>\n&gt;&gt; &gt;&gt; example, to add a copy constructor or clone method). Most importantly,<br/>\n&gt;&gt; it<br/>\n&gt;&gt; &gt;&gt; makes it clear to the tester that without a copy strategy one theory<br/>\n&gt;&gt; &gt;&gt; execution can impact another.<br/>\n&gt;&gt; &gt;&gt;<br/>\n&gt;&gt; &gt;&gt; I have CC&#39;d the two students in this email. Please direct any questions<br/>\n&gt;&gt; to<br/>\n&gt;&gt; &gt;&gt; them.<br/>\n&gt;&gt; &gt;&gt;<br/>\n&gt;&gt; &gt;&gt; Brett<br/>\n&gt;&gt; &gt;&gt;<br/>\n&gt;&gt; &gt;&gt;<br/>\n&gt;&gt; &gt;&gt; On Thu, Feb 18, 2010 at 5:28 PM, Berin &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:berin.loritsch@...\">berin.loritsch@...</a>&lt;berin.loritsch%40gd-ais.com&gt;&lt;mailto:<br/>\n&gt;&gt; berin.loritsch%40gd-ais.com &lt;berin.loritsch%2540gd-ais.com&gt;&gt;<br/>\n&gt;&gt; &lt;berin.loritsch%40gd-ais.com&gt;&gt;<br/>\n&gt;&gt; &gt;&gt; wrote:<br/>\n&gt;&gt; &gt;&gt;<br/>\n&gt;&gt; &gt;&gt; &gt;<br/>\n&gt;&gt; &gt;&gt; &gt;<br/>\n&gt;&gt; &gt;&gt; &gt; I agree with your prognosis, about fresh data points for testing the<br/>\n&gt;&gt; &gt;&gt; &gt; theories. That is precisely why I proposed reading them once, and<br/>\n&gt;&gt; cloning<br/>\n&gt;&gt; &gt;&gt; &gt; them (making a copy) as needed for each theory. With that approach we<br/>\n&gt;&gt; &gt;&gt; even<br/>\n&gt;&gt; &gt;&gt; &gt; get the protection from mutated data points when you use the<br/>\n&gt;&gt; @DataPoint<br/>\n&gt;&gt; &gt;&gt; to<br/>\n&gt;&gt; &gt;&gt; &gt; mark a static field.<br/>\n&gt;&gt; &gt;&gt; &gt;<br/>\n&gt;&gt; &gt;&gt; &gt; Cloning is a much quicker operation, does not execute any<br/>\n&gt;&gt; constructors.<br/>\n&gt;&gt; &gt;&gt; It<br/>\n&gt;&gt; &gt;&gt; &gt; merely copies the contents of the object memory verbatim.<br/>\n&gt;&gt; &gt;&gt; &gt;<br/>\n&gt;&gt; &gt;&gt; &gt; With the current implementation, if you are not prepared for the<br/>\n&gt;&gt; &gt;&gt; &gt; combinatorial affect of 60 data points combined with 60 data points<br/>\n&gt;&gt; for<br/>\n&gt;&gt; &gt;&gt; each<br/>\n&gt;&gt; &gt;&gt; &gt; theory there is a major disconnect. The majority of the overhead in<br/>\n&gt;&gt; this<br/>\n&gt;&gt; &gt;&gt; &gt; particular scenario has to do with creating objects (with the<br/>\n&gt;&gt; additional<br/>\n&gt;&gt; &gt;&gt; &gt; overhead of doing it by reflection).<br/>\n&gt;&gt; &gt;&gt; &gt;<br/>\n&gt;&gt; &gt;&gt; &gt; When I created only one instance of each class instead of two, the<br/>\n&gt;&gt; &gt;&gt; &gt; performance was twice as fast (i.e. 37 seconds down to about 16<br/>\n&gt;&gt; seconds).<br/>\n&gt;&gt; &gt;&gt; &gt;<br/>\n&gt;&gt; &gt;&gt; &gt; Essentially the number of times your @DataPoints method is called<br/>\n&gt;&gt; depends<br/>\n&gt;&gt; &gt;&gt; &gt; on the number of parameters in your @Theory and how many theories you<br/>\n&gt;&gt; &gt;&gt; have.<br/>\n&gt;&gt; &gt;&gt; &gt; Essentially the formula for my theory (ha, ha) of the execution is<br/>\n&gt;&gt; like<br/>\n&gt;&gt; &gt;&gt; &gt; this:<br/>\n&gt;&gt; &gt;&gt; &gt;<br/>\n&gt;&gt; &gt;&gt; &gt; N^(p-1) + 1<br/>\n&gt;&gt; &gt;&gt; &gt;<br/>\n&gt;&gt; &gt;&gt; &gt; where:<br/>\n&gt;&gt; &gt;&gt; &gt;<br/>\n&gt;&gt; &gt;&gt; &gt; N is the number of data points returned by the method<br/>\n&gt;&gt; &gt;&gt; &gt; p is the number of parameters<br/>\n&gt;&gt; &gt;&gt; &gt; and the + 1 represents the run where the data point is read the first<br/>\n&gt;&gt; &gt;&gt; time<br/>\n&gt;&gt; &gt;&gt; &gt;<br/>\n&gt;&gt; &gt;&gt; &gt; So for 60 data points it is run 61 times for two parameters. With<br/>\n&gt;&gt; three<br/>\n&gt;&gt; &gt;&gt; &gt; parameters it would be called 3601 times. I have to verify with three<br/>\n&gt;&gt; &gt;&gt; &gt; parameters. The theory is called N^p times for sure and that is<br/>\n&gt;&gt; expected.<br/>\n&gt;&gt; &gt;&gt; &gt;<br/>\n&gt;&gt; &gt;&gt; &gt; With the above formula, the mapping of number of calls to parameters<br/>\n&gt;&gt; for<br/>\n&gt;&gt; &gt;&gt; 60<br/>\n&gt;&gt; &gt;&gt; &gt; data points would be:<br/>\n&gt;&gt; &gt;&gt; &gt;<br/>\n&gt;&gt; &gt;&gt; &gt; 1 -&gt; 2 (I know this is wrong which gives me doubts on the formula)<br/>\n&gt;&gt; &gt;&gt; &gt; 2 -&gt; 61<br/>\n&gt;&gt; &gt;&gt; &gt; 3 -&gt; 3601<br/>\n&gt;&gt; &gt;&gt; &gt; 3 -&gt; 216001<br/>\n&gt;&gt; &gt;&gt; &gt;<br/>\n&gt;&gt; &gt;&gt; &gt; Essentially when the Assignments class needs to make the combinations,<br/>\n&gt;&gt; it<br/>\n&gt;&gt; &gt;&gt; &gt; will collect the data points initially for each theory. It then calls<br/>\n&gt;&gt; the<br/>\n&gt;&gt; &gt;&gt; &gt; data points again for each existing data point it collected from the<br/>\n&gt;&gt; &gt;&gt; first<br/>\n&gt;&gt; &gt;&gt; &gt; read. With a third parameter it would take all those combinations<br/>\n&gt;&gt; again,<br/>\n&gt;&gt; &gt;&gt; to<br/>\n&gt;&gt; &gt;&gt; &gt; add all the permutations for the next round.<br/>\n&gt;&gt; &gt;&gt; &gt;<br/>\n&gt;&gt; &gt;&gt; &gt; I might be wrong and the real formula would be like this:<br/>\n&gt;&gt; &gt;&gt; &gt;<br/>\n&gt;&gt; &gt;&gt; &gt; N^0 + N^1 ... + N^(p-1)<br/>\n&gt;&gt; &gt;&gt; &gt;<br/>\n&gt;&gt; &gt;&gt; &gt; If this is the correct formula, then if you have 60 data points the<br/>\n&gt;&gt; &gt;&gt; number<br/>\n&gt;&gt; &gt;&gt; &gt; of times the method is called would map to the number of parameters<br/>\n&gt;&gt; like<br/>\n&gt;&gt; &gt;&gt; &gt; this:<br/>\n&gt;&gt; &gt;&gt; &gt;<br/>\n&gt;&gt; &gt;&gt; &gt; 1 -&gt; 1<br/>\n&gt;&gt; &gt;&gt; &gt; 2 -&gt; 61<br/>\n&gt;&gt; &gt;&gt; &gt; 3 -&gt; 3661<br/>\n&gt;&gt; &gt;&gt; &gt; 4 -&gt; 219661<br/>\n&gt;&gt; &gt;&gt; &gt;<br/>\n&gt;&gt; &gt;&gt; &gt;<br/>\n&gt;&gt; &gt;&gt; &gt; --- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a> &lt;junit%40yahoogroups.com&gt; &lt;mailto:<br/>\n&gt;&gt; junit%40yahoogroups.com &lt;junit%2540yahoogroups.com&gt;&gt;  &lt;junit%<br/>\n&gt;&gt; 40yahoogroups.com&gt; &lt;junit%<br/>\n&gt;&gt; &gt;&gt; 40yahoogroups.com&gt;, Brett Daniel<br/>\n&gt;&gt; &gt;&gt;<br/>\n&gt;&gt; &gt;&gt; &gt; &lt;brettdaniel@...&gt; wrote:<br/>\n&gt;&gt; &gt;&gt; &gt; &gt;<br/>\n&gt;&gt; &gt;&gt; &gt; &gt; Berin,<br/>\n&gt;&gt; &gt;&gt; &gt; &gt;<br/>\n&gt;&gt; &gt;&gt; &gt; &gt; When a theory mutates data points, it might be beneficial to<br/>\n&gt;&gt; recreate<br/>\n&gt;&gt; &gt;&gt; &gt; &gt; the data point for every theory invocation. Doing so prevents one<br/>\n&gt;&gt; &gt;&gt; &gt; &gt; theory execution from affecting others. I wrote about this issue in<br/>\n&gt;&gt; &gt;&gt; &gt; &gt; the following weblog post:<br/>\n&gt;&gt; &gt;&gt; &gt; &gt;<br/>\n&gt;&gt; &gt;&gt; &gt; &gt; <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.brettdaniel.com/archives/2009/09/24/200845/\">http://www.brettdaniel.com/archives/2009/09/24/200845/</a> &lt;<br/>\n&gt;&gt; <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.brettdaniel.com/archives/2009/09/24/200845/\">http://www.brettdaniel.com/archives/2009/09/24/200845/</a>&gt;<br/>\n&gt;&gt; &gt;&gt; &gt; &gt;<br/>\n&gt;&gt; &gt;&gt; &gt; &gt; You are correct, though, that copying would avoid some of the<br/>\n&gt;&gt; overhead<br/>\n&gt;&gt; &gt;&gt; &gt; &gt; in calling datapoint methods. It is interesting you mention this<br/>\n&gt;&gt; idea,<br/>\n&gt;&gt; &gt;&gt; &gt; &gt; because I am currently overseeing two students who for their senior<br/>\n&gt;&gt; &gt;&gt; &gt; &gt; thesis project are implementing framework for copying datapoints. I<br/>\n&gt;&gt; &gt;&gt; &gt; &gt; will post more information to the mailing list as the project<br/>\n&gt;&gt; &gt;&gt; &gt; &gt; continues.<br/>\n&gt;&gt; &gt;&gt; &gt; &gt;<br/>\n&gt;&gt; &gt;&gt; &gt; &gt; Brett<br/>\n&gt;&gt; &gt;&gt; &gt; &gt;<br/>\n&gt;&gt; &gt;&gt; &gt;<br/>\n&gt;&gt; &gt;&gt; &gt;<br/>\n&gt;&gt; &gt;&gt; &gt;<br/>\n&gt;&gt; &gt;&gt;<br/>\n&gt;&gt; &gt;&gt; [Non-text portions of this message have been removed]<br/>\n&gt;&gt; &gt;&gt;<br/>\n&gt;&gt; &gt;&gt;<br/>\n&gt;&gt; &gt;&gt;<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt; [Non-text portions of this message have been removed]<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt; [Non-text portions of this message have been removed]<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt; ------------------------------------<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt; Yahoo! Groups Links<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt;<br/>\n&gt;&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; [Non-text portions of this message have been removed]<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; ------------------------------------<br/>\n&gt;<br/>\n&gt; Yahoo! Groups Links<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 22552, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1268685980", 
    "canDelete": false, 
    "nextInTopic": 22555, 
    "prevInTopic": 22552, 
    "headers": {
        "inReplyToHeader": "PDU4ZGJhMjI1MTAwMzE1MTA1Nms0YmYyNGZmMnhmMTYxZTY0MTVhYmY0YWJhQG1haWwuZ21haWwuY29tPg==", 
        "messageIdInHeader": "PDRmN2RhNmI5MTAwMzE1MTM0Nmo3MzNkZjFjMGc1ZWMwNDU5YTE4ZmNkMTRjQG1haWwuZ21haWwuY29tPg==", 
        "referencesHeader": "PDU4ZGJhMjI1MTAwMjE4MDk0M3EyMzhkZDhkdjExYWI0ODczNjMyMWUxNzhAbWFpbC5nbWFpbC5jb20+CSA8aGxraWYyKzNtdGVAZUdyb3Vwcy5jb20+CSA8NThkYmEyMjUxMDAzMTIxNTQ0cDNjZDdkZDI4aDFhODk5Y2U2NTdmNjZhZDNAbWFpbC5nbWFpbC5jb20+CSA8YTUyN2ZkZGYxMDAzMTQwOTE1bDczNzYxZWUxcjc4MWJhMjBmYzc2OGU0MmVAbWFpbC5nbWFpbC5jb20+CSA8NzVGNUVEOEE1QTU1MzY0NkE0NkUwMEU2RUM4NTRGQTMwMzc4QzdFNEB2YWZmMDEtbWFpbDAxLmFkLmdkLWFpcy5jb20+CSA8NGY3ZGE2YjkxMDAzMTUwNjUxbTEyZjI3OTZrZjlhYWIxN2ZmMzEyY2Q5M0BtYWlsLmdtYWlsLmNvbT4JIDw1OGRiYTIyNTEwMDMxNTEwNTZrNGJmMjRmZjJ4ZjE2MWU2NDE1YWJmNGFiYUBtYWlsLmdtYWlsLmNvbT4="
    }
}