{
    "numMessagesInTopic": 13, 
    "nextInTime": 18575, 
    "senderId": "6FWqShXSqZx-i3Xem5tbJ2_XrNePa4mvEm6oX4Kz4pIOsFIqJC70TmFwEaOYgtx-yMmuIrBF41tVr5ihoObOofgN", 
    "systemMessage": false, 
    "subject": "Re: [junit] How JUnit runs test class", 
    "from": "&quot;David Saff&quot; &lt;saff@...&gt;", 
    "authorName": "David Saff", 
    "msgSnippet": "... I m not sure what definition of validity you re applying here, so I can t agree or disagree.  JUnit makes it somewhat hard, but not impossible, to keep", 
    "msgId": 18574, 
    "profile": "dsaff", 
    "topicId": 18565, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 139771899, 
    "messageBody": "<div id=\"ygrps-yiv-1161205879\">On 12/21/06, Cédric Beust ♔ &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:cbeust@...\">cbeust@...</a>&gt; wrote:<br/>\n<blockquote><span title=\"ireply\"> &gt; On 12/21/06, J. B. Rainsberger &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:jbrains762@...\">jbrains762@...</a>&gt; wrote:<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt; JUnit wants to make all tests isolated from each other, so that if test<br/>\n&gt; &gt; #2 fails, test #5 can still pass. This is why it always creates a new<br/>\n&gt; &gt; instance of the test class for each test.<br/>\n&gt; &gt;<br/>\n&gt; &gt; If you really don&#39;t want your tests to be isolated, then I agree this is<br/>\n&gt; &gt; a waste of resources, but I have two questions:<br/>\n&gt; &gt;<br/>\n&gt; &gt; 1. Do you really want your tests /not/ to be isolated?<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; You make it sound as if the only way to have isolated tests is for JUnit to<br/>\n&gt; create a new instance every time...  There are other ways that are just as<br/>\n&gt; valid :-)<br/>\n<br/>\n </span></blockquote>I&#39;m not sure what definition of validity you&#39;re applying here, so I<br/>\ncan&#39;t agree or disagree.  JUnit makes it somewhat hard, but not<br/>\nimpossible, to keep implicit state lying around between tests.  If I<br/>\nfind myself wanting to do that, I have a choice to push against JUnit,<br/>\nor push against my design.  Sometimes I find that something I had been<br/>\nkeeping as a singleton should instead be passed into the objects that<br/>\nneed it, and I&#39;m happier with the resulting design.<br/>\n<br/>\nIt&#39;s like the safety catch on my hand-held rotary saw--it makes it<br/>\nsomewhat hard, but not impossible, to run the saw with the blade fully<br/>\nextended without some wood to cut.  Holding the safety catch and<br/>\nretracting the blade cover at the same time is hard, and makes me<br/>\nthink if maybe I&#39;d rather re-configure my cutting job, and often, I&#39;m<br/>\nglad when I reconfigure the job.<br/>\n<br/>\nThat said, I proceed knowing that JUnit is a unit-testing framework,<br/>\nbest for testing units that can be isolated one from another, and<br/>\nstarted up and shut down without much overhead.  It&#39;s clever enough to<br/>\nbe used for functional and system tests, but with some wrinkles, like<br/>\nthe one you point out.  I find that the impedence mismatch isn&#39;t<br/>\nenough to justify learning another framework for different kinds of<br/>\ntests, but understand if other&#39;s mileage varies.  I also find that<br/>\nsometimes I&#39;m surprised--I expect there&#39;s no way to write a particular<br/>\nserver or parser as a well-encapsulated unit, but find that with a<br/>\nlittle effort, it&#39;s not that hard, and I&#39;m glad that JUnit pushes me<br/>\nto try.  I imagine that a framework built primarily for functional or<br/>\nsystem tests would also have mismatches if I tried to write unit tests<br/>\nwith it--I might not get the design feedback that is so valuable from<br/>\nJUnit.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; As you already know, I think it would be nice if JUnit at least gave us the<br/>\n&gt; option.<br/>\n<br/>\n </span></blockquote>Well, it does, especially in JUnit 4, which has an extensible Runner<br/>\nframework.  The below test class has two inner classes.<br/>\nRunWithOneInstance is a test class which will only be run once, and<br/>\nOneInstance is the custom Runner that makes it possible.  In terms of<br/>\nJUnit&#39;s design, I&#39;m happy this is possible without modifying JUnit&#39;s<br/>\ncode, but I think it should be possible in fewer than the 20 lines of<br/>\ncode I currently use.  In any case, share and enjoy.<br/>\n<br/>\npackage constructonce;<br/>\n<br/>\nimport static org.junit.Assert.*;<br/>\n<br/>\nimport org.junit.Test;<br/>\nimport org.junit.internal.runners.InitializationError;<br/>\nimport org.junit.internal.runners.TestClassMethodsRunner;<br/>\nimport org.junit.internal.runners.TestClassRunner;<br/>\nimport org.junit.runner.JUnitCore;<br/>\nimport org.junit.runner.Result;<br/>\nimport org.junit.runner.RunWith;<br/>\n<br/>\npublic class ConstructOnceTest {<br/>\n\tpublic static class OneInstance extends TestClassRunner {<br/>\n\t\tpublic OneInstance(Class&lt;?&gt; klass) throws InitializationError {<br/>\n\t\t\tsuper(klass, new OneInstanceMethodsRunner(klass));<br/>\n\t\t}<br/>\n\t\t<br/>\n\t\tprivate static class OneInstanceMethodsRunner extends TestClassMethodsRunner {<br/>\n\t\t\tprivate Object fInstance;<br/>\n<br/>\n\t\t\tpublic OneInstanceMethodsRunner(Class&lt;?&gt; klass) {<br/>\n\t\t\t\tsuper(klass);<br/>\n\t\t\t\tfInstance = null;<br/>\n\t\t\t}<br/>\n\t\t\t<br/>\n\t\t\t@Override<br/>\n\t\t\tprotected Object createTest() throws Exception {<br/>\n\t\t\t\tif (fInstance == null)<br/>\n\t\t\t\t\tfInstance = super.createTest();<br/>\n\t\t\t\treturn fInstance;<br/>\n\t\t\t}<br/>\n\t\t}<br/>\n\t}<br/>\n<br/>\n\t@RunWith(OneInstance.class)<br/>\n\tpublic static class RunWithOneInstance {<br/>\n\t\tprivate static boolean constructed = false;<br/>\n<br/>\n\t\tpublic RunWithOneInstance() {<br/>\n\t\t\tif (constructed)<br/>\n\t\t\t\tthrow new IllegalStateException(&quot;Only construct me once!&quot;);<br/>\n\t\t\tconstructed = true;<br/>\n\t\t}<br/>\n<br/>\n\t\t@Test<br/>\n\t\tpublic void firstTest() {<br/>\n\t\t}<br/>\n<br/>\n\t\t@Test<br/>\n\t\tpublic void secondTest() {<br/>\n\t\t}<br/>\n\t}<br/>\n<br/>\n\t@Test<br/>\n\tpublic void runWithOneInstance() {<br/>\n\t\tResult result = JUnitCore.runClasses(RunWithOneInstance.class);<br/>\n\t\tassertEquals(0, result.getFailureCount());<br/>\n\t}<br/>\n}</div>", 
    "prevInTime": 18573, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1166800436", 
    "canDelete": false, 
    "nextInTopic": 18576, 
    "prevInTopic": 18570, 
    "headers": {
        "inReplyToHeader": "PGI4NmI2YTljMDYxMjIxMTE0NWw1Yzk3NmZjNm1kNmUyNmRhMGI2YTJkOWQ1QG1haWwuZ21haWwuY29tPg==", 
        "messageIdInHeader": "PDRmN2RhNmI5MDYxMjIyMDcxM2o1Nzk5NTY0cTRjNjc0MGMwYzJhYjMzNGVAbWFpbC5nbWFpbC5jb20+", 
        "referencesHeader": "PDg2REYyODgzRUM2ODRBNEM5MDQzRUUxODM0MDUyMUZBMDM2OERFMDhARVgwMDA0LkFsbHN0cmVhbUlUUy5sb2NhbD4JIDw0NThBRDUxNS40MDQwOUBnbWFpbC5jb20+CSA8Yjg2YjZhOWMwNjEyMjExMTQ1bDVjOTc2ZmM2bWQ2ZTI2ZGEwYjZhMmQ5ZDVAbWFpbC5nbWFpbC5jb20+"
    }
}