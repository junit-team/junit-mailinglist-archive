{
    "numMessagesInTopic": 33, 
    "nextInTime": 21639, 
    "senderId": "xXVbRoqbs_ELx0WPVFnG5lRS6nctUf0eW1HDcykT8fXS_ENrZXGkt_Bv2cz5yaSvOeheRo3qD2zRskhvBL1v6_4R", 
    "systemMessage": false, 
    "subject": "Re: [junit] Re: Missing API: Assert.assertThat(boolean) or \tIsCollection.isEmpty()", 
    "from": "David Saff &lt;david@...&gt;", 
    "authorName": "David Saff", 
    "msgSnippet": "... I m proposing that the one-arg assertThat method is _also_ seamlessly extensible by the user, by creating boolean methods on their domain objects. ... If", 
    "msgId": 21638, 
    "profile": "dsaff", 
    "topicId": 21596, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 341876227, 
    "messageBody": "<div id=\"ygrps-yiv-1054606318\">On Tue, May 19, 2009 at 12:40 PM, nat_pryce &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:nat.pryce@...\">nat.pryce@...</a>&gt; wrote:<br/>\n<blockquote><span title=\"ireply\"> &gt; The advantage Hamcrest&#39;s matcher factory functions is that the assertThat method is seamlessly extensible by the user.  I can write assertThat(someString, isMyMothersMaidenName()), for example, and it looks no different, stylistically, to assertThat(someString, containsString(&quot;foo&quot;)).  The user can write one small component -- the new matcher -- and seamlessly plug it into anything that accepts a matcher and get all the testing and diagnostic descriptions almost for free.<br/>\n<br/>\n </span></blockquote>I&#39;m proposing that the one-arg assertThat method is _also_ seamlessly<br/>\nextensible by the user, by creating boolean methods on their domain<br/>\nobjects.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; David&#39;s suggestion is convenient but cannot be extended. I can&#39;t write assertThat(someString).isMyMothersMaidenName(), for example.<br/>\n<br/>\n </span></blockquote>If your mother&#39;s maiden name is an important concept in the domain,<br/>\nit&#39;s probably already expressed (or should be?) as a method on some<br/>\nobject, perhaps Name, which allows:<br/>\n<br/>\nassertThat(Name.fromString(someString)).isMyMothersMaidenName();<br/>\n<br/>\nFor absolutely free, _if_ you don&#39;t finalize Name.  I think that it<br/>\nintensifies some of the better aspects of TDD design (&quot;That assertion<br/>\nwould be easier to debug if I had a method called<br/>\nisMyMothersMaidenName()&quot;);<br/>\n<br/>\nWith current hamcrest, you have to Repeat Yourself, by writing both<br/>\nName.isMyMothersMaidenName and Matchers.isMyMothersMaidenName.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; I&#39;d like to see some middle-ground between the two.  Maybe a factory function can use reflection to create a matcher that is then passed as a parameter to assertThat.  I think this is how the logicalpractice-collections library works.<br/>\n<br/>\n </span></blockquote>I see the single-arg assertThat as sugar on top of exactly that<br/>\nimplementation, so the following would be equivalent:<br/>\n<br/>\nassertThat(list).isEmpty();<br/>\nassertThat(list, theAforementioned(List.class).isEmpty());<br/>\n<br/>\nYes, some serious work needs to be done on naming on the second line,<br/>\nbut hopefully the idea is clear.<br/>\n<br/>\n   David Saff</div>", 
    "prevInTime": 21637, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1242754900", 
    "canDelete": false, 
    "nextInTopic": 21639, 
    "prevInTopic": 21637, 
    "headers": {
        "inReplyToHeader": "PGd1dW5kaCtnMGprQGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PDRmN2RhNmI5MDkwNTE5MTA0MWtiYWE3ZGE1b2Y5ZDJjMzM1MDk5NDYxYTNAbWFpbC5nbWFpbC5jb20+", 
        "referencesHeader": "PDRmN2RhNmI5MDkwNTE5MDgyNHM0OTIyOThmOWc3ZjhkYTRmYjNmNWYwNjA1QG1haWwuZ21haWwuY29tPgkgPGd1dW5kaCtnMGprQGVHcm91cHMuY29tPg=="
    }
}