{
    "numMessagesInTopic": 6, 
    "nextInTime": 11984, 
    "senderId": "hJPzyBcA_mUWfUcS_VTHEM4Dc5Tko2BrklSYhkYNaaRdU4C2UfPPetOFYNuNDHXN4GgJV_7ciYstEDDziqYFEjuQZCY", 
    "systemMessage": false, 
    "subject": "Re: [junit] Testing Spring/Hibernate", 
    "from": "jeff.nielsen@...", 
    "authorName": "jeff.nielsen@digitalfocus.com", 
    "msgSnippet": "We have a thorougly-unit-tested J2EE app that also uses Spring & Hibernate.  Here are a couple of recommendations. 1. Do most of your unit testing so that it", 
    "msgId": 11983, 
    "profile": "jeffreymads", 
    "topicId": 11972, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 65487161, 
    "messageBody": "<div id=\"ygrps-yiv-534064909\">We have a thorougly-unit-tested J2EE app that also uses Spring &<br/>\nHibernate.  Here are a couple of recommendations.<br/>\n<br/>\n1. Do most of your unit testing so that it is /independent/ of the<br/>\ndatabase.  Test all of the callers of the DAO--such as<br/>\nInvestorWebServices--using a MockHibernateFacade that returns the data you<br/>\nset up in the test.<br/>\n<br/>\n2. For testing the DAO operation itself (as in the example you give<br/>\nbelow), configure the test so that it /does not/ use the transaction<br/>\nmanager at all.  You could do this by having multiple versions of the<br/>\napplicationContext.xml as you suggest, but it is probably easier just to<br/>\ninstantiate the DAO &quot;by hand&quot; with setUp code in your test.  Just because<br/>\nyou are using the Hibernate container to hook up your objects in<br/>\nproduction doesn&#39;t mean that you can&#39;t do manual setup for unit testing.<br/>\n<br/>\n3. Testing that the transactions are working properly should be an<br/>\nentirely different test than making sure the DB updates work.  Here is an<br/>\nexample transaction test case, with the associated method that builds the<br/>\nSpring transaction manager.<br/>\n<br/>\npublic class CellServiceTxnTestDb extends TestCase {<br/>\n<br/>\n.    public void testTransactonRollback() throws Exception {<br/>\n.        CellServiceImpl impl = new CellServiceImpl() {<br/>\n.            protected void touchCampaignUpdateDate(Cell cell) {<br/>\n.                throw new RuntimeException(&quot;Campaign table update had a<br/>\nproblem!&quot;);<br/>\n.            }<br/>\n.        };<br/>\n.        impl.setHibernate(IntegrationLocator.getHibernate());<br/>\n<br/>\n.        CellService service = (CellService)<br/>\n.            ServiceLocator.createTxnProxy(impl, CellService.class);<br/>\n<br/>\n.        Cell cell = service.findByPrimaryKey(new Integer(-1));<br/>\n.        cell.setName(&quot;Trying to change the name&quot;);<br/>\n.        try {<br/>\n.            service.updateCellHeader(cell);<br/>\n.            fail(&quot;Testing the test&quot;);<br/>\n.        } catch (RuntimeException expected) {}<br/>\n<br/>\n.        cell = service.findByPrimaryKey(new Integer(-1));<br/>\n.        assertEquals(&quot;Should not change the name!!&quot;, &quot;Original&quot;,<br/>\ncell.getName());<br/>\n.    }<br/>\n.}<br/>\n<br/>\n.    /** Public so tests can use this method also */<br/>\n.    public static Object createTxnProxy(Object target, Class<br/>\ninterfaceClass) {<br/>\n.        if (txnManager == null) {<br/>\n.            // lazily load this<br/>\n.            txnManager = new HibernateTransactionManager(<br/>\n.                    IntegrationLocator.getSessionFactory());<br/>\n.        }<br/>\n.        TransactionProxyFactoryBean proxy = new<br/>\nTransactionProxyFactoryBean();<br/>\n.        proxy.setTransactionManager(txnManager);<br/>\n.        proxy.setTarget(target);<br/>\n.        proxy.setTransactionAttributes(getTxnProperties(interfaceClass));<br/>\n.        proxy.afterPropertiesSet();<br/>\n.        return proxy.getObject();<br/>\n.    }<br/>\n<br/>\n<br/>\n<br/>\n<br/>\nIn general, architect your system so that you can hook up the objects<br/>\nhowever you want for unit testing.  Then separate them through interfaces<br/>\nand test them one at a time.<br/>\n<br/>\n<br/>\nJeff Nielsen<br/>\nDigital Focus<br/>\nwww.digitalfocus.com<br/>\n<br/>\n<blockquote><span title=\"qreply\"> &gt; Hi<br/>\n&gt;<br/>\n&gt; I am working a project with a contactor where we are using Spring and<br/>\n&gt; Hibernate (both which are new to me, and somewhat new to the<br/>\n&gt; contractor).<br/>\n&gt;<br/>\n&gt; Our app is a Swing client calling WebServices running in WebSphere.<br/>\n&gt; The Webservices uses a DAO object which extends the<br/>\n&gt; HibernateDaoSupport class provided by the Spring framework.<br/>\n&gt;<br/>\n&gt; Now according to the contractor, the way we have the transaction<br/>\n&gt; manager setup in our applicationContext.xml file<br/>\n&gt; using &quot;PROPAGATION_REQUIRED&quot; for our get/save/update/delete<br/>\n&gt; operations means that the &quot;commit&quot; of the transaction will only occur<br/>\n&gt; when the starting method is finished.<br/>\n&gt;<br/>\n&gt; So if we were to create a JUnit test:<br/>\n&gt;<br/>\n&gt; public void testUpdate()<br/>\n&gt; {<br/>\n&gt;         InvestorWebServices iws = new InvestorWebServices();<br/>\n&gt;         InvestorDTO identity = iws.getInvestorByPK(new Integer<br/>\n&gt; (7000011));<br/>\n&gt;         identity.setName(&quot;Bob);<br/>\n&gt;<br/>\n&gt;         iws.updateInvestor(identity);<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; He is telling me that the commit to the Db will not have happened<br/>\n&gt; until the testUpdate method has completed.<br/>\n&gt;<br/>\n&gt; As part of the test we want to be able to assert that the record in<br/>\n&gt; the db has indeed been updated so in our current situation we could<br/>\n&gt; not do that within the testUpdate method.<br/>\n&gt;<br/>\n&gt; I was wondering if anyone with more experience than us is doing<br/>\n&gt; similar testing with Spring/Hibernate and how are the doing such<br/>\n&gt; testing?<br/>\n&gt;<br/>\n&gt; On idea I have just briefly read about looked like it had different<br/>\n&gt; applicationContext.xml files, and so perhaps creating one for testing<br/>\n&gt; so that the commit occurs as soon as iws.updateInvestor(identity) is<br/>\n&gt; called and the assertion of the db can be then done after the call.<br/>\n&gt; Is that feasible?<br/>\n&gt;<br/>\n&gt; Thanks for any advice.<br/>\n&gt;<br/>\n&gt; Shane<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; Yahoo! Groups Links<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 11982, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1095189230", 
    "canDelete": false, 
    "nextInTopic": 12071, 
    "prevInTopic": 11972, 
    "headers": {
        "inReplyToHeader": "PGNpNTNtZisyZmF2QGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PDYwOTE1LjIwNC4xNTYuMC4xMC4xMDk1MTg5MjMwLnNxdWlycmVsQG1haWwuaG9zdDU0YS5zaW1wbGljYXRvLmNvbT4=", 
        "referencesHeader": "PGNpNTNtZisyZmF2QGVHcm91cHMuY29tPg=="
    }
}