{
    "numMessagesInTopic": 56, 
    "nextInTime": 6228, 
    "senderId": "8QHEfsjJJjMNa-0TPygcskaC-D-J9V3wHqItpYwZNy0w0slzy_Ya25i0XJlEwUxru7zt92Ord12RPCkV6QfrqiQxM74h9uncC38itf-hRCLCtvm9Htk", 
    "systemMessage": false, 
    "subject": "Looking for some &quot;Best Practices&quot;", 
    "from": "&quot;Chermside, Michael&quot; &lt;mchermside@...&gt;", 
    "authorName": "Chermside, Michael", 
    "msgSnippet": "Hi! I am starting at a new company, and am starting on a new, fairly large project. As such, I m presented with a fairly unique opportunity to establish some", 
    "msgId": 6227, 
    "profile": "mcherm", 
    "topicId": 6227, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 130483429, 
    "messageBody": "<div id=\"ygrps-yiv-1243271136\">Hi!<br/>\n<br/>\nI am starting at a new company, and am starting on a new, fairly large<br/>\nproject. As such, I&#39;m presented with a fairly unique opportunity to<br/>\nestablish some standard practices for unit testing.<br/>\n<br/>\nA few things are obvious. Yes, writing unit tests for all new code<br/>\nshould be STRONGLY ENCOURAGED. Yes, the JUnit framework is what we<br/>\nwill use for launching our tests. <br/>\n<br/>\nSome are less obvious, but I&#39;m still clear on what to do. For instance,<br/>\nwriting tests that include the database are often QUITE difficult. Not<br/>\neveryone has a copy of Oracle; we can&#39;t just erase tables willy-nilly<br/>\nto set up for each test; etc. So I will use mock objects (hopefully<br/>\nstarting from those at www.mockobjects.com) to simulate the connection,<br/>\nand other &quot;external&quot; data sources/sinks.<br/>\n<br/>\nAnd there are a few questions on which I&#39;d like to hear input from<br/>\nsome with more experience so I can start out using &quot;Best Practices&quot;<br/>\ninstead of having to learn from my OWN experience.<br/>\n<br/>\nQUESTION 1:<br/>\n   Where do my JUnit unit tests go?<br/>\n   <br/>\n   I see 3 likely answers... (a) make each an inner class of the<br/>\n   class being tested, (b) for every class &quot;Foo&quot; have a class called <br/>\n   &quot;TestFoo&quot; in the same package, or (c) have a separate (but parallel<br/>\n   hierarchy of classes... SOURCE/com/pkg/Foo.java is tested by <br/>\n   TEST/com/pkg/TestFoo.java.<br/>\n<br/>\n   I lean towards (c) because it makes it easy to build the &quot;real&quot; code<br/>\n   and the &quot;test&quot; code separately, and omit the &quot;test&quot; code from<br/>\n   production deployment. Are there other significant issues here?<br/>\n<br/>\n<br/>\nQUESTION 2:<br/>\n   How do I automatically build the suite of all tests?<br/>\n<br/>\n   For each class, I can have several methods called &quot;testXxx()&quot; and<br/>\n   can collect them into a suite to run at once. I can collect the<br/>\n   suites together into larger suites, eventually coalescing into a<br/>\n   suite called &quot;RunAllTests&quot; which does just that. But this requires<br/>\n   me to write each of these suites, and to remember to include each<br/>\n   and every test class. I&#39;d rather if &quot;RunAllTests&quot; just magically<br/>\n   found all of the tests... that way I couldn&#39;t forget to include<br/>\n   one and wind up with some tests that never get run just because I<br/>\n   forgot a line in a suite. How do I create this &quot;magical&quot; <br/>\n   RunAllTests?<br/>\n<br/>\n   Stray thought... if there&#39;s no simple solution in straight java,<br/>\n   I wonder if ant can help me to achieve RunAllTests as an ant<br/>\n   target?<br/>\n<br/>\n<br/>\nQUESTION 3:<br/>\n   How do I &quot;turn on&quot; my mock objects when tests are running?<br/>\n<br/>\n   The most straightforward use of mock objects is to pass them<br/>\n   directly to the code being tested. However, (despite the fact that<br/>\n   this is a bit broader than simply &quot;unit&quot; testing), I plan to have<br/>\n   a lot of tests that exercise an entire sub-system at once. For<br/>\n   example, I might create the input file, run the command, and then<br/>\n   test the output file. But if this &quot;command&quot; opens a connection to<br/>\n   a database (or other system), then I&#39;d like to return a mock<br/>\n   ResultSet instead of a real one. So the code that obtains a DB<br/>\n   connection has to look at some global setting to see if we&#39;re in<br/>\n   &quot;test mode&quot; or &quot;real life&quot;. What is a good way to achieve this --<br/>\n   is it something I&#39;ll have to write for myself?<br/>\n<br/>\n<br/>\nI&#39;m sure I&#39;ll have more questions also, but this email is QUITE long<br/>\nenough as is. Thanks in advance for any feedback, suggestions, or<br/>\npointers to other forums/FAQs for this kind of stuff.<br/>\n<br/>\n-- Michael Chermside</div>", 
    "prevInTime": 6226, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1037725778", 
    "canDelete": false, 
    "nextInTopic": 6228, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PDkwMkExRTcxMEZFQUI3NDA5NjZFQzk5MUMzQTM4QTg5MDNDMzVCMTRASU5HREVYQ0hBTkdFQzEuaW5nZGlyZWN0LmNvbT4="
    }
}