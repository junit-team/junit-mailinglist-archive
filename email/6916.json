{
    "numMessagesInTopic": 41, 
    "nextInTime": 6917, 
    "senderId": "wIVmxf8CbwgKpIccR5qj_NZtvYUmwu7rlPIVHAofG3Wg__QGP7rhQ0g16iIrNEhFtw0bZFVQzh75enZey5soEESNgl9H_NJyxM6G", 
    "systemMessage": false, 
    "subject": "Re: [junit] Programmer Tests and the Database", 
    "from": "Curt Sampson &lt;yahoo_sucks@...&gt;", 
    "authorName": "Curt Sampson", 
    "msgSnippet": "I ll respond to several points made in various messages here. First, WRT to putting all of the SQL in one place in the code : I m not sure what various", 
    "msgId": 6916, 
    "profile": "cjstokyo", 
    "topicId": 6711, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 110189933, 
    "messageBody": "<div id=\"ygrps-yiv-611384730\">I&#39;ll respond to several points made in various messages here.<br/>\n<br/>\nFirst, WRT to putting all of the SQL &quot;in one place in the code&quot;:<br/>\n<br/>\nI&#39;m not sure what various definitions of &quot;in once place&quot; are, but if<br/>\nanybody&#39;s talking about putting all SQL in one class, I&#39;ve worked with<br/>\na system that did that, it was a real pain as far as development went.<br/>\nThe class grew to a enormous size (several thousand lines), and it was<br/>\ndifficult to find the particular bit of code you were looking for, and<br/>\nto find out what other code in the system used it. Dealing with, say,<br/>\nthe database and internal representation of a &quot;user&quot; or a &quot;folder&quot;<br/>\nbecame much easier when we kept all of the code--including SQL--for a<br/>\nuser or folder together, rather than having some (the Java code) in one<br/>\nclass and some (the database code) in another.<br/>\n<br/>\nSecond, I&#39;m not sure where people came up with the &quot;SQL scattered<br/>\nthoughout the application&quot; idea. All of our database code, both the<br/>\nSQL portions and the Java portions, is in one package containing our<br/>\ndatabase interface layer. If you change the database schema, it&#39;s quite<br/>\neasy to find the bits that are using that because we give single objects<br/>\nor small sets of objects the authority over that part of the database.<br/>\nAll access to information about, say, a &quot;user&quot; goes though the class<br/>\nthat owns that information, so that there&#39;s one central point of control<br/>\nover it. And of course running all of the unit tests before a commit<br/>\nwill help make sure that any changes you&#39;ve made to any code--database<br/>\nor other-- do not have bad consequences. If you forgot to modify an SQL<br/>\nstatement that needed to be modified, the unit tests would catch it<br/>\nbefore you commit.<br/>\n<br/>\nYes, these add significant (compared to the non-database tests) time to<br/>\nthe full unit test run. But it&#39;s not as bad as some here have made out.<br/>\nIt&#39;s nowhere near one second per statement, as Rainsberger suggested.<br/>\nOur complete suite of unit tests (for the entire system, not just the<br/>\ndatabase code) takes approximately 35 seconds to run on a modern machine<br/>\n(2GHz P4), and a quick count shows that this includes coverage of 84 SQL<br/>\nstatements in 72 unit tests in the database package, amongst all the<br/>\nrest of it.<br/>\n<br/>\nAs for not running the database tests with every unit test run, I really<br/>\ndon&#39;t like the idea. The Java code is only part of the application code:<br/>\nthe complete application code includes the entire SQL schema and all of<br/>\nthe SQL statements that access it. If you&#39;re not testing that, you&#39;re<br/>\nnot testing your entire application. (We keep the SQL schemas for our<br/>\nvarious databases--we actually have four separate ones we access--in<br/>\nseparate directories from our Java code, but we have a unit testing<br/>\nsystem for that, too, and the full set of unit tests for a database<br/>\nschema, as well as the full set of Java unit tests, is run every time<br/>\nthe schema is touched.)<br/>\n<br/>\nThis also makes nonsense of the idea of having to &quot;search the<br/>\napplication&quot; for SQL statements that need to be modified, even if they<br/>\nwere widely scattered; just run the unit tests and you will very quickly<br/>\nfind every statement that needs to be modified.<br/>\n<br/>\nAs for a few specific points:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; From: Andrew McDonagh &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:andrew.mcdonagh@...\">andrew.mcdonagh@...</a>&gt;<br/>\n&gt;<br/>\n&gt; My point (and there is one honestly ) is that if all of the SQL was in the<br/>\n&gt; resource file in the first place, then its less likely (I feel) that people<br/>\n&gt; would of mixed the cases used within the statements.<br/>\n<br/>\n </span></blockquote>Who cares? The point is, you ran the unit tests and caught all of the<br/>\nproblems. Whether it&#39;s &quot;less likely&quot; that the problem would have appeared<br/>\nin the first place is not nearly so important as that you will catch this<br/>\nand any other such problem with proper testing.<br/>\n<br/>\nDr. Strebel writes that he uses inner classes to deal with database<br/>\ncode; that looks a lot like what we do for getting objects out of the<br/>\ndatabase, actually. I developed a builder interface that contains the<br/>\nSQL query and the code to create objects from the resulting ResultSet,<br/>\nand I pass this builder to a common build method that takes care of the<br/>\nexception handling and other details.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; From: Bob Koss &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:koss@...\">koss@...</a>&gt;<br/>\n&gt;<br/>\n&gt; If you have database access spread throughout your code, different places<br/>\n&gt; will do the accessing differently. One place might use a table to do a join,<br/>\n&gt; another uses a table to create a view, and yet a third uses the table as a<br/>\n&gt; target for a SELECT. Rearrange the schema and it&#39;s rarely clear what the<br/>\n&gt; changes to the app are going to have to be, let alone writing a regex to<br/>\n&gt; locate them.<br/>\n<br/>\n </span></blockquote>Well, there&#39;s no question in my mind that spreading database access out<br/>\nlike this is a bad thing, which is why I don&#39;t do it. (Whatever made<br/>\nanybody think I did, I wonder?) I almsot invariably give a specific<br/>\nclass or small set of related classes ownership over a particular<br/>\ndatabase table or set of related tables. And this helps to make sure<br/>\nthat not only the appropriate embedded SQL code gets changed, but also<br/>\nthe Java code that relies closely on it. And that was my big problem<br/>\nwith pulling the SQL away from this Java code; you might find the SQL<br/>\nmore easily (though as I said, once that SQL class I used in an old<br/>\nproject grew to several thousand lines, we could no longer do even<br/>\nthat), but it makes it harder to see what Java code changes are also<br/>\nrequired.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; From: J. B. Rainsberger &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:jbr@...\">jbr@...</a>&gt;<br/>\n&gt;<br/>\n&gt; If I test your implementation rather than just checking the SQL<br/>\n&gt; string, then I have to run that [taking a lot of time] OR I simply<br/>\n&gt; don&#39;t run those tests. (If I knew ahead of time what would break, then<br/>\n&gt; I wouldn&#39;t want to run all the tests all the time, but I don&#39;t, so I<br/>\n&gt; do.)<br/>\n<br/>\n </span></blockquote>I read this as you suggesting that you want to run all the tests and<br/>\nhave reasonable coverage, but you don&#39;t want to run the SQL code. That<br/>\nmakes no sense to me; if you&#39;re not running the SQL code, you&#39;re not<br/>\ntesting it. Proving that the SQL code compares to some arbitrary string<br/>\nis not at all the same thing as saying that, when executed, it does the<br/>\nright thing in the context of the application, and the surrounding Java<br/>\ncode that uses the result of that SQL statement does the right thing.<br/>\n<br/>\nIn other words, it sounds like you&#39;re not testing the entire application<br/>\nat all. You&#39;re just hoping the SQL will work, rather than proving it by<br/>\nactually executing it and verifying the results.<br/>\n<br/>\n(And as I said, the tests do not take nearly as long as you&#39;ve<br/>\nsuggested, if you set things up properly. There are lots of tricks, such<br/>\nas using very small sets of sample data for the unit tests, that help<br/>\nkeep things moving quickly.)<br/>\n<br/>\ncjs<br/>\n-- <br/>\nCurt Sampson  &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:cjs@...\">cjs@...</a>&gt;   +81 90 7737 2974   <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.netbsd.org\">http://www.netbsd.org</a><br/>\n    Don&#39;t you know, in this new Dark Age, we&#39;re all light.  --XTC</div>", 
    "prevInTime": 6915, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1044783006", 
    "canDelete": false, 
    "nextInTopic": 6918, 
    "prevInTopic": 6915, 
    "headers": {
        "inReplyToHeader": "PDIwMDMwMjA4MTUzNzE5MDM1NC4wNDhDQTg1QUBzc210cC5ibG9vci5pcy5uZXQuY2FibGUucm9nZXJzLmNvbT4=", 
        "messageIdInHeader": "PFBpbmUuTkVCLjQuNTEuMDMwMjA5MTc1NzM0MC41NzBAYW5nZWxpYy5jeW5pYy5uZXQ+", 
        "referencesHeader": "PEtJRUhJQklPQkFFTEpBSElQTkhEQ0VNTENPQUEuc2NvdHRzdGlybGluZ0ByY24uY29tPiA8UGluZS5ORUIuNC41MS4wMzAyMDYxNTQwMzUwLjczNTZAYW5nZWxpYy5jeW5pYy5uZXQ+IDwyMDAzMDIwNjA5MzA1MTA3NjkuMDA0NzM0MEJAc3NtdHAuYmxvb3IuaXMubmV0LmNhYmxlLnJvZ2Vycy5jb20+IDxQaW5lLk5FQi40LjUxLjAzMDIwNzE0MjczNDAuMzY5QGFuZ2VsaWMuY3luaWMubmV0PiA8MjAwMzAyMDgxNTM3MTkwMzU0LjA0OENBODVBQHNzbXRwLmJsb29yLmlzLm5ldC5jYWJsZS5yb2dlcnMuY29tPg=="
    }
}