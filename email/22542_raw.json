{
    "numMessagesInTopic": 23, 
    "nextInTime": 22543, 
    "senderId": "62KoYYSJHmuHPJvhS2Roo4cclWVF7cU2qD6d99eyjWKEHFfEqPhmoGrFy3RV4MC4MKcYyIoAicywXqPuDIXGt6eI", 
    "systemMessage": false, 
    "subject": "Re: [junit] Re: @DataPoints called several times for Theories", 
    "from": "David Saff &lt;david@...&gt;", 
    "authorName": "David Saff", 
    "msgSnippet": "Brett, If developer 1 needs a fresh data point created every time, and developer 2 needs to re-use an expensive-to-create immutable data point, I definitely", 
    "msgId": 22542, 
    "rawEmail": "Return-Path: &lt;david.saff@...&gt;\r\nX-Sender: david.saff@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nX-Received: (qmail 22000 invoked from network); 15 Mar 2010 03:29:02 -0000\r\nX-Received: from unknown (98.137.34.46)\n  by m11.grp.re1.yahoo.com with QMQP; 15 Mar 2010 03:29:02 -0000\r\nX-Received: from unknown (HELO mail-pw0-f54.google.com) (209.85.160.54)\n  by mta3.grp.sp2.yahoo.com with SMTP; 15 Mar 2010 03:29:02 -0000\r\nX-Received: by mail-pw0-f54.google.com with SMTP id 4so1851499pwj.41\n        for &lt;junit@yahoogroups.com&gt;; Sun, 14 Mar 2010 20:29:02 -0700 (PDT)\r\nMIME-Version: 1.0\r\nX-Received: by 10.141.22.16 with SMTP id z16mr5303547rvi.139.1268623741404; Sun, \n\t14 Mar 2010 20:29:01 -0700 (PDT)\r\nIn-Reply-To: &lt;58dba2251003121544p3cd7dd28h1a899ce657f66ad3@...&gt;\r\nReferences: &lt;58dba2251002180943q238dd8dv11ab48736321e178@...&gt;\n\t &lt;hlkif2+3mte@...&gt;\n\t &lt;58dba2251003121544p3cd7dd28h1a899ce657f66ad3@...&gt;\r\nDate: Sun, 14 Mar 2010 23:29:01 -0400\r\nX-Google-Sender-Auth: 30fab8dbbcf94dad\r\nMessage-ID: &lt;4f7da6b91003142029t433633dci348c7da639dad10@...&gt;\r\nTo: junit@yahoogroups.com\r\nCc: Shin Hwei Tan &lt;stan6@...&gt;, Sang Y Baik &lt;sybaik2@...&gt;\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Transfer-Encoding: quoted-printable\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: David Saff &lt;david@...&gt;\r\nSubject: Re: [junit] Re: @DataPoints called several times for Theories\r\nX-Yahoo-Group-Post: member; u=341876227; y=ecBHs2oNX-FnSWbvkqxxODYqdYJ9K6e9p5ReFXWhxFw\r\nX-Yahoo-Profile: dsaff\r\n\r\nBrett,\n\nIf developer 1 needs a fresh data point created every time, and\ndev=\r\neloper 2 needs to re-use an expensive-to-create immutable data\npoint, I def=\r\ninitely want to make it as easy as possible for both to do\nwhat they need t=\r\no do.  Just to be clear, do you agree the below would\nwork with the current=\r\n implementation of Theories?  It&#39;s four lines\nmore of boilerplate, but not =\r\ntotally intractable, in my humble\nopinion:\n\n @RunWith(Theories.class)\n   pu=\r\nblic class TestMutable {\n\n   private static Mutable createdOnce =3D new Mut=\r\nable();\n\n   @DataPoint\n   public static Mutable mutable() {\n     return Cop=\r\ny.copy(createdOnce);\n   }\n\n   @Theory\n   public static testMutate(Mutable a=\r\n) {\n     a.mutate();\n   }\n\n   @Theory\n   public static testNotMutated(Mutab=\r\nle a) {\n     assertFalse(a.isMutated());\n   }\n }\n\nI think though, that requ=\r\niring both the field and the method to be\nthere in the class could restrict=\r\n the ability to share data and\nconcepts.  What would you think of allowing =\r\nfields or methods to\nreturn PontentialAssignment, the type of named referen=\r\nces to data\nvalues used in the Theories runner?  Then we could have:\n\n\n @Ru=\r\nnWith(Theories.class)\n   public class TestMutable {\n\n   @DataPointSource pu=\r\nblic static PotentialAssignment&lt;Mutable&gt; =3D\nCopy.ofMutable(new Mutable());=\r\n\n\n   @Theory\n   public static testMutate(Mutable a) {\n     a.mutate();\n   }=\r\n\n\n   @Theory\n   public static testNotMutated(Mutable a) {\n     assertFalse(=\r\na.isMutated());\n   }\n }\n\nHere, I&#39;m guessing about the typing on PotentialAs=\r\nsignment and the\nname of the DataPointSource annotation, but perhaps the id=\r\nea is clear?\n\n   David Saff\n\nOn Fri, Mar 12, 2010 at 6:44 PM, Brett Daniel =\r\n&lt;brettdaniel@...&gt; wrote:\n&gt; The undergrads I am advising recently push=\r\ned a patch that addresses the\n&gt; issue of mutable data points.\n&gt;\n&gt;\n&gt; http://=\r\ngithub.com/stan6/junit/commit/dcfa3c41446c469a4edc7513e9e7a9b610b04020\n&gt;\n&gt; =\r\nThe patch allows developers to define &quot;copy strategies&quot; that duplicate\n&gt; ma=\r\nrked data points before every theory execution. In this way, every\n&gt; execut=\r\nion receives a pristine data point, which removes the problems caused\n&gt; whe=\r\nn a theory mutates data points. This is orthogonal to datapoint\n&gt; (re)creat=\r\nion, but I think copy strategies may help address the bug that\n&gt; Berin foun=\r\nd.\n&gt;\n&gt; The patch creates a new, optional &quot;copyStrategy&quot; parameter for the\n&gt;=\r\n @DataPoint and @DataPoints annotations. If the developer wants to copy dat=\r\na\n&gt; points, he or she sets the parameter to a class implementing a new\n&gt; Co=\r\npyStrategy interface.\n&gt;\n&gt; Here is an example:\n&gt;\n&gt; =A0@RunWith(Theories.clas=\r\ns)\n&gt; =A0 =A0public class TestMutable {\n&gt;\n&gt; =A0 =A0@DataPoint(copyStrategy =\r\n=3D MutableWithCopyStrategy.class)\n&gt; =A0 =A0public static Mutable mutable =\r\n=3D new Mutable();\n&gt;\n&gt; =A0 =A0@Theory\n&gt; =A0 =A0public static testMutate(Mut=\r\nable a) {\n&gt; =A0 =A0 =A0a.mutate();\n&gt; =A0 =A0}\n&gt;\n&gt; =A0 =A0@Theory\n&gt; =A0 =A0p=\r\nublic static testNotMutated(Mutable a) {\n&gt; =A0 =A0 =A0assertFalse(a.isMutat=\r\ned());\n&gt; =A0 =A0}\n&gt; =A0}\n&gt;\n&gt; In the current implementation of JUnit, the se=\r\ncond theory may fail because\n&gt; the first theory mutates the datapoint. With=\r\n a copy strategy enabled, both\n&gt; theories receive a new value.\n&gt;\n&gt; Strategi=\r\nes can do almost anything: clone the data point, call a factory\n&gt; method, o=\r\nr--as in the following implementation--instantaiate a new object\n&gt; with a c=\r\nopy constructor.\n&gt;\n&gt; =A0public class MutableWithCopyStrategy implements Cop=\r\nyStrategy {\n&gt; =A0 =A0public Object copyDataPoint(Object toCopy) throws Exce=\r\nption {\n&gt; =A0 =A0 =A0return new Mutable((Mutable)toCopy);\n&gt; =A0 =A0}\n&gt; =A0}=\r\n\n&gt;\n&gt; There are several benefits to this implementation. First, the new para=\r\nmeter\n&gt; is completely optional; if it is omitted, the theory runner behaves=\r\n as it\n&gt; always has. Second, it doesn&#39;t require modifying the data point&#39;s =\r\nclass (for\n&gt; example, to add a copy constructor or clone method). Most impo=\r\nrtantly, it\n&gt; makes it clear to the tester that without a copy strategy one=\r\n theory\n&gt; execution can impact another.\n&gt;\n&gt; I have CC&#39;d the two students in=\r\n this email. Please direct any questions to\n&gt; them.\n&gt;\n&gt; Brett\n&gt;\n&gt; On Thu, F=\r\neb 18, 2010 at 5:28 PM, Berin &lt;berin.loritsch@...&gt; wrote:\n&gt;\n&gt;&gt;\n&gt;&gt;\n&gt;&gt;=\r\n I agree with your prognosis, about fresh data points for testing the\n&gt;&gt; th=\r\neories. That is precisely why I proposed reading them once, and cloning\n&gt;&gt; =\r\nthem (making a copy) as needed for each theory. With that approach we even\n=\r\n&gt;&gt; get the protection from mutated data points when you use the @DataPoint =\r\nto\n&gt;&gt; mark a static field.\n&gt;&gt;\n&gt;&gt; Cloning is a much quicker operation, does =\r\nnot execute any constructors. It\n&gt;&gt; merely copies the contents of the objec=\r\nt memory verbatim.\n&gt;&gt;\n&gt;&gt; With the current implementation, if you are not pr=\r\nepared for the\n&gt;&gt; combinatorial affect of 60 data points combined with 60 d=\r\nata points for each\n&gt;&gt; theory there is a major disconnect. The majority of =\r\nthe overhead in this\n&gt;&gt; particular scenario has to do with creating objects=\r\n (with the additional\n&gt;&gt; overhead of doing it by reflection).\n&gt;&gt;\n&gt;&gt; When I =\r\ncreated only one instance of each class instead of two, the\n&gt;&gt; performance =\r\nwas twice as fast (i.e. 37 seconds down to about 16 seconds).\n&gt;&gt;\n&gt;&gt; Essenti=\r\nally the number of times your @DataPoints method is called depends\n&gt;&gt; on th=\r\ne number of parameters in your @Theory and how many theories you have.\n&gt;&gt; E=\r\nssentially the formula for my theory (ha, ha) of the execution is like\n&gt;&gt; t=\r\nhis:\n&gt;&gt;\n&gt;&gt; N^(p-1) + 1\n&gt;&gt;\n&gt;&gt; where:\n&gt;&gt;\n&gt;&gt; N is the number of data points re=\r\nturned by the method\n&gt;&gt; p is the number of parameters\n&gt;&gt; and the + 1 repres=\r\nents the run where the data point is read the first time\n&gt;&gt;\n&gt;&gt; So for 60 da=\r\nta points it is run 61 times for two parameters. With three\n&gt;&gt; parameters i=\r\nt would be called 3601 times. I have to verify with three\n&gt;&gt; parameters. Th=\r\ne theory is called N^p times for sure and that is expected.\n&gt;&gt;\n&gt;&gt; With the =\r\nabove formula, the mapping of number of calls to parameters for 60\n&gt;&gt; data =\r\npoints would be:\n&gt;&gt;\n&gt;&gt; 1 -&gt; 2 (I know this is wrong which gives me doubts o=\r\nn the formula)\n&gt;&gt; 2 -&gt; 61\n&gt;&gt; 3 -&gt; 3601\n&gt;&gt; 3 -&gt; 216001\n&gt;&gt;\n&gt;&gt; Essentially whe=\r\nn the Assignments class needs to make the combinations, it\n&gt;&gt; will collect =\r\nthe data points initially for each theory. It then calls the\n&gt;&gt; data points=\r\n again for each existing data point it collected from the first\n&gt;&gt; read. Wi=\r\nth a third parameter it would take all those combinations again, to\n&gt;&gt; add =\r\nall the permutations for the next round.\n&gt;&gt;\n&gt;&gt; I might be wrong and the rea=\r\nl formula would be like this:\n&gt;&gt;\n&gt;&gt; N^0 + N^1 ... + N^(p-1)\n&gt;&gt;\n&gt;&gt; If this i=\r\ns the correct formula, then if you have 60 data points the number\n&gt;&gt; of tim=\r\nes the method is called would map to the number of parameters like\n&gt;&gt; this:=\r\n\n&gt;&gt;\n&gt;&gt; 1 -&gt; 1\n&gt;&gt; 2 -&gt; 61\n&gt;&gt; 3 -&gt; 3661\n&gt;&gt; 4 -&gt; 219661\n&gt;&gt;\n&gt;&gt;\n&gt;&gt; --- In junit@=\r\nyahoogroups.com &lt;junit%40yahoogroups.com&gt;, Brett Daniel\n&gt;&gt; &lt;brettdaniel@...=\r\n&gt; wrote:\n&gt;&gt; &gt;\n&gt;&gt; &gt; Berin,\n&gt;&gt; &gt;\n&gt;&gt; &gt; When a theory mutates data points, it m=\r\night be beneficial to recreate\n&gt;&gt; &gt; the data point for every theory invocat=\r\nion. Doing so prevents one\n&gt;&gt; &gt; theory execution from affecting others. I w=\r\nrote about this issue in\n&gt;&gt; &gt; the following weblog post:\n&gt;&gt; &gt;\n&gt;&gt; &gt; http://w=\r\nww.brettdaniel.com/archives/2009/09/24/200845/\n&gt;&gt; &gt;\n&gt;&gt; &gt; You are correct, t=\r\nhough, that copying would avoid some of the overhead\n&gt;&gt; &gt; in calling datapo=\r\nint methods. It is interesting you mention this idea,\n&gt;&gt; &gt; because I am cur=\r\nrently overseeing two students who for their senior\n&gt;&gt; &gt; thesis project are=\r\n implementing framework for copying datapoints. I\n&gt;&gt; &gt; will post more infor=\r\nmation to the mailing list as the project\n&gt;&gt; &gt; continues.\n&gt;&gt; &gt;\n&gt;&gt; &gt; Brett\n&gt;=\r\n&gt; &gt;\n&gt;&gt;\n&gt;&gt;\n&gt;&gt;\n&gt;\n&gt;\n&gt; [Non-text portions of this message have been removed]\n&gt;\n=\r\n&gt;\n&gt;\n&gt; ------------------------------------\n&gt;\n&gt; Yahoo! Groups Links\n&gt;\n&gt;\n&gt;\n&gt;\n=\r\n\n", 
    "profile": "dsaff", 
    "topicId": 22425, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 341876227, 
    "prevInTime": 22541, 
    "contentTrasformed": false, 
    "postDate": "1268623741", 
    "canDelete": false, 
    "nextInTopic": 22543, 
    "prevInTopic": 22541, 
    "headers": {
        "inReplyToHeader": "PDU4ZGJhMjI1MTAwMzEyMTU0NHAzY2Q3ZGQyOGgxYTg5OWNlNjU3ZjY2YWQzQG1haWwuZ21haWwuY29tPg==", 
        "messageIdInHeader": "PDRmN2RhNmI5MTAwMzE0MjAyOXQ0MzM2MzNkY2kzNDhjN2RhNjM5ZGFkMTBAbWFpbC5nbWFpbC5jb20+", 
        "referencesHeader": "PDU4ZGJhMjI1MTAwMjE4MDk0M3EyMzhkZDhkdjExYWI0ODczNjMyMWUxNzhAbWFpbC5nbWFpbC5jb20+CSA8aGxraWYyKzNtdGVAZUdyb3Vwcy5jb20+CSA8NThkYmEyMjUxMDAzMTIxNTQ0cDNjZDdkZDI4aDFhODk5Y2U2NTdmNjZhZDNAbWFpbC5nbWFpbC5jb20+"
    }
}