{
    "numMessagesInTopic": 23, 
    "nextInTime": 22541, 
    "senderId": "_6zMpK6oN7g9rLfExVFXW4nPVfDyePOhAP8GbECaqe0ZXYpxUGpxSFxRDmJq99rNe7bnBnQEsUAwfrwh45oBoXiATznkBmkN80V_", 
    "systemMessage": true, 
    "subject": "Re: [junit] Re: @DataPoints called several times for Theories", 
    "from": "Brett Daniel &lt;brettdaniel@...&gt;", 
    "authorName": "Brett Daniel", 
    "msgSnippet": "The undergrads I am advising recently pushed a patch that addresses the issue of mutable data points. ", 
    "msgId": 22540, 
    "profile": "brettddaniel", 
    "topicId": 22425, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 416009989, 
    "messageBody": "<div id=\"ygrps-yiv-190702592\">The undergrads I am advising recently pushed a patch that addresses the<br/>\nissue of mutable data points.<br/>\n<br/>\n<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://github.com/stan6/junit/commit/dcfa3c41446c469a4edc7513e9e7a9b610b04020\">http://github.com/stan6/junit/commit/dcfa3c41446c469a4edc7513e9e7a9b610b04020</a><br/>\n<br/>\nThe patch allows developers to define &quot;copy strategies&quot; that duplicate<br/>\nmarked data points before every theory execution. In this way, every<br/>\nexecution receives a pristine data point, which removes the problems caused<br/>\nwhen a theory mutates data points. This is orthogonal to datapoint<br/>\n(re)creation, but I think copy strategies may help address the bug that<br/>\nBerin found.<br/>\n<br/>\nThe patch creates a new, optional &quot;copyStrategy&quot; parameter for the<br/>\n@DataPoint and @DataPoints annotations. If the developer wants to copy data<br/>\npoints, he or she sets the parameter to a class implementing a new<br/>\nCopyStrategy interface.<br/>\n<br/>\nHere is an example:<br/>\n<br/>\n  @RunWith(Theories.class)<br/>\n    public class TestMutable {<br/>\n<br/>\n    @DataPoint(copyStrategy = MutableWithCopyStrategy.class)<br/>\n    public static Mutable mutable = new Mutable();<br/>\n<br/>\n    @Theory<br/>\n    public static testMutate(Mutable a) {<br/>\n      a.mutate();<br/>\n    }<br/>\n<br/>\n    @Theory<br/>\n    public static testNotMutated(Mutable a) {<br/>\n      assertFalse(a.isMutated());<br/>\n    }<br/>\n  }<br/>\n<br/>\nIn the current implementation of JUnit, the second theory may fail because<br/>\nthe first theory mutates the datapoint. With a copy strategy enabled, both<br/>\ntheories receive a new value.<br/>\n<br/>\nStrategies can do almost anything: clone the data point, call a factory<br/>\nmethod, or--as in the following implementation--instantaiate a new object<br/>\nwith a copy constructor.<br/>\n<br/>\n  public class MutableWithCopyStrategy implements CopyStrategy {<br/>\n    public Object copyDataPoint(Object toCopy) throws Exception {<br/>\n      return new Mutable((Mutable)toCopy);<br/>\n    }<br/>\n  }<br/>\n<br/>\nThere are several benefits to this implementation. First, the new parameter<br/>\nis completely optional; if it is omitted, the theory runner behaves as it<br/>\nalways has. Second, it doesn&#39;t require modifying the data point&#39;s class (for<br/>\nexample, to add a copy constructor or clone method). Most importantly, it<br/>\nmakes it clear to the tester that without a copy strategy one theory<br/>\nexecution can impact another.<br/>\n<br/>\nI have CC&#39;d the two students in this email. Please direct any questions to<br/>\nthem.<br/>\n<br/>\nBrett<br/>\n<br/>\n<blockquote><span title=\"qreply\"> On Thu, Feb 18, 2010 at 5:28 PM, Berin &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:berin.loritsch@...\">berin.loritsch@...</a>&gt; wrote:<br/>\n<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; I agree with your prognosis, about fresh data points for testing the<br/>\n&gt; theories. That is precisely why I proposed reading them once, and cloning<br/>\n&gt; them (making a copy) as needed for each theory. With that approach we even<br/>\n&gt; get the protection from mutated data points when you use the @DataPoint to<br/>\n&gt; mark a static field.<br/>\n&gt;<br/>\n&gt; Cloning is a much quicker operation, does not execute any constructors. It<br/>\n&gt; merely copies the contents of the object memory verbatim.<br/>\n&gt;<br/>\n&gt; With the current implementation, if you are not prepared for the<br/>\n&gt; combinatorial affect of 60 data points combined with 60 data points for each<br/>\n&gt; theory there is a major disconnect. The majority of the overhead in this<br/>\n&gt; particular scenario has to do with creating objects (with the additional<br/>\n&gt; overhead of doing it by reflection).<br/>\n&gt;<br/>\n&gt; When I created only one instance of each class instead of two, the<br/>\n&gt; performance was twice as fast (i.e. 37 seconds down to about 16 seconds).<br/>\n&gt;<br/>\n&gt; Essentially the number of times your @DataPoints method is called depends<br/>\n&gt; on the number of parameters in your @Theory and how many theories you have.<br/>\n&gt; Essentially the formula for my theory (ha, ha) of the execution is like<br/>\n&gt; this:<br/>\n&gt;<br/>\n&gt; N^(p-1) + 1<br/>\n&gt;<br/>\n&gt; where:<br/>\n&gt;<br/>\n&gt; N is the number of data points returned by the method<br/>\n&gt; p is the number of parameters<br/>\n&gt; and the + 1 represents the run where the data point is read the first time<br/>\n&gt;<br/>\n&gt; So for 60 data points it is run 61 times for two parameters. With three<br/>\n&gt; parameters it would be called 3601 times. I have to verify with three<br/>\n&gt; parameters. The theory is called N^p times for sure and that is expected.<br/>\n&gt;<br/>\n&gt; With the above formula, the mapping of number of calls to parameters for 60<br/>\n&gt; data points would be:<br/>\n&gt;<br/>\n&gt; 1 -&gt; 2 (I know this is wrong which gives me doubts on the formula)<br/>\n&gt; 2 -&gt; 61<br/>\n&gt; 3 -&gt; 3601<br/>\n&gt; 3 -&gt; 216001<br/>\n&gt;<br/>\n&gt; Essentially when the Assignments class needs to make the combinations, it<br/>\n&gt; will collect the data points initially for each theory. It then calls the<br/>\n&gt; data points again for each existing data point it collected from the first<br/>\n&gt; read. With a third parameter it would take all those combinations again, to<br/>\n&gt; add all the permutations for the next round.<br/>\n&gt;<br/>\n&gt; I might be wrong and the real formula would be like this:<br/>\n&gt;<br/>\n&gt; N^0 + N^1 ... + N^(p-1)<br/>\n&gt;<br/>\n&gt; If this is the correct formula, then if you have 60 data points the number<br/>\n&gt; of times the method is called would map to the number of parameters like<br/>\n&gt; this:<br/>\n&gt;<br/>\n&gt; 1 -&gt; 1<br/>\n&gt; 2 -&gt; 61<br/>\n&gt; 3 -&gt; 3661<br/>\n&gt; 4 -&gt; 219661<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; --- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a> &lt;junit%40yahoogroups.com&gt;, Brett Daniel<br/>\n&gt; &lt;brettdaniel@...&gt; wrote:<br/>\n&gt; &gt;<br/>\n&gt; &gt; Berin,<br/>\n&gt; &gt;<br/>\n&gt; &gt; When a theory mutates data points, it might be beneficial to recreate<br/>\n&gt; &gt; the data point for every theory invocation. Doing so prevents one<br/>\n&gt; &gt; theory execution from affecting others. I wrote about this issue in<br/>\n&gt; &gt; the following weblog post:<br/>\n&gt; &gt;<br/>\n&gt; &gt; <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.brettdaniel.com/archives/2009/09/24/200845/\">http://www.brettdaniel.com/archives/2009/09/24/200845/</a><br/>\n&gt; &gt;<br/>\n&gt; &gt; You are correct, though, that copying would avoid some of the overhead<br/>\n&gt; &gt; in calling datapoint methods. It is interesting you mention this idea,<br/>\n&gt; &gt; because I am currently overseeing two students who for their senior<br/>\n&gt; &gt; thesis project are implementing framework for copying datapoints. I<br/>\n&gt; &gt; will post more information to the mailing list as the project<br/>\n&gt; &gt; continues.<br/>\n&gt; &gt;<br/>\n&gt; &gt; Brett<br/>\n&gt; &gt;<br/>\n&gt;<br/>\n&gt;  <br/>\n&gt;<br/>\n<br/>\n<br/>\n[Non-text portions of this message have been removed] </span></blockquote></div>", 
    "prevInTime": 22539, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1268437484", 
    "canDelete": false, 
    "nextInTopic": 22541, 
    "prevInTopic": 22452, 
    "headers": {
        "inReplyToHeader": "PGhsa2lmMiszbXRlQGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PDU4ZGJhMjI1MTAwMzEyMTU0NHAzY2Q3ZGQyOGgxYTg5OWNlNjU3ZjY2YWQzQG1haWwuZ21haWwuY29tPg==", 
        "referencesHeader": "PDU4ZGJhMjI1MTAwMjE4MDk0M3EyMzhkZDhkdjExYWI0ODczNjMyMWUxNzhAbWFpbC5nbWFpbC5jb20+CSA8aGxraWYyKzNtdGVAZUdyb3Vwcy5jb20+"
    }
}