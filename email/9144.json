{
    "numMessagesInTopic": 12, 
    "nextInTime": 9145, 
    "senderId": "wiuKBkwkdYAuaCiQUCzkVeN1K1tW9Qi5O4nkFNduB9Qb6J9so_ziMfefPCbVlrkNmy_F6jUzGj8WUMMoe5YIWliu70zL7KAKOycZl8ihzA", 
    "systemMessage": false, 
    "subject": "Re: [junit] Interfaces and Mock Objects", 
    "from": "&quot;J. B. Rainsberger&quot; &lt;jbrains@...&gt;", 
    "authorName": "J. B. Rainsberger", 
    "msgSnippet": "... Serious answer: whenever you need them. ... Write the tests first, then refactor. Use JUnitX if you need access to private parts. Refactoring without tests", 
    "msgId": 9144, 
    "profile": "nails762", 
    "topicId": 9138, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 127224993, 
    "messageBody": "<div id=\"ygrps-yiv-17212181\">gurron2002 wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; I am not sure when to use interfaces in the context of unit testing<br/>\n<br/>\n </span></blockquote>Serious answer: whenever you need them.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; (I haven&#39;t actually implemented any unit tests yet, still figuring<br/>\n&gt; out how to refactor a design to best support unit testing).<br/>\n<br/>\n </span></blockquote>Write the tests first, then refactor. Use JUnitX if you need access to <br/>\nprivate parts. Refactoring without tests is like walking a tightrope <br/>\nwithout a net. You can do it, but I wouldn&#39;t.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Given a class Foo for which I want to create a mock object:<br/>\n&gt; <br/>\n&gt; public class Foo {<br/>\n&gt;       public void doSomething() {<br/>\n&gt;             ...<br/>\n&gt;       }<br/>\n&gt; }<br/>\n&gt; <br/>\n&gt; What is the better approach? To define an interface that only the<br/>\n&gt; mock object and the original object implement or to subclass Foo?<br/>\n<br/>\n </span></blockquote>My advice: Extract the narrowest interface that could possibly work and <br/>\nimplement it.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; I don&#39;t see a reason to to use an interface if it is only going to be<br/>\n&gt; implemented once (not counting the mock object, I can achieve the<br/>\n&gt; same overriding methods). Am I missing something? Or is it &quot;good<br/>\n&gt; design&quot; to specify the contract of a class with an interface even if<br/>\n&gt; there is not going to be more than one implementation ever?<br/>\n<br/>\n </span></blockquote>First, you don&#39;t know how many implementations there will ever be. Even <br/>\nif you really think you know, you don&#39;t. That&#39;s nothing bad about you -- <br/>\nno-one knows.<br/>\n<br/>\nNext, I am experimenting with the following Java implementation pattern. <br/>\nA refactoring, I think.<br/>\n<br/>\n    * Replace private/public separation with interface/implementation <br/>\nseparation.<br/>\n<br/>\nIn other words, rather than make methods private, which can hurt <br/>\ntesting, extract a client interface and ship it to the client. Hide <br/>\ncreating instances behind factories. In other words, do like JDBC, JMS, <br/>\nEJB...<br/>\n<br/>\nI like it. Thoughts?<br/>\n-- <br/>\nJ. B. Rainsberger,<br/>\nDiaspar Software Services<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.diasparsoftware.com\">http://www.diasparsoftware.com</a> :: +1 416 791-8603<br/>\nLet&#39;s write software that people understand</div>", 
    "prevInTime": 9143, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1061481214", 
    "canDelete": false, 
    "nextInTopic": 9151, 
    "prevInTopic": 9138, 
    "headers": {
        "inReplyToHeader": "PGJodGh2ZisxMGNndkBlR3JvdXBzLmNvbT4=", 
        "messageIdInHeader": "PDNGNDRFQUZFLjIwNTA4MDhAcm9nZXJzLmNvbT4=", 
        "referencesHeader": "PGJodGh2ZisxMGNndkBlR3JvdXBzLmNvbT4="
    }
}