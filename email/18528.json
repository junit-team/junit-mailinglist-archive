{
    "numMessagesInTopic": 23, 
    "nextInTime": 18529, 
    "senderId": "Lp3CXePXSntVzd9Uhv-tZ8x4ZfmX7QDYiH-l3DdbViWb1CrMwuwMuYx1vzOmnXHOaZ5jaJO03ZAdp2Q3bM3Q8K73bs-5Snz7Uy_hebF81_enYmxC3dGn7pmxUgJUCZP9yX_hniQ", 
    "systemMessage": false, 
    "subject": "Re: [junit] Re: Essay: The Trouble With JUnit", 
    "from": "&quot;=?UTF-8?Q?C=C3=A9dric_Beust_=E2=99=94_?=&quot; &lt;cbeust@...&gt;", 
    "authorName": "Cédric Beust ♔", 
    "msgSnippet": "As much as I like the idea, I really don t think Design by Contract scales anywhere beyond collections and toy projects. Either your test is very simple and", 
    "msgId": 18528, 
    "profile": "cbeust", 
    "topicId": 18392, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 199443513, 
    "messageBody": "<div id=\"ygrps-yiv-575210782\">As much as I like the idea, I really don&#39;t think Design by Contract scales<br/>\nanywhere beyond collections and toy projects.<br/>\n<br/>\nEither your test is very simple and you are better off capturing it as an<br/>\nassert, or it&#39;s complex enough to require an entire test in itself, and the<br/>\nvalue of completely tying it to the class doesn&#39;t seem to add much compared<br/>\nto simply having a tests for it.<br/>\n<br/>\nAnd in general, I still believe that pre/post conditions and invariants are<br/>\nextremely hard to express to the point where spending time coming up with<br/>\nthem is wasted time compared to writing a series of functional tests.  If<br/>\nsomebody disagrees, I&#39;ll be happy to post some of the code I deal with on a<br/>\nregular basis and see if they can come up with reasonable invariants and<br/>\nconditions :-)<br/>\n<br/>\nDesign by Contract:  nice idea, great for education purposes, but outclassed<br/>\nby functional testing in the real world.<br/>\n<br/>\n-- <br/>\nCedric<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://testng.org\">http://testng.org</a><br/>\n<br/>\n<br/>\n<br/>\n<blockquote><span title=\"qreply\"> On 12/11/06, Jan Theodore Galkowski &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:jtgalkowski@...\">jtgalkowski@...</a>&gt; wrote:<br/>\n&gt;<br/>\n&gt; Hi David,<br/>\n&gt;<br/>\n&gt; Well, it&#39;s from the work of Tony Hoare and others that if programs are<br/>\n&gt; annotated with a rich enough (minimally complete) set of pre- and post-<br/>\n&gt; conditions describing state changes using predicate assertions, it&#39;s<br/>\n&gt; possible to delete the intervening program (or state transformation)<br/>\n&gt; steps and &quot;execute&quot; the program using just the stated pre- and post-<br/>\n&gt; conditions.  This is part of the motivation behind Bertrand Meyer&#39;s work<br/>\n&gt; with Eiffel and Design By Contract.<br/>\n&gt;<br/>\n&gt; This is not, at present, a part of the test-driven methodology, as far<br/>\n&gt; as I know, but it is implicit in the sense that by writing tests first,<br/>\n&gt; the requirements for the code under test are supposed to be expressed in<br/>\n&gt; the tests.  Then, one invests in the &quot;throw anything at it&quot; cycle where<br/>\n&gt; code is written, tested using an xUnit, if it&#39;s red, add another<br/>\n&gt; assertion to cover the case missed. If it&#39;s green, extend the scope of<br/>\n&gt; the requirements to better approximate what&#39;s wanted.  There&#39;s cleanup<br/>\n&gt; via refactoring needed for code.<br/>\n&gt;<br/>\n&gt; As mentioned, refactoring should probably be applied to the tests as<br/>\n&gt; well, assuming they are complicated enough.  And, what I&#39;m getting at is<br/>\n&gt; that perhaps the language of predicates, as well known and studied as it<br/>\n&gt; is, isn&#39;t quite enough to make truly requirements-level test<br/>\n&gt; prescriptions easy.<br/>\n&gt;<br/>\n&gt; Let&#39;s get narrow and specific for a moment.  Suppose you have a Python-<br/>\n&gt; like language and want to assert that the head of a list L is &#39;foo&#39;:<br/>\n&gt;<br/>\n&gt;   &#39;foo&#39; == L[0]<br/>\n&gt;<br/>\n&gt; Sure, but you&#39;re obligated also to test first that L has at least one<br/>\n&gt; element, lest the assertion itself fail.  Yes, you can check first<br/>\n&gt;<br/>\n&gt;   1 &lt;= L.count(&#39;foo&#39;)<br/>\n&gt;<br/>\n&gt; then<br/>\n&gt;<br/>\n&gt;    &#39;foo&#39; == L[0]<br/>\n&gt;<br/>\n&gt; or even<br/>\n&gt;<br/>\n&gt;    1 &lt;= L.count(&#39;foo&#39;) and &#39;foo&#39; == L[0]<br/>\n&gt;<br/>\n&gt; relying upon short-circuiting evaluation, but wouldn&#39;t it be easier to<br/>\n&gt; use some kind of Prolog-like matching notation<br/>\n&gt;<br/>\n&gt;     L == [: &#39;foo&#39; . % :]<br/>\n&gt;<br/>\n&gt; where I&#39;ve arbitrarily co-opted special brackets &quot;[:&quot; and &quot;:]&quot; to<br/>\n&gt; indicate the (LISP) CONS-like pairing?  If actually realized in Python<br/>\n&gt; the notation could be built into a tuple, but the idea would be if the<br/>\n&gt; match fails, the assertion fails.<br/>\n&gt;<br/>\n&gt; If requirements are the focus of a test-driven approach, then the (a)<br/>\n&gt; language for expressing tests ought to not tie up the hands of the<br/>\n&gt; programmer with worries about ancillary conditions, (b) it ought to be<br/>\n&gt; perspicacious, and (c) it should allow an economy of expression which<br/>\n&gt; predicates and the base language don&#39;t.  The problems of writing &quot;bigger<br/>\n&gt; requirements&quot; get, well, bigger if the conditions tested rely upon<br/>\n&gt; exogenous factors, like status of external resources or the execution of<br/>\n&gt; other whole subsystems.  At present, I suppose try-except-else could be<br/>\n&gt; put into the tests, but I think that&#39;s really a distraction.  I&#39;d<br/>\n&gt; probably encapsulate it in a function and then call the function in the<br/>\n&gt; assertion.  All I&#39;m asking is why? and can&#39;t we do better?<br/>\n&gt;<br/>\n&gt; I&#39;m sure once such a natural patterns sublanguage was decided, it could<br/>\n&gt; be built with present facilities in something like Python, Smalltalk,<br/>\n&gt; SCHEME, LISP, probably Java and C#.  As for jsunit,  phpunit,  other<br/>\n&gt; such,  I have my doubts.  There&#39;s a point of separation here: xUnit is a<br/>\n&gt; ubiquitous metapattern for testing.  Here, when seeing &quot;tests&quot; as a<br/>\n&gt; means of stating program requirements, we&#39;re leaving ubiquity aside and<br/>\n&gt; reaching for bigger things.<br/>\n&gt;<br/>\n&gt; Leaving the narrow and specific, don&#39;t we really want to separate tests<br/>\n&gt; of a program fragment into two different kinds?  One kind tests whether<br/>\n&gt; the conditions we expect to be established for the fragment to execute<br/>\n&gt; are actually there, the precondition.  The other kind tests whether the<br/>\n&gt; fragment actually achieved what we expect it to, the postcondition.<br/>\n&gt; Preconditions are in part a check that our tests themselves are properly<br/>\n&gt; formed.  In fact, although there&#39;s value in the unit-testing emphasis of<br/>\n&gt; test-driven, we might carry these new kinds of test assertions over to<br/>\n&gt; &quot;string testing&quot;, where each program fragment brings its precondition<br/>\n&gt; with it preceding it, and a postcondition with it succeeding it, and we<br/>\n&gt; can then test a series of fragments at once.<br/>\n&gt;<br/>\n&gt; This is a small step away from Meyer&#39;s ultimate world.  I&#39;ve often<br/>\n&gt; thought how nice it would be if the methods of a class could be<br/>\n&gt; discriminated among not only by their signature (argument numbers and<br/>\n&gt; types), but by an Eiffel-like &quot;require&quot; precondition that needs to be<br/>\n&gt; satisfied before the method is picked.  This would further suppress the<br/>\n&gt; need for case analysis in nested if-then-else structures.<br/>\n&gt;<br/>\n&gt; There&#39;s more opportunity for innovation in notation with postconditions,<br/>\n&gt; too.  How often have *you* wanted to readily express a test relating the<br/>\n&gt; value of a variable after a fragment to that before it?  Sure, you can<br/>\n&gt; do this by introducing new variables in the test fixture, declaring them<br/>\n&gt; appropriately where that&#39;s needed, but wouldn&#39;t it be nice to have a<br/>\n&gt; simple notation for it, like for a list L, checking that &#39;foo&#39; was<br/>\n&gt; properly appended (using Python terminology again):<br/>\n&gt;<br/>\n&gt;     +L == -L.append(&#39;foo&#39;)<br/>\n&gt;<br/>\n&gt; if the prefix operators &quot;+&quot; and &quot;-&quot; were used to denote &quot;after&quot; and<br/>\n&gt; &quot;before&quot;, respectively.<br/>\n&gt;<br/>\n&gt; Whether there should also be a special class of tests for loop or<br/>\n&gt; recursion invariants is something that needs further thought.<br/>\n&gt;<br/>\n&gt; David, does this help?<br/>\n&gt;<br/>\n&gt; -- Jan<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; Yahoo! Groups Links<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n<br/>\n<br/>\n-- <br/>\nCédric<br/>\n<br/>\n<br/>\n[Non-text portions of this message have been removed] </span></blockquote></div>", 
    "prevInTime": 18527, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1165868958", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 18527, 
    "headers": {
        "inReplyToHeader": "PDExNjU4NTY5NDIuMTAwMjUuMjc5OTA0MDIzQHdlYm1haWwubWVzc2FnaW5nZW5naW5lLmNvbT4=", 
        "messageIdInHeader": "PGI4NmI2YTljMDYxMjExMTIyOW02NDE3ZjVhOW8zZmZlNTgxNDBiZjhiZTBmQG1haWwuZ21haWwuY29tPg==", 
        "referencesHeader": "PDExNjU4NTY5NDIuMTAwMjUuMjc5OTA0MDIzQHdlYm1haWwubWVzc2FnaW5nZW5naW5lLmNvbT4="
    }
}