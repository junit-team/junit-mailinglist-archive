{
    "numMessagesInTopic": 8, 
    "nextInTime": 22939, 
    "senderId": "WkY6aySkpIeOZpC6xC1tQ_u7qZYx4hKafQP92xaYgKvM5XCevTA_r3uu5Ef2b9vlJ0iNgT07RbsmhBiD8ExmTdwFvmsR", 
    "systemMessage": false, 
    "subject": "Re: [junit] Common Test Runner for JVM", 
    "from": "Bill Venners &lt;bill@...&gt;", 
    "authorName": "Bill Venners", 
    "msgSnippet": "Hi Esko, ... What you say you want here makes sense. My point is that it doesn t require nested tests. You can do it with nested descriptions. That s the", 
    "msgId": 22938, 
    "profile": "billvenners", 
    "topicId": 22933, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 416990097, 
    "messageBody": "<div id=\"ygrps-yiv-955828944\">Hi Esko,<br/>\n<br/>\n<blockquote><span title=\"qreply\"> On Mon, Sep 13, 2010 at 12:18 PM, Esko Luontola &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:esko.luontola@...\">esko.luontola@...</a>&gt; wrote:<br/>\n&gt;&gt;  &gt; In terms of IDE integration, JUnit just reports a tree of<br/>\n&gt;&gt;  &gt; Descriptions, and results against them. Runners are free to structure<br/>\n&gt;&gt;  &gt; these trees however they wish. Have you run into IDE limitations for<br/>\n&gt;&gt;  &gt; displaying/interacting with these trees?<br/>\n&gt;&gt;  &gt;<br/>\n&gt;&gt; I would question the need for nesting tests. I can easily see the benefit<br/>\n&gt;&gt; of nesting closures in test code. Several traits in ScalaTest do that, but<br/>\n&gt;&gt; the model I use in ScalaTest is that each leaf node is one test. The<br/>\n&gt;&gt; closures surrounding the leaf nodes are descriptions, not tests themselves.<br/>\n&gt;&gt; I would think you and Eric could adopt that approach in Specs and Specsy<br/>\n&gt;&gt; without much trouble.<br/>\n&gt;<br/>\n&gt; It would be possible for me to detect the leaf nodes after the tests<br/>\n&gt; have been run, but I prefer the UI to show the correct mental model of<br/>\n&gt; what is happening during test runs.<br/>\n&gt;<br/>\n&gt; To illustrate, here is a partial version of one of Specsy&#39;s example<br/>\n&gt; specs with some println() debug statements.<br/>\n&gt;<br/>\n&gt; @RunWith(classOf[Specsy])<br/>\n&gt; class StackSpec extends Spec {<br/>\n&gt;   val stack = new scala.collection.mutable.Stack[String]<br/>\n&gt;   println(stack)<br/>\n&gt;<br/>\n&gt;   &quot;When objects have been pushed onto a stack&quot; &gt;&gt; {<br/>\n&gt;     stack.push(&quot;pushed first&quot;)<br/>\n&gt;     stack.push(&quot;pushed last&quot;)<br/>\n&gt;     println(stack)<br/>\n&gt;<br/>\n&gt;     &quot;the object pushed last is popped first&quot; &gt;&gt; {<br/>\n&gt;       val poppedFirst = stack.pop()<br/>\n&gt;       assertThat(poppedFirst, is(&quot;pushed last&quot;))<br/>\n&gt;       println(stack)<br/>\n&gt;     }<br/>\n&gt;     &quot;the object pushed first is popped last&quot; &gt;&gt; {<br/>\n&gt;       stack.pop()<br/>\n&gt;       val poppedLast = stack.pop()<br/>\n&gt;       assertThat(poppedLast, is(&quot;pushed first&quot;))<br/>\n&gt;       println(stack)<br/>\n&gt;     }<br/>\n&gt;   }<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; To execute that, Specsy needs to instantiate and run the class two<br/>\n&gt; times. The first test run will print:<br/>\n&gt;<br/>\n&gt; Stack()<br/>\n&gt; Stack(pushed last, pushed first)<br/>\n&gt; Stack(pushed first)<br/>\n&gt;<br/>\n&gt; The second test run will print:<br/>\n&gt;<br/>\n&gt; Stack()<br/>\n&gt; Stack(pushed last, pushed first)<br/>\n&gt; Stack()<br/>\n&gt;<br/>\n&gt; My vision is that the UI would visualize where one test ends and another<br/>\n&gt; begins. It would provide the same information as the following examples<br/>\n&gt; (but better visualized ;).<br/>\n&gt;<br/>\n&gt; Test run 1:<br/>\n&gt;<br/>\n&gt; -- &lt;net.orfjackal.specsy.examples.StackSpec&gt;<br/>\n&gt; Stack()<br/>\n&gt; --     &lt;When objects have been pushed onto a stack&gt;<br/>\n&gt; Stack(pushed last, pushed first)<br/>\n&gt; --         &lt;the object pushed last is popped first&gt;<br/>\n&gt; Stack(pushed first)<br/>\n&gt; --         &lt;/the object pushed last is popped first&gt;<br/>\n&gt; --     &lt;/When objects have been pushed onto a stack&gt;<br/>\n&gt; -- &lt;/net.orfjackal.specsy.examples.StackSpec&gt;<br/>\n&gt;<br/>\n&gt; Test run 2:<br/>\n&gt;<br/>\n&gt; -- &lt;net.orfjackal.specsy.examples.StackSpec&gt;<br/>\n&gt; Stack()<br/>\n&gt; --     &lt;When objects have been pushed onto a stack&gt;<br/>\n&gt; Stack(pushed last, pushed first)<br/>\n&gt; --         &lt;the object pushed first is popped last&gt;<br/>\n&gt; Stack()<br/>\n&gt; --         &lt;/the object pushed first is popped last&gt;<br/>\n&gt; --     &lt;/When objects have been pushed onto a stack&gt;<br/>\n&gt; -- &lt;/net.orfjackal.specsy.examples.StackSpec&gt;<br/>\n&gt;<br/>\n&gt; Then when I select &quot;StackSpec&quot; or &quot;When objects have been pushed onto a<br/>\n&gt; stack&quot; in the tree of tests shown by the UI, it would show both of those<br/>\n&gt; test runs, because those tests were included in both of them. But if I<br/>\n&gt; select &quot;the object pushed last is popped first&quot; then it will show only<br/>\n&gt; test run 1, and if I select &quot;the object pushed first is popped last&quot; it<br/>\n&gt; will show only test run 2.<br/>\n&gt;<br/>\nWhat you say you want here makes sense. My point is that it doesn&#39;t<br/>\nrequire nested tests. You can do it with nested descriptions. That&#39;s<br/>\nthe approach I take in ScalaTest. In ScalaTest the test names for<br/>\nStackSpec two tests would be:<br/>\n<br/>\nWhen objects have been pushed onto a stack the object pushed last is<br/>\npopped first<br/>\nWhen objects have been pushed onto a stack the object pushed first is<br/>\npopped last<br/>\n<br/>\nBut when you run it through ScalaTest&#39;s standard out reporter, for<br/>\nexample, the output would look something like:<br/>\n<br/>\nStackSpec:<br/>\nWhen objects have been pushed onto a stack<br/>\n- the object pushed first is popped last<br/>\n- the object pushed first is popped last<br/>\n<br/>\nThe output looks like a specification. The number of tests here is 2,<br/>\nnot 3, because the outer closure is not a test with two tests inside<br/>\nit but a description clause with two tests inside it. You could write<br/>\na reporter that shows these specification-style results as a tree that<br/>\ncan have the various branches opened and closed, which is I think what<br/>\nyou&#39;re really after.<br/>\n<br/>\nTo me conceptually it is fuzzy to say you can nest a test inside<br/>\nanother test. If an inner test fails, does that mean all the enclosing<br/>\nouter tests fail too? It isn&#39;t clear.<br/>\n<br/>\nThe other thing I heard you mention as a deficiency in JUnit&#39;s runner<br/>\nis that tests need to have unique names. (I&#39;m not sure that&#39;s true of<br/>\nJUnit but I&#39;ll take your work on it.) ScalaTest&#39;s runner does not<br/>\nrequire that tests have unique names, but Suite does. The reason is it<br/>\nallows you to run just one test by providing its name. So while I<br/>\nthink the runner needn&#39;t have this requirement, I think it is useful<br/>\nto ask a suite of tests to run just one test, and a unique name<br/>\nrequirement facilitates that.<br/>\n<br/>\nBill<br/>\n----<br/>\nBill Venners<br/>\nArtima, Inc.<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.artima.com\">http://www.artima.com</a> </span></blockquote></div>", 
    "prevInTime": 22937, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1284407950", 
    "canDelete": false, 
    "nextInTopic": 22939, 
    "prevInTopic": 22937, 
    "headers": {
        "inReplyToHeader": "PDRDOEU3OTFELjUwNDA3MDRAZ21haWwuY29tPg==", 
        "messageIdInHeader": "PEFBTkxrVGlrOGhDUmdyQXZLV3BlZ0w4QmgrX1FSWXYtYzUzWS1uUE84NVFoMEBtYWlsLmdtYWlsLmNvbT4=", 
        "referencesHeader": "PDRDOEJGREU3LjMwMTA2MDNAZ21haWwuY29tPgk8QUFOTGtUaW40QVhrOEJHY2JYR2ZtNjhLUUZ6THFiVnprK20yMkNyY1VnUnQxQG1haWwuZ21haWwuY29tPgk8QUFOTGtUaW0xMU9STzY4aXJGaEhyVkNCdnFIOHZLOUJRRzI2d2lVeFdkOVpkQG1haWwuZ21haWwuY29tPgk8NEM4RTc5MUQuNTA0MDcwNEBnbWFpbC5jb20+"
    }
}