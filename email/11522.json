{
    "numMessagesInTopic": 18, 
    "nextInTime": 11523, 
    "senderId": "FjRQkqrn-bP7zNsV-93sIXtzGdO1OzB5tl9vyVgGkeiifEfLknNHDydIvwPLZHsEa8oid9zG76cjLxMvYA1MPVQ9jekkXet8NfHHVpL4NQ", 
    "systemMessage": false, 
    "subject": "Re: [junit] Re: Did my question get missed, somehow?", 
    "from": "&quot;J. B. Rainsberger&quot; &lt;jbrains@...&gt;", 
    "authorName": "J. B. Rainsberger", 
    "msgSnippet": "... Rudeness objection. I expressly did not dismiss your point. [I have removed some items in light of a realization, late in your message, of what s really", 
    "msgId": 11522, 
    "profile": "nails762", 
    "topicId": 11495, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 127224993, 
    "messageBody": "<div id=\"ygrps-yiv-2126787402\">cypherfox wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; The problem with dismissing it like<br/>\n&gt; that is...<br/>\n<br/>\n </span></blockquote>Rudeness objection. I expressly did not dismiss your point.<br/>\n<br/>\n[I have removed some items in light of a realization, late in your <br/>\nmessage, of what&#39;s really going on here.]<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;  &gt; &gt; Is there any way to override this, making it call the test*<br/>\n&gt;  &gt; &gt; methods all on the same object?<br/>\n&gt;  &gt;<br/>\n&gt;  &gt; Not without rewriting the framework. The framework was written<br/>\n&gt;  &gt; /expressly with the goal/ of isolating tests from one another. The<br/>\n&gt;  &gt; framework achieves this by executing each test in its own instance<br/>\n&gt; of<br/>\n&gt;  &gt; Test (or TestCase).<br/>\n&gt; <br/>\n&gt; The problem I have with this is it&#39;s completely unlike how code is<br/>\n&gt; actually used.  It&#39;s forcing a framework on code that makes it much<br/>\n&gt; less useful to test.  <br/>\n<br/>\n </span></blockquote>No-one is forcing anything. If JUnit doesn&#39;t work for you, then build <br/>\nyour own testing framework. No-one is going to stop you.<br/>\n<br/>\n<blockquote><span title=\"ireply\">  &gt; I don&#39;t need (or think it&#39;s right at all) to<br/>\n&gt; test all of:<br/>\n&gt; <br/>\n&gt; connect to server<br/>\n&gt; create user<br/>\n&gt; create mailbox<br/>\n&gt; post message<br/>\n&gt; *read message*<br/>\n&gt; delete message<br/>\n&gt; delete mailbox<br/>\n&gt; delete user<br/>\n&gt; disconnect<br/>\n&gt; <br/>\n&gt; all in one test, just in order to test the &#39;read message&#39; in the<br/>\n&gt; middle.<br/>\n<br/>\n </span></blockquote>Well of course not! I would /never/ do such a thing! I would just pull <br/>\nout the &quot;read message&quot; part and test it in isolation. I do that all the <br/>\ntime, successfully, with JUnit.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Are you saying this is expressly what is desired?  That all<br/>\n&gt; the authors think is appropriate is one single &#39;mega test&#39;<br/>\n&gt; that runs all those functions?  Or was testing code that<br/>\n&gt; talks to external stateful systems just not considered?<br/>\n<br/>\n </span></blockquote>No, no, no... I can&#39;t imagine what you would have read that would have <br/>\nsuggested that to you. I apologize for that. Absolutely not.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;  &gt; &gt; My reasoning is that if I write a test which creates, reads,<br/>\n&gt;  &gt; &gt; and deletes the entry from the server, I&#39;m doing too much<br/>\n&gt;  &gt; &gt; in a single test.<br/>\n&gt;  &gt;<br/>\n&gt;  &gt; A test consists of three parts: arrange, act, assert. You need to<br/>\n&gt; set up<br/>\n&gt;  &gt; the system in a desired, known state (arrange),<br/>\n&gt; <br/>\n&gt; Done through the prior tests, and since they&#39;ve presumably<br/>\n&gt; succeeded, the next test can run.<br/>\n<br/>\n </span></blockquote>With object-level testing, /each/ test contains the &quot;Arrange, act, <br/>\nassert&quot; triad. In order for these tests to run quickly, each part must <br/>\nrun quickly, and it turns out that when you make that a goal, good <br/>\nthings happen. Different things than you&#39;re accustomed to, but good things.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;  &gt; do something of interest (act)<br/>\n&gt; <br/>\n&gt; E.g., The &#39;read message&#39;, which is the only thing of interest to the<br/>\n&gt; testReadMessage method.<br/>\n<br/>\n </span></blockquote>Right. There should be absolutely no need to set up the system in a <br/>\ncomplicated manner, just to read a message (whatever that means in this <br/>\ncontext). Would you describe what &quot;read message&quot; does?<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;  &gt; then check the results (assert).<br/>\n&gt; <br/>\n&gt; See you&#39;re forgetting a few things, when dealing with stateful<br/>\n&gt; external systems.  <br/>\n<br/>\n </span></blockquote>Rudeness objection again. You do not know what I&#39;m remembering and what <br/>\nI&#39;m forgetting.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Namely &#39;reset state&#39;, which should occur<br/>\n&gt; AFTER assert.  <br/>\n<br/>\n </span></blockquote>Well, for me, &quot;reset state&quot; is a no-op, because an isolated, <br/>\nobject-level test generally does not affect global state. If it did, <br/>\nthen I wouldn&#39;t be able to call it &quot;isolated&quot;.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; But it needs to be tested also, of course.  And<br/>\n&gt; since it needs to be tested, it needs a test, preferrably simple<br/>\n&gt; because simple is good, that runs in the normal sequence of<br/>\n&gt; things.   Instead of doing the 9 operations every time, for 9<br/>\n&gt; tests, the clear process is to do it once, in the prior test, and<br/>\n&gt; use that state in the next test.<br/>\n<br/>\n </span></blockquote>I agree that that&#39;s clear. However, when many tests share the same <br/>\nglobal state, and when each test&#39;s success depends on a preceding test <br/>\npassing, bad things happen.<br/>\n<br/>\nExample: test #1 fails, and tests #2-#10 are now meaningless, because <br/>\n#1&#39;s failure leaves the system in an undesirable, strange state. To me, <br/>\ntest failures ought not to affect one another.<br/>\n<br/>\nExample: if I need to add a new special case test for inserting data, <br/>\nand my &quot;insert&quot; tests come before my &quot;read&quot; and &quot;delete&quot; tests, which <br/>\nseems to follow your idea of reasonable, then I have to change my &quot;read&quot; <br/>\ntests (and maybe even my &quot;delete&quot; tests) to handle the new, extra data, <br/>\n/even if those changes don&#39;t improve those tests/! I will have created <br/>\nan unnecessary maintenance issue in my tests.<br/>\n<br/>\nThese are only two common examples of problems that come from writing <br/>\ntests that depend on shared, global state. My experience tells me that <br/>\nwriting isolated tests costs less, so that&#39;s the way I do things.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Statics aren&#39;t an answer, and the framework forcing them on<br/>\n&gt; tests is a failure in the framework.  I was hoping that wasn&#39;t<br/>\n&gt; the answer.<br/>\n<br/>\n </span></blockquote>Statics aren&#39;t an answer, and having to use them is a failure in the <br/>\ndesign of the production code.<br/>\n<br/>\n(It sounds silly when I state it that way, doesn&#39;t it?)<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;  &gt; You are right: your test is<br/>\n&gt;  &gt; doing too much, but I don&#39;t think the test is at fault.<br/>\n&gt; <br/>\n&gt; Each test is testing a single, basic unit of functionality.   You<br/>\n&gt; misread me, I&#39;m saying that if I have to do all the steps<br/>\n&gt; outlined above EVERY time I want to do only ONE of those<br/>\n&gt; tests, then the test is doing far too much, and it&#39;s the<br/>\n&gt; framework at fault for forcing that kind of test process.<br/>\n<br/>\n </span></blockquote>I&#39;m afraid that /you/ have misread /me/.<br/>\n<br/>\nI wrote: &quot;your test is doing too much&quot;<br/>\nYou wrote: &quot;Each test is testing a single, basic unit...&quot;<br/>\n<br/>\nI didn&#39;t say that your test was /testing/ too much. I said that your <br/>\ntest is /doing/ too much. Here&#39;s the distinction: the &quot;too much&quot; that <br/>\nyour test is doing is jumping through hoops to set up global state that <br/>\nsuch a test does not need to set up, /if/ you approach it slightly <br/>\ndifferently.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;  &gt; &gt; The only place that threading comes in is that I can&#39;t use a<br/>\n&gt;  &gt; &gt; static value to keep this data, because then it&#39;s shared among<br/>\n&gt;  &gt; &gt; all the threads.<br/>\n&gt;  &gt;<br/>\n&gt;  &gt; I don&#39;t understand why you need multiple threads while running the<br/>\n&gt;  &gt; tests. Could you run the tests in singlethreaded mode? The fact<br/>\n&gt; that you<br/>\n&gt;  &gt; want to test logic in multithreaded mode tells me that you may be<br/>\n&gt; trying<br/>\n&gt;  &gt; to test too many things at once.<br/>\n&gt; <br/>\n&gt; Yes, yes, the test is run once in single-threaded mode,<br/>\n&gt; to make sure the basic logic is correct.  I do that as a<br/>\n&gt; sanity test before running the multi-threaded test.  The<br/>\n&gt; problem still exists, of course, because state should be<br/>\n&gt; preserved.  (Actually, there are about a half dozen pre-MT<br/>\n&gt; test classes that are run, testing the logic of various layers.)<br/>\n&gt; <br/>\n&gt; It&#39;s then run in a heavily multithreaded context, because<br/>\n&gt; that&#39;s the context it&#39;s going to be run in the real world,<br/>\n&gt; so it tries to hash out any threading issues in the various<br/>\n&gt; layers.  This is a test, after all.<br/>\n<br/>\n </span></blockquote>If I understand you correctly, you are doing some load tests to iron out <br/>\nconcurrency issues. From my understanding, you could use JUnit to do <br/>\nthat, but I wouldn&#39;t do it that way. I would use some other kind of <br/>\nend-to-end testing tool, like Silk Performer. I would have to defer to <br/>\nsomeone else who is more capable of commenting on that, since I have <br/>\nlittle experience in that direction.<br/>\n<br/>\nI feel even more strongly now that JUnit is not the right tool for the <br/>\njob you&#39;re trying to perform.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;  &gt;  &gt; Any suggestions?<br/>\n&gt;  &gt;<br/>\n&gt;  &gt; What is your goal? To verify your logic? To test concurrency? At a<br/>\n&gt;  &gt; minimum, do each of these separately, and not together.<br/>\n&gt; <br/>\n&gt; I do each of them separately.  I test the logic once, with the<br/>\n&gt; storageTest class as a single thread.  I then try to test the<br/>\n&gt; concurrency by calling storageTest from one to three hundred<br/>\n&gt; threads.<br/>\n<br/>\n </span></blockquote>All right. I think I understand. It wasn&#39;t clear that you were already <br/>\ndoing this, and so much of my previous advice is likely old hat. I <br/>\nprobably should have asked this question earlier.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Right now, I have a &#39;massiveTest&#39; class which calls all the methods<br/>\n&gt; of the storageTest class directly, after doing a hand-setup so that<br/>\n&gt; the storageTest object can query some data.  It&#39;s just a hack-around<br/>\n&gt; for the problem that the TestSuite instantiates a new object every<br/>\n&gt; time.  If it didn&#39;t do that, the code would be vastly cleaner.<br/>\n<br/>\n </span></blockquote>I imagine you could build your own test runner easily enough to execute <br/>\nall the tests in a suite against the same fixture data.<br/>\n<br/>\nI still think that simply using class-level data would suffice. I still <br/>\ndon&#39;t understand the objection. It appears that your tests are using <br/>\nsome external resource (like a database, mail server/client, whatever). <br/>\nWhat&#39;s the difference between using an external resource and class-level <br/>\ndata? It&#39;s all global, from the test case&#39;s point of view. I don&#39;t <br/>\nunderstand why using one would be any better or worse than using the other.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;  &gt; &gt; p.s.  Nope, no extensions yet, although I&#39;m eyeing TestResult<br/>\n&gt;  &gt; &gt; as needing a touch of an upgrade...<br/>\n&gt;  &gt;<br/>\n&gt;  &gt; Interesting... do tell.<br/>\n&gt; <br/>\n&gt; Certainly.  The massiveTest I mentioned above has to call each<br/>\n&gt; method on storageTest directly, so when a failure occurs I can&#39;t<br/>\n&gt; easily determine WHERE it failed, because the only test that<br/>\n&gt; appears in TestResult is &#39;testMultithreadedStorage&#39;.<br/>\n&gt; <br/>\n&gt; It would be good to have testMultithreadedStorage call the<br/>\n&gt; suite.run(myResult) for the storageTest class (if that worked<br/>\n&gt; properly with state preservation), and then aggregate the<br/>\n&gt; results for all the threads, so it appears more like what really<br/>\n&gt; happened, that the storageTest test suite was run 2000 times,<br/>\n&gt; and which calls failed, asserted, etc.<br/>\n&gt; <br/>\n&gt; This was the part that was probably pretty complex and poorly<br/>\n&gt; described in my original post, so I left it out initially.<br/>\n<br/>\n </span></blockquote>I /think/ I understand. There /are/ multithreaded extensions to JUnit, <br/>\nalthough I&#39;ve never tried any of them. MTUnit comes to mind, although <br/>\nthat could be wrong. It may be worth examining.<br/>\n-- <br/>\nJ. B. Rainsberger,<br/>\nDiaspar Software Services<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.diasparsoftware.com\">http://www.diasparsoftware.com</a> :: +1 416 791-8603<br/>\nLet&#39;s write software that people understand</div>", 
    "prevInTime": 11521, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1089985152", 
    "canDelete": false, 
    "nextInTopic": 11538, 
    "prevInTopic": 11521, 
    "headers": {
        "inReplyToHeader": "PGNkNzc1NitsNnI0QGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PDQwRjdEQTgwLjcwOTAxMDZAcm9nZXJzLmNvbT4=", 
        "referencesHeader": "PGNkNzc1NitsNnI0QGVHcm91cHMuY29tPg=="
    }
}