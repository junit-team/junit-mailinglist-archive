{
    "numMessagesInTopic": 6, 
    "nextInTime": 20470, 
    "senderId": "MZRlJ0ctWkoys3JgwbtCQaFrIAkfz319VC4FDg5oCPk6FIy1oZjtgFDfJ7sbc_dovK3HU8UHP3bquZuc7-Qhvc9sW3UgpbV2M2IrKg", 
    "systemMessage": true, 
    "subject": "Re: TextListener improvement", 
    "from": "&quot;toalexsmail&quot; &lt;toalexsmail@...&gt;", 
    "authorName": "toalexsmail", 
    "msgSnippet": "Kent, I will do it in the future, maybe in this weekend, but I don t promise. ... current code", 
    "msgId": 20469, 
    "profile": "toalexsmail", 
    "topicId": 20361, 
    "spamInfo": {
        "reason": "6", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 340165037, 
    "messageBody": "<div id=\"ygrps-yiv-278924065\">Kent, I will do it in the future, maybe in this weekend, but I don&#39;t<br/>\npromise.<br/>\n<br/>\n<blockquote><span title=\"qreply\"> --- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>, &quot;Kent Beck&quot; &lt;kentb@...&gt; wrote:<br/>\n&gt;<br/>\n&gt; Alex,<br/>\n&gt;  <br/>\n&gt; It would help me if you provided test cases that break with the<br/>\ncurrent code<br/>\n&gt; and pass with the changes below.<br/>\n&gt;  <br/>\n&gt; Regards,<br/>\n&gt;  <br/>\n&gt; Kent Beck<br/>\n&gt; Three Rivers Institute<br/>\n&gt; <br/>\n&gt;   _____  <br/>\n&gt; <br/>\n&gt; From: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a> [mailto:<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>] On Behalf Of<br/>\n&gt; toalexsmail<br/>\n&gt; Sent: Monday, April 28, 2008 4:33 PM<br/>\n&gt; To: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a><br/>\n&gt; Subject: [junit] Re: TextListener improvement<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; <br/>\n&gt; PrintStreamListener has a bug. Here is correct version:<br/>\n&gt; <br/>\n&gt; public class PrintStreamListener extends RunListener{<br/>\n&gt; //Definition of delimiters is in Description<br/>\n&gt; private static final Pattern DISPAY_NAME_PATTERN =<br/>\n&gt; Pattern.compile(&quot;[()]&quot;); <br/>\n&gt; private TextListener textListener;<br/>\n&gt; private PrintStream writer;<br/>\n&gt; <br/>\n&gt; public PrintStreamListener() {<br/>\n&gt; this(System.out);<br/>\n&gt; }<br/>\n&gt; <br/>\n&gt; public PrintStreamListener(PrintStream writer) {<br/>\n&gt; super();<br/>\n&gt; this.textListener = new TextListener(writer);<br/>\n&gt; this.writer = writer;<br/>\n&gt; }<br/>\n&gt; <br/>\n&gt; /**<br/>\n&gt; * For sub-classes use.<br/>\n&gt; * <br/>\n&gt; * @return<br/>\n&gt; */<br/>\n&gt; protected PrintStream getWriter(){<br/>\n&gt; return writer;<br/>\n&gt; }<br/>\n&gt; <br/>\n&gt; private PrintStream getNotNullWriter(){<br/>\n&gt; PrintStream writer = getWriter();<br/>\n&gt; if(writer==null){<br/>\n&gt; throw new IllegalStateException(&quot;writer should be not null&quot;);<br/>\n&gt; }<br/>\n&gt; return writer;<br/>\n&gt; }<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; /**<br/>\n&gt; * This method can be overriden in sub-classes.<br/>\n&gt; * <br/>\n&gt; * @param description<br/>\n&gt; * @throws IllegalArgumentException if description is null.<br/>\n&gt; */<br/>\n&gt; protected void writeMethodName(Description description){<br/>\n&gt; if(description==null){<br/>\n&gt; throw new IllegalArgumentException(&quot;description should be not null&quot;);<br/>\n&gt; }<br/>\n&gt; String displayName = description.getDisplayName();<br/>\n&gt; //third place is empty, workaround to avoid ) at the end of the String<br/>\n&gt; String[] complexNames = DISPAY_NAME_PATTERN.split(displayName, 3); <br/>\n&gt; String methodName = (complexNames==null ||<br/>\n&gt; complexNames.length==0)?null:complexNames[0];<br/>\n&gt; if(methodName == null || &quot;&quot;.equals(methodName)){<br/>\n&gt; methodName = displayName;<br/>\n&gt; }<br/>\n&gt; PrintStream writer = getNotNullWriter();<br/>\n&gt; <br/>\n&gt; writer.print(methodName);<br/>\n&gt; writer.print(&#39; &#39;);<br/>\n&gt; }<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; /**<br/>\n&gt; * Called when an atomic test is about to be started.<br/>\n&gt; * @param description the description of the test that is about to be<br/>\n&gt; run <br/>\n&gt; * (generally a class and method name)<br/>\n&gt; */<br/>\n&gt; @Override<br/>\n&gt; public void testStarted(Description description) {<br/>\n&gt; textListener.testStarted(description);<br/>\n&gt; }<br/>\n&gt; <br/>\n&gt; /** <br/>\n&gt; * Called when an atomic test fails.<br/>\n&gt; * @param failure describes the test that failed and the exception<br/>\n&gt; that was thrown<br/>\n&gt; */<br/>\n&gt; @Override<br/>\n&gt; public void testFailure(Failure failure) {<br/>\n&gt; Description description = failure.getDescription();<br/>\n&gt; PrintStream writer = getNotNullWriter();<br/>\n&gt; <br/>\n&gt; writeMethodName(description);<br/>\n&gt; textListener.testFailure(failure);<br/>\n&gt; writer.println();<br/>\n&gt; }<br/>\n&gt; <br/>\n&gt; /**<br/>\n&gt; * Called when a test will not be run, generally because a test<br/>\n&gt; method is annotated <br/>\n&gt; * with {@link org.junit.Ignore}.<br/>\n&gt; * @param description describes the test that will not be run<br/>\n&gt; */<br/>\n&gt; @Override<br/>\n&gt; public void testIgnored(Description description) {<br/>\n&gt; writeMethodName(description);<br/>\n&gt; PrintStream writer = getNotNullWriter();<br/>\n&gt; textListener.testIgnored(description);<br/>\n&gt; writer.println();<br/>\n&gt; }<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; @Override<br/>\n&gt; public void testRunFinished(Result result) {<br/>\n&gt; textListener.testRunFinished(result);<br/>\n&gt; }<br/>\n&gt; <br/>\n&gt; /**<br/>\n&gt; * Called before any tests have been run.<br/>\n&gt; * @param description describes the tests to be run<br/>\n&gt; */<br/>\n&gt; @Override<br/>\n&gt; public void testRunStarted(Description description) throws Exception {<br/>\n&gt; PrintStream writer = getNotNullWriter();<br/>\n&gt; String displayName = description.getDisplayName();<br/>\n&gt; //third place is empty, workaround to avoid ) at the end of the String<br/>\n&gt; String[] complexNames = DISPAY_NAME_PATTERN.split(displayName, 3); <br/>\n&gt; String className = (complexNames==null ||<br/>\n&gt; complexNames.length&lt;2)?null:complexNames[1];<br/>\n&gt; if(className == null || &quot;&quot;.equals(className)){<br/>\n&gt; className = displayName;<br/>\n&gt; }<br/>\n&gt; writer.print(&quot;started to test &quot;+className);<br/>\n&gt; writer.println(); <br/>\n&gt; }<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; <br/>\n&gt; <br/>\n&gt; <br/>\n&gt; }<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; <br/>\n&gt;  <br/>\n&gt; <br/>\n&gt; <br/>\n&gt; [Non-text portions of this message have been removed]<br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 20468, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1209565228", 
    "canDelete": false, 
    "nextInTopic": 20470, 
    "prevInTopic": 20467, 
    "headers": {
        "inReplyToHeader": "PDAxODcwMWM4YTlhMyQyN2M0YzczMCQwMjAwYThjMEBrZW50c3BhdmlsaW9uPg==", 
        "messageIdInHeader": "PGZ2OXY3YytqZjl0QGVHcm91cHMuY29tPg=="
    }
}