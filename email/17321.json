{
    "numMessagesInTopic": 287, 
    "nextInTime": 17322, 
    "senderId": "GOHd5-l-56p9iqH6VAnAjaNGlyPIC93MYhC5KF5ZqJLpfRXjF0EHZZnzEhtPB8fLcIiClSt6aP-Ucl1bm9gbtB_eFLn05yFASFhQkoXzd7jtkZF6KQ", 
    "systemMessage": false, 
    "subject": "Re: [junit] Re: Are you really using JUnit during your development?", 
    "from": "&quot;Jeff Nielsen&quot; &lt;jeff.nielsen@...&gt;", 
    "authorName": "Jeff Nielsen", 
    "msgSnippet": "... Taken to the next level, this is the kind of reasoning that leads to phase-based SW dev. schedules rather than iterative ones.  On paper, it looks like it", 
    "msgId": 17321, 
    "profile": "jeffreymads", 
    "topicId": 17266, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 65487161, 
    "messageBody": "<div id=\"ygrps-yiv-1863094466\">CÃ©dric Beust wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; It can be argued that writing test firsts can be detrimental to your<br/>\n&gt; velocity because it introduces churn: you don&#39;t know yet what your<br/>\n&gt; final code will look like, and before you reach something you&#39;re<br/>\n&gt; comfortable with, you might have to rewrite it two or three times.<br/>\n&gt; And every time, you will have to modify these tests as well.  TDD<br/>\n&gt; can be a big waste of time.<br/>\n&gt;<br/>\n&gt; Here is why.<br/>\n&gt;<br/>\n&gt; With test first, you have something like: Test v1, Code v1, Test v2,<br/>\n&gt; Code v2, Test v3, Code v3.  Check in.<br/>\n&gt;<br/>\n&gt; If you postpone your testing a bit, you have: Code v1, Code v2, Code<br/>\n&gt; v3, Test v3, Commit.<br/>\n&gt;<br/>\n&gt; The latter approach will get you to your goal much faster.<br/>\n<br/>\n </span></blockquote>Taken to the next level, this is the kind of reasoning that leads to<br/>\nphase-based SW dev. schedules rather than iterative ones.  On paper,<br/>\nit looks like it will be more efficient to write a bunch of code and<br/>\nthen test/integrate it at once, rather than do acceptance testing and<br/>\nintegration iteration-by-iteration or story-by-story.  On paper, it<br/>\nlooks like lots of re-work to test & integrate the code every day<br/>\nrather than once every couple of weeks/months after features are<br/>\n&quot;stable.&quot;  (It also looks more efficient to do the requirements work<br/>\nall at once, to save the requirements people time.)<br/>\n<br/>\nA phase-based, batch approach only turns out to be more efficient if<br/>\n<br/>\n  * The tasks to be done are fairly well understood & somewhat<br/>\n    repetitive<br/>\n<br/>\n  * The dominant cost of the work /is/ in the repetitive labor<br/>\n<br/>\nThis doesn&#39;t seem to hold true with programming, for me at least.  I<br/>\nusually find that the dominant cost is in the thinking, learning, and<br/>\ncommunication, rather than in the typing.  All that stuff that looks<br/>\nlike re-work on paper is actually speeding up my ability to think,<br/>\nlearn, and communicate.<br/>\n<br/>\n<br/>\n-- <br/>\nJeff Nielsen<br/>\nDigital Focus<br/>\nwww.digitalfocus.com</div>", 
    "prevInTime": 17320, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1154892114", 
    "canDelete": false, 
    "nextInTopic": 17340, 
    "prevInTopic": 17320, 
    "headers": {
        "messageIdInHeader": "PDAxMDMwMWM2Yjk4ZCQ5M2FmYjExMCRkYjQxNjQ0NEBMYXB0b3AyMTA+", 
        "referencesHeader": "PDExNTQ2MTY4ODIuMTYxMi44NjM3Ni5tMTlAeWFob29ncm91cHMuY29tPiA8RDkzNDZGNzUtRDgyMS00QUYxLUFENjAtNTRGNzM1NzAyRUNEQG9iamVjdG1lbnRvci5jb20+IDxiODZiNmE5YzA2MDgwMzE3MTNtNDY0OTdjM2ZqOGNiN2YyOThmZmJmM2Q1MEBtYWlsLmdvb2dsZS5jb20+"
    }
}