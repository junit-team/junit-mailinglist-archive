{
    "numMessagesInTopic": 3, 
    "nextInTime": 17125, 
    "senderId": "sW6i3GWcCEAZ-UZ13dvKbWasEI3ytxKZYECtg2o-bRCaiZneFNb_Cv5ZOyzgNuyrrSqeHDpkfdc63JFzLCQAkTY5HfNrFDNusRaeZ9SgpFiU", 
    "systemMessage": true, 
    "subject": "Re: [junit] non static method testing with JUnit", 
    "from": "&quot;Brett L. Schuchert&quot; &lt;schuchert@...&gt;", 
    "authorName": "Brett L. Schuchert", 
    "msgSnippet": "The only special thing you need to do is to make sure you have an instance of your object before you test it. If you have a single test that needs an object,", 
    "msgId": 17124, 
    "profile": "schuchert", 
    "topicId": 17122, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 162568887, 
    "messageBody": "<div id=\"ygrps-yiv-396979751\">The only &quot;special&quot; thing you need to do is to make sure you have an instance of your object before you test it.<br/>\n <br/>\nIf you have a single test that needs an object, you might write the following:<br/>\n// JUnit 4.x<br/>\n@Test<br/>\npublic void simpleCreation() {<br/>\n  Foo myFoo = new Foo(...);<br/>\n  assertTrue(myFoo.isX());<br/>\n}<br/>\n <br/>\n// JUnit 3.x<br/>\npublic void testSimpleCreation() {<br/>\n  Foo myFoo = new Foo(...);<br/>\n  assertTrue(myFoo.isX());<br/>\n}<br/>\n<br/>\nIf you plan to use that same instance over and over in each test method in a test class, you might do the following:<br/>\n <br/>\n//JUnit 4.x<br/>\npublic class FooTest {<br/>\n  private Foo myFoo;<br/>\n <br/>\n  @Before<br/>\n  public void init() {<br/>\n    myFoo = new Foo();<br/>\n  }<br/>\n <br/>\n  @Test<br/>\n  public void simpleCreation() {<br/>\n    assertTrue(myFoo.isX());<br/>\n  }<br/>\n}<br/>\n <br/>\nBut other than instantiation, there&#39;s not much different between static and regular methods.<br/>\n <br/>\nOf course, if your method is polymorphic (in the sense that sub-classes implement it as well), you might need to make sure your test instantiations of all sub-classes.<br/>\n <br/>\nBrett<br/>\n  <br/>\n   <br/>\nTutorials and Articles<br/>\n     <a rel=\"nofollow\" target=\"_blank\" href=\"http://schuchert.wikispaces.com/\">http://schuchert.wikispaces.com/</a><br/>\n<br/>\n<br/>\n<br/>\n----- Original Message ----<br/>\nFrom: Kamal Ahmed &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:KAhmed@...\">KAhmed@...</a>&gt;<br/>\nTo: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a><br/>\nSent: Tuesday, July 11, 2006 3:03:50 PM<br/>\nSubject: [junit] non static method testing with JUnit<br/>\n<br/>\n<br/>\nHi,<br/>\n<br/>\nIs there a special way to test non static methods with JUnit? Or they are<br/>\ntreated the same way as static methods.<br/>\n<br/>\nHere is the reason why I asked this question. After reading this article<br/>\n(below). It is rather &quot;back to basics&quot; but sometimes I find it useful to go<br/>\nto &quot;root&quot;<br/>\n<br/>\nMr. Happy Object teaches static methods<br/>\nWhen to choose static methods over instance methods<br/>\n<br/>\nBy Tony Sintes<br/>\n<br/>\nNovember 21, 2001<br/>\n<br/>\nQ) When would you create static methods as opposed to instance methods? I<br/>\nunderstand that static methods allow you to use those methods without having<br/>\nto create an instance of that class, and that class methods apply to the<br/>\nclass rather than an object. Are these the only reasons? Could you give an<br/>\nexample of a case where you would use a class method over an instance<br/>\nmethod?<br/>\n<br/>\nA) Many Java developers find it confusing to decide when, and when not to<br/>\ndeclare a method as static. However, making the choice is simple if you have<br/>\na clear understanding of the difference between a class method and an<br/>\ninstance method.<br/>\n<br/>\nNote: You can download the source code that accompanies this article from<br/>\nResources.<br/>\n<br/>\nConsider the following class definition:<br/>\n<br/>\npublic class MrHappyObject {<br/>\n<br/>\nprivate String _mood = _HAPPY;<br/>\n<br/>\nprivate final static String _HAPPY = &quot;happy&quot;;<br/>\nprivate final static String _ANNOYED = &quot;annoyed&quot;;<br/>\nprivate final static String _ANGRY = &quot;angry&quot;;<br/>\n<br/>\npublic void printMood() {<br/>\nSystem.out.println( &quot;I am &quot; + _mood );<br/>\n}<br/>\n<br/>\npublic void receivePinch( ) {<br/>\nif( _mood.equals( _HAPPY ) ) {<br/>\n_mood = _ANNOYED;<br/>\n} else {<br/>\n_mood = _ANGRY;<br/>\n}<br/>\n}<br/>\n<br/>\npublic void receiveHug() {<br/>\nif( _mood.equals( _ANGRY ) ) {<br/>\n_mood = _ANNOYED;<br/>\n} else {<br/>\n_mood = _HAPPY;<br/>\n}<br/>\n}<br/>\n}<br/>\n<br/>\nFigure 1. Mr. Happy Object<br/>\n<br/>\nFirst, before I get emails about it, there are more object-oriented ways to<br/>\ntrack and transition between states. However, those fancy ways would detract<br/>\nfrom the intent of the example. Now, without further ado...<br/>\n<br/>\nprintMood(), receivePinch( ), and receiveHug() are all instance methods.<br/>\nSyntactically, you call these methods instance methods because they are not<br/>\nstatic; but the important distinction concerns why I didn&#39;t declare them as<br/>\nstatic.<br/>\n<br/>\nInstance methods are instance methods because they rely on the state of the<br/>\nspecific object instance. Instance methods are tied to a particular instance<br/>\nbecause the behavior that the method invokes relies upon the state of that<br/>\nparticular instance.<br/>\n<br/>\nConsider the following example:<br/>\n<br/>\nMrHappyObject obj1 = new MrHappyObject( );<br/>\nMrHappyObject obj2 = new MrHappyObject( );<br/>\n<br/>\nobj1.printMood( );<br/>\nobj2.printMood( );<br/>\n<br/>\nWhen obj1 and obj2 first instantiate, they have the same state -- they are<br/>\nborn happy. As a result, when the printMood() is called on each instance,<br/>\neach object prints &quot;I am happy&quot; to the screen. However, every object<br/>\ninstance has its own state that can vary independently of all other<br/>\ninstances of that class of object.<br/>\n<br/>\nAs obj1 and obj2 go through their day, their states can vary independently<br/>\nfrom one another. Here I hug obj1 and pinch obj2:<br/>\n<br/>\nobj1.receiveHug( );<br/>\nobj2.receivePinch( );<br/>\n<br/>\nobj1.printMood( );<br/>\nobj2.printMood( );<br/>\n<br/>\nNow when I query each instance&#39;s mood, obj1 is happy while obj2 is annoyed.<br/>\nWhile the example is silly, it drives home a point: Every instance possesses<br/>\nits own state, and that state is independent of every other object. Any<br/>\nmethod whose behavior depends upon the particular state of a particular<br/>\ninstance is an instance method. You should not declare such a method as<br/>\nstatic.<br/>\n<br/>\nWhen you declare a method as static, you define that method as being a class<br/>\nmethod. A class method applies to the class as opposed to any particular<br/>\ninstance. The behavior instigated by a class method does not rely on the<br/>\nstate of a particular instance. In fact, a static method cannot rely on an<br/>\ninstance&#39;s state since static methods lack access to this reference.<br/>\nInstead, the behavior of a class method either depends on a state that all<br/>\nobjects share at the class level, or is independent of any state at all.<br/>\n<br/>\nLet&#39;s add the following definitions to the original MrHappyObject:<br/>\n<br/>\nprivate static int _instantiations;<br/>\n<br/>\npublic MrHappyObject( ) {<br/>\n_instantiations+ +;<br/>\n}<br/>\n<br/>\npublic static int instances() {<br/>\nreturn _instantiations;<br/>\n}<br/>\n<br/>\ninstances() is a static method. The instances() method returns the number of<br/>\nMrHappyObjects that have been created. The number of instantiations is<br/>\nindependent of any particular MrHappyObject. Instead, MrHappyObject tracks<br/>\nthe number of instantiations at the class level.<br/>\n<br/>\nAgain, this example is a bit contrived but it demonstrates an important<br/>\nlesson: Class methods instigate behavior that is independent of instance<br/>\nstate. instances() returns the number of instances regardless of whether<br/>\nobj1 is happy and obj2 is annoyed. The instance state is simply irrelevant.<br/>\nAny method that is independent of instance state is a candidate for being<br/>\ndeclared as static.<br/>\n<br/>\nNote that I say &quot;candidate for being declared as static.&quot; Even in the<br/>\nprevious example nothing forces you to declare instances() as static.<br/>\nDeclaring it as static just makes it more convenient to call since you do<br/>\nnot need an instance to call the method. Sometimes you will have methods<br/>\nthat don&#39;t seem to rely on instance state. You might not want to make these<br/>\nmethods static. In fact you&#39;ll probably only want to declare them as static<br/>\nif you need to access them without an instance.<br/>\n<br/>\nMoreover, even though you can declare such a method as static, you might not<br/>\nwant to because of the inheritance issues that it interjects into your<br/>\ndesign. Take a look at &quot;Effective Object-Oriented Design&quot; to see some of the<br/>\nissues that you will face.<br/>\n<br/>\nAnyway, simply counting the number of instantiations is a fairly useless<br/>\nexample -- it&#39;s probably not something you will do in your day-to-day<br/>\ncoding. However, sometimes you will want to use statics.<br/>\n<br/>\nStatic methods prove useful for creating utility classes and factory<br/>\nmethods. (See &quot;Factory Methods&quot; for more information. )<br/>\n<br/>\nA utility class simply contains static methods and no public constructor.<br/>\nUtility classes are not meant to be instantiated. As Joshua Bloch points out<br/>\nin Effective Java Programming Language Guide, utility classes have earned a<br/>\nbad reputation because they are easily abused and can lead to procedural<br/>\nprogramming.<br/>\n<br/>\nHowever, utility classes do have valid uses. Take a look at java.lang.Math,<br/>\njava.util.Arrays, and java.util.Collectio ns; each is a utility class. These<br/>\nutilities group related methods on primitive values, arrays, and interfaces.<br/>\nThese related methods are placed in these utility classes since they cannot<br/>\ngo anywhere else (you can&#39;t place methods into a primitive, array, or<br/>\ninterface after all!).<br/>\n<br/>\nUtility classes have another use. Sometimes you cannot extend a class<br/>\nbecause it is declared final. Utility classes are an excellent place to put<br/>\nmethods that you would have otherwise put into a subclass.<br/>\n<br/>\nAbout the author<br/>\nTony Sintes is an independent consultant and founder of First Class<br/>\nConsulting, Inc., a consulting firm that specializes in the bridging of<br/>\ndisparate enterprise systems and training. Outside of First Class<br/>\nConsulting, Tony is an active freelance writer as well as author of Sams<br/>\nTeach Yourself Object-Oriented Programming in 21 Days (Sams, 2001; ISBN:<br/>\n0672321092).<br/>\n<br/>\nThanks,<br/>\n-Kamal.<br/>\n<br/>\n<br/>\n <br/>\n<br/>\n[Non-text portions of this message have been removed]</div>", 
    "prevInTime": 17123, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1152656283", 
    "canDelete": false, 
    "nextInTopic": 17133, 
    "prevInTopic": 17122, 
    "headers": {
        "inReplyToHeader": "PEM0Qjg4MDA5OEFBNjhCNENCNEEwQjgyQjE0MTlBNDYwMDExMkQ5NUZAbWFpbHZhPg==", 
        "messageIdInHeader": "PDIwMDYwNzExMjIxODAzLjQ0NDQ0LnFtYWlsQHdlYjU0MTA3Lm1haWwueWFob28uY29tPg=="
    }
}