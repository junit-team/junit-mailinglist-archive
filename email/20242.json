{
    "numMessagesInTopic": 11, 
    "nextInTime": 20243, 
    "senderId": "KQSjhvPqPOBm1iq53La5w2oizbxVmkhD6TIsIwggY4y6_kxd2HF1g9MytOecqOzzNTjmNuMSeMBkK4AFF3sjXOqXo7W_TT7oIOE", 
    "systemMessage": true, 
    "subject": "Re: class isolation and class order for testing", 
    "from": "&quot;lancezant&quot; &lt;lancezant@...&gt;", 
    "authorName": "lancezant", 
    "msgSnippet": "Since this is an existing system, the other major source of test cases is bug reports.  Write a test to manifest each reported bug before doing anything to fix", 
    "msgId": 20242, 
    "profile": "lancezant", 
    "topicId": 20231, 
    "spamInfo": {
        "reason": "6", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 291419863, 
    "messageBody": "<div id=\"ygrps-yiv-717796648\">Since this is an existing system, the other major source of test cases<br/>\nis bug reports.  Write a test to manifest each reported bug before<br/>\ndoing anything to fix it.  These will often be of the end-to-end or<br/>\nintegration variety already recommended.  <br/>\n<br/>\nBesides accumulating a regression suite, this has a couple of other<br/>\nbenefits.  First, bugs tend to occur in clusters, so you&#39;ll tend to<br/>\naccumulate the most tests for the most problematic code.    Second,<br/>\nthe code that is the most problematic will probably also be the<br/>\nhardest to test, encouraging refactoring.  Again, focusing on bug<br/>\nhot-spots tends to focus your efforts where they&#39;re needed most.<br/>\n<br/>\nGood hunting,<br/>\nLance<br/>\n<br/>\n<blockquote><span title=\"qreply\"> --- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>, &quot;Nat Pryce&quot; &lt;nat.pryce@...&gt; wrote:<br/>\n&gt;<br/>\n&gt; On 15/01/2008, Chris Dollin &lt;chris.dollin@...&gt; wrote:<br/>\n&gt; &gt; On Tuesday 15 January 2008 09:47, csabcsi.szucs wrote:<br/>\n&gt; &gt;<br/>\n&gt; &gt;  &gt; I meant the following:<br/>\n&gt; &gt;  &gt;  I cannot do a TDD this time, because I have already an existing<br/>\n&gt; &gt;  &gt; project with about 100 production classes (and some time to<br/>\nlearn and<br/>\n&gt; &gt;  &gt; exercise JUnit tests).<br/>\n&gt; &gt;<br/>\n&gt; &gt;  Read Michael Feathers&#39; book /Working Effectively with Legacy Code/.<br/>\n&gt; &gt;<br/>\n&gt; &gt;  &gt; So which class shall I start with to write JUnit tests for? Perhaps<br/>\n&gt; &gt;  &gt; it is worth starting with a class that does not have any<br/>\ncollaborators<br/>\n&gt; &gt;  &gt; or only ones that are already tested in a previous &quot;test phase&quot;.<br/>\n&gt; &gt;<br/>\n&gt; &gt;  I&#39;d suggest classes which are likely to be worked on &quot;soon&quot;.<br/>\nThose are,<br/>\n&gt; &gt;  after all, the ones which you might otherwise break, and for which<br/>\n&gt; &gt;  unit tests will add most value.<br/>\n&gt; &gt;<br/>\n&gt; &gt;  It&#39;s tempting to start with &quot;easy&quot; ones, but you run the risk of<br/>\nwriting<br/>\n&gt; &gt;  tests for things that won&#39;t change and won&#39;t break, and you&#39;d gain an<br/>\n&gt; &gt;  unrealistic view of how easy it is(n&#39;t) to add tests post-hoc.<br/>\n&gt; <br/>\n&gt; All good advice.<br/>\n&gt; <br/>\n&gt; I&#39;d also cover the code with end-to-end tests.<br/>\n&gt; <br/>\n&gt; Unit tests give you a lot of feedback about the internal quality of<br/>\n&gt; your code (is it maintainable, readable, decoupled, cohesive etc.),<br/>\n&gt; but less feedback about the external quality of the code (is it good<br/>\n&gt; enough for purpose).<br/>\n&gt; <br/>\n&gt; End-to-end and integration tests give you more feedback about the<br/>\n&gt; external quality of your code, but less feedback about its internal<br/>\n&gt; quality.  E.g. the tell you whether all the pieces work together, but<br/>\n&gt; not whether the pieces are well structured and easily (un)pluggable.<br/>\n&gt; <br/>\n&gt; If you&#39;ve already got a lot of code, feedback about its internal<br/>\n&gt; quality now is a bit late in the day.  I expect you&#39;re concerned about<br/>\n&gt; regressions as you add behaviour.  So, I would concentrate on<br/>\n&gt; integration and end-to-end tests to ensure correct system behaviour.<br/>\n&gt; <br/>\n&gt; It&#39;s worth adding unit tests for new classes as you add new behaviour.<br/>\n&gt; They will also help you to discover where the code is difficult to<br/>\n&gt; maintain and help you introduce flex points.  At that point you can<br/>\n&gt; start refactoring the existing code, where it touches the new code, to<br/>\n&gt; make it more testable and more easily surround the refactored with<br/>\n&gt; unit tests.  You&#39;ll feel more confident that you aren&#39;t breaking<br/>\n&gt; anything because the end-to-end tests will help detect any regressions<br/>\n&gt; the changes cause.<br/>\n&gt; <br/>\n&gt; --Nat<br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 20241, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1200417366", 
    "canDelete": false, 
    "nextInTopic": 20244, 
    "prevInTopic": 20237, 
    "headers": {
        "inReplyToHeader": "PDE3ZmE1M2QwODAxMTUwMjU2eTJhNzIxNzU3ajVkNDBiMTBiYjk3ZmM1NDVAbWFpbC5nbWFpbC5jb20+", 
        "messageIdInHeader": "PGZtaXBvbStzYTdiQGVHcm91cHMuY29tPg=="
    }
}