{
    "numMessagesInTopic": 9, 
    "nextInTime": 11144, 
    "senderId": "e2XaJcA9ASwt8-tXnZy63PzJqbiksEd69FG1b6JoiFoMSBpIx-Xm2iC0sj8DOurDbQvFl9cYqsOBEYR1i6hIPzfDU00siqsNN-OK", 
    "systemMessage": false, 
    "subject": "Re: [junit] using JUnit with derived classes", 
    "from": "Curt Sampson &lt;yahoo_sucks@...&gt;", 
    "authorName": "Curt Sampson", 
    "msgSnippet": "... Oh, it s often more to do with changing the testing framework itself. I ve found that in Java I m often stymied because someone has not declared an", 
    "msgId": 11143, 
    "profile": "cjstokyo", 
    "topicId": 11010, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 110189933, 
    "messageBody": "<div id=\"ygrps-yiv-1843608190\">On Mon, 7 Jun 2004, J. B. Rainsberger wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Curt Sampson wrote:<br/>\n&gt;<br/>\n&gt; &gt; I think [things like declaring a test without extending TestCase are]<br/>\n&gt; &gt; valuable because [they give] you a lot more leway to play with<br/>\n&gt; &gt; the design of your testing framework within a particular application. I<br/>\n&gt; &gt; know that I often feel that certain refactoring directions I&#39;d like to<br/>\n&gt; &gt; try are closed to me because of the fairly strict structure of the JUnit<br/>\n&gt; &gt; testing framework.<br/>\n&gt;<br/>\n&gt; Do you have a specific example? Given that the structure (hierarchy) of<br/>\n&gt; test classes does not need to reflect the structure of production<br/>\n&gt; classes, what kinds of refactorings are difficult in JUnit but easy in<br/>\n&gt; NUnit? This is the kind of thing I need to explore, because my JUnit<br/>\n&gt; preconceptions hold me back when thinking in NUnit. You could jump-start<br/>\n&gt; me. :)<br/>\n<br/>\n </span></blockquote>Oh, it&#39;s often more to do with changing the testing framework itself.<br/>\nI&#39;ve found that in Java I&#39;m often stymied because someone has not<br/>\ndeclared an interface for something I wish he had, and so I can&#39;t<br/>\nreplace his object with my own when I want to do something he&#39;s not<br/>\nconsidered. With languages such as SmallTalk and Ruby, this tends to be<br/>\nless of a problem because I so long as I supply an object that answers<br/>\nthe necessary messages, it will work.<br/>\n<br/>\nI&#39;ve been doing some work with Ruby lately, but I&#39;ve not spent enough<br/>\ntime with it really to discover how useful this will be. (As well,<br/>\nTest::Unit in Ruby has some unpleasant problems, such a TestCase class<br/>\nthat seems very difficult to subclass due to the way the run method<br/>\ncalls the actual test method. Really, that framework code should be<br/>\nmixed in from a module, not be embedded class, I think.)<br/>\n<br/>\nAnyway, I&#39;ve appended a little example I was playing with this morning<br/>\nwhere I ended up making a test suite that was just a hash of inputs<br/>\nand expected results, something you&#39;d typically have to build up a<br/>\nparameterized test case for. The key code ends up being, instead, just:<br/>\n<br/>\n<br/>\n    fibtest_hash = { 0 =&gt; 0, 1 =&gt; 1, 2 =&gt; 1, 3 =&gt; 2, 4 =&gt; 3, 5 =&gt; 5, 6 =&gt; 8 }<br/>\n<br/>\n    def fibtest_hash.calculate_result(input)<br/>\n\tFib.new.fib(input)<br/>\n    end<br/>\n<br/>\n    fibtest_hash.extend(TestEachInputExpectedPair)<br/>\n<br/>\n    Test::Unit::UI::Console::TestRunner.run(fibtest_hash)<br/>\n<br/>\nOf course, that object doesn&#39;t have to be a Hash. It might be, for<br/>\nexample, a database query that pulls data from test runs against an<br/>\noracle, or even the oracle itself:<br/>\n<br/>\n    suite = SQLQuery.new(&quot;SELECT input, result FROM old_test_run&quot;)<br/>\n<br/>\n    def suite.calculate_result(input)<br/>\n\t...<br/>\n    end<br/>\n<br/>\n    suite.extend(TestEachInputExpectedPair)<br/>\n<br/>\n    Test::Unit::UI::Console::TestRunner.run(suite)<br/>\n<br/>\nUnfortunately, I&#39;m out of time today to think about this further....<br/>\n<br/>\ncjs<br/>\n-- <br/>\nCurt Sampson  &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:cjs@...\">cjs@...</a>&gt;   +81 90 7737 2974   <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.NetBSD.org\">http://www.NetBSD.org</a><br/>\n    Don&#39;t you know, in this new Dark Age, we&#39;re all light.  --XTC<br/>\n<br/>\n<br/>\n<br/>\nrequire &#39;test/unit/testcase&#39;<br/>\nrequire &#39;test/unit/testsuite&#39;<br/>\nrequire &#39;test/unit/ui/console/testrunner&#39;<br/>\n<br/>\n######################################################################<br/>\n# Given the ordinal position of a Fibonacci number, return its value.<br/>\n<br/>\nclass Fib<br/>\n<br/>\n    def fib(ordinal)<br/>\n\tcase ordinal<br/>\n\t    when 0<br/>\n\t\treturn 0<br/>\n\t    when 1<br/>\n\t\treturn 1<br/>\n\t    else<br/>\n\t\treturn fib(ordinal - 1) + fib(ordinal - 2)<br/>\n\tend<br/>\n    end<br/>\n<br/>\nend<br/>\n<br/>\n<br/>\n######################################################################<br/>\n# Here&#39;s is J. B. Rainsberger&#39;s example of a parameterized test case<br/>\n# in Java, followed by the Ruby equivalant for testing the Fib class.<br/>\n<br/>\n=begin<br/>\npublic class CalculateAgeTest extends TestCase {<br/>\n    private int expectedAge;<br/>\n    private Date futureDate;<br/>\n<br/>\n    public CalculateAgeTest(String testName,<br/>\n\tint expectedAge, Date futureDate) {<br/>\n\tsuper(testName);<br/>\n\tthis.expectedAge = expectedAge;<br/>\n\tthis.futureDate = futureDate;<br/>\n    }<br/>\n<br/>\n    public static Test suite() {<br/>\n\tTestSuite suite = new TestSuite(&quot;Calculate Age&quot;);<br/>\n\tsuite.addTest(new CalculateAgeTest(&quot;birthday&quot;,<br/>\n\t    30, DateUtil .makeDate(2004, 5, 4)));<br/>\n\tsuite.addTest(new CalculateAgeTest(&quot;day before birthday&quot;,<br/>\n\t    29, DateUtil.makeDate(2004, 5, 3)));<br/>\n\tsuite.addTest(new CalculateAgeTest(&quot;day after birthday&quot;,<br/>\n\t    30, DateUtil.makeDate(2004, 5, 5)));<br/>\n\tsuite.addTest(new CalculateAgeTest(&quot;date of birth&quot;,<br/>\n\t    0, DateUtil .makeDate(1974, 5, 4)));<br/>\n\tsuite.addTest(new CalculateAgeTest(&quot;invalid future date&quot;,<br/>\n\t    0, DateUtil .makeDate(1974, 5, 3)));<br/>\n\treturn suite;<br/>\n    }<br/>\n<br/>\n    protected void runTest() throws Exception {<br/>\n\tBiographicalReport biographicalReport<br/>\n\t    = PlayerFactory.makeBiographicalReport(<br/>\n\t    &quot;Joe&quot;, &quot;Rainsberger&quot;, DateUtil .makeDate(1974, 5, 4));<br/>\n<br/>\n\tassertEquals(new Integer(expectedAge),<br/>\n\t    biographicalReport.getAgeAsOf(futureDate));<br/>\n    }<br/>\n}<br/>\n=end<br/>\n<br/>\nclass TC_Fib_JBRStyle &lt; Test::Unit::TestCase<br/>\n<br/>\n    def initialize(input, expected)<br/>\n\tsuper(&quot;run_test&quot;)<br/>\n\t@input = input<br/>\n\t@expected = expected<br/>\n    end<br/>\n<br/>\n    def name<br/>\n\treturn &quot;input #{@input}&quot;<br/>\n    end<br/>\n<br/>\n    def self.suite<br/>\n\tsuite = Test::Unit::TestSuite.new(self.to_s)<br/>\n\tsuite &lt;&lt; new(0, 0)<br/>\n\tsuite &lt;&lt; new(1, 1)<br/>\n\tsuite &lt;&lt; new(2, 1)<br/>\n\tsuite &lt;&lt; new(3, 2)<br/>\n\tsuite &lt;&lt; new(4, 3)<br/>\n\tsuite &lt;&lt; new(5, 5)<br/>\n\tsuite &lt;&lt; new(6, 8)<br/>\n\treturn suite<br/>\n    end<br/>\n<br/>\n    def run_test<br/>\n\tassert_equal(@expected, Fib.new.fib(@input))<br/>\n    end<br/>\n<br/>\nend<br/>\n<br/>\nputs &quot;&#92;n#{&#39;=&#39; * 60}&#92;n&quot;<br/>\nTest::Unit::UI::Console::TestRunner.run(TC_Fib_JBRStyle.suite)<br/>\n<br/>\n<br/>\n######################################################################<br/>\n# However, with a helper class and a simple suite method that we<br/>\n# can mix in to another object, we can use any object that responds<br/>\n# to the each_pair message, such as a Hash,  as a set of inputs and<br/>\n# expected output values. We merely need to make it answer to a<br/>\n# calculate_result message to tell us what the actual output is for<br/>\n# a given input. Here&#39;s the helper class and the module with the<br/>\n# method we mixin.<br/>\n<br/>\nclass InputAndExpectedTestCase &lt; Test::Unit::TestCase<br/>\n<br/>\n    def initialize(input, expected, &calculate_result)<br/>\n\tsuper(&quot;run_test&quot;)<br/>\n\t@input = input<br/>\n\t@expected = expected<br/>\n\t@calculate_result = calculate_result<br/>\n    end<br/>\n<br/>\n    def name<br/>\n\treturn &quot;input #{@input}&quot;<br/>\n    end<br/>\n<br/>\n    def run_test<br/>\n\tassert_equal(@expected, @calculate_result.call(@input))<br/>\n    end<br/>\n<br/>\nend<br/>\n<br/>\nmodule TestEachInputExpectedPair<br/>\n<br/>\n    def suite<br/>\n\tsuite = Test::Unit::TestSuite.new(self.to_s)<br/>\n\teach_pair { |input, expected|<br/>\n\t    suite &lt;&lt; InputAndExpectedTestCase.new(input, expected) { |i|<br/>\n\t\tself.calculate_result(i)<br/>\n\t    }<br/>\n\t}<br/>\n\treturn suite<br/>\n    end<br/>\n<br/>\nend<br/>\n<br/>\n<br/>\n######################################################################<br/>\n# Now let&#39;s see how easy it is to set up our test.<br/>\n# Note that below we never extend any class in Test::Unit.<br/>\n<br/>\nfibtest_hash = { 0 =&gt; 0, 1 =&gt; 1, 2 =&gt; 1, 3 =&gt; 2, 4 =&gt; 3, 5 =&gt; 5, 6 =&gt; 8 }<br/>\n<br/>\ndef fibtest_hash.calculate_result(input)<br/>\n    Fib.new.fib(input)<br/>\nend<br/>\n<br/>\nfibtest_hash.extend(TestEachInputExpectedPair)<br/>\n<br/>\nputs &quot;&#92;n#{&#39;=&#39; * 60}&#92;n&quot;<br/>\nTest::Unit::UI::Console::TestRunner.run(fibtest_hash)<br/>\n<br/>\n<br/>\n######################################################################<br/>\n# But, as it turns out, if we&#39;re iterating through every number of<br/>\n# a Fibonacci sequence from the beginning, we know a very easy<br/>\n# algorithm to calculate the result; it&#39;s just the sum of the last<br/>\n# two results (after the first two special cases). So we can automate<br/>\n# the test using that algorithm. (This could actually have been done<br/>\n# in a very similar way using J. B. Rainsberger&#39;s style above.)<br/>\n<br/>\nclass Fibtest_Programmatic<br/>\n<br/>\n    def calculate_result(input)<br/>\n\tFib.new.fib(input)<br/>\n    end<br/>\n<br/>\n    def each_pair<br/>\n\tyield(0, 0)<br/>\n\tyield(1, 1)<br/>\n\tlast = 0; current = 1<br/>\n\t(2..15).each { |next_ordinal|<br/>\n\t    yield(next_ordinal, last + current)<br/>\n\t    last, current = current, last + current<br/>\n\t}<br/>\n    end<br/>\n<br/>\nend<br/>\n<br/>\nprogrammatic_suite = Fibtest_Programmatic.new<br/>\nprogrammatic_suite.extend(TestEachInputExpectedPair)<br/>\n<br/>\nputs &quot;&#92;n#{&#39;=&#39; * 60}&#92;n&quot;<br/>\nTest::Unit::UI::Console::TestRunner.run(programmatic_suite)</div>", 
    "prevInTime": 11142, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1086656582", 
    "canDelete": false, 
    "nextInTopic": 11144, 
    "prevInTopic": 11134, 
    "headers": {
        "inReplyToHeader": "PDQwQzQ0QzJCLjIwNTAzMDlAcm9nZXJzLmNvbT4=", 
        "messageIdInHeader": "PFBpbmUuTkVCLjQuNTguMDQwNjA4MDk1MDAyMC40NzlAYW5nZWxpYy12dGZ3LmN2cG4uY3luaWMubmV0Pg==", 
        "referencesHeader": "PGM3dHN1MytmY3NiQGVHcm91cHMuY29tPiA8NDBBMkFDRjcuOTAzMDcwNEByb2dlcnMuY29tPiA8UGluZS5ORUIuNC41OC4wNDA1MjUxMzA5NTQwLjkyMzNAYW5nZWxpYy12dGZ3LmN2cG4uY3luaWMubmV0PiA8NDBCMzgyOUEuMjA0MDYwM0Byb2dlcnMuY29tPiA8UGluZS5ORUIuNC41OC4wNDA2MDcxMjE3MDUwLjQ0OEBhbmdlbGljLXZ0ZncuY3Zwbi5jeW5pYy5uZXQ+IDw0MEM0NEMyQi4yMDUwMzA5QHJvZ2Vycy5jb20+"
    }
}