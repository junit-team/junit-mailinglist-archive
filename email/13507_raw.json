{
    "numMessagesInTopic": 55, 
    "nextInTime": 13508, 
    "senderId": "cbT4xfeMV465aQFBWMlXn2FeSbpTXvOafKkv5uRS28ouK3eRzxmPt9v1gYcheKog7D22LxBaG3KBXImUzfmKtKzOZ_OWNyATL3KrqQ", 
    "systemMessage": false, 
    "subject": "Re: DbUnit & ORM", 
    "from": "&quot;haefeleuser&quot; &lt;haefeleuser@...&gt;", 
    "authorName": "haefeleuser", 
    "msgSnippet": "... It does not need to know. What you do in your example, is to mock the data source. The ORM we use has so called Providers for every entity: ", 
    "msgId": 13507, 
    "rawEmail": "Return-Path: &lt;haefeleuser@...&gt;\r\nX-Sender: haefeleuser@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (qmail 26871 invoked from network); 13 May 2005 16:38:13 -0000\r\nReceived: from unknown (66.218.66.166)\n  by m25.grp.scd.yahoo.com with QMQP; 13 May 2005 16:38:13 -0000\r\nReceived: from unknown (HELO n10a.bulk.scd.yahoo.com) (66.94.237.44)\n  by mta5.grp.scd.yahoo.com with SMTP; 13 May 2005 16:38:13 -0000\r\nComment: DomainKeys? See http://antispam.yahoo.com/domainkeys\r\nReceived: from [66.218.66.58] by n10.bulk.scd.yahoo.com with NNFMP; 13 May 2005 16:36:58 -0000\r\nReceived: from [66.218.66.83] by mailer7.bulk.scd.yahoo.com with NNFMP; 13 May 2005 16:36:58 -0000\r\nDate: Fri, 13 May 2005 16:36:57 -0000\r\nTo: junit@yahoogroups.com\r\nMessage-ID: &lt;d62l39+ruvj@...&gt;\r\nIn-Reply-To: &lt;4283EF61.10700@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Length: 2958\r\nX-Mailer: Yahoo Groups Message Poster\r\nX-Yahoo-Newman-Property: groups-compose\r\nX-eGroups-Msg-Info: 1:12:0\r\nFrom: &quot;haefeleuser&quot; &lt;haefeleuser@...&gt;\r\nSubject: Re: DbUnit & ORM\r\nX-Yahoo-Group-Post: member; u=174752849\r\nX-Yahoo-Profile: haefeleuser\r\n\r\n--- In junit@yahoogroups.com, &quot;J. B. Rainsberger&quot; &lt;jbrains@r...&gt;\nwrote:\n&gt;&gt;Does your business logic need to know where it gets the data from?\n&gt;&gt;Usually not. Separate the data source from the business logic using \n&gt;&gt;the data...\nIt does not need to know.\n\nWhat you do in your example, is to mock the data source.\n\nThe ORM we use has so called Providers for every entity:\nArticleProvider, SupplierProvider and so on. Besides that, the ORM has\nso called Managers, for example ArticleManager, SupplierManager and\nso on.\n\nMost of these ORM-related classes are generated by a code generation\ntool. We have methods like ArticleProvider.getArticleById(String id)\nand SupplierManager.createSupplier(Supplier supplier). Most of it is\ngenerated from meta data.\n\nIf we would use your strategy, we had to mock a lot of Providers and\nManagers. Lets assume the business logic method called\ncalculateReplacementTime(...) uses 2 Providers directly and another 2\nProviders indirectly (by calling other methods which use them). Then\nwe would have to mock 4 Providers for testing.\n\nThe business logic is often inside a stateless session bean. So we\nwould need to pass the Providers (either real or just mocks) into the\nmethod calculateReplacementTime(...), which would be 4 parameters.\n\nSome business logic methods (we call them &quot;Services&quot;) even use\nManagers which I mentioned above. So we would have to mock all these\nManagers too. In a way we would have to mock the whole ORM if we are\nconsequent. Would we walk on air then? I don&#39;t know.\n\nDon&#39;t be confused about Managers and Providers for each entity. They\nare an ugly consequence of that home grown crappy ORM I have to use.\n\nI don&#39;t know if this strategy can be applied in our case without\nintroducing too much noise and confusion in implementation and design.\nI&#39;ll think about it in more detail later. It could work. But I have to\nfind a good solution for our case.\n\n&gt;&gt;DbUnit is good for any test that talks to a live database. I simply\n&gt;&gt;prefer to do that as little as possible.\n\nYou wrote in your earlier answer that you wouldn&#39;t use DbUnit for\nbuilding test data and that you would use the ORM to do it. Or did I\nmisunderstood you?\n\nIts much easier for me to read this data building below than a data\nXML file for DbUnit:\nmeasurementUnit.setIsoId(&quot;KGM&quot;);\narticle.setId(&quot;123);\narticle.setMeasurementUnit(measurementUnit);\narticleMgr.persistArticle(article);\nentityGarbageCollector.addGarbage(article);\n...\nentityGarbageCollector.disposeGarbage(); // after the test is finished\n\nIf I refactor a entity name or a persistant attribute name (inside\nEclipse with the wizard), then my test still works. But with DbUnit I\nwould need to update the XML file manually, changing the field &quot;buyer&quot;\nto &quot;purchaser&quot; for example.\n\nUsing mocks is okay. But there are quite a lot of bugs which can only\nbe found with integration tests. Do you write pure unit tests? What\nabout integration testing? Is JUnit suitable for integration tests?\n\n\n\n", 
    "profile": "haefeleuser", 
    "topicId": 13451, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 174752849, 
    "prevInTime": 13506, 
    "contentTrasformed": false, 
    "postDate": "1116002217", 
    "canDelete": false, 
    "nextInTopic": 13516, 
    "prevInTopic": 13504, 
    "headers": {
        "inReplyToHeader": "PDQyODNFRjYxLjEwNzAwQHJvZ2Vycy5jb20+", 
        "messageIdInHeader": "PGQ2MmwzOStydXZqQGVHcm91cHMuY29tPg=="
    }
}