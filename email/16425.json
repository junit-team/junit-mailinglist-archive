{
    "numMessagesInTopic": 18, 
    "nextInTime": 16426, 
    "senderId": "8D6qhOQpJmjkOfpGua861gm7Y9sPBNPRZ0HzYkcvRrkztuuSlwR1XMeLNyA__hqI6b1ZpfsjBLfvDqlPsOf0jk1UQ3569m9tz7eBIPwgTw", 
    "systemMessage": false, 
    "subject": "Re: [junit] chosing between jmock and easymock for mocks?", 
    "from": "&quot;J. B. Rainsberger&quot; &lt;jbrains@...&gt;", 
    "authorName": "J. B. Rainsberger", 
    "msgSnippet": "... It s possible that the projects I ve been on have been small, but the few times that I need to change method name strings in jMock tests, I don t have to", 
    "msgId": 16425, 
    "profile": "nails762", 
    "topicId": 16387, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 127224993, 
    "messageBody": "<div id=\"ygrps-yiv-1926957303\">Joakim Ohlrogge wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; I have a lot of respect for you and your opinions and I usually enjoy<br/>\n&gt; your posts and agree with what you write but did you really think this<br/>\n&gt; one through: (?)<br/>\n&gt; <br/>\n&gt;  &gt; First, I don&#39;t know why he&#39;s creating a constant for every method he<br/>\n&gt;  &gt; mocks. If he lives in a world where all literals must be stored in a<br/>\n&gt;  &gt; constant, that&#39;s not jMock&#39;s fault. That&#39;s called &quot;tyranny&quot; and is bound<br/>\n&gt;  &gt; to bad for a number of other reasons.<br/>\n&gt; <br/>\n&gt; About keeping all literals constants I coudn&#39;t agree more. But if you<br/>\n&gt; need to use the same method over and over again it kind of bites when<br/>\n&gt; you need to change it doesn&#39;t it? So in a way you could say jMock<br/>\n&gt; forces you to do that (or search replace, or not change that many<br/>\n&gt; methods that often, or be really clever when you write your tests).<br/>\n<br/>\n </span></blockquote>It&#39;s possible that the projects I&#39;ve been on have been small, but the <br/>\nfew times that I need to change method name strings in jMock tests, I <br/>\ndon&#39;t have to change 10 or 20 locations, but a handful--up to 5, say. <br/>\nThat could either be due to the size of the project or due to the way I <br/>\nhandle dependencies: once a method&#39;s being used 10 times, it&#39;s probably <br/>\nnamed correctly; and if it isn&#39;t, then it&#39;s probably not being used <br/>\nmuch. It could just be luck.<br/>\n<br/>\nAny way we slice it, it has not been a hardship for me. I&#39;ve not yet had <br/>\njMock force me to spend more than a couple of minutes a few times per <br/>\nproject on this problem. The flexibility it gives me far repays that <br/>\ncost. That could someday change.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; I think jMock tend to bite beginners a bit more than record/replay<br/>\n&gt; frameworks such as easyMock. If you are really good at test-driven<br/>\n&gt; programming, understand interaction based testing fully and know all<br/>\n&gt; your patterns and your OO-principles you will not have a big problem<br/>\n&gt; with jMock, Your test will not have that much setUp-code that the<br/>\n&gt; &quot;declarative&quot; nature is a problem.<br/>\n&gt; <br/>\n&gt; However in most projects (if not all) I have been on there have been a<br/>\n&gt; few people that are not (yet) that great at TDD or OO for that matter.<br/>\n&gt; Very few have yet seen the light when it comes to interaction based<br/>\n&gt; testing and think that it is used primarily for isolating your system<br/>\n&gt; from external systems. With that view they will use any mock-framework<br/>\n&gt; poorly. They make mistakes and learn from them same as we all have<br/>\n&gt; done. There will be tests with too complicated setup etc, they might<br/>\n&gt; not be your&#39;s but you may have to change them when refactoring<br/>\n&gt; something else...<br/>\n<br/>\n </span></blockquote>Well, naturally no tool is for everyone. I was simply pointing out some <br/>\nof CrazyBob&#39;s arguments with which I disagreed or that I thought were <br/>\nincomplete or inadequate. It was definitely not a call for the entire <br/>\nworld to stop using EasyMock and start using jMock.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;  &gt; Still, there&#39;s a flipside to the whole &quot;can&#39;t generate a method stub&quot;<br/>\n&gt;  &gt; argument. With EasyMock, if I use a faked or mocked method that doesn&#39;t<br/>\n&gt;  &gt; yet exist, my test can&#39;t even compile yet!<br/>\n&gt; <br/>\n&gt; Yes but I see that as a good thing, I totally don&#39;t see the problem.<br/>\n&gt; You will have compilation errors if your compiler runs automatically<br/>\n&gt; like in eclipse but that is kind of because it doesn&#39;t compile right?<br/>\n<br/>\n </span></blockquote>If I&#39;m designing an API, and I haven&#39;t settled on a method name or <br/>\nsignature yet, it&#39;s nice that jMock doesn&#39;t force me to generate a <br/>\nmethod stub, possibly in many places (if I&#39;m adding to an existing <br/>\ninterface with several implementations) until I&#39;m sure it&#39;s what I want. <br/>\nWith jMock, I can run that test, watch it fail, think about whether I <br/>\nlike the proposed method, then and only then, add it to the interface.<br/>\n<br/>\nYes, I can run broken code in Eclipse, but I don&#39;t like running broken <br/>\ncode if I can avoid it.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;  &gt; When I practise TDD, I often<br/>\n&gt;  &gt; design interfaces, and forcing me to generate a method stub for a method<br/>\n&gt;  &gt; I might not even like yet is annoying.<br/>\n&gt; <br/>\n&gt; I usually create my interfaces from tests too and I think if anything<br/>\n&gt; RMock and Easymock promtes that: ctrl-space, done. If you don&#39;t like<br/>\n&gt; the method at some later Ã¶point, delete. I don&#39;t see how this can be<br/>\n&gt; annoying. You allways have the oportunity not to generate the method<br/>\n&gt; if you until you like it and whith rMock and EasyMock you can<br/>\n&gt; automatically refactor it to something you like when you know what you<br/>\n&gt; like, with jmock this is a bit harder IMHO. _I_ personally find it way<br/>\n&gt; more annying to replace all occurences of a method that I decided I<br/>\n&gt; didn&#39;t like at some point later when I know more about the system I&#39;m<br/>\n&gt; coding than I did when I created an interface.<br/>\n<br/>\n </span></blockquote>I think you misunderstand me, but it&#39;s not that important.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;  &gt; Keeping the methods as strings<br/>\n&gt;  &gt; allows me to write the test, compile it, and even run it before I decide<br/>\n&gt;  &gt; whether the interface or method signature is good enough to start<br/>\n&gt;  &gt; putting into stone.<br/>\n&gt; <br/>\n&gt; What does putting it into stone mean? It is not like you cannot change<br/>\n&gt; your mind once you generated your method-stub and it is not like you<br/>\n&gt; can&#39;t refactor it later (unless you&#39;re using jMock :))<br/>\n<br/>\n </span></blockquote>Compared to not having to remove anything at all, having to remove a <br/>\nmethod from an interface and 3 implementation is &quot;stone&quot;.<br/>\n<br/>\nI agree that jMock can make it slightly more expensive to rename a <br/>\nmocked method, but as I wrote above, in my practice, jMock returns that <br/>\ncost in other ways, and then some.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; And what is the point in running it, nothing can possibly call your<br/>\n&gt; mocks since the methods do not exist. To me this is like saying using<br/>\n&gt; only reflection instead of calling methods directly is bettter because<br/>\n&gt; you can run the code before it compiles. What am I missing, I don&#39;t<br/>\n&gt; see that any value is lost with EasyMock and rMock in this case.<br/>\n<br/>\n </span></blockquote>I like to run the test, because then I get to think about what&#39;s <br/>\nhappening when it runs. This is purely a personal point. This allows me <br/>\nto reflect on the run-time aspects of what I&#39;ve just written. After the <br/>\ntest fails and I look at the code again, I return to reflecting on the <br/>\ndesign aspects of what I&#39;ve just written. If, during that time, nothing <br/>\ntells me, &quot;This is silly! Change it!&quot; then I continue on.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;  &gt; As for EasyMock being more readable, EasyMock 1.x certainly wasn&#39;t. It<br/>\n&gt;  &gt; looks like EasyMock 2.0 gives jMock a run for its money, at least in the<br/>\n&gt;  &gt; easiest cases. The jury&#39;s out, since I haven&#39;t used it yet.<br/>\n&gt; <br/>\n&gt; I think that is in the eyes of the beholder. Ironically I noticed that<br/>\n&gt; a lot of people think that EasyMock is more intuitive than jMock and<br/>\n&gt; hence more readable until someone explains to them why jMock is more<br/>\n&gt; readable and then they change their mind. So which is better?<br/>\n<br/>\n </span></blockquote>There is probably no one answer to that question. There is no question <br/>\nthat EasyMock is, well, easier. (It&#39;s in the name after all.) But <br/>\nreadability and refactorability of the code is not the only factor in <br/>\ndetermining which is better. I think you&#39;re forgotten that jMock has <br/>\nmore features and flexibility than (at least) EasyMock 1.x. (I could be <br/>\nwrong, because I haven&#39;t touched EasyMock since early 2004.)<br/>\n&lt;snip /&gt;<br/>\n-- <br/>\nJ. B. (Joe) Rainsberger :: <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.jbrains.info\">http://www.jbrains.info</a><br/>\nYour guide to software craftsmanship<br/>\nJUnit Recipes: Practical Methods for Programmer Testing<br/>\n2005 Gordon Pask Award for contribution Agile Software Practice</div>", 
    "prevInTime": 16424, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1143636510", 
    "canDelete": false, 
    "nextInTopic": 16432, 
    "prevInTopic": 16418, 
    "headers": {
        "inReplyToHeader": "PGI5ZWU1ZTQxMDYwMzI3MDAyN3A1NTVmNmFjMXJhMmEwYWNhMDZiMTdkNDQzQG1haWwuZ21haWwuY29tPg==", 
        "messageIdInHeader": "PDQ0MkE4MjFFLjkwODA3MDBAcm9nZXJzLmNvbT4=", 
        "referencesHeader": "PGEwM2EyMDkzMDYwMzI0MDc1MG42YWIxYTI3OWc0M2QxOTJhMDZmZmNhMjY1QG1haWwuZ21haWwuY29tPgkgPGI4NmI2YTljMDYwMzI1MjEyNWk0NTgxZmZlNnE0MGFhZDY1YjdhNzAwM2I1QG1haWwuZ29vZ2xlLmNvbT4JIDw0NDI3M0E3Qy4xMDAwNzA1QHJvZ2Vycy5jb20+IDxiOWVlNWU0MTA2MDMyNzAwMjdwNTU1ZjZhYzFyYTJhMGFjYTA2YjE3ZDQ0M0BtYWlsLmdtYWlsLmNvbT4="
    }
}