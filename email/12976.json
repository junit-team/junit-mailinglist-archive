{
    "numMessagesInTopic": 3, 
    "nextInTime": 12977, 
    "senderId": "Lu52fwV9dAJDDOcobbKDj1LadVlzPN0y_ob49q3hNVLviLCy7l_q-FbLYc07UH9U4b8IzZdGq6t0Lnw1w8B1ND-Y", 
    "systemMessage": false, 
    "subject": "Approach for testing privately contained list?", 
    "from": "&quot;kk_oop&quot; &lt;kk_oop@...&gt;", 
    "authorName": "kk_oop", 
    "msgSnippet": "Hi. In Java, we have a class MyClass that privately contains an ArrayList as an attribute called myList.  We were looking for a way to enable a JUnit test case", 
    "msgId": 12976, 
    "profile": "kk_oop", 
    "topicId": 12976, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 192309277, 
    "messageBody": "<div id=\"ygrps-yiv-1148340242\">Hi.<br/>\n<br/>\nIn Java, we have a class MyClass that privately contains an ArrayList<br/>\nas an attribute called myList.  We were looking for a way to enable a<br/>\nJUnit test case class to call MyClass methods, then check the state of<br/>\nmyList.<br/>\n<br/>\nHere&#39;s a what we are considering:<br/>\n<br/>\na.  Make a protected method in MyClass called getMyList that returns<br/>\nmyList and performs lazy instantiation (it&#39;ll only instantiate myList<br/>\nthe first time it is called but will return myList everytime). <br/>\nMyClass should only access myList through this getter.<br/>\n<br/>\nb. Make a test version of MyClass called something like TestMyClass. <br/>\nGive that a public version of the myList attribute called myTestList.<br/>\n <br/>\n<br/>\nc. Override getMyList so it will use myTestList instead of myList.<br/>\n<br/>\nd. The test case class will instantiate TestMyClass, and call its<br/>\nmethods polymorphically through an variable of type MyClass.<br/>\n<br/>\ne.  When the test case wants to check the list values, it will just<br/>\ncast MyClass back to TestMyClass and access the public myTestList.<br/>\n<br/>\nThe upside of this is that myList gets to remain private in the<br/>\nproduction code.  The downside is that we are not actually using<br/>\nmyList in the test runs.  My thought was that if myTestList is the<br/>\nsame type as myList and the override version of getMyList does exactly<br/>\nthe same thing as the production code&#39;s getMyList (except for acting<br/>\non the test version of myList), this downside becomes negligible.<br/>\n<br/>\nNote that we would define TestMyClass as an inner class of the JUnit<br/>\ntest case so it will not have a .java file generated for it.<br/>\n<br/>\nAny thoughts on this approach?  Good?  Bad?  Recommend a different<br/>\napproach?<br/>\n<br/>\nThanks for any feedback!<br/>\n<br/>\nKen</div>", 
    "prevInTime": 12975, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1109650718", 
    "canDelete": false, 
    "nextInTopic": 12980, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PGQwMHFldStpcDl0QGVHcm91cHMuY29tPg=="
    }
}