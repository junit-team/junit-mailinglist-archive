{
    "numMessagesInTopic": 13, 
    "nextInTime": 23640, 
    "senderId": "7A3Da0JJPSd209VbT7CjBa5lQU7cS_H4lP0fZ6kOp747Lw9FS68Vw_Mcwqt5HW-Q57R8iV9sbEK5M1quJcEpy0dEstt4RTagGkDYC7uq5MrBZxT1fytno_Y", 
    "systemMessage": false, 
    "subject": "Re: [junit] Feature request: @Assumes", 
    "from": "Stephen Connolly &lt;stephen.alan.connolly@...&gt;", 
    "authorName": "Stephen Connolly", 
    "msgSnippet": "Nope not a mock at all. Say you have a class List (which is not java.util.List but looks a lot like it in terms of interface) This list class is something you", 
    "msgId": 23639, 
    "rawEmail": "Return-Path: &lt;stephen.alan.connolly@...&gt;\r\nReceived: (qmail 41885 invoked by uid 7800); 14 Sep 2011 17:00:26 -0000\r\nX-Sender: stephen.alan.connolly@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nX-Received: (qmail 39230 invoked from network); 14 Sep 2011 15:43:01 -0000\r\nX-Received: from unknown (98.137.34.45)\n  by m16.grp.sp2.yahoo.com with QMQP; 14 Sep 2011 15:43:01 -0000\r\nX-Received: from unknown (HELO mail-wy0-f182.google.com) (74.125.82.182)\n  by mta2.grp.sp2.yahoo.com with SMTP; 14 Sep 2011 15:43:01 -0000\r\nX-Received: by wyh15 with SMTP id 15so2340159wyh.13\n        for &lt;junit@yahoogroups.com&gt;; Wed, 14 Sep 2011 08:42:59 -0700 (PDT)\r\nMIME-Version: 1.0\r\nX-Received: by 10.227.203.194 with SMTP id fj2mr317925wbb.79.1316014699675; Wed,\n 14 Sep 2011 08:38:19 -0700 (PDT)\r\nX-Received: by 10.227.152.73 with HTTP; Wed, 14 Sep 2011 08:38:19 -0700 (PDT)\r\nIn-Reply-To: &lt;CACfbOveM6NMPJDFn5B9uyo5bccFJy1+rWvs8373cGHhv71wVWg@...&gt;\r\nReferences: &lt;CA+nPnMwbfNvxbhqjWVyXW7UDt2VM5TzwWzwAiRJaHkKrnHzmxQ@...&gt;\n\t&lt;CA+nPnMyQPw_hmB5PZjY5tO7LdhSvXJkb7Nn9JFZreB1Vy5P8ow@...&gt;\n\t&lt;CACfbOveM6NMPJDFn5B9uyo5bccFJy1+rWvs8373cGHhv71wVWg@...&gt;\r\nDate: Wed, 14 Sep 2011 16:38:19 +0100\r\nMessage-ID: &lt;CA+nPnMzynw4Fw-3FBHF8=d+emhD3g7SOvXJ6x3uN5uj++AP-Vw@...&gt;\r\nTo: junit@yahoogroups.com\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Transfer-Encoding: quoted-printable\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: Stephen Connolly &lt;stephen.alan.connolly@...&gt;\r\nSubject: Re: [junit] Feature request: @Assumes\r\nX-Yahoo-Group-Post: member; u=458231986; y=m7pZSjFexjKv2hLy5-wa7Q8Gq8d7zZEn4TOBVvfyWm5FhqQ30K6Xs54ynaW3NA\r\nX-Yahoo-Profile: stephenalanconnolly\r\nX-eGroups-Approved-By: dsaff &lt;david@...&gt; via email; 14 Sep 2011 17:00:26 -0000\r\n\r\nNope not a mock at all.\n\nSay you have a class List (which is not java.util.=\r\nList but looks a lot\nlike it in terms of interface)\n\nThis list class is som=\r\nething you are developing via TDD.\n\nYou write a whole lot of unit tests for=\r\n it.\n\nNow suppose it happens to be a linked list, and you decide to change\n=\r\nfrom a null for end of list marker to a sentinel instead. All your\nmethods =\r\nare working now, except for the isEmpty() method, but yet 200+\ntest cases a=\r\nre failing because they all rely on isEmpty working. Which\nunit test do I t=\r\nry to fix first?\n\nwith @Assumes, you would have 1 failing test and 199 skip=\r\nped tests...\n\nNo mocks involved at all\n\nOn 14 September 2011 16:34, Carfiel=\r\nd Yim &lt;carfield@...&gt; wrote:\n&gt; It sound like a mock, isn&#39;t it?\n&gt;\n&gt; On =\r\nWed, Sep 14, 2011 at 6:02 PM, Stephen Connolly &lt;\n&gt; stephen.alan.connolly@gm=\r\nail.com&gt; wrote:\n&gt;\n&gt;&gt; Note: I have also posted this to junit-devel@...=\r\nrceforge.net but\n&gt;&gt; I think that wider input could be beneficial\n&gt;&gt;\n&gt;&gt; Cons=\r\nider the case where you are testing a List class...\n&gt;&gt;\n&gt;&gt; we have\n&gt;&gt;\n&gt;&gt; pub=\r\nlic class ListTest {\n&gt;&gt;\n&gt;&gt; =A0@Test\n&gt;&gt; =A0public void newListIsEmpty() {\n&gt;&gt;=\r\n =A0 =A0assertThat(new List().isEmpty(), is(true);\n&gt;&gt; =A0}\n&gt;&gt;\n&gt;&gt; =A0@Test\n&gt;=\r\n&gt; =A0public void newListHasSizeZero() {\n&gt;&gt; =A0 =A0assertThat(new List().siz=\r\ne(), is(0));\n&gt;&gt; =A0}\n&gt;&gt;\n&gt;&gt; =A0@Test\n&gt;&gt; =A0public void addPutsAnElementIntoA=\r\nnEmptyList() {\n&gt;&gt; =A0 =A0List l =3D new List();\n&gt;&gt; =A0 =A0l.add(new Object(=\r\n));\n&gt;&gt; =A0 =A0assertThat(l.isEmpty(), is(false));\n&gt;&gt; =A0}\n&gt;&gt;\n&gt;&gt; =A0@Test\n&gt;&gt;=\r\n =A0public void addIncreasesSizeOfPopulatedListByOne() {\n&gt;&gt; =A0 =A0List l =\r\n=3D new List();\n&gt;&gt; =A0 =A0l.add(new Object());\n&gt;&gt; =A0 =A0int s =3D l.size()=\r\n;\n&gt;&gt; =A0 =A0l.add(new Object());\n&gt;&gt; =A0 =A0assertThat(l.size(), is(s + 1));=\r\n\n&gt;&gt; =A0}\n&gt;&gt;\n&gt;&gt; }\n&gt;&gt;\n&gt;&gt; We now want to add some tests of the delete function=\r\nality... but the\n&gt;&gt; reality is that until/unless some of the preceding test=\r\ns are passing,\n&gt;&gt; the tests for delete are meaningless. We could have a per=\r\nfectly\n&gt;&gt; functional List.delete() method but until such time as the above =\r\ntests\n&gt;&gt; are passing, there is no way to tell that the method does not work=\r\n.\n&gt;&gt;\n&gt;&gt; Now I could code my tests like such\n&gt;&gt;\n&gt;&gt; =A0@Test\n&gt;&gt; =A0public voi=\r\nd deleteIsANoOpOnEmptyList() {\n&gt;&gt; =A0 =A0List l =3D new List();\n&gt;&gt; =A0 =A0a=\r\nssumeThat(l.isEmpty(), is(true));\n&gt;&gt; =A0 =A0l.delete(new Object());\n&gt;&gt; =A0}=\r\n\n&gt;&gt;\n&gt;&gt; But all that I am doing is repeating code from the preceding tests,\n=\r\n&gt;&gt; having changed all those tests&#39; assertThat(...)s into assumeThat(...)s\n&gt;=\r\n&gt;\n&gt;&gt; That does not seem agile to me, copy & paste & search & replace... ban=\r\n\n&gt;&gt; code smell there\n&gt;&gt;\n&gt;&gt; I would much rather be able to annotate the test=\r\ns with an @Assumes\n&gt;&gt; annotation that indicates that the test assumes that =\r\nthe specified\n&gt;&gt; tests are passing, e.g.\n&gt;&gt;\n&gt;&gt; =A0@Test\n&gt;&gt; =A0@Assumes(&quot;new=\r\nListIsEmpty&quot;)\n&gt;&gt; =A0public void deleteIsANoOpOnEmptyList() {\n&gt;&gt; =A0 =A0List=\r\n l =3D new List();\n&gt;&gt; =A0 =A0l.delete(new Object());\n&gt;&gt; =A0}\n&gt;&gt;\n&gt;&gt; =A0@Test=\r\n\n&gt;&gt; =A0@Assumes({&quot;newListIsEmpty&quot;,&quot;addPutsAnElementIntoAnEmptyList&quot;)\n&gt;&gt; =A0=\r\npublic void deleteRemovesAnElement() {\n&gt;&gt; =A0 =A0List l =3D new List();\n&gt;&gt; =\r\n=A0 =A0Object o =3D new Object();\n&gt;&gt; =A0 =A0l.add(o);\n&gt;&gt; =A0 =A0l.delete(o)=\r\n;\n&gt;&gt; =A0 =A0assertThat(l.isEmpty(), is(true));\n&gt;&gt; =A0}\n&gt;&gt;\n&gt;&gt; In fact in my =\r\ninitial example of tests, there are some additional\n&gt;&gt; assumptions that I d=\r\nidn&#39;t make explicit\n&gt;&gt;\n&gt;&gt;\n&gt;&gt; =A0@Test\n&gt;&gt; =A0@Assumes(&quot;newListIsEmpty&quot;)\n&gt;&gt; =\r\n=A0public void addPutsAnElementIntoAnEmptyList() {\n&gt;&gt; =A0 =A0...\n&gt;&gt; =A0}\n&gt;&gt;=\r\n\n&gt;&gt; and\n&gt;&gt;\n&gt;&gt; =A0@Test\n&gt;&gt; =A0@Assumes({&quot;newListIsEmpty&quot;,&quot;addPutsAnElementIn=\r\ntoAnEmptyList&quot;)\n&gt;&gt; =A0public void addIncreasesSizeOfPopulatedListByOne() {\n=\r\n&gt;&gt; =A0 =A0...\n&gt;&gt; =A0}\n&gt;&gt;\n&gt;&gt; Now you could get some of this functionality vi=\r\na a TestRule...\n&gt;&gt;\n&gt;&gt; You could watch tests to see if they pass, and skip t=\r\nests annotated\n&gt;&gt; with the annotation if assumed functionality is failing, =\r\nbut that\n&gt;&gt; would result in sporadic failures of, e.g. deleteRemovesAnEleme=\r\nnt\n&gt;&gt; because of the failing newListIsEmpty being executed _after_\n&gt;&gt; delet=\r\neRemovesAnElement rather than before.\n&gt;&gt;\n&gt;&gt; The simple point is that the te=\r\nst result of deleteRemovesAnElement is\n&gt;&gt; meaningless until its assumptions=\r\n are true, and while I could code the\n&gt;&gt; assumptions with assumeThat(..)s C=\r\n&P&S&R is even worse than C&P.\n&gt;&gt;\n&gt;&gt; Another alternative to @Assumes would =\r\nbe to invoke the assumed\n&gt;&gt; method(s) at the start of the test, e.g.\n&gt;&gt;\n&gt;&gt; =\r\n=A0@Test\n&gt;&gt; =A0public void deleteRemovesAnElement() {\n&gt;&gt; =A0 =A0newListIsEm=\r\npty(); // verify assumed functionality\n&gt;&gt; =A0 =A0addPutsAnElementIntoAnEmpt=\r\nyList(); =A0// verify assumed functionality\n&gt;&gt; =A0 =A0...\n&gt;&gt; =A0}\n&gt;&gt;\n&gt;&gt; Tha=\r\nt gets rid of the C&P&S&R, but there are two issues with that:\n&gt;&gt;\n&gt;&gt; =A01. =\r\nWe have to manually invoke any setup/tearDown methods, including\n&gt;&gt; all tho=\r\nse of the rules that the test class has... very messy\n&gt;&gt;\n&gt;&gt; =A02. The test =\r\nfails when the assumed test fails. In actuality we can\n&gt;&gt; say nothing at al=\r\nl about whether deleteRemovesAnElement if a\n&gt;&gt; newListIsEmpty is not passin=\r\ng... yes we could code the test\n&gt;&gt; differently, but that is just moving our=\r\n assumptions somewhere else.\n&gt;&gt;\n&gt;&gt; I am sure that there are others out ther=\r\ne who feel there is a point 3...\n&gt;&gt;\n&gt;&gt; =A03. We already ran those tests why=\r\n waste time running them again?\n&gt;&gt;\n&gt;&gt; Well the answer to 3 is that these ar=\r\ne UNIT tests which should be very\n&gt;&gt; fast, so what is the harm...\n&gt;&gt;\n&gt;&gt; So,=\r\n in my view, best practice unit testing needs the ability to mark\n&gt;&gt; tests =\r\nas assuming that other tests are passing, so that those tests\n&gt;&gt; can be ski=\r\npped when the assumptions are known to be failing or\n&gt;&gt; skipped. [This is a=\r\n deliberately loaded criteria... if the\n&gt;&gt; org.junit.runner.Request does no=\r\nt include the assumed test, then that\n&gt;&gt; test is neither known failing or k=\r\nnown skipped, so we can run the test\n&gt;&gt; and output a warning that the failu=\r\nre may be because of assumed\n&gt;&gt; functionality... the use case of executing =\r\none and only one test\n&gt;&gt; repeatedly until you get that test passing]\n&gt;&gt;\n&gt;&gt; =\r\nThe annotation would have implications on test sorting, as any assumed\n&gt;&gt; t=\r\nests would have to always happen before the assuming tests (as long\n&gt;&gt; as t=\r\nhe assumed tests are in the org.junit.runner.Request)\n&gt;&gt;\n&gt;&gt; Also might have=\r\n to be two annotations, e.g.\n&gt;&gt;\n&gt;&gt; @Assumes(methodNames)\n&gt;&gt; @AssumesClasses=\r\n(classes)\n&gt;&gt;\n&gt;&gt; though in my view the @AssumesClasses is less critical, as =\r\nthese are\n&gt;&gt; UNIT tests and each test class should be independent to a larg=\r\ne\n&gt;&gt; extent. However I am willing to consider that some people may have\n&gt;&gt; =\r\nmany test classes for one class under test, one test class containing\n&gt;&gt; al=\r\nl the tests of the constructors, another testing the Add methods,\n&gt;&gt; etc. i=\r\nn which case an @AssumesClasses annotation makes sense.\n&gt;&gt;\n&gt;&gt; Where tests c=\r\nontain a circular dependency, fail/error both tests\n&gt;&gt;\n&gt;&gt; Ok, let the criti=\r\nque begin!\n&gt;&gt;\n&gt;&gt; -Stephen\n&gt;&gt;\n&gt;&gt; P.S.\n&gt;&gt;\n&gt;&gt; I pinged Kent with an earlier ve=\r\nrsion of this idea... but I think that\n&gt;&gt; he missed the point about elimina=\r\nting C&P&S&R that this feature would\n&gt;&gt; provide because I didn&#39;t frame the =\r\nidea correctly...\n&gt;&gt;\n&gt;&gt; ---------- Forwarded message ----------\n&gt;&gt; From: &quot;K=\r\nent Beck&quot;\n&gt;&gt; Date: 13 Sep 2011 17:11\n&gt;&gt; Subject: Re: JUnit and test depende=\r\nncies\n&gt;&gt; To: &quot;Stephen Connolly&quot;\n&gt;&gt;\n&gt;&gt; Stephen,\n&gt;&gt;\n&gt;&gt; Thank you for articula=\r\nting your idea so clearly. The short answer is that\n&gt;&gt; no, we don&#39;t plan to=\r\n support dependencies. If I have tests that are slow\n&gt;&gt; enough that I care =\r\nabout dependencies, my most productive option is\n&gt;&gt; generally to work on th=\r\ne design of the software until the tests are fast\n&gt;&gt; enough that I no longe=\r\nr care. That said, my voice is only one of many. The\n&gt;&gt; longer answer is th=\r\nat I encourage you to post your idea on the JUnit\n&gt;&gt; mailing\n&gt;&gt; list for co=\r\nmmunity discussion.\n&gt;&gt;\n&gt;&gt; Regards,\n&gt;&gt;\n&gt;&gt; Kent\n&gt;&gt;\n&gt;&gt; On Sep 13, 2011, at 8:3=\r\n2 AM, Stephen Connolly wrote:\n&gt;&gt;\n&gt;&gt; &gt; Kent,\n&gt;&gt; &gt;\n&gt;&gt; &gt; Are there any plans f=\r\nor JUnit to support some test dependencies, such as:\n&gt;&gt; &gt;\n&gt;&gt; &gt; public class=\r\n OnlyRunTestsThatMakeSenseTest {\n&gt;&gt; &gt;\n&gt;&gt; &gt; =A0@Test\n&gt;&gt; &gt; =A0public void bas=\r\nicFunctionalityWorks() {\n&gt;&gt; &gt; =A0 =A0...\n&gt;&gt; &gt; =A0}\n&gt;&gt; &gt;\n&gt;&gt; &gt; =A0@Test\n&gt;&gt; &gt; =\r\n=A0@AssumesPasses(&quot;basicFunctionalityWorks&quot;)\n&gt;&gt; &gt; =A0public void advancedFu=\r\nnctionalityWorks() {\n&gt;&gt; &gt; =A0 =A0...\n&gt;&gt; &gt; =A0}\n&gt;&gt; &gt;\n&gt;&gt; &gt; =A0@Test\n&gt;&gt; &gt; =A0@=\r\nAssumesPasses(&quot;basicFunctionalityWorks&quot;)\n&gt;&gt; &gt; =A0public void basicFunctiona=\r\nlityWorksWithBevel() {\n&gt;&gt; &gt; =A0 =A0...\n&gt;&gt; &gt; =A0}\n&gt;&gt; &gt;\n&gt;&gt; &gt; =A0@Test\n&gt;&gt; &gt;\n&gt;&gt;=\r\n\n&gt;&gt; =A0@AssumesPasses({&quot;basicFunctionalityWorksWithBevel&quot;,&quot;advancedFunction=\r\nalityWorks&quot;})\n&gt;&gt; &gt; =A0public void advancedFunctionalityWorksWithBevel() {\n&gt;=\r\n&gt; &gt; =A0 =A0...\n&gt;&gt; &gt; =A0}\n&gt;&gt; &gt;\n&gt;&gt; &gt; }\n&gt;&gt; &gt;\n&gt;&gt; &gt; In the above example, no mat=\r\nter what sorting is applied,\n&gt;&gt; &gt; basicFunctionalityWorks will always be ru=\r\nn first, and the other three\n&gt;&gt; &gt; tests will only be run if basicFunctional=\r\nityWorks passed.\n&gt;&gt; &gt;\n&gt;&gt; &gt; I see the above being completely in the spirit o=\r\nf unit testing, the\n&gt;&gt; &gt; point with the above is that the @Before and @Afte=\r\nr&#39;s will be run\n&gt;&gt; &gt; around each method, you are just saying that there is =\r\nno point even\n&gt;&gt; &gt; trying to test the advanced functionality when the basic=\r\n functionality\n&gt;&gt; &gt; is broken, skip those tests which we know cannot pass. =\r\nThat allows the\n&gt;&gt; &gt; person writing advancedFunctionalityWorks to power thr=\r\nough the setup\n&gt;&gt; &gt; that depends on the basic functionality and not have to=\r\n litter their\n&gt;&gt; &gt; advanced test with asserts that are redundant because of=\r\n the basic\n&gt;&gt; &gt; functionality. Those people who are relying on side-effects=\r\n should\n&gt;&gt; &gt; really, for unit tests at least, be invoking the method who&#39;s\n=\r\n&gt;&gt; &gt; side-effects they depend on directly within their test method, rather\n=\r\n&gt;&gt; &gt; than relying on accidental ordering.\n&gt;&gt; &gt;\n&gt;&gt; &gt; Having said that, a sec=\r\nond feature that I think would be good is\n&gt;&gt; &gt; something like a @RunAfter a=\r\nnd/or @RunBefore which would ensure that\n&gt;&gt; &gt; the test method is run in seq=\r\nuence even if the before or after tests\n&gt;&gt; &gt; fail/are skipped. with @RunAft=\r\ner and @RunBefore I still think the\n&gt;&gt; &gt; @Before and @After methods should =\r\nbe invoked in-between, this would be\n&gt;&gt; &gt; moving towards more of a general =\r\npurpose testing framework as opposed\n&gt;&gt; &gt; to being unit-testing focused, bu=\r\nt JUnit is just too good ;-)\n&gt;&gt; &gt;\n&gt;&gt; &gt; Thoughts?\n&gt;&gt; &gt;\n&gt;&gt; &gt; -Stephen\n&gt;&gt;\n&gt;&gt;\n&gt;=\r\n&gt; ------------------------------------\n&gt;&gt;\n&gt;&gt; Yahoo! Groups Links\n&gt;&gt;\n&gt;&gt;\n&gt;&gt;\n&gt;=\r\n&gt;\n&gt;\n&gt;\n&gt; [Non-text portions of this message have been removed]\n&gt;\n&gt;\n&gt;\n&gt; -----=\r\n-------------------------------\n&gt;\n&gt; Yahoo! Groups Links\n&gt;\n&gt;\n&gt;\n&gt;\n\n", 
    "profile": "stephenalanconnolly", 
    "topicId": 23636, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 458231986, 
    "prevInTime": 23638, 
    "contentTrasformed": false, 
    "postDate": "1316014699", 
    "canDelete": false, 
    "nextInTopic": 23640, 
    "prevInTopic": 23638, 
    "headers": {
        "inReplyToHeader": "PENBQ2ZiT3ZlTTZOTVBKREZuNUI5dXlvNWJjY0ZKeTErcld2czgzNzNjR0hodjcxd1ZXZ0BtYWlsLmdtYWlsLmNvbT4=", 
        "messageIdInHeader": "PENBK25Qbk16eW53NEZ3LTNGQkhGOD1kK2VtaEQzZzdTT3ZYSjZ4M3VONXVqKytBUC1Wd0BtYWlsLmdtYWlsLmNvbT4=", 
        "referencesHeader": "PENBK25Qbk13YmZOdnhiaHFqV1Z5WFc3VUR0MlZNNVR6d1d6d0FpUkphSGtLcm5Iem14UUBtYWlsLmdtYWlsLmNvbT4JPENBK25Qbk15UVB3X2htQjVQWmpZNXRPN0xkaFN2WEprYjdObjlKRlpyZUIxVnk1UDhvd0BtYWlsLmdtYWlsLmNvbT4JPENBQ2ZiT3ZlTTZOTVBKREZuNUI5dXlvNWJjY0ZKeTErcld2czgzNzNjR0hodjcxd1ZXZ0BtYWlsLmdtYWlsLmNvbT4="
    }
}