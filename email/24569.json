{
    "numMessagesInTopic": 7, 
    "nextInTime": 24570, 
    "senderId": "BW5vv7bLy3juVyY5v1vJzux1--HSNqWxYoSZpa9ze6d5drCauHD9sbff9FL7OlxHLG0ndJBK6nkPyj9z_XjTP2bto1UKhAeFSHVlMA", 
    "systemMessage": false, 
    "subject": "Re: [junit] Side effects between test cases", 
    "from": "Stefan Penndorf &lt;stefan@...&gt;", 
    "authorName": "Stefan Penndorf", 
    "msgSnippet": "Hi Tobi, I think it s really hard to address those things. I agree with Esko that those concerns are rare in every-day projects. If you re using timeouts in", 
    "msgId": 24569, 
    "topicId": 24565, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 515214438, 
    "messageBody": "<div id=\"ygrps-yiv-1693315245\"><html>\n  <head>\n\n    \n  </head>\n  \n    <div class=\"ygrps-yiv-1693315245moz-cite-prefix\">Hi Tobi,<br>\n      <br>\n      I think it&#39;s really hard to address those things. I agree with\n      Esko that those concerns are rare in &quot;every-day&quot; projects.<br>\n      <br>\n      If you&#39;re using timeouts in tests those might not be _unit_ tests\n      but _integration_ tests. That said you should consider separating\n      them from the &quot;real&quot; unit tests. If you&#39;re a maven user you could\n      use failsafe to run those. With failsafe you could use multiple\n      JVMs or a JVM per test(class) if memory is an issue. I always\n      configure a larger heap for integration tests than for unit tests\n      which will reduce the likelyhood of OutOfMemoryErrors. I would\n      avoid that but you could trigger garbage collection in @Before or\n      @BeforeClass or @After methods.<br>\n      <br>\n      If you&#39;re having long running code you should check\n      Thread.isInterrupted() and exit the computation or throw an\n      InterruptedException(). This applies to long running test code and\n      will also be good practice for long running production code. For\n      example you could insert the check between line 40 and 41 of your\n      example [1] and throw InterruptedException or return &quot;silently&quot;.\n      See also [2] for more details.<br>\n      Nevertheless if I experienced long running production code in the\n      wild there was always I/O involved - most I/O operations do throw\n      InterruptedExceptions themselfes. And - additionally - if I/O is\n      involved those tests are no longer unit tests.<br>\n      <br>\n      ------<br>\n      But that won&#39;t safe you from infinite loops in production code\n      tested by real unit tests. If your team executes all unit tests\n      before checking in, those infinite loops will only occur once on\n      developer machines and should be fixed before checking code in. If\n      there&#39;s an infinite loop and no timeout configured the developer\n      will see the test causing the infinite loop and fix it. <br>\n      <br>\n      <br>\n      Maybe you could explain further why timing is an issue for you.\n      And maybe you can also describe the code and project that causes\n      the issue.<br>\n      <br>\n      Stefan<br>\n      <br>\n      [2] Java Concurrency in Practice by Brian Goetz et al.<br>\n      <br>\n      Am 24.07.2014 22:49, schrieb Tobias Werth <a rel=\"nofollow\" class=\"ygrps-yiv-1693315245moz-txt-link-abbreviated\" target=\"_blank\" href=\"mailto:Tobias.Werth@...\">Tobias.Werth@...</a>\n      [junit]:<br>\n    </div>\n    <blockquote><span title=\"qreply\"> <blockquote\n\n type=\"cite\"> <span style=\"display:none;\">&nbsp;</span>\n      \n          <div id=\"ygrps-yiv-1693315245ygrp-text\">\n            <p>Hi,<br>\n              <br>\n              I wanted to discuss two side effects between multiple\n              JUnit test<br>\n              methods:<br>\n              <br>\n              a) timing issues<br>\n              If a test method runs into a timeout, the executing thread\n              is<br>\n              interrupted (but not stopped). Hence, if it executes an\n              infinite loop,<br>\n              it will still occupy some of your resources after this\n              test failed.<br>\n              <br>\n              For an example, see [1]. The helper method is executed\n              either once or<br>\n              infinite often in a loop. If executed once, it runs\n              approx. 100ms on my<br>\n              machine. If executed in a loop, JUnit&#39;s runtime is approx.\n              600ms times<br>\n              for a single parameterized run.<br>\n              Executing 10 infinite loops first and then 10 single\n              helper calls<br>\n              results in more than 10 timeouts (which is set to 500ms).\n              You may have<br>\n              to increase NUM_RUNS on your machine to reproduce.<br>\n              <br>\n              b) memory issues<br>\n              It&#39;s easy to construct cases from the above insight\n              (threads may keep<br>\n              running in case of a timeout) with side effects on memory\n              which lead to<br>\n              an OutOfMemoryError.<br>\n              Even when threads do not keep running, and one test\n              allocates many<br>\n              objects, the garbage collector may kick in during the\n              execution of the<br>\n              next test method. This may result in an timeout that is\n              not caused by<br>\n              the code under test but by the previous massive object\n              allocation.<br>\n              <br>\n              I know that&#39;s almost impossible to stop Java threads. I\n              also assume that<br>\n              both side effects are well known.<br>\n              <br>\n              So what&#39;s the best practice to reduce or even avoid these\n              side effects<br>\n              when writing JUnit test methods?<br>\n              <br>\n              Cheers,<br>\n              Tobi<br>\n              <br>\n              --<br>\n              1: <a rel=\"nofollow\" class=\"ygrps-yiv-1693315245moz-txt-link-freetext\" target=\"_blank\" href=\"https://gist.github.com/meisterT/97db378abea366036f36\">https://gist.github.com/meisterT/97db378abea366036f36</a><br>\n              <br>\n            </p>\n          </div>\n          \n      \n      \n    </blockquote>\n    <br>\n  \n</span></blockquote></html>\n</div>", 
    "prevInTime": 24568, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1406321798", 
    "canDelete": false, 
    "nextInTopic": 24570, 
    "prevInTopic": 24568, 
    "headers": {
        "inReplyToHeader": "PDIwMTQwNzI0MjA0OTMyLkdDMjMwOTZAZmF1aTIwZS5pbmZvcm1hdGlrLnVuaS1lcmxhbmdlbi5kZT4=", 
        "messageIdInHeader": "PDUzRDJDNDg2LjMwNjA1MDRAY3lwaG9yaWEubmV0Pg==", 
        "referencesHeader": "PDIwMTQwNzI0MjA0OTMyLkdDMjMwOTZAZmF1aTIwZS5pbmZvcm1hdGlrLnVuaS1lcmxhbmdlbi5kZT4="
    }
}