{
    "numMessagesInTopic": 24, 
    "nextInTime": 23498, 
    "senderId": "mu7rVpawtj6qbK45Ym_gmvHDPaPpYCU7qNh5nq5O9g2vhCtYbXjQ5z_cpMykqk3-vyZoyP5Mp3dTt9HNP2Aq_VtBpEkq", 
    "systemMessage": false, 
    "subject": "Re: [junit] Not knowing the tests in advance when providing a test runner", 
    "from": "Bill Venners &lt;bill@...&gt;", 
    "authorName": "Bill Venners", 
    "msgSnippet": "Hi Charlie, Thanks for explaining the theory behind theories. I think my own theory that this concept is like a property in Scala-land still holds, though. Let", 
    "msgId": 23497, 
    "profile": "billvenners", 
    "topicId": 23466, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 416990097, 
    "messageBody": "<div id=\"ygrps-yiv-1020420720\">Hi Charlie,<br/>\n<br/>\nThanks for explaining the theory behind theories. I think my own theory that<br/>\nthis concept is like a property in Scala-land still holds, though. Let me<br/>\nrun this past you and see if you agree.<br/>\n<br/>\nBasically a &quot;property&quot; is a statement about something that should be true<br/>\nfor all values meeting a certain criteria. The way that is expressed is as a<br/>\nfunction. The inputs to the function provide one set of values (I.e., to<br/>\ncheck 100 data points, you&#39;d call the function 100 times, passing in a<br/>\ndifferent data point each time.) If the function returns normally, the<br/>\nproperty evaluation &quot;passes&quot;. If it throws an exception, it &quot;fails.&quot; So<br/>\ngiven a Fraction class, you could have a property like:<br/>\n<br/>\n(n: Int, d: Int) =&gt; { // n and d are inputs to the &quot;property&quot; function<br/>\n<br/>\n  whenever (d != 0 && d != Integer.MIN_VALUE<br/>\n      && n != Integer.MIN_VALUE) {<br/>\n<br/>\n    val f = new Fraction(n, d)<br/>\n<br/>\n    if (n &lt; 0 && d &lt; 0 || n &gt; 0 && d &gt; 0)<br/>\n      f.numer should be &gt; 0<br/>\n    else if (n != 0)<br/>\n      f.numer should be &lt; 0<br/>\n    else<br/>\n      f.numer should be === 0<br/>\n<br/>\n    f.denom should be &gt; 0<br/>\n  }<br/>\n}<br/>\n<br/>\nSo whenever the n and d inputs are valid numerators and denominators for the<br/>\nFraction constructor, the assertions made here (like f.denom should be &gt; 0)<br/>\nshould hold. That sounds exactly what you mean by theory, is that correct?<br/>\nAnd if so, that&#39;s called a property in Scala-land, probably because it was<br/>\ncalled a property in QuickCheck in Haskell, which inspired ScalaCheck in<br/>\nScala. The idea is you&#39;re defining a &quot;property of the Fraction class&quot; that<br/>\nyou&#39;re testing.<br/>\n<br/>\nSo then the question becomes how do you check it. One way is to use the<br/>\ntables approach that I showed earlier. You define some tables with data<br/>\npoints in them, and give both the table and the property to forAll:<br/>\n<br/>\nforAll (examples) { (n: Int, d: Int) =&gt; ...<br/>\n<br/>\nThis says that for all the example numerator/denominator pairs given in the<br/>\ntable, the property should hold.<br/>\n<br/>\nBut you also just say this:<br/>\n<br/>\nforAll { (n: Int, d: Int) =&gt; ...<br/>\n<br/>\nThat says for all integers, n and d, the property should hold. In that case<br/>\nyou&#39;ll be using ScalaCheck generators to get the data. So instead of you<br/>\nproviding a table of datapoints, the generators will provide them for you,<br/>\nand ScalaCheck provides generators for common data points such as integers.<br/>\nYou can create your own generators for your own data types, or to make<br/>\ngenerators for numerators and denominators that only generate valid values.<br/>\n<br/>\nSo I think the difference may be more that theories are methods in J/NUnit<br/>\nand properties are functions in ScalaTest and ScalaCheck. There may be<br/>\nanother difference in how theories are mapped to tests in results. Does one<br/>\n&quot;theory check&quot; of 100 data points show up as one test that succeeds or<br/>\nfails, or as 100 tests that succeeded or failed?<br/>\n<br/>\nTo see both table- and generator-driven property checks, look at the<br/>\nexamples on this page:<br/>\n<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.scalatest.org/scaladoc-1.6.1/#org.scalatest.prop.PropertyChecks\">http://www.scalatest.org/scaladoc-1.6.1/#org.scalatest.prop.PropertyChecks</a><br/>\n<br/>\nBill<br/>\n<br/>\n<blockquote><span title=\"qreply\"> On Tue, Jun 28, 2011 at 5:44 PM, Charlie Poole &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:charliepoole@...\">charliepoole@...</a>&gt;wrote:<br/>\n<br/>\n&gt; **<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; Hi Bill,<br/>\n&gt;<br/>\n&gt; The concept of a Theory is quite different from a normal (example) test<br/>\n&gt; and even from a set of examples. That said the implementation, in J/NUnit<br/>\n&gt; lags the concept a bit and J/N-users don&#39;t generally seem to grok it (yet).<br/>\n&gt;<br/>\n&gt; The general idea is that a Theory makes a statement that is true for all<br/>\n&gt; values meeting a set of criteria. It invites the framework to supply any<br/>\n&gt; values that meet those criteria - without any special intervention on the<br/>\n&gt; part of the user. The individual test cases are not relevant except in the<br/>\n&gt; case of a failure, since the user should be viewing the Theory as a single<br/>\n&gt; test. Of course, the syntactic similarity to data-driven tests tends to<br/>\n&gt; hide<br/>\n&gt; the fact that this is a completely different way of looking at a test.<br/>\n&gt;<br/>\n&gt; IME, Theories work best when I start out with a theory in mind. Standard<br/>\n&gt; tests work best when I only have a collection of examples.<br/>\n&gt;<br/>\n&gt; The J/NUnit implementation, where the &#39;givens&#39; are provided within the<br/>\n&gt; tests themselves through Assume.That, is not necessarily the only way<br/>\n&gt; to do it. We could construct some sort of DSL that instructed the framework<br/>\n&gt; about what our assumptions are and allowed the data to be generated. In<br/>\n&gt; .NET that&#39;s quite difficult because of the limitations of attribute syntax<br/>\n&gt; and<br/>\n&gt; I suspect it&#39;s also true for Java.<br/>\n&gt;<br/>\n&gt; Charlie<br/>\n&gt;<br/>\n&gt; On Tue, Jun 28, 2011 at 4:08 PM, Bill Venners &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:bill@...\">bill@...</a>&gt; wrote:<br/>\n&gt;<br/>\n&gt; &gt; **<br/>\n&gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt; Hi All,<br/>\n&gt; &gt;<br/>\n&gt; &gt; This is all very interesting. One difference I see from ScalaTest is<br/>\n&gt; &gt; that a &quot;theory&quot; is not treated as a special kind of test. J/NUnit<br/>\n&gt; &gt; &quot;theories&quot; map to ScalaTest &quot;properties.&quot; J/NUnit &quot;assumptions&quot; (when<br/>\n&gt; &gt; used with theories) map to ScalaTest &quot;conditions.&quot; And J/NUnit &quot;data<br/>\n&gt; &gt; points&quot; map to a ScalaTest &quot;table.&quot;<br/>\n&gt; &gt;<br/>\n&gt; &gt; So for this example from the JUNit 4.4 release notes:<br/>\n&gt; &gt;<br/>\n&gt; &gt; @RunWith(Theories.class)<br/>\n&gt; &gt; public class UserTest {<br/>\n&gt; &gt; @DataPoint public static String GOOD_USERNAME = &quot;optimus&quot;;<br/>\n&gt; &gt; @DataPoint public static String USERNAME_WITH_SLASH = &quot;optimus/prime&quot;;<br/>\n&gt; &gt;<br/>\n&gt; &gt; @Theory public void filenameIncludesUsername(String username) {<br/>\n&gt; &gt; assumeThat(username, not(containsString(&quot;/&quot;)));<br/>\n&gt; &gt; assertThat(new User(username).configFileName(),<br/>\n&gt; containsString(username));<br/>\n&gt; &gt; }<br/>\n&gt; &gt; }<br/>\n&gt; &gt;<br/>\n&gt; &gt; You might do this in ScalaTest:<br/>\n&gt; &gt;<br/>\n&gt; &gt; public class UserSuite extends FunSuite {<br/>\n&gt; &gt;<br/>\n&gt; &gt; test(&quot;filename includes username&quot;) {<br/>\n&gt; &gt;<br/>\n&gt; &gt; val examples =<br/>\n&gt; &gt; Table(<br/>\n&gt; &gt; &quot;username&quot;,<br/>\n&gt; &gt; &quot;optimus&quot;,<br/>\n&gt; &gt; &quot;optimus/prime&quot;<br/>\n&gt; &gt; )<br/>\n&gt; &gt;<br/>\n&gt; &gt; forAll (examples) { username =&gt;<br/>\n&gt; &gt; whenever(!username.contains(&quot;/&quot;)) {<br/>\n&gt; &gt; (new User(username).configFileName) should include (username)<br/>\n&gt; &gt; }<br/>\n&gt; &gt; }<br/>\n&gt; &gt; }<br/>\n&gt; &gt; }<br/>\n&gt; &gt;<br/>\n&gt; &gt; A false &quot;whenever&quot; expression is a failed &quot;condition,&quot; that causes a<br/>\n&gt; &gt; &quot;property evaluation&quot; to be &quot;discarded.&quot; But the test encompasses all<br/>\n&gt; &gt; property evaluations. Here there&#39;s just two property evaluations, one<br/>\n&gt; &gt; of which gets discarded, but usually there would be a table of many<br/>\n&gt; &gt; example usernames, otherwise it isn&#39;t worth using a table.<br/>\n&gt; &gt;<br/>\n&gt; &gt; So what&#39;s missing from ScalaTest at this point is some way to do<br/>\n&gt; &gt; something like this, also taken from the JUnit 4.4 release notes:<br/>\n&gt; &gt;<br/>\n&gt; &gt; @Test public void filenameIncludesUsername() {<br/>\n&gt; &gt; assumeThat(File.separatorChar, is(&#39;/&#39;));<br/>\n&gt; &gt; assertThat(new User(&quot;optimus&quot;).configFileName(),<br/>\n&gt; &gt; is(&quot;configfiles/optimus.cfg&quot;));<br/>\n&gt; &gt; }<br/>\n&gt; &gt;<br/>\n&gt; &gt; That&#39;s actually a use of an assumption disconnected with a theory, and<br/>\n&gt; &gt; it seems useful. I haven&#39;t put anything like that into ScalaTest<br/>\n&gt; &gt; because no one has asked for it, and I wanted to make sure that if I<br/>\n&gt; &gt; put something in it is based on real requirements. It seems to me that<br/>\n&gt; &gt; TestNG&#39;s dependencies are a similar concept, except instead of an<br/>\n&gt; &gt; assumption expression (like File.separatorChar is (&#39;/&#39;) here) deciding<br/>\n&gt; &gt; whether a test is &quot;skipped&quot;, it is the failure of a dependent test.<br/>\n&gt; &gt;<br/>\n&gt; &gt; So one thing I&#39;d like to hear about from JUnit, NUnit, and TestNG<br/>\n&gt; &gt; users are use cases. How have theoryless assumptions actually been<br/>\n&gt; &gt; used in practice? What are they good for in reality?<br/>\n&gt; &gt;<br/>\n&gt; &gt; The other thing is the naming. To Esko I&#39;d say that I think &quot;skipped&quot;<br/>\n&gt; &gt; sounds to me most like the generic term that would encompass all of<br/>\n&gt; &gt; these concepts, so maybe that would not be a good term for me to use<br/>\n&gt; &gt; in ScalaTest if I end up adding this feature. I hadn&#39;t thought of<br/>\n&gt; &gt; &quot;canceled&quot; until Charlie mentioned it, but that sounds like a clear<br/>\n&gt; &gt; way to describe a test that for this run is being skipped because of<br/>\n&gt; &gt; some unmet &quot;assumption.&quot; Another word you could consider for your<br/>\n&gt; &gt; runner, Esko, is &quot;discarded,&quot; which is what I use for properties<br/>\n&gt; &gt; thrown out during a property check in ScalaTest.<br/>\n&gt; &gt;<br/>\n&gt; &gt; In case you&#39;re curious, the details on table-driven property checks in<br/>\n&gt; &gt; ScalaTest is here:<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.scalatest.org/scaladoc-1.6.1/#org.scalatest.prop.TableDrivenPropertyChecks\">http://www.scalatest.org/scaladoc-1.6.1/#org.scalatest.prop.TableDrivenPropertyChecks</a><br/>\n&gt; &gt;<br/>\n&gt; &gt; Bill<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt; On Tue, Jun 28, 2011 at 11:58 AM, Charlie Poole &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:charliepoole@...\">charliepoole@...</a>&gt;<br/>\n&gt; &gt; wrote:<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; Hi David,<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; The devil is of course in the details... see inline...<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; On Tue, Jun 28, 2011 at 10:37 AM, David Saff &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:david@...\">david@...</a>&gt; wrote:<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; Just to make it clear, the statuses translate as:<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; 1) Passed: We know it works<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; Yes<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; 2) Failed: We know it doesn&#39;t work.<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; Yes, but we don&#39;t know why without further info. For example, an<br/>\n&gt; &gt; &gt; assertion may have<br/>\n&gt; &gt; &gt; failed or an unexpected exception may have been thrown. I currently<br/>\n&gt; &gt; recognize<br/>\n&gt; &gt; &gt; &#39;Failed&#39;, &#39;Failed:Error&#39; and &#39;Failed:Cancelled&#39;. The last one could<br/>\n&gt; &gt; equally well<br/>\n&gt; &gt; &gt; be treated as a sub-category of Inconclusive but I made it a failure<br/>\n&gt; &gt; because<br/>\n&gt; &gt; &gt; the cancellation is not something the test can control.<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; 3) Skipped: We _could_ know if it works, but have asked not to be<br/>\n&gt; told<br/>\n&gt; &gt; &gt; &gt; (because the information is redundant, or to save time, for example)<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; No... The test never ran... OR we are treating it as if it never ran<br/>\n&gt; &gt; &gt; (since tests can<br/>\n&gt; &gt; &gt; be ignored dynamically in their setup. This is the most interesting<br/>\n&gt; &gt; &gt; category with<br/>\n&gt; &gt; &gt; options &#39;Skipped&#39;, &#39;Skipped:Ignored&#39; and &#39;Skipped:Invalid&#39; showing up<br/>\n&gt; in<br/>\n&gt; &gt; the Gui<br/>\n&gt; &gt; &gt; as grey, yellow and red respectively. I&#39;m considering adding a<br/>\n&gt; &gt; &gt; &#39;Severity&#39; field to<br/>\n&gt; &gt; &gt; the result so that this coloring (or other text display) is automatic.<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; 4) Inconclusive: We _can&#39;t_ know if it works<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; Yes. This is the one we use in Theories. My intent is that<br/>\n&gt; &gt; &gt; Inconclusive should have<br/>\n&gt; &gt; &gt; no effect on the success of a theory _unless_ all results are<br/>\n&gt; &gt; &gt; Inconclusive. I can&#39;t<br/>\n&gt; &gt; &gt; make up my mind what it should mean in a normal test. :-)<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; Is that right? I can dig that.<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; I&#39;m in favor of a categorization that we believe will serve without<br/>\n&gt; &gt; &gt; &gt; alteration for five years or so: there&#39;s too many runners to say &quot;Oh,<br/>\n&gt; &gt; &gt; &gt; yeah, we thought of a fifth status!&quot; and expect them all to catch up.<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; David Saff<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; On Mon, Jun 27, 2011 at 8:42 PM, Charlie Poole &lt;<br/>\n&gt; <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:charliepoole@...\">charliepoole@...</a>&gt;<br/>\n&gt; &gt; wrote:<br/>\n&gt; &gt; &gt; &gt; &gt; For NUnit 3.0, I took a page from the Gallo project and defined<br/>\n&gt; four<br/>\n&gt; &gt; &gt; &gt; &gt; fundamental test<br/>\n&gt; &gt; &gt; &gt; &gt; statuses: Passed, Failed, Skipped and Inconclusive. These can be<br/>\n&gt; &gt; extended<br/>\n&gt; &gt; &gt; &gt; &gt; by use<br/>\n&gt; &gt; &gt; &gt; &gt; of an arbitrary text field, e.g.: Skipped:Ignored.<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt; This allows a test runner/reporter to at least give some basic info<br/>\n&gt; &gt; without<br/>\n&gt; &gt; &gt; &gt; &gt; being extended.<br/>\n&gt; &gt; &gt; &gt; &gt; Extended runners could recognize specific test outcomes and report<br/>\n&gt; &gt; them<br/>\n&gt; &gt; &gt; &gt; &gt; separately.<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt; Note that in this design, Skipped and Inconclusive carry no notion<br/>\n&gt; of<br/>\n&gt; &gt; being<br/>\n&gt; &gt; &gt; &gt; &gt; a GoodThing,<br/>\n&gt; &gt; &gt; &gt; &gt; a BadThing or just neutral. In practice, for example, we might<br/>\n&gt; color<br/>\n&gt; &gt; the<br/>\n&gt; &gt; &gt; &gt; &gt; testing bar yellow for<br/>\n&gt; &gt; &gt; &gt; &gt; Skipped.Ignored but just plain Skipped doesn&#39;t have any effect on<br/>\n&gt; the<br/>\n&gt; &gt; test<br/>\n&gt; &gt; &gt; &gt; &gt; outcome.<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt; Charlie<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt; 2011/6/27 Cédric Beust ♔ &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:cedric@...\">cedric@...</a>&gt;<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt;&gt; **<br/>\n&gt; &gt; &gt; &gt; &gt;&gt;<br/>\n&gt; &gt; &gt; &gt; &gt;&gt;<br/>\n&gt; &gt; &gt; &gt; &gt;&gt; On Fri, Jun 24, 2011 at 2:36 PM, Bill Venners &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:bill@...\">bill@...</a>&gt;<br/>\n&gt; &gt; wrote:<br/>\n&gt; &gt; &gt; &gt; &gt;&gt;<br/>\n&gt; &gt; &gt; &gt; &gt;&gt; &gt; The skipped concept shows up in JUnit as assumptions, and in<br/>\n&gt; &gt; TestNG as<br/>\n&gt; &gt; &gt; &gt; &gt;&gt; &gt; dependent tests, I think.<br/>\n&gt; &gt; &gt; &gt; &gt;&gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt;&gt;<br/>\n&gt; &gt; &gt; &gt; &gt;&gt; I think that JUnit marks tests that fail their assumption as<br/>\n&gt; &gt; &quot;Failed&quot;,<br/>\n&gt; &gt; &gt; &gt; &gt;&gt; while<br/>\n&gt; &gt; &gt; &gt; &gt;&gt; TestNG marks them as &quot;Skipped&quot; (a status which doesn&#39;t exist in<br/>\n&gt; &gt; JUnit<br/>\n&gt; &gt; &gt; &gt; &gt;&gt; AFAIK).<br/>\n&gt; &gt; &gt; &gt; &gt;&gt;<br/>\n&gt; &gt; &gt; &gt; &gt;&gt; --<br/>\n&gt; &gt; &gt; &gt; &gt;&gt; Cédric<br/>\n&gt; &gt; &gt; &gt; &gt;&gt;<br/>\n&gt; &gt; &gt; &gt; &gt;&gt; [Non-text portions of this message have been removed]<br/>\n&gt; &gt; &gt; &gt; &gt;&gt;<br/>\n&gt; &gt; &gt; &gt; &gt;&gt;<br/>\n&gt; &gt; &gt; &gt; &gt;&gt;<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt; [Non-text portions of this message have been removed]<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt; ------------------------------------<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt; Yahoo! Groups Links<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt; --<br/>\n&gt; &gt; Bill Venners<br/>\n&gt; &gt; Artima, Inc.<br/>\n&gt; &gt; <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.artima.com\">http://www.artima.com</a><br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt;<br/>\n&gt; [Non-text portions of this message have been removed]<br/>\n&gt;<br/>\n&gt;  <br/>\n&gt;<br/>\n<br/>\n<br/>\n<br/>\n-- <br/>\nBill Venners<br/>\nArtima, Inc.<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.artima.com\">http://www.artima.com</a><br/>\n<br/>\n<br/>\n[Non-text portions of this message have been removed] </span></blockquote></div>", 
    "prevInTime": 23496, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1309310292", 
    "canDelete": false, 
    "nextInTopic": 23498, 
    "prevInTopic": 23496, 
    "headers": {
        "inReplyToHeader": "PEJBTkxrVGlrdTN6TDdHZnA2amVRSEJGdm9uRkpuOXRQZ19BQG1haWwuZ21haWwuY29tPg==", 
        "messageIdInHeader": "PEJBTkxrVGlrSEtad2RhZFA1MUErQ3dBR0I0NkJBcHAxSnVRQG1haWwuZ21haWwuY29tPg==", 
        "referencesHeader": "PGl0Zmk1YSt1NTJjQGVHcm91cHMuY29tPgk8NEUwMjE0RDQuMjA0MDUwNEBnbWFpbC5jb20+CTxCQU5Ma1RpbWFibU9LUnZDNmpQTjdEYlBTMjdmS3plVkpUZ0BtYWlsLmdtYWlsLmNvbT4JPDRFMDJGNDRBLjYwMjA1MDhAZ21haWwuY29tPgk8QkFOTGtUaW1EU2FiVGZjRnd6Z0tvNWE0Vnp4ZnZZa1gtaEFAbWFpbC5nbWFpbC5jb20+CTxCQU5Ma1RpPTJtTDNFVnRLaHZuZFJGUGgydGlLN3RMN09pUUBtYWlsLmdtYWlsLmNvbT4JPEJBTkxrVGk9dnZIdV9aSjBETXBhZXZWb19LV21lU08tV2ZnQG1haWwuZ21haWwuY29tPgk8QkFOTGtUaWtqMEVxeDhQZmVOaz1PeGRSOG5KM05fd253MXdAbWFpbC5nbWFpbC5jb20+CTxCQU5Ma1RpPVFIOG1ycm5LSjAzQlhRUzJoRmswZFNuRHNXd0BtYWlsLmdtYWlsLmNvbT4JPEJBTkxrVGltdFM0ZEJqQTByLXlTQ19acC1nRFItYVdWdDFnQG1haWwuZ21haWwuY29tPgk8QkFOTGtUaWt1M3pMN0dmcDZqZVFIQkZ2b25GSm45dFBnX0FAbWFpbC5nbWFpbC5jb20+"
    }
}