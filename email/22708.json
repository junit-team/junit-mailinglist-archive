{
    "numMessagesInTopic": 5, 
    "nextInTime": 22709, 
    "senderId": "JnPzM_ruQOR61C9EdHHS75-QzL-EGECN6sfhE-lIbAvqH-88o26M-qFOZ77eceIU8cpOEVr4SzDnkfyDsxL5IXwE8JfqESi1lon0SHAdL537wmvbAa1K", 
    "systemMessage": false, 
    "subject": "RE: [junit] Real World JUnit (first time poster)", 
    "from": "&quot;Loritsch, Berin C.&quot; &lt;berin.loritsch@...&gt;", 
    "authorName": "Loritsch, Berin C.", 
    "msgSnippet": "The best place to start is that you and your team need to make the following commitments: *         You will stick with it for at least 30 days (you should", 
    "msgId": 22708, 
    "profile": "bloritsch", 
    "topicId": 22706, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 428096731, 
    "messageBody": "<div id=\"ygrps-yiv-1411337308\">The best place to start is that you and your team need to make the<br/>\nfollowing commitments:<br/>\n<br/>\n*         You will stick with it for at least 30 days (you should start<br/>\nseeing benefits by then)<br/>\n<br/>\n*         Make room with your estimates and schedule to write the unit<br/>\ntests<br/>\n<br/>\n*         Everyone has the responsibility to keep the tests passing-your<br/>\nbuild needs to fail if the tests fail<br/>\n<br/>\n*         Try to make quick running tests<br/>\n<br/>\n <br/>\n<br/>\nWithout the above commitments, TDD gets tossed out.  In the very<br/>\nbeginning it may seem like a lot of extra work for very little benefit,<br/>\nbut stick with it anyway.  It takes time to see how TDD is affecting how<br/>\nyou approach writing code and the time saved by not having to step<br/>\nthrough the code with a debugger as often.  If you don&#39;t make room in<br/>\nyour schedule to write the unit tests, your schedule will be off,<br/>\neveryone will feel behind the 8-ball, and what they are not familiar<br/>\nwith won&#39;t get done.  Sometimes everything passes until you check in<br/>\nyour code.  When everyone makes their (at least daily) check-ins, it<br/>\nhelps to do a check-out and rerun the tests-just in case.  Lastly, if<br/>\nthe tests take a long time to run, it becomes painful to run them.  If<br/>\nit&#39;s painful to run them, they don&#39;t get run and you lose all your<br/>\nbenefits.<br/>\n<br/>\n <br/>\n<br/>\nAs to a real world example, I&#39;ve got a few.  When I first started doing<br/>\nTDD, it was with an open source framework I was building.  I started out<br/>\ndutifully writing the test, watching it fail, and doing the simplest<br/>\nthing that could possibly work.  Essentially I used &quot;triangulation&quot; to<br/>\nget to a set of tests that forced the code to work the way I wanted it.<br/>\nIt seemed counterintuitive at first, even a bit awkward.  But I was<br/>\nwilling to keep at it.  I noticed that the code I was writing was a bit<br/>\ndifferent from what I used to write.  Essentially, by thinking about how<br/>\nI was going to test the code before I wrote the code I was intentionally<br/>\nmaking the tests easy to write.  By extension, the code I was writing<br/>\nwas simpler and easier to comprehend.  As I progressed with writing the<br/>\nframework, there were a few tests that I wrote thinking I had to write<br/>\nsomething to satisfy the case, but the code already handled that case.<br/>\nI left the tests there to make sure the functionality didn&#39;t regress<br/>\nafter refactoring the code.  I noticed that I was much more confident in<br/>\nrefactoring my code regularly, and made it a point to incorporate that<br/>\ninto the way I work.  What was the simplest thing one day isn&#39;t so<br/>\nsimple after you&#39;ve made a series of changes.  I also noticed that I was<br/>\nspending a lot less time in the debugger.  In fact, the only time I<br/>\nneeded to open it up was when someone reported a difficult to reproduce<br/>\nbug.  Once I discovered what was happening, I added a new test case to<br/>\nreproduce the problem as closely as I could to the cause.  Once I got<br/>\nthe expected failure, I was able to make the change with more<br/>\nconfidence.<br/>\n<br/>\n <br/>\n<br/>\nMy first experience introducing TDD to a team taught me a few things.<br/>\nFirst, not everyone knows how to write good tests.  The book Pragmatic<br/>\nUnit Testing: in Java with JUnit is a good resource with how to approach<br/>\nwriting unit tests.  All it&#39;s examples are JUnit 3 examples, but the<br/>\nprinciples still apply no matter what your unit testing framework is.<br/>\nBasically, the unit tests need to be as simple as possible.  The setup,<br/>\nexecution, and assertions need to be clear.  Adding too much to the<br/>\nsetup will cause the tests to be harder to understand, and make them<br/>\ntake longer to run.  Your team really needs someone to coach in writing<br/>\ngood unit tests.  On my team, that was me.  There will likely be someone<br/>\non the team that needs to know that unit tests require an assertion-they<br/>\ncannot rely on manual inspection.  Unit tests are not just a way to run<br/>\ncode, they are a way to verify the code is correct.  That doesn&#39;t mean<br/>\nthe person is stupid, they just aren&#39;t experienced with unit tests.<br/>\nIt&#39;s a brand new idea for them.  There will likely be someone else who<br/>\ntries to lump multiple separate tests into one test case.  They need to<br/>\nbe taught how to test only one thing at a time.  Lastly, with people<br/>\nwriting unit tests with differing levels of experience, we can run into<br/>\nperformance problems in the unit test suite.  A common area where this<br/>\nproblem occurs is when you test anything that requires a network<br/>\nconnection such as database access and web services.  It requires a<br/>\nlittle more creativity to solve these problems, but it can be done.  I<br/>\nsolved the remote service problem by stubbing it out and creating a mock<br/>\nimplementation to generate all the test conditions without requiring<br/>\nnetwork services.  The database can be more of a problem, particularly<br/>\nbecause writing cross database queries can be very hard.  Sometimes it<br/>\nhelps to separate out the database tests into a separate suite.  As long<br/>\nas the remainder of the unit tests run quickly, you can reserve running<br/>\nthe database tests for the official build and the other unit tests as<br/>\npart of your daily work.<br/>\n<br/>\n <br/>\n<br/>\nThat&#39;s a summary of the highlights with instituting TDD on a project.<br/>\nAs people learn how to write better tests, they also end up writing<br/>\nbetter code.  The expectations, results, and error conditions are<br/>\nthought out much better.  It can also bring to light when different<br/>\napproaches are used by different people.  By changing the unit tests,<br/>\nyou can get everyone on the same page.  You&#39;ll find some corners that<br/>\njust can&#39;t be tested without resorting to extraordinary lengths.<br/>\nTypically, these are exceptions that the Java API forces you to catch<br/>\neven though there is no way in your code to make those exceptions be<br/>\nthrown.  Examples include catching unsupported algorithm exceptions when<br/>\nyou are using encryption algorithms installed on everyone&#39;s machine, or<br/>\nusing a character set that exists on every instance of Java for your<br/>\nstreams.  For those, don&#39;t worry about testing it.  It&#39;s just not worth<br/>\nhacking the JVM installation to force these errors.  As long as you<br/>\nremain consistent with your error handling techniques and you (at the<br/>\nvery least) log the exceptions you can be pretty confident in that code.<br/>\n<br/>\n <br/>\n<br/>\nFrom: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a> [mailto:<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>] On Behalf Of<br/>\namalcamel<br/>\nSent: Monday, May 17, 2010 2:34 PM<br/>\nTo: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a><br/>\nSubject: [junit] Real World JUnit (first time poster)<br/>\n<br/>\n <br/>\n<br/>\n  <br/>\n<br/>\nHi, I am new to this forum and new to JUnit. I started searching for<br/>\nbest practices and found that people were asking that question all the<br/>\nway back in 2001! Kind of intimidating!<br/>\n<br/>\nAnyway, what I am looking for is not &quot;best practices&quot;, per se, but a<br/>\nreal world example. And from that I mean an example that starts from an<br/>\nidea in someone&#39;s head and evolves all the way through application<br/>\ncompletion and testing coverage. For example, I am thinking of an auto<br/>\ninsurance type of application that has certain requirements, say 10, and<br/>\nhow the tests are derived from the requirements and the code gets<br/>\nderived from the tests. <br/>\n<br/>\nWe have many developers that are new to Test Driven Development, and to<br/>\nsimply come out with best practices and ask them to get on board will<br/>\nnever work. However, if we can take a real world example, from start to<br/>\nfinish, and show how the tests did drive the code and how refactoring<br/>\nbecame so much simpler as a result, that would be a great start into<br/>\nchanging the mentality of some of our developers (myself included ;-)<br/>\n<br/>\nAny suggestions?<br/>\nThank you,<br/>\nRegards,<br/>\nElaine<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n[Non-text portions of this message have been removed]</div>", 
    "prevInTime": 22707, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1274126517", 
    "canDelete": false, 
    "nextInTopic": 22709, 
    "prevInTopic": 22707, 
    "headers": {
        "inReplyToHeader": "PGhzczI2MCt1MWZ0QGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PDc1RjVFRDhBNUE1NTM2NDZBNDZFMDBFNkVDODU0RkEzMDQ3ODlDOTRAdmFmZjAxLW1haWwwMS5hZC5nZC1haXMuY29tPg==", 
        "referencesHeader": "PGhzczI2MCt1MWZ0QGVHcm91cHMuY29tPg=="
    }
}