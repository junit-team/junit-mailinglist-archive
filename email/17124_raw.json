{
    "numMessagesInTopic": 3, 
    "nextInTime": 17125, 
    "senderId": "jUBD5USmRsHwPvlV7llt3l5_FTF0FCFWMYdyR07toZninjUhE0gV4P6hgQQropDqgQsJrLuAGYYmp-oW9XYdzoAfcpJZlbi_QJXpF1hS4VWW", 
    "systemMessage": true, 
    "subject": "Re: [junit] non static method testing with JUnit", 
    "from": "&quot;Brett L. Schuchert&quot; &lt;schuchert@...&gt;", 
    "authorName": "Brett L. Schuchert", 
    "msgSnippet": "The only special thing you need to do is to make sure you have an instance of your object before you test it. If you have a single test that needs an object,", 
    "msgId": 17124, 
    "rawEmail": "Return-Path: &lt;schuchert@...&gt;\r\nReceived: (qmail 67361 invoked from network); 11 Jul 2006 22:46:28 -0000\r\nReceived: from unknown (66.218.67.33)\n  by m41.grp.scd.yahoo.com with QMQP; 11 Jul 2006 22:46:28 -0000\r\nReceived: from unknown (HELO n8a.bullet.sc5.yahoo.com) (66.163.187.151)\n  by mta7.grp.scd.yahoo.com with SMTP; 11 Jul 2006 22:46:28 -0000\r\nReceived: from [66.163.187.122] by n8.bullet.sc5.yahoo.com with NNFMP; 11 Jul 2006 22:46:28 -0000\r\nReceived: from [66.218.66.59] by t3.bullet.sc5.yahoo.com with NNFMP; 11 Jul 2006 22:46:25 -0000\r\nReceived: from [66.218.66.71] by t8.bullet.scd.yahoo.com with NNFMP; 11 Jul 2006 22:46:22 -0000\r\nX-Sender: schuchert@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (qmail 46959 invoked from network); 11 Jul 2006 22:18:12 -0000\r\nReceived: from unknown (66.218.66.172)\n  by m41.grp.scd.yahoo.com with QMQP; 11 Jul 2006 22:18:12 -0000\r\nReceived: from unknown (HELO web54107.mail.yahoo.com) (206.190.37.242)\n  by mta4.grp.scd.yahoo.com with SMTP; 11 Jul 2006 22:18:11 -0000\r\nReceived: (qmail 44451 invoked by uid 60001); 11 Jul 2006 22:18:03 -0000\r\nMessage-ID: &lt;20060711221803.44444.qmail@...&gt;\r\nReceived: from [12.41.204.3] by web54107.mail.yahoo.com via HTTP; Tue, 11 Jul 2006 15:18:03 PDT\r\nDate: Tue, 11 Jul 2006 15:18:03 -0700 (PDT)\r\nTo: junit@yahoogroups.com\r\nIn-Reply-To: &lt;C4B880098AA68B4CB4A0B82B1419A4600112D95F@mailva&gt;\r\nMIME-Version: 1.0\r\nX-eGroups-Msg-Info: 1:0:0:0\r\nFrom: &quot;Brett L. Schuchert&quot; &lt;schuchert@...&gt;\r\nReply-To: &quot;Brett L. Schuchert&quot; &lt;schuchert@...&gt;\r\nSubject: Re: [junit] non static method testing with JUnit\r\nX-Yahoo-Group-Post: member; u=162568887; y=SJ2zU9S3VQXezUL9RS6fc-31RHfkmkwJNugQJUEdUeprWQOd\r\nX-Yahoo-Profile: schuchert\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\nX-Yahoo-Newman-Property: groups-system\r\nX-eGroups-Approved-By: mark_l_salter &lt;marksalter@...&gt; via web; 11 Jul 2006 22:46:17 -0000\r\n\r\nThe only &quot;special&quot; thing you need to do is to make sure you have an instance of your object before you test it.\n \nIf you have a single test that needs an object, you might write the following:\n// JUnit 4.x\n@Test\npublic void simpleCreation() {\n  Foo myFoo = new Foo(...);\n  assertTrue(myFoo.isX());\n}\n \n// JUnit 3.x\npublic void testSimpleCreation() {\n  Foo myFoo = new Foo(...);\n  assertTrue(myFoo.isX());\n}\n\nIf you plan to use that same instance over and over in each test method in a test class, you might do the following:\n \n//JUnit 4.x\npublic class FooTest {\n  private Foo myFoo;\n \n  @Before\n  public void init() {\n    myFoo = new Foo();\n  }\n \n  @Test\n  public void simpleCreation() {\n    assertTrue(myFoo.isX());\n  }\n}\n \nBut other than instantiation, there&#39;s not much different between static and regular methods.\n \nOf course, if your method is polymorphic (in the sense that sub-classes implement it as well), you might need to make sure your test instantiations of all sub-classes.\n \nBrett\n  \n   \nTutorials and Articles\n     http://schuchert.wikispaces.com/\n\n\n\n----- Original Message ----\nFrom: Kamal Ahmed &lt;KAhmed@...&gt;\nTo: junit@yahoogroups.com\nSent: Tuesday, July 11, 2006 3:03:50 PM\nSubject: [junit] non static method testing with JUnit\n\n\nHi,\n\nIs there a special way to test non static methods with JUnit? Or they are\ntreated the same way as static methods.\n\nHere is the reason why I asked this question. After reading this article\n(below). It is rather &quot;back to basics&quot; but sometimes I find it useful to go\nto &quot;root&quot;\n\nMr. Happy Object teaches static methods\nWhen to choose static methods over instance methods\n\nBy Tony Sintes\n\nNovember 21, 2001\n\nQ) When would you create static methods as opposed to instance methods? I\nunderstand that static methods allow you to use those methods without having\nto create an instance of that class, and that class methods apply to the\nclass rather than an object. Are these the only reasons? Could you give an\nexample of a case where you would use a class method over an instance\nmethod?\n\nA) Many Java developers find it confusing to decide when, and when not to\ndeclare a method as static. However, making the choice is simple if you have\na clear understanding of the difference between a class method and an\ninstance method.\n\nNote: You can download the source code that accompanies this article from\nResources.\n\nConsider the following class definition:\n\npublic class MrHappyObject {\n\nprivate String _mood = _HAPPY;\n\nprivate final static String _HAPPY = &quot;happy&quot;;\nprivate final static String _ANNOYED = &quot;annoyed&quot;;\nprivate final static String _ANGRY = &quot;angry&quot;;\n\npublic void printMood() {\nSystem.out.println( &quot;I am &quot; + _mood );\n}\n\npublic void receivePinch( ) {\nif( _mood.equals( _HAPPY ) ) {\n_mood = _ANNOYED;\n} else {\n_mood = _ANGRY;\n}\n}\n\npublic void receiveHug() {\nif( _mood.equals( _ANGRY ) ) {\n_mood = _ANNOYED;\n} else {\n_mood = _HAPPY;\n}\n}\n}\n\nFigure 1. Mr. Happy Object\n\nFirst, before I get emails about it, there are more object-oriented ways to\ntrack and transition between states. However, those fancy ways would detract\nfrom the intent of the example. Now, without further ado...\n\nprintMood(), receivePinch( ), and receiveHug() are all instance methods.\nSyntactically, you call these methods instance methods because they are not\nstatic; but the important distinction concerns why I didn&#39;t declare them as\nstatic.\n\nInstance methods are instance methods because they rely on the state of the\nspecific object instance. Instance methods are tied to a particular instance\nbecause the behavior that the method invokes relies upon the state of that\nparticular instance.\n\nConsider the following example:\n\nMrHappyObject obj1 = new MrHappyObject( );\nMrHappyObject obj2 = new MrHappyObject( );\n\nobj1.printMood( );\nobj2.printMood( );\n\nWhen obj1 and obj2 first instantiate, they have the same state -- they are\nborn happy. As a result, when the printMood() is called on each instance,\neach object prints &quot;I am happy&quot; to the screen. However, every object\ninstance has its own state that can vary independently of all other\ninstances of that class of object.\n\nAs obj1 and obj2 go through their day, their states can vary independently\nfrom one another. Here I hug obj1 and pinch obj2:\n\nobj1.receiveHug( );\nobj2.receivePinch( );\n\nobj1.printMood( );\nobj2.printMood( );\n\nNow when I query each instance&#39;s mood, obj1 is happy while obj2 is annoyed.\nWhile the example is silly, it drives home a point: Every instance possesses\nits own state, and that state is independent of every other object. Any\nmethod whose behavior depends upon the particular state of a particular\ninstance is an instance method. You should not declare such a method as\nstatic.\n\nWhen you declare a method as static, you define that method as being a class\nmethod. A class method applies to the class as opposed to any particular\ninstance. The behavior instigated by a class method does not rely on the\nstate of a particular instance. In fact, a static method cannot rely on an\ninstance&#39;s state since static methods lack access to this reference.\nInstead, the behavior of a class method either depends on a state that all\nobjects share at the class level, or is independent of any state at all.\n\nLet&#39;s add the following definitions to the original MrHappyObject:\n\nprivate static int _instantiations;\n\npublic MrHappyObject( ) {\n_instantiations+ +;\n}\n\npublic static int instances() {\nreturn _instantiations;\n}\n\ninstances() is a static method. The instances() method returns the number of\nMrHappyObjects that have been created. The number of instantiations is\nindependent of any particular MrHappyObject. Instead, MrHappyObject tracks\nthe number of instantiations at the class level.\n\nAgain, this example is a bit contrived but it demonstrates an important\nlesson: Class methods instigate behavior that is independent of instance\nstate. instances() returns the number of instances regardless of whether\nobj1 is happy and obj2 is annoyed. The instance state is simply irrelevant.\nAny method that is independent of instance state is a candidate for being\ndeclared as static.\n\nNote that I say &quot;candidate for being declared as static.&quot; Even in the\nprevious example nothing forces you to declare instances() as static.\nDeclaring it as static just makes it more convenient to call since you do\nnot need an instance to call the method. Sometimes you will have methods\nthat don&#39;t seem to rely on instance state. You might not want to make these\nmethods static. In fact you&#39;ll probably only want to declare them as static\nif you need to access them without an instance.\n\nMoreover, even though you can declare such a method as static, you might not\nwant to because of the inheritance issues that it interjects into your\ndesign. Take a look at &quot;Effective Object-Oriented Design&quot; to see some of the\nissues that you will face.\n\nAnyway, simply counting the number of instantiations is a fairly useless\nexample -- it&#39;s probably not something you will do in your day-to-day\ncoding. However, sometimes you will want to use statics.\n\nStatic methods prove useful for creating utility classes and factory\nmethods. (See &quot;Factory Methods&quot; for more information. )\n\nA utility class simply contains static methods and no public constructor.\nUtility classes are not meant to be instantiated. As Joshua Bloch points out\nin Effective Java Programming Language Guide, utility classes have earned a\nbad reputation because they are easily abused and can lead to procedural\nprogramming.\n\nHowever, utility classes do have valid uses. Take a look at java.lang.Math,\njava.util.Arrays, and java.util.Collectio ns; each is a utility class. These\nutilities group related methods on primitive values, arrays, and interfaces.\nThese related methods are placed in these utility classes since they cannot\ngo anywhere else (you can&#39;t place methods into a primitive, array, or\ninterface after all!).\n\nUtility classes have another use. Sometimes you cannot extend a class\nbecause it is declared final. Utility classes are an excellent place to put\nmethods that you would have otherwise put into a subclass.\n\nAbout the author\nTony Sintes is an independent consultant and founder of First Class\nConsulting, Inc., a consulting firm that specializes in the bridging of\ndisparate enterprise systems and training. Outside of First Class\nConsulting, Tony is an active freelance writer as well as author of Sams\nTeach Yourself Object-Oriented Programming in 21 Days (Sams, 2001; ISBN:\n0672321092).\n\nThanks,\n-Kamal.\n\n\n \n\n[Non-text portions of this message have been removed]\n\n\n\n\n\n", 
    "profile": "schuchert", 
    "topicId": 17122, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 162568887, 
    "prevInTime": 17123, 
    "contentTrasformed": false, 
    "postDate": "1152656283", 
    "canDelete": false, 
    "nextInTopic": 17133, 
    "prevInTopic": 17122, 
    "headers": {
        "inReplyToHeader": "PEM0Qjg4MDA5OEFBNjhCNENCNEEwQjgyQjE0MTlBNDYwMDExMkQ5NUZAbWFpbHZhPg==", 
        "messageIdInHeader": "PDIwMDYwNzExMjIxODAzLjQ0NDQ0LnFtYWlsQHdlYjU0MTA3Lm1haWwueWFob28uY29tPg=="
    }
}