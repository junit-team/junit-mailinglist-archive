{
    "numMessagesInTopic": 55, 
    "nextInTime": 13619, 
    "senderId": "C-4B0SzzwxX408Hh6LduYSNmKjE7U2L1NpkoS85CdUupQIWYsKPDSecXdociCCcAtHxLFODcD0UqR0kAkDb7ZsFaFE2dwazgvHKleV1lbA", 
    "systemMessage": false, 
    "subject": "Re: [junit] RE: Isolation or Collaboration", 
    "from": "&quot;J. B. Rainsberger&quot; &lt;jbrains@...&gt;", 
    "authorName": "J. B. Rainsberger", 
    "msgSnippet": "... These examples seem to fall into one category: an object representing a resource we have released. This is far different from initializing an object in an", 
    "msgId": 13618, 
    "profile": "nails762", 
    "topicId": 13451, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 127224993, 
    "messageBody": "<div id=\"ygrps-yiv-1753033563\">Harald M. Muller wrote:<br/>\n<blockquote><span title=\"ireply\"> &gt; Just 2 small points:<br/>\n&gt; <br/>\n&gt; J. B. Rainsberger wrote:<br/>\n&gt;  &gt; Cedric Beust wrote:<br/>\n&gt;  &gt;<br/>\n&gt;  &gt; &gt; Real code relies on dependencies all the time:<br/>\n&gt;  &gt; &gt;<br/>\n&gt; [...]<br/>\n&gt;  &gt;<br/>\n&gt;  &gt; &gt; - This method can only be invoked if such field has been<br/>\n&gt;  &gt; initialized.<br/>\n&gt;  &gt;<br/>\n&gt;  &gt; All objects should be in a &quot;sane&quot; state all the time. If not,<br/>\n&gt;  &gt; then the<br/>\n&gt;  &gt; design could be improved to avoid this problem. The Pragmatic<br/>\n&gt;  &gt; Programmers call what you describe as &quot;Programming by Coincidence&quot;.<br/>\n&gt;  &gt;<br/>\n&gt; <br/>\n&gt; &quot;Sane state&quot; does NOT mean that everything can be done to the object at<br/>\n&gt; every time. Cedric&#39;s &quot;initialized&quot; example is probably actually a design<br/>\n&gt; flaw, but for other states, it makes of course much sense to disallow<br/>\n&gt; certain operations: If a database connection is not open, you cannot<br/>\n&gt; execute a select; if a file has been deleted, it cannot be deleted a<br/>\n&gt; second time; a bill that has been cancelled cannot be invoiced; etc.etc.<br/>\n&gt; In many cases I saw and see, programmers/designers/architects seem to<br/>\n&gt; believe that the String class (where you can indeed execute every method<br/>\n&gt; sensibly at every time) is the paradigmatic example of a class. Nothing<br/>\n&gt; can be further from the truth: Many classes have an &quot;interesting state<br/>\n&gt; diagram&quot;, where certain operations can only be invoked if certain<br/>\n&gt; conditions hold.<br/>\n<br/>\n </span></blockquote>These examples seem to fall into one category: an object representing a <br/>\nresource we have released. This is far different from initializing an <br/>\nobject in an insane state, so my argument certainly doesn&#39;t apply, nor <br/>\ndid I try to make it apply. :)<br/>\n<br/>\nJava&#39;s File class is an example of questionable design: it represents <br/>\nboth a file path and a file. I shouldn&#39;t be able to create a File object <br/>\nthat doesn&#39;t represent an underlying file, just like I shouldn&#39;t be able <br/>\nto create a DatabaseConnection object that doesn&#39;t represent an <br/>\nunderlying connection to Postgresql. An object like this is insane:<br/>\n<br/>\nnew File(&quot;wi8ybv3ql4i587b43;95876bvq3495786bgq347895&quot;)<br/>\n<br/>\nI would much prefer this:<br/>\n<br/>\npath = new FileSystemPath(&quot;/Users/jbrains/Documents&quot;);<br/>\ndirectory = path.locate();   // or &quot;open&quot; or &quot;validate&quot; -- not sure <br/>\nabout the method name<br/>\nassertTrue(directory.isDirectory());<br/>\n<br/>\nOr, since it&#39;s simpler:<br/>\n<br/>\ndirectory = FileSystem.locate(&quot;/Users/jbrains/Documents&quot;);<br/>\nassertTrue(directory.isDirectory());<br/>\n...<br/>\n<br/>\nI have been experimenting with using different classes aggressively to <br/>\ndeal with objects in different states. I&#39;m very happy with the result. <br/>\nIt&#39;s nothing new; I&#39;m just taking the technique further than I used to.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; [...]<br/>\n&gt;  &gt; &gt; - A certain object can only be created if a previous object<br/>\n&gt;  &gt; has been created<br/>\n&gt;  &gt; &gt; before.<br/>\n&gt;  &gt;<br/>\n&gt;  &gt; If so, then the previous object should be the only thing that<br/>\n&gt;  &gt; can create<br/>\n&gt;  &gt; the new object!<br/>\n&gt; <br/>\n&gt; This is often contrary to design concepts with somewhat centralized<br/>\n&gt; responsibilities. For example, if you look at the UML metamodel, an<br/>\n&gt; association is a thing &quot;between two (or more) classes&quot; - so an<br/>\n&gt; association (e.g. in an UML tool) can only be created when the classes<br/>\n&gt; (e.g. class &quot;icons&quot;) are there. Obviously, the order of the class<br/>\n&gt; (&quot;icon&quot;) creation is not important - but both must be there. Usually,<br/>\n&gt; one does not design this by giving the &quot;icons&quot; the responsibility of<br/>\n&gt; creating the association (even in this case, the creating &quot;icon&quot; must<br/>\n&gt; check whether the other one exists), but has a central &quot;association<br/>\n&gt; creation tool&quot; which checks for the existence of the necessary icons.<br/>\n<br/>\n </span></blockquote>Let me say it differently then: if we cannot create B without having <br/>\ncreated A, then the method creating B should require the instance of A, <br/>\neither by:<br/>\n<br/>\n1. a.createB(), or<br/>\n2. C.createB(a)<br/>\n<br/>\nEither way, there&#39;s no way to create B without A.<br/>\n<br/>\nGoing back to your example, if an Association cannot exist without a <br/>\npair of objects to associate, then I would prefer this:<br/>\n<br/>\nAssociation.fromTo(class1, class2);<br/>\n<br/>\nto this:<br/>\n<br/>\nassociation = new Assocation();<br/>\nassociation.setFrom(class1);<br/>\nassociation.setTo(class2);<br/>\n<br/>\nor any of its variants.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Still, on a more general level - e.g. when one talks about closely tied<br/>\n&gt; groups of classes (yes: they are there; not even one of the tutorials<br/>\n&gt; that explain JUnit pretends that litterally everything makes sense to be<br/>\n&gt; mocked) - the guidelines hinted at by JBR do make sense.<br/>\n<br/>\n </span></blockquote>I appreciate that.<br/>\n-- <br/>\nJ. B. (Joe) Rainsberger<br/>\nDiaspar Software Services<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.diasparsoftware.com\">http://www.diasparsoftware.com</a><br/>\nAuthor, JUnit Recipes: Practical Methods for Programmer Testing</div>", 
    "prevInTime": 13617, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1116986296", 
    "canDelete": false, 
    "nextInTopic": 13621, 
    "prevInTopic": 13598, 
    "headers": {
        "inReplyToHeader": "PDAwMDIwMWM1NWUyZCQwYzcxN2FiMCRiYjAwYThjMEBIQVJSWT4=", 
        "messageIdInHeader": "PDQyOTNEQkI4LjYwMDAyMDVAcm9nZXJzLmNvbT4=", 
        "referencesHeader": "PDAwMDIwMWM1NWUyZCQwYzcxN2FiMCRiYjAwYThjMEBIQVJSWT4="
    }
}