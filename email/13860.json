{
    "numMessagesInTopic": 32, 
    "nextInTime": 13861, 
    "senderId": "DOLXBRmxdaOao41Hg0aekZMhaeKpz3bDsH4KKN6SrFEy_8JfaEpCLrjO3fPAxPZmMmQeEmpUU9AD3d9-1rwyENdtJO0qSjb0f9bRGlURjOg07hV3BA", 
    "systemMessage": false, 
    "subject": "Re: [junit] Testing multiple interfaces?", 
    "from": "jason r tibbetts &lt;tibbettj@...&gt;", 
    "authorName": "jason r tibbetts", 
    "msgSnippet": "Comments below... ... It turns out that this wasn t such a radical idea--the /exact/ same pattern is used in Johannes Link s /Unit Testing in Java/ ", 
    "msgId": 13860, 
    "topicId": 13795, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 224061497, 
    "messageBody": "<div id=\"ygrps-yiv-1746131834\">Comments below...<br/>\n<br/>\nJ. B. Rainsberger wrote:<br/>\n<blockquote><span title=\"ireply\"> &gt; jason r tibbetts wrote:<br/>\n&gt; <br/>\n&gt;&gt;I want to write something like the following, but I&#39;m looking for better<br/>\n&gt;&gt;ideas:<br/>\n&gt;&gt;<br/>\n&gt;&gt;public class FooBar implements Foo, Bar { ... }<br/>\n&gt;&gt;<br/>\n&gt;&gt;public class BarTestBase extends TestCase {<br/>\n&gt;&gt;   protected Bar bar;<br/>\n&gt;&gt;<br/>\n&gt;&gt;   public void testSomeMethod() { ... }<br/>\n&gt;&gt;}<br/>\n&gt;&gt;<br/>\n&gt;&gt;// does NOT subclass FooTestBase or BarTestBase<br/>\n&gt;&gt;public class FooBarTest extends TestCase {<br/>\n&gt;&gt;   static class FooSubclassTest extends FooTestBase {<br/>\n&gt;&gt;     protected void setUp() { foo = new FooBar(); }<br/>\n&gt;&gt;   }<br/>\n&gt;&gt;<br/>\n&gt;&gt;   static class BarSubclassTest extends BarTestBase {<br/>\n&gt;&gt;     protected void setUp() { foo = new FooBar(); }<br/>\n&gt;&gt;   }<br/>\n&gt;&gt;<br/>\n&gt;&gt;   public static Test suite() {<br/>\n&gt;&gt;      TestSuite suite = new TestSuite(FooBarTest.class);<br/>\n&gt;&gt;      suite.addTest(new TestSuite(FooSubclassTest.class);  // ?<br/>\n&gt;&gt;      suite.addTest(new TestSuite(BarSubclassTest.class);  // ?<br/>\n&gt;&gt;      return suite;<br/>\n&gt;&gt;   }<br/>\n&gt;&gt;}<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; You&#39;ve done here what I would do, except you&#39;ve added a suite() method <br/>\n&gt; to collect all the &quot;FooBar&quot; tests together. Since I usually try to run <br/>\n&gt; all my tests all the time, I&#39;d get that free.<br/>\n&gt; <br/>\n&gt; <br/>\n&gt;&gt;Considerations:<br/>\n&gt;&gt;* Because the static inner test classes&#39; names end with &#39;Test&#39;, they&#39;ll<br/>\n&gt;&gt;be picked up automatically by an Ant &lt;junit&gt; task that executes anything<br/>\n&gt;&gt;called &#39;*Test.class&#39;, right? If so, then adding them to the FooBarTest&#39;s<br/>\n&gt;&gt;suite is redundant.<br/>\n&gt; <br/>\n&gt; That&#39;s handy.<br/>\n&gt; <br/>\n&gt;&gt;* If the inner classes&#39; names end in &#39;Test&#39;, they must be declared<br/>\n&gt;&gt;static in order to prevent a reflection exception when the JUnit test<br/>\n&gt;&gt;loader attempts to invoke them, since they&#39;d have to be instantiated<br/>\n&gt;&gt;within an instance of FooBarTest.<br/>\n&gt; <br/>\n&gt; That makes sense.<br/>\n&gt; <br/>\n&gt; I think you&#39;re on the right track here. Let us know how it works for <br/>\n&gt; you. This is one of those deeper examples that no-one has written about <br/>\n&gt; in detail yet. (Even _JUnit Recipes_ only mentions it in passing.) You <br/>\n&gt; should write about your experiences with this pattern and share it with <br/>\n&gt; the world. :)<br/>\n<br/>\n </span></blockquote>It turns out that this wasn&#39;t such a radical idea--the /exact/ same <br/>\npattern is used in Johannes Link&#39;s /Unit Testing in Java/ <br/>\n(<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.amazon.com/exec/obidos/tg/detail/-/1558608680/)\">http://www.amazon.com/exec/obidos/tg/detail/-/1558608680/)</a>, pp. <br/>\n152-155. Link says,<br/>\n<br/>\n\t&quot;The technique introduced here for reusing abstract test<br/>\n\tclasses by means of internal classes means reaching deeply<br/>\n\tinto Java&#39;s bag of tricks, and it is hard to understand.<br/>\n\tFor this reason, we will not use this technique mechanically<br/>\n\tfor each interface to be implemented. Instead, we will use<br/>\n\tit only when there is actually a nontrivial<br/>\n\tspecification-based test suite. There are often very few<br/>\n\tsemantic requirements to the implementing class, apart<br/>\n\tfrom the requirement to make the interface public. In this<br/>\n\tcase, the interface tests would be better off in the test<br/>\n\tsuite of that class.&quot;<br/>\n<br/>\nI have since tried both approaches that I outlined in the considerations <br/>\nabove:<br/>\n<br/>\n1) Add the inner classes&#39; suites to the suite() of the primary test class.<br/>\n<br/>\nPros:<br/>\n* The inner class tests get run automatically when the primary test is <br/>\nexecuted.<br/>\n<br/>\nCons:<br/>\n* The JUnit output makes no distinction as to which particular /inner/ <br/>\nsuite is running. For example, I always have a test_constructor() method <br/>\nin each of my TestCases. The output of running the main test therefore <br/>\nsimply looks like:<br/>\n<br/>\n     [junit] Testsuite: FooBarTest<br/>\n     [junit] Tests run: 3, Failures: 0, Errors: 0, Time elapsed: 0.09 sec<br/>\n<br/>\n     [junit] Testcase: test_constructor took 0.038 sec<br/>\n     [junit] Testcase: test_constructor took 0 sec<br/>\n     [junit] Testcase: test_constructor took 0.002 sec<br/>\n<br/>\n2) Don&#39;t add their suites to the main suite(), but instead name them <br/>\n&#39;*Test&#39; so that my Ant task will pick them up and execute them individually.<br/>\n<br/>\nPros:<br/>\n* JUnit output is much more understandable:<br/>\n<br/>\n     [junit] Testsuite: FooBarTest<br/>\n     [junit] Tests run: 1, Failures: 0, Errors: 0, Time elapsed: 0.038 sec<br/>\n<br/>\n     [junit] Testcase: test_constructor took 0.038 sec<br/>\n<br/>\n     [junit] Testsuite: FooBarTest$FooSubclassTest<br/>\n     [junit] Tests run: 1, Failures: 0, Errors: 0, Time elapsed: 0 sec<br/>\n<br/>\n     [junit] Testcase: test_constructor took 0 sec<br/>\n<br/>\n     [junit] Testsuite: FooBarTest$BarSubclassTest<br/>\n     [junit] Tests run: 1, Failures: 0, Errors: 0, Time elapsed: 0.002 sec<br/>\n<br/>\n     [junit] Testcase: test_constructor took 0.002 sec<br/>\n* Because their names end in &#39;*Test&#39;, they&#39;re picked up automatically by <br/>\nthe Ant &lt;junit&gt; task.<br/>\n<br/>\nCons:<br/>\n* The interface tests won&#39;t be run if a user simply selects the main <br/>\nclass in a TestRunner. Of course, since the interface tests&#39; names are <br/>\nnamed &#39;&lt;main-test&gt;$&lt;interface-test&gt;&#39;, a list of available tests (such as <br/>\nprovided by the JUnit GUI TestRunners) will make it pretty clear that <br/>\nthese are all related.<br/>\n<br/>\nAll things considered, I think that I prefer the second version, just <br/>\nbecause it&#39;s so much easier to see what&#39;s happening in the JUnit output.</div>", 
    "prevInTime": 13859, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1118151681", 
    "canDelete": false, 
    "nextInTopic": 13861, 
    "prevInTopic": 13858, 
    "headers": {
        "inReplyToHeader": "PDQyOUY3QTk2LjgwMDAwQHJvZ2Vycy5jb20+", 
        "messageIdInHeader": "PDQyQTVBNDAxLjgwNDAzMDVAdmVyZGkuaWlzZC5zcmEuY29tPg==", 
        "referencesHeader": "PDQyOUYxMERFLjgwNjAyMDJAdmVyZGkuaWlzZC5zcmEuY29tPiA8NDI5RjdBOTYuODAwMDBAcm9nZXJzLmNvbT4="
    }
}