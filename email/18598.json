{
    "numMessagesInTopic": 13, 
    "nextInTime": 18599, 
    "senderId": "uR7ib77zzKtyoHKdnEbQaRr1ZkNKdm4agoIO_Jvejo3R4HEicuzF1dOEe2CWYtfewztMkTKAZxYDg7LjvQNFiPPvG2sjfqkkyyruqLasofjK", 
    "systemMessage": false, 
    "subject": "Re: [junit] How JUnit runs test class", 
    "from": "&quot;J. B. Rainsberger&quot; &lt;jbrains762@...&gt;", 
    "authorName": "J. B. Rainsberger", 
    "msgSnippet": "...  ... If the tests touch a global resource, like a database, then it s true that creating separate instances of the test does not (alone) ensure ", 
    "msgId": 18598, 
    "profile": "nails762", 
    "topicId": 18565, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 282027414, 
    "messageBody": "<div id=\"ygrps-yiv-1851384082\">Vietchau Nguyen wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;  &gt; 1. Do you really want your tests /not/ to be isolated?<br/>\n&gt; <br/>\n&gt; Yes, I want the test cases to be isolated, that is test 2 fails and test<br/>\n&gt; 5 can still pass.. <br/>\n </span></blockquote>&lt;snip /&gt;<br/>\n<blockquote><span title=\"ireply\"> &gt; <br/>\n&gt; But I don&#39;t see by create each instance of the test class can ensure<br/>\n&gt; isolation... for example, if I have a test #2 that add a new user to the<br/>\n&gt; system, and I expect an error (password not strict enough, for example),<br/>\n&gt; and this test fails, that is it adds the user to the system. Normally,<br/>\n&gt; if I have a test that adds a user, I would delete the user afterward,<br/>\n&gt; but for this case, since I didn&#39;t expect the user to be added, I don&#39;t<br/>\n&gt; do the cleaning up. Then on my test #5, I check how many users in the<br/>\n&gt; system, I would expect none, and the test will fail because the previous<br/>\n&gt; test already added the user by error. (Sure, in this simple case, I can<br/>\n&gt; check the result and if the user is successfully added, I can delete,<br/>\n&gt; but I just want to give an example, other cases may not as so easy). So,<br/>\n&gt; I don&#39;t see a benefit of create a new instance, the tests still get<br/>\n&gt; affected.<br/>\n<br/>\n </span></blockquote>If the tests touch a global resource, like a database, then it&#39;s true <br/>\nthat creating separate instances of the test does not (alone) ensure <br/>\nisolation. This is why I tend to write fewer tests that touch a <br/>\ndatabase, preferring to use other techniques to drive flexible designs.<br/>\n<br/>\nWhat you describe is a classic testing problem, and there are a few <br/>\nsolutions:<br/>\n<br/>\n1. Write the tests to depend on the order of execution: test #1 adds a <br/>\nuser, test #2 expects that user to be there, test #3 deletes that user.<br/>\n<br/>\n2. Write the tests to restore the &quot;users&quot; table to a known state before <br/>\neach test.<br/>\n<br/>\n3. Write the tests not to use a database.<br/>\n<br/>\nWhen I started writing tests, I tried #1. After a few months, I realized <br/>\nthat it took a lot of effort to keep the tests in the correct order. I <br/>\nalso found it difficult to add more tests. I would follow this pattern:<br/>\n<br/>\n  * Add a new test that requires 2 new rows of data in a table<br/>\n  * Retrofit many of the old tests, changing their expected results to <br/>\ntake into account the 2 new rows--for example, for a &quot;find all&quot; query, <br/>\nif I used to expect 10 rows, I now expect 12<br/>\n<br/>\nAfter doing this a number of times, I decided that #2, while it cost <br/>\nmore CPU cycles, took less time, because it was much easier to maintain. <br/>\nFor this, DbUnit is my favorite tool. The slowest part of this work <br/>\nbecame running the tests and waiting for the results.<br/>\n<br/>\nAfter some more time, I learned I could do even better with an in-memory <br/>\ndatabase, because test execution speed was much better. For this, I use <br/>\nHSQLDB, which is pure Java, runs in memory and supports very recent SQL <br/>\nstandards. Once I started doing that, the slowest part of my job became <br/>\nconstructing datasets from Java objects and keeping dataset files up to <br/>\ndate as the database design changed.<br/>\n<br/>\nNext, I found out that by testing my business logic (usually Controllers <br/>\nin the MVC sense) against data access interfaces allowed me to wrote <br/>\nmost of my tests without worrying about datasets, SQL, DbUnit and <br/>\nHSQLDB. (That&#39;s #3 above.) I use JMock to do this, and although it took <br/>\nme only a few weeks to learn and understand, it took me years to truly <br/>\nmaster. This is my current favorite technique. Now I only write a few <br/>\ndozen tests that touch the real database for a medium-sized system (say, <br/>\n30 database tables), and I don&#39;t know how to go any faster.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;  &gt; 2. Do the tests run quickly enough even if you &quot;waste&quot; the resources?<br/>\n&gt; <br/>\n&gt; Well, right now it still runs quick enough... but I don&#39;t know if I<br/>\n&gt; write more tests into the class it will be fast or not... I have to<br/>\n&gt; parse an xml file to get all the parameters for the tests, and I rather<br/>\n&gt; parse once for all the tests to keep in the system than to parse over<br/>\n&gt; and over the file for each test case because each time a new instance is<br/>\n&gt; created.<br/>\n<br/>\n </span></blockquote>I understand this. I would tend to prefer hardcoding test parameters in <br/>\nmy tests, rather than reading them from a file. The simplest thing I can <br/>\nrecommend for your specific case is to read the XML document into a <br/>\nsingleton, then have your tests ask the singleton for test data. This is <br/>\na well-known case where a singleton is not dangerous: read-only, global <br/>\ndata. Still, I would prefer to put the test data directly into the <br/>\ntests, as I find that easier to read.<br/>\n<br/>\nTake care, and good luck.<br/>\n-- <br/>\nJ. B. (Joe) Rainsberger :: <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.jbrains.ca\">http://www.jbrains.ca</a><br/>\nYour guide to software craftsmanship<br/>\nJUnit Recipes: Practical Methods for Programmer Testing<br/>\n2005 Gordon Pask Award for contribution Agile Software Practice</div>", 
    "prevInTime": 18597, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1167358212", 
    "canDelete": false, 
    "nextInTopic": 18599, 
    "prevInTopic": 18597, 
    "headers": {
        "inReplyToHeader": "PDg2REYyODgzRUM2ODRBNEM5MDQzRUUxODM0MDUyMUZBMDM2OERGNTBARVgwMDA0LkFsbHN0cmVhbUlUUy5sb2NhbD4=", 
        "messageIdInHeader": "PDQ1OTQ3OTA0LjEwMzA5MDVAZ21haWwuY29tPg==", 
        "referencesHeader": "PDg2REYyODgzRUM2ODRBNEM5MDQzRUUxODM0MDUyMUZBMDM2OERGNTBARVgwMDA0LkFsbHN0cmVhbUlUUy5sb2NhbD4="
    }
}