{
    "numMessagesInTopic": 17, 
    "nextInTime": 6883, 
    "senderId": "5gSca5FIgz3cnqQard13oN-Cy0FWNfC_9wUr9fzaItSqXu48fRqS8MzSlv7kDW6TtEtrnuAX9ISevdVlg1YskZ9Z3JB8oPHVW87h", 
    "systemMessage": false, 
    "subject": "Re: [junit] Testability", 
    "from": "Curt Sampson &lt;yahoo_sucks@...&gt;", 
    "authorName": "Curt Sampson", 
    "msgSnippet": "... Yes, Kent Beck indeed did say, TDD followed religiously should result in 100% statement coverage. But on the other hand, the sentence before that in his", 
    "msgId": 6882, 
    "profile": "cjstokyo", 
    "topicId": 6863, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 110189933, 
    "messageBody": "<div id=\"ygrps-yiv-1979106561\">On Tue, 4 Feb 2003, Scott Stirling wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; I&#39;ve been thinking about Test Driven Development and the question of<br/>\n&gt; what is it about it that ensures testability. As Kent Beck says, if<br/>\n&gt; you follow TDD religiously, you should have 100% statement coverage<br/>\n&gt; for your code. Let me repeat that: 100%.<br/>\n<br/>\n </span></blockquote>Yes, Kent Beck indeed did say, &quot;TDD followed religiously should result<br/>\nin 100% statement coverage.&quot; But on the other hand, the sentence<br/>\nbefore that in his TDD book is &quot;Statement coverage is certainly not a<br/>\nsufficient measure of test quality, but it is a starting place.&quot; If you<br/>\nlook at the chapter on method/class scope testing in Binder&#39;s _Testing<br/>\nObject Oriented Systems_, you&#39;ll find that having meerly full statement<br/>\ncoverage is pretty poor test quality indeed. If you&#39;re looking just at a<br/>\ncoverage metric, I&#39;d say you want at least full coverage of branches.<br/>\n<br/>\nBut then again, Kent Beck also said, on page 115/6 of _Extreme<br/>\nProgramming Explained_, &quot;So you should write the tests that help get<br/>\nprograms working and keep programs working. Nothing more.&quot;<br/>\n<br/>\nIn the end, it really depends on the consequences of failure. In most<br/>\nof the systems I build, the consequence of failure is a stack exception<br/>\nappearing on the screen and a slightly troubled user. No big deal if<br/>\nthat happens once in a while; I just find, fix and roll out a new release.<br/>\n<br/>\nOn the other hand, if I had an embedded system that was going to be<br/>\nmass-produced, where a new release is extremely expensive, I&#39;d spend a<br/>\nlot more money and time testing.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; I engaged in a stimulating debate with Curt on his answer, which I tried to<br/>\n&gt; argue wasn&#39;t as elegant or object oriented, in principle, as a mock object<br/>\n&gt; approach.  It won&#39;t result in 100% statement coverage, for one thing (which<br/>\n&gt; will require you to trust Curt or whomever that the 5% of code that isn&#39;t<br/>\n&gt; covered by unit tests, &quot;can&#39;t go wrong,&quot; which might be true, but more<br/>\n&gt; likely not).<br/>\n<br/>\n </span></blockquote>Actually, I see it as relying on my judgement that it&#39;s cheaper to deal<br/>\nwith the rare failures in that area when they happen than it is to spend<br/>\nthe money and time for more comprehensive test coverage.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; So why are we arguing such different strategies for solving<br/>\n&gt; the problem of &quot;testability?&quot;<br/>\n<br/>\n </span></blockquote>Because we&#39;re costing it out differently. That&#39;s all.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Put another way, I wonder the same thing about any behavior added to an<br/>\n&gt; object.  Testing is not a behavior of most objects.<br/>\n<br/>\n </span></blockquote>Well, this perhaps a point of disagreement. I think that testing is a<br/>\npotential behaviour of every object I write.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; It seems the best way to build and test a finite-state machine is<br/>\n&gt; to make the inputs and outputs explicit, and to make the state<br/>\n&gt; transitions step-wise and traceable.<br/>\n<br/>\n </span></blockquote>I would consider that to be modifying an object, beyond its overt<br/>\nfunction, to make it more testable.<br/>\n<br/>\nIf you didn&#39;t have to test the object, because you always wrote perfect<br/>\ncode, would you bother exposing the state-wide transitions?<br/>\n<br/>\ncjs<br/>\n-- <br/>\nCurt Sampson  &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:cjs@...\">cjs@...</a>&gt;   +81 90 7737 2974   <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.netbsd.org\">http://www.netbsd.org</a><br/>\n    Don&#39;t you know, in this new Dark Age, we&#39;re all light.  --XTC</div>", 
    "prevInTime": 6881, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1044518414", 
    "canDelete": false, 
    "nextInTopic": 6884, 
    "prevInTopic": 6875, 
    "headers": {
        "inReplyToHeader": "PEtJRUhJQklPQkFFTEpBSElQTkhETUVNTkNPQUEuc2NvdHRzdGlybGluZ0ByY24uY29tPg==", 
        "messageIdInHeader": "PFBpbmUuTkVCLjQuNTEuMDMwMjA2MTYzNzEyMC43MzU2QGFuZ2VsaWMuY3luaWMubmV0Pg==", 
        "referencesHeader": "PEtJRUhJQklPQkFFTEpBSElQTkhETUVNTkNPQUEuc2NvdHRzdGlybGluZ0ByY24uY29tPg=="
    }
}