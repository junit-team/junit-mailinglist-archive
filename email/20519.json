{
    "numMessagesInTopic": 21, 
    "nextInTime": 20520, 
    "senderId": "r4m2AMzqslv94ETrYgjGZN9ksm4VeQ9sWqwaWOh89pMtRMnwfYdte4PNGG5XI6lon7c5--jc4bR5gQ_daJ6KQBuxgJJAQuzpH_GP9Foz", 
    "systemMessage": true, 
    "subject": "Re: What is expected behavior on Assert.assertEquals on Number object?", 
    "from": "&quot;Roger Glover&quot; &lt;glover_roger@...&gt;", 
    "authorName": "Roger Glover", 
    "msgSnippet": "... wrote: On Jun 3, 2008, at 22:41 , Nattapong Sirilappanich wrote: Hi, When i try to make an assertion on Number object, e.g. Double the result always", 
    "msgId": 20519, 
    "profile": "glover_roger", 
    "topicId": 20513, 
    "spamInfo": {
        "reason": "6", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 151020962, 
    "messageBody": "<div id=\"ygrps-yiv-1299186055\">--- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>, &quot;J. B. Rainsberger&quot; &lt;jbrains762@...&gt;<br/>\nwrote:<br/>\n<blockquote><span title=\"qreply\">   On Jun 3, 2008, at 22:41 , Nattapong Sirilappanich wrote:<br/>\n  Hi,<br/>\n<br/>\nWhen i try to make an assertion on Number object, e.g. Double the  <br/>\nresult always assertion successful. Even i try to compare by<br/>\n<br/>\norg.junit.Assert.assertEquals(123456789.345,123456789.34)<br/>\n<br/>\n  it still success. (I&#39;m expecting failure)<br/>\nThis is not a good way to compare floating point numbers. You should<br/>\nactually use:<br/>\n<br/>\nAssert.assertEquals(expected, actual, delta)<br/>\n<br/>\nwhere expected and actual are as in the form you did use, but there is a<br/>\nthird &quot;delta&quot; argument (also a double). This argument provides a<br/>\ntolerance value by which to judge &quot;equality&quot;. basically the assertion<br/>\nfails if:<br/>\n<br/>\nMath.abs(expected - actual) &gt; delta<br/>\n<br/>\nThus, working from your failing example:<br/>\n<br/>\nAssert.assertEquals(123456789.345, 123456789.34, 0.5);    // PASS<br/>\nAssert.assertEquals(123456789.345, 123456789.34, 0.0005); // FAIL<br/>\n<br/>\nBy the way, this usage really makes the name of the method a misnomer.<br/>\nIt should really be called &quot;assertClose&quot; (as in &quot;close, but no cigar&quot;,<br/>\nnot &quot;close the door; it&#39;s cold&quot;). But that should be okay if you are<br/>\nusing double the way it is meant to be used, because, as the old saying<br/>\ngoes, close only counts in horseshoes, hand grenades, and limited<br/>\nprecision floating point operations.<br/>\n<br/>\nIn other words, the idea is that after even a few operations (or even<br/>\nafter none in some cases) it is unreasonable to expect floating point<br/>\nquantities to be exactly equal to their unlimited precision real number<br/>\ncounterparts (even when an exact match exists). So you aim for &quot;close&quot;<br/>\ninstead. &quot;How close can you get&quot; is itself a black art that combines<br/>\nroughly equal portions of operation counting, number magnitude tracking,<br/>\noperation order tracking, and wild-ass guessing.<br/>\n<br/>\nNow back to the problem at hand. Just for grins I compiled Nattapong&#39;s<br/>\noriginal assert under a J2SE 1.4 compiler and it gave a syntax error,<br/>\nsaying that essentially that the third double argument was missing. It<br/>\nappears that this is one of those rare-but-not-rare-enough cases when<br/>\nautoboxing is actually working against you.<br/>\n<br/>\nAnd now J.B.&#39;s response...<br/>\nWeird. assertEquals() appears only to compare the whole parts.<br/>\n<br/>\npublic class DoubleTest {<br/>\n   @Test<br/>\n   public void unequalDoubleValueObjectsShouldBeUnequal() {<br/>\n     Assert.assertFalse(new Double(3).equals(new Double(4)));<br/>\n     Assert.assertFalse(new Double(3.1d).equals(new Double(3.2d)));<br/>\n     Assert.assertFalse(new Double(123456789.345d).equals(new<br/>\nDouble(123456789.34d)));<br/>\nSo far so good...<br/>\n     Assert.assertEquals(new Double(123456789.345d), new<br/>\nDouble(123456789.34d));<br/>\nWhen compiled under J2SE 1.4 the above assertEquals() fails. So, once<br/>\nagain, I suspect autoboxing is the culprit. In this case I suspect the<br/>\nDoubles are being &quot;unboxed&quot; into longs, since there is a two-long<br/>\nassertEquals() but not a two-double assertEquals().<br/>\n     Assert.assertEquals(new Double(3.1d), new Double(3.2d));<br/>\nSame with the above.<br/>\n     Assert.assertEquals(new Double(3), new Double(4));<br/>\nSame with the above, but if I am right this one fails (as J.B. noted)<br/>\nbecause the<br/>\nintegral parts are different, so you get different longs.<br/>\n   }<br/>\n}<br/>\n<br/>\nOnly the last assertion fails.<br/>\nThis behavior makes me wonder if in Nattapong&#39;s original case the<br/>\nprimitive doubles are being boxed into object Doubles which are, in<br/>\nturn, being unboxed into primitive longs. If that is not what is<br/>\nhappening, something even stranger is going on. Either way, I don&#39;t like<br/>\nit.<br/>\n<br/>\n-- Roger Glover<br/>\n     Object Partners, Inc.<br/>\n<br/>\n<br/>\n<br/>\n[Non-text portions of this message have been removed] </span></blockquote></div>", 
    "prevInTime": 20518, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1212691413", 
    "canDelete": false, 
    "nextInTopic": 20520, 
    "prevInTopic": 20516, 
    "headers": {
        "inReplyToHeader": "PDJFMUY5RkUyLTVEQTEtNDE0NS04MDg2LTdDMTJBMDA5QkZDMUBnbWFpbC5jb20+", 
        "messageIdInHeader": "PGcyOWM0bCttZ2ZvQGVHcm91cHMuY29tPg=="
    }
}