{
    "numMessagesInTopic": 2, 
    "nextInTime": 8767, 
    "senderId": "IQpv2SxSiL2qaC9AJY-PIil7Tx4-UUZOx2FGZ66TXOScwiXC-nj_HTnTuGU_GH_IlYRCgsykrNjSo2X5qS1eUt-4RhcKlVFRhJtrIOTNSxdGsw", 
    "systemMessage": false, 
    "subject": "Re: unit testing philosophy [LONG]", 
    "from": "&quot;ranjan_chakrab&quot; &lt;ranjan_chakrab@...&gt;", 
    "authorName": "ranjan_chakrab", 
    "msgSnippet": "Hi Steve, I am trying to use JUnit to perform unit testing of ATG Dynamo Droplets and Form Handlers. Please let me know if there are any documents/ papers that", 
    "msgId": 8766, 
    "rawEmail": "Return-Path: &lt;ranjan_chakrab@...&gt;\r\nReceived: (qmail 30588 invoked from network); 23 Jul 2003 18:26:25 -0000\r\nReceived: from unknown (66.218.66.217)\n  by m5.grp.scd.yahoo.com with QMQP; 23 Jul 2003 18:26:25 -0000\r\nReceived: from unknown (HELO n2.grp.scd.yahoo.com) (66.218.66.75)\n  by mta2.grp.scd.yahoo.com with SMTP; 23 Jul 2003 18:26:25 -0000\r\nX-eGroups-Return: ranjan_chakrab@...\r\nReceived: from [66.218.67.159] by n2.grp.scd.yahoo.com with NNFMP; 23 Jul 2003 18:26:24 -0000\r\nX-Sender: ranjan_chakrab@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (qmail 17291 invoked from network); 23 Jul 2003 00:46:59 -0000\r\nReceived: from unknown (66.218.66.216)\n  by m20.grp.scd.yahoo.com with QMQP; 23 Jul 2003 00:46:59 -0000\r\nReceived: from unknown (HELO n7.grp.scd.yahoo.com) (66.218.66.91)\n  by mta1.grp.scd.yahoo.com with SMTP; 23 Jul 2003 00:46:59 -0000\r\nReceived: from [66.218.67.180] by n7.grp.scd.yahoo.com with NNFMP; 23 Jul 2003 00:46:59 -0000\r\nDate: Wed, 23 Jul 2003 00:46:56 -0000\r\nTo: junit@yahoogroups.com\r\nSubject: Re: unit testing philosophy [LONG]\r\nMessage-ID: &lt;bfklu0+vel5@...&gt;\r\nIn-Reply-To: &lt;003501c1f9a1$a47582a0$123b27d9@gateway&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Length: 6383\r\nX-Mailer: Yahoo Groups Message Poster\r\nFrom: &quot;ranjan_chakrab&quot; &lt;ranjan_chakrab@...&gt;\r\nX-Yahoo-Group-Post: member; u=132883670\r\nX-Yahoo-Profile: ranjan_chakrab\r\nX-eGroups-Approved-By: nails762 &lt;jbrains@...&gt; via web; 23 Jul 2003 18:26:24 -0000\r\n\r\nHi Steve,\n\n I am trying to use JUnit to perform unit testing of ATG Dynamo\nDroplets and Form Handlers.\n\nPlease let me know if there are any documents/ papers that discuss \nthis subject.\n\nThank you.\n\nRanjan Chakrabarty\ne-mail: ranjan_chakrab@...\n\n--- In junit@yahoogroups.com, &quot;Steve Freeman&quot; &lt;steve@m...&gt; wrote:\n&gt; &gt; In the real world, I use ATG Dynamo.  If you&#39;ve heard of it or \nused\n&gt; &gt; it, it&#39;s an App Server / EJB Container.   Dynamo&#39;s entire \nframework is\n&gt; &gt; based off this component known as Nucleus, which does a lot of \nwork in\n&gt; &gt; terms of instantiating classes, setting properties, etc..  It&#39;s \nalso\n&gt; &gt; very slow and to test - build - test takes forever if I have to \nstart\n&gt; &gt; and stop the app-server for every change in the code.\n&gt; \n&gt; That&#39;s why we started mocking up Dynamo components. In some ways, \nthe\n&gt; Nucleus is very amenable to writing mock-based unit tests given that\n&gt; it&#39;s all about glueing components together at runtime. If you define\n&gt; your components in terms of interfaces rather than classes, then \nit&#39;s\n&gt; easier to substitute alternative implementations. Once you&#39;ve done\n&gt; this, it turns out that your code is better structured for coping \nwith\n&gt; new requirements.\n&gt; \n&gt; &gt; That&#39;s where MockObjects come in.  Dynamo is a very Java Beans \nheavy\n&gt; &gt; framework, that relies a lot on setters and getters.  ( In fact, \nthe\n&gt; &gt; MockObjects guys at SF have started putting together some Dynamo\n&gt; &gt; MockObjects. ) I was looking into MockObjects as a way to lessen \nmy\n&gt; &gt; reliance on the Nucleus namespace so that I could code quickly and\n&gt; &gt; only integrate with the Nucleus namespace at the latest possible \ntime.\n&gt; \n&gt; Sadly, our library is getting out of date, because I&#39;m not working\n&gt; with Dynamo any more. One point is that we&#39;re trying to move away \nfrom\n&gt; getters and setters. It&#39;s worth thinking about passing handler and\n&gt; policy objects around, rather than extracting values via getters. \nThe\n&gt; Nucleus supports it just as well.\n&gt; \n&gt; &gt; However, I can&#39;t get my head around the fact that in certain \ncases my\n&gt; &gt; mock code will need to generate other mock code\n&gt; \n&gt; Sometimes that happens, for example with the JDBC library. Where \nit&#39;s\n&gt; unavoidable, at least it&#39;s usually repeated across multiple tests \nand\n&gt; so worth wrapping in some helper code, or in the TestCase setup. For\n&gt; something like the Dynamo repository, you&#39;re likely to be using the\n&gt; infrastructure a lot, so there may be some point in investing in a\n&gt; little infrastrcuture. Don&#39;t forget that you only need enough\n&gt; implementation to get through the test (in a modern IDE this is a\n&gt; matter of a few points-and-clicks). For example, something like:\n&gt; \n&gt; class MockRepository extends MockObject {\n&gt;   private RepositoryView view;\n&gt;   private ExpectationValue itemDescription =\n&gt;     new ExpectationValue(&quot;MockRepository.itemDescription&quot;);\n&gt; \n&gt;   public void setExpectedGetView(String description,\n&gt;                                  RepositoryView aView) {\n&gt;     view = aView;\n&gt;     itemDescription.setExpected(description);\n&gt;   }\n&gt; \n&gt;   public RepositoryView getView(String description) {\n&gt;     itemDescription.setActual(description);\n&gt;     return view;\n&gt;   }\n&gt; }\n&gt; \n&gt; Another other route to consider is that you can use the Repository\n&gt; outside Dynamo. Set up a test instance of the database and manage \ntest\n&gt; values with something like DBUnit.\n&gt; \n&gt; Finally, what makes this code hard to test is that there are too \nmany\n&gt; objects involved in the method, can we break them up? One \nobservation\n&gt; is that the sequence from the Repository to the array of items is \nmore\n&gt; or less independant of the application. Does it repeat often enough \nto\n&gt; write something like:\n&gt; \n&gt; public Map generateEmptyPreferencesMap(Map map)\n&gt; {\n&gt;   RepositoryView contactMethodView =\n&gt; \n&gt; \n&gt;     getPreferencesRepository().getView\n(CONTACT_METHOD_REPOSITORY_ITEM );\n&gt;   PropertyFinder finder = finderFactory.make(contactMethodView);\n&gt;   finder.addPropertyValuesTo(map, \nCONTACT_METHOD_CODE_PROPERTY_NAME);\n&gt;   return map;\n&gt; }\n&gt; \n&gt; Where the PropertyFinder encapsulates all that RepositoryView\n&gt; stuff. If you create PropertyFinder&#39;s via a factory, you can \nsubsitute\n&gt; a MockPropertyFinder when testing the Droplet. You can then test the\n&gt; PropertyFinder separately with a smaller chain of mock\n&gt; (or real) Repository objects. It would be too much work if this is \nthe\n&gt; only place you do this but, more likely, you can refactor in this\n&gt; direction as you discover repetitions. An example of a test would \nbe:\n&gt; \n&gt; public void testGenerateEmptyPreferencesMap() throws \nRepositoryException\n&gt; {\n&gt;     MockPropertyFinder mockFinder = new MockPropertyFinder();\n&gt;     Map map = new Hashmap();\n&gt; \n&gt;     mockRepository.setupView(mockRepositoryView);\n&gt;     mockFinderFactory.setupFinder(mockFinder);\n&gt; \n&gt;     mockFinderFactory.setExpectedView(mockRepositoryView);\n&gt;     mockRepository.setExpectedGetView\n(CONTACT_METHOD_REPOSITORY_ITEM);\n&gt;     mockFinder.setExpectedAddPropertyValuesTo(map,\n&gt; CONTACT_METHOD_CODE_PROPERTY_NAME);\n&gt; \n&gt;     assertEquals(&quot;Should be same map&quot;, map,\n&gt; droplet.generateEmptyPreferencesMap(map));\n&gt;     mockFinderFactory.verify();\n&gt;     mockRepository.verify();\n&gt;     mockFinder.verify();\n&gt; }\n&gt; \n&gt; Hmmm, thinking about it, the next version might be:\n&gt; \n&gt; public Map generateEmptyPreferencesMap(Map map)\n&gt; {\n&gt;     PropertyFinder finder =\n&gt;         finderFactory.simpleFinder(preferencesRepository,\n&gt; CONTACT_METHOD_REPOSITORY_ITEM );\n&gt;     finder.addPropertyValuesTo(map, \nCONTACT_METHOD_CODE_PROPERTY_NAME);\n&gt;     return map;\n&gt; }\n&gt; \n&gt; Steve\n&gt; \n&gt; &gt; Here&#39;s a method from a piece of old code that I wrote before I \ndecided\n&gt; &gt; to start using JUnit:\n&gt; &gt;\n&gt; &gt;     public  Map generateEmptyPreferencesMap( Map m ) throws\n&gt; &gt; RepositoryException {\n&gt; &gt;\n&gt; &gt; // get the list of possible preferences\n&gt; &gt; RepositoryView contactMethodView = getPreferencesRepository\n().getView(\n&gt; &gt; CONTACT_METHOD_REPOSITORY_ITEM );\n&gt; &gt; RepositoryItem[] contactMethods = contactMethodView.executeQuery(\n&gt; &gt; contactMethodView.getQueryBuilder().createUnconstrainedQuery() );\n&gt; &gt;\n&gt; &gt; if ( ( contactMethods != null ) && ( contactMethods.length &gt; \n0 ) )  {\n&gt; &gt;     // add each one to the map\n&gt; &gt;     for ( int i = 0 ; i &lt; contactMethods.length ; i++ ) {\n&gt; &gt; m.put( contactMethods[i].getPropertyValue(\n&gt; &gt; CONTACT_METHOD_CODE_PROPERTY_NAME ), new BooleanPlaceHolder() );\n&gt; &gt;     }\n&gt; &gt; }\n&gt; &gt;      return m;\n&gt; &gt;     }\n\n\n\n", 
    "profile": "ranjan_chakrab", 
    "topicId": 4951, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 132883670, 
    "prevInTime": 8765, 
    "contentTrasformed": false, 
    "postDate": "1058921216", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 4951, 
    "headers": {
        "inReplyToHeader": "PDAwMzUwMWMxZjlhMSRhNDc1ODJhMCQxMjNiMjdkOUBnYXRld2F5Pg==", 
        "messageIdInHeader": "PGJma2x1MCt2ZWw1QGVHcm91cHMuY29tPg=="
    }
}