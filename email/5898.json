{
    "numMessagesInTopic": 38, 
    "nextInTime": 5899, 
    "senderId": "rJ4Ok8dgXEf6zFG_ZTss5Pj16G1uCAfL7y0gh4QIeluU5rJqioi1CHFvTQoTRa36SwU4DHlQzRSJ0VMgoXTBGI71kC7T-1vbTGDeGw", 
    "systemMessage": false, 
    "subject": "Re: [junit] Do JUnit internals suck?!?", 
    "from": "Berin Loritsch &lt;bloritsch@...&gt;", 
    "authorName": "Berin Loritsch", 
    "msgSnippet": "... Not the typical case. ... There are some really good things, but the design is not painfully clear to the person just perusing the source code. ... There", 
    "msgId": 5898, 
    "profile": "bloritsch", 
    "topicId": 5875, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 64910131, 
    "messageBody": "<div id=\"ygrps-yiv-728978519\">Manuel Amago wrote:<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt;But I suspect that the people who discovered Design<br/>\n&gt;&gt;Patterns/XP/Refactoring might have some idea on Object <br/>\n&gt;&gt;Oriented design ;-)<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; And I suspect that in that remark lies the crux of it.  The common<br/>\n&gt; topics that appear when discussing the complexity of JUnit are Suites<br/>\n&gt; and Tests, where this is just a typical instantiation of the Composite<br/>\n&gt; pattern.  The TestResult is a collecting parameter, and so on.<br/>\n<br/>\n<br/>\n </span></blockquote>Not the typical case.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; I am one of those people who puts JUnit forward as an example to be<br/>\n&gt; followed, and am, so far, unswayed from that position.  My views are<br/>\n&gt; based on the code for JUnit 3.7, but I can only imagine that it has<br/>\n&gt; gotten better, and not worse in the latest release.<br/>\n<br/>\n </span></blockquote>There are some really good things, but the design is not painfully<br/>\nclear to the person just perusing the source code.<br/>\n<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; As is usually the case when using patterns in code, to the non-initiated<br/>\n&gt; any such code may look very complex indeed, and the relationships<br/>\n&gt; between the different classes unfathomable.  The benefits for those who<br/>\n&gt; do recognise the patterns, however, is great.<br/>\n<br/>\n </span></blockquote>There are antipatterns you have to beware of as well, one such<br/>\nantipattern is an overuse of patterns.<br/>\n<br/>\nThe crux of the issue is that we know we have TestListeners,<br/>\nTestResults, TestCases, TestRunners, and TestSuites--but the specifics<br/>\nof *how* they relate are not clear.<br/>\n<br/>\nFor example:<br/>\n<br/>\nThe TestCase is taken, and by reflection is turned into a TestSuite.  So<br/>\nis it a TestCase or a TestSuite?  That is an important distinction.<br/>\nThe Model is not readily apparent.  A stable and predictable model is<br/>\nessential to good design--esp. in this case.  I have no problem with<br/>\nsaying that a TestCollector dynamically creates a TestSuite from a<br/>\ncollection of TestCases.  That is understandable.  I do have a problem<br/>\nwith the TestCase being treated as a TestSuite though.<br/>\n<br/>\nFurthermore, sometimes there is information that needs to be<br/>\ncommunicated as to exactly *why* a test failed.  There is no clear way<br/>\nto #1 directly get with the TestResult, #2 how to use it in your tests.<br/>\nThere isn&#39;t any way to display the results of nested exceptions because<br/>\nJUnit doesn&#39;t know about them.  However there is no provided method to<br/>\nadd that support either.<br/>\n<br/>\nThe last case is that the ClassLoader hierarchy needs to be really<br/>\nthought through.  The whole issue with only letting some classes remain<br/>\nstatic for the life of a test run is an artificial constraint that<br/>\ncan cause tests to fail that normally won&#39;t.  Don&#39;t outsmart yourself<br/>\nwith the classloaders.<br/>\n<br/>\nAnother issue I have is that while JUnit defines the Test interface,<br/>\nit only really expects the TestCase base class.  It is unclear how<br/>\nthe Test interface interacts with the system.  Sometimes I would much<br/>\nrather work with my own base class that is completely separate from<br/>\nJUnit.  The Assert class should be made a static utility clasee, not<br/>\na base class as well.  That would allow us to work with the assert<br/>\nmethods from any class something like this is much better:<br/>\n<br/>\nAssert.isTrue( myObject.rocks() );<br/>\n<br/>\nthan this:<br/>\n<br/>\nassertTrue( myObject.rocks() );<br/>\n<br/>\nThe reason being that sometimes the semantics and internals of the<br/>\nway TestCase is written gets in the way of how I want to make JUnit<br/>\nwork in my environment.  By not forcing an inheritance hierarchy on<br/>\nthe user, and really using interfaces correctly, you can have more<br/>\nintelligently designed and robust systems.  Interfaces are very<br/>\nimportant to protect a system from refactoring.  If the contracts<br/>\nwith the interface hold true, the implementation can change its<br/>\ninheritance hierarchy easily.<br/>\n<br/>\nWhat I would like to see is the following:<br/>\n<br/>\n* Explicit use of interfaces--make the contracts clear, and code the<br/>\n   test runners/collectors to use the interfaces and not the base<br/>\n   classes.  If there are different contracts with a type of test/suite,<br/>\n   then it needs a new interface.<br/>\n<br/>\n* Making Assert into a set of static utilities so that we don&#39;t have<br/>\n   to inherit it to make it useful.<br/>\n<br/>\n* Explicit use of the TestResult made clear so that we can extend it<br/>\n   to recognize nested exceptions or any other system specific info that<br/>\n   would help narrow down exactly why a test failed (sometimes it isn&#39;t<br/>\n   so clear--like classloader issues).<br/>\n<br/>\n* Conversion of Tests to be run with the Command pattern.  A test is<br/>\n   a special command that must be run.  The TestRunner doesn&#39;t care what<br/>\n   it does, just that it is run.  The Method, Class, ClassLoader, test<br/>\n   name, etc. can all be encapsulated in the Command object.<br/>\n<br/>\n* Explicit declaration of the TestCase being the Leaf of the model, not<br/>\n   a branch (as it is now treated).  A different interface for TestSuite<br/>\n   and TestCase will help.<br/>\n<br/>\n-- <br/>\n<br/>\n&quot;They that give up essential liberty to obtain a little temporary safety<br/>\n  deserve neither liberty nor safety.&quot;<br/>\n                 - Benjamin Franklin</div>", 
    "prevInTime": 5897, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1033565613", 
    "canDelete": false, 
    "nextInTopic": 5899, 
    "prevInTopic": 5897, 
    "headers": {
        "messageIdInHeader": "PDNEOUFGNUFELjIwNDA0MDNAYXBhY2hlLm9yZz4=", 
        "referencesHeader": "PDAwNGMwMWMyNjg5YSRjYzVmZmMxMCRhMjM4ODZkOUBtYW1hZ28+"
    }
}