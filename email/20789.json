{
    "numMessagesInTopic": 12, 
    "nextInTime": 20790, 
    "senderId": "qjPa8mYRgZ6VfCYgyQYTQR2HuMUk1XTCJiM4wsuPsx3uusxKMdwswGfFPa8XKS8SnzwKrtE4Lp-jfrhIxESJhG73z2x1gBm8OYXFZkFtW09oUtnUTlpoJMQfsxYn_PtaAuLUXg", 
    "systemMessage": false, 
    "subject": "Re: [junit] Anyone help me to figure out the java.lang.StackOverflowError problem?", 
    "from": "&quot;=?UTF-8?Q?C=C3=A9dric_Beust_=E2=99=94?=&quot; &lt;cbeust@...&gt;", 
    "authorName": "Cédric Beust ♔", 
    "msgSnippet": "Nobody can help you until you post the stack trace that contains the StackOverflowError. -- Cedric ... -- Cédric [Non-text portions of this message have been", 
    "msgId": 20789, 
    "profile": "cbeust", 
    "topicId": 20751, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 199443513, 
    "messageBody": "<div id=\"ygrps-yiv-1033373785\">Nobody can help you until you post the stack trace that contains the<br/>\nStackOverflowError.<br/>\n-- <br/>\nCedric<br/>\n<br/>\n<br/>\n<blockquote><span title=\"qreply\"> On Thu, Aug 7, 2008 at 2:23 AM, Fuguo Wei &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:tawqir_wei@...\">tawqir_wei@...</a>&gt; wrote:<br/>\n<br/>\n&gt;<br/>\n&gt; Dear David staff,<br/>\n&gt; I am sure I tried the man funtion debugger. No problem for that. This<br/>\n&gt; situation only happens when I use JUnit.<br/>\n&gt;<br/>\n&gt; wish you are lucky<br/>\n&gt;<br/>\n&gt; WEI FUGUO<br/>\n&gt;<br/>\n&gt; --- On Wed, 8/6/08, David Saff &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:david@...\">david@...</a> &lt;david%40saff.net&gt;&gt; wrote:<br/>\n&gt;<br/>\n&gt; From: David Saff &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:david@...\">david@...</a> &lt;david%40saff.net&gt;&gt;<br/>\n&gt; Subject: Re: [junit] Anyone help me to figure out the<br/>\n&gt; java.lang.StackOverflowError problem?<br/>\n&gt; To: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a> &lt;junit%40yahoogroups.com&gt;<br/>\n&gt; Date: Wednesday, August 6, 2008, 5:22 AM<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; Fuguo,<br/>\n&gt;<br/>\n&gt; I&#39;m sorry this has been bugging you. It&#39;s difficult to understand how<br/>\n&gt; JUnit could be encountering a recursion loop that wasn&#39;t there in your<br/>\n&gt; production code. Have you tried writing a main() method that runs the<br/>\n&gt; same test, but has no dependencies on JUnit? If it also fails with a<br/>\n&gt; StackOverflowError, then you can rest assured that JUnit is not the<br/>\n&gt; problem.<br/>\n&gt;<br/>\n&gt; David Saff<br/>\n&gt;<br/>\n&gt; On Tue, Aug 5, 2008 at 6:29 AM, Fuguo Wei &lt;tawqir_wei@yahoo. com&gt; wrote:<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt; Dear all, I am so upset about the problem I encountered. Wish any one<br/>\n&gt; could<br/>\n&gt; &gt; help me. Thank here first. It&#39;s the StackOverflowError problem. I thought<br/>\n&gt; &gt; It&#39;s because the recursive program I did. Any way ,I don&#39;t know how to<br/>\n&gt; solve<br/>\n&gt; &gt; this problem.<br/>\n&gt; &gt; Maybe I used it wrong. I was wandering where I am wrong for a few days. I<br/>\n&gt; am<br/>\n&gt; &gt; confused. Kindly hope you could help me. here is the code.(in the<br/>\n&gt; attachment<br/>\n&gt; &gt; also) if you can not get it, you could check the group file folder as<br/>\n&gt; well.<br/>\n&gt; &gt; I uploaded them to there. By the way, I tried the debug my source code<br/>\n&gt; with<br/>\n&gt; &gt; Eclipse debugger. There is no problem.<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt; Best regards<br/>\n&gt; &gt;<br/>\n&gt; &gt; WEI FUGUO<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt; (1) the test case is like this<br/>\n&gt; &gt;<br/>\n&gt; &gt; public void testCreateTableClus ter() {<br/>\n&gt; &gt; mapper2.createTable Cluster() ;<br/>\n&gt; &gt; assertNotNull( mapper.getClassM ap().getTableClu ster());<br/>\n&gt; &gt; }<br/>\n&gt; &gt;<br/>\n&gt; &gt; (2) the createTableCluster( ) source code is like this<br/>\n&gt; &gt;<br/>\n&gt; &gt; public void createTableCluster( ) {<br/>\n&gt; &gt; tableCluster. createMasterTabl e(tableName, classmap);<br/>\n&gt; &gt; }<br/>\n&gt; &gt;<br/>\n&gt; &gt; (3) the createMasterTable( ) source code is like this<br/>\n&gt; &gt;<br/>\n&gt; &gt; public MasterTableMap createMasterTable( String aTablename, ClassMap<br/>\n&gt; &gt; aClassmap)<br/>\n&gt; &gt; {<br/>\n&gt; &gt; return (MasterTableMap) createTable( aTablename, aClassmap, &#39;masterTable&#39;<br/>\n&gt; );<br/>\n&gt; &gt; }<br/>\n&gt; &gt;<br/>\n&gt; &gt; (4) createTable( ) source code<br/>\n&gt; &gt;<br/>\n&gt; &gt; public TableMap createTable( String aTablename, ClassMap aClassmap,<br/>\n&gt; String<br/>\n&gt; &gt; aTabletype)<br/>\n&gt; &gt; {<br/>\n&gt; &gt; pf.ColumnMap colummap=null;<br/>\n&gt; &gt; TableMap result =null;<br/>\n&gt; &gt; if (aTabletype. equals(&#39;masterTa ble&#39;))<br/>\n&gt; &gt; {<br/>\n&gt; &gt; result= new MasterTableMap( aTablename) ;<br/>\n&gt; &gt; this.set_masterTabl eMap(result) ;<br/>\n&gt; &gt; }<br/>\n&gt; &gt; else if (aTabletype. equals(&#39;independ entTable&#39; ))<br/>\n&gt; &gt; result= new IndependentTableMap (aTablename) ;<br/>\n&gt; &gt; else if (aTabletype. equals(&#39;dependen tTable&#39;))<br/>\n&gt; &gt; result= new DependentTableMap( aTablename) ;<br/>\n&gt; &gt; setCurrentTableMap( result);<br/>\n&gt; &gt; aClassmap.setMaster Table(result) ;<br/>\n&gt; &gt;<br/>\n&gt; &gt; java.util.List tempList =aClassmap.getColum nMaps();<br/>\n&gt; &gt;<br/>\n&gt; &gt; Iterator tmpIter = tempList.iterator( );<br/>\n&gt; &gt; while (tmpIter.hasNext( ))<br/>\n&gt; &gt; {<br/>\n&gt; &gt; colummap = (pf.ColumnMap) tmpIter.next( );<br/>\n&gt; &gt; colummap.getAttribu teMapper( ).createTableSql Process(this, colummap,<br/>\n&gt; &gt; aClassmap);<br/>\n&gt; &gt; }<br/>\n&gt; &gt; addTableMaps( result);<br/>\n&gt; &gt; return result;<br/>\n&gt; &gt; }<br/>\n&gt; &gt; (5) one of createTableSqlProce ss() is like this. [many classes which<br/>\n&gt; &gt; inherit from the same parent have createTableSqlProce ss]<br/>\n&gt; &gt;<br/>\n&gt; &gt; public void createTableSqlProce ss(TableCluster aTablecluster,<br/>\n&gt; pf.ColumnMap<br/>\n&gt; &gt; aColumnmap, pf.ClassMap aMasterClass) {<br/>\n&gt; &gt; ArrayColumnMap arrayColumnmap = (ArrayColumnMap) aColumnmap;<br/>\n&gt; &gt; ClassMap classmap=null;<br/>\n&gt; &gt; pf.PersistenceClass persisClass= null;<br/>\n&gt; &gt; String tableName =null;<br/>\n&gt; &gt; configfiend. RelationshipItem relation=null;<br/>\n&gt; &gt; DependentTableMap depentable=null;<br/>\n&gt; &gt;<br/>\n&gt; &gt; String elementCategory= arrayColumnmap. getElementCatego ry();<br/>\n&gt; &gt; if (elementCategory. equals(&#39;Complex&#39; ))<br/>\n&gt; &gt; {<br/>\n&gt; &gt; classmap =arrayColumnmap. getClassMap( );<br/>\n&gt; &gt; if (classmap==null)<br/>\n&gt; &gt; {<br/>\n&gt; &gt; logger.debug( &#39;The array attribute &#39;+arrayColumnmap. getColumnName( )+&#39;&#39;s<br/>\n&gt; &gt; related class was not there, the system will load it at once!&#39;);<br/>\n&gt; &gt; persisClass= PersistentClassM anager.loadPersi stenceClass(<br/>\n&gt; arrayColumnmap.<br/>\n&gt; &gt; getFieldType( ));<br/>\n&gt; &gt; if (persisClass! =null)<br/>\n&gt; &gt; {<br/>\n&gt; &gt; classmap=persisClas s.getMapper( ).getClassMap( );<br/>\n&gt; &gt; }<br/>\n&gt; &gt; else<br/>\n&gt; &gt; {<br/>\n&gt; &gt; logger.debug( &#39;couldn&#39;t get the persistence class from peristence class<br/>\n&gt; &gt; lib.. the process will be terminated&#39;) ;<br/>\n&gt; &gt; return;<br/>\n&gt; &gt; }<br/>\n&gt; &gt; }<br/>\n&gt; &gt; tableName=classmap. getTableName( );<br/>\n&gt; &gt; relation=arrayColum nmap.getRelation ship();<br/>\n&gt; &gt; if (arrayColumnmap. isReflectRelatio n())<br/>\n&gt; &gt; {<br/>\n&gt; &gt; if (relation!=null)<br/>\n&gt; &gt; {<br/>\n&gt; &gt; if ((relation.getRelat ionshipType( ).equals( &#39;Composition&#39;<br/>\n&gt; ))||(relation..<br/>\n&gt; &gt; getRelationshipT ype().equals( &#39;Strong Aggregation&#39; )))<br/>\n&gt; &gt; {<br/>\n&gt; &gt; depentable=aTablecl uster.createDepe ndentTable( tableName, classmap);<br/>\n&gt; &gt; depentable.setRefer enceTable( aMasterClass. getMasterTable( ));<br/>\n&gt; &gt; }<br/>\n&gt; &gt; else<br/>\n&gt; &gt; aTablecluster. createIndependen tTable(tableName , classmap);<br/>\n&gt; &gt; }<br/>\n&gt; &gt; }<br/>\n&gt; &gt; else<br/>\n&gt; &gt; aTablecluster. createIndependen tTable(tableName , classmap);<br/>\n&gt; &gt; }<br/>\n&gt; &gt; else<br/>\n&gt; &gt; {<br/>\n&gt; &gt; String fieldname=arrayColu mnmap.getFieldNa me();<br/>\n&gt; &gt; String fieldtype=arrayColu mnmap.getFieldTy pe();<br/>\n&gt; &gt; TableField tablefield=new TableField(fieldnam e,fieldtype, aMasterClass..<br/>\n&gt; &gt; getDomainClass( ));<br/>\n&gt; &gt; aTablecluster. getCurrentTableM ap().addField( tablefield) ;<br/>\n&gt; &gt;<br/>\n&gt; &gt; String tempstr =aMasterClass. getDomainClass( ).getName( ).substring(<br/>\n&gt; &gt; aMasterClass. getDomainClass( ).getName( ).lastIndexOf( &#39;.&#39;)+1)+&#39; oid&#39;;<br/>\n&gt; &gt; if (fieldname.toUpperC ase().indexOf( tempstr.toUpperC ase())!=- 1)<br/>\n&gt; &gt; aTablecluster. getCurrentTableM ap().setPrimaryK ey(tablefield) ;<br/>\n&gt; &gt; }<br/>\n&gt; &gt; }<br/>\n&gt; &gt;<br/>\n&gt; &gt; as you can see the createTable method is invoked recursively in<br/>\n&gt; &gt; createTableSqlProce ss() [the bold statement]<br/>\n&gt; &gt;<br/>\n&gt; &gt; the sourse code of createDependentTabl e() likes this<br/>\n&gt; &gt;<br/>\n&gt; &gt; public DependentTableMap createDependentTabl e(String aTablename,<br/>\n&gt; ClassMap<br/>\n&gt; &gt; aClassmap) {<br/>\n&gt; &gt; return (DependentTableMap) createTable( aTablename, aClassmap,<br/>\n&gt; &gt; &#39;dependentTable&#39; );<br/>\n&gt; &gt; }<br/>\n&gt; &gt;<br/>\n&gt; &gt; the sourse code of createIndependentTa ble() likes this<br/>\n&gt; &gt;<br/>\n&gt; &gt; public IndependentTableMap createIndependentTa ble(String aTablename,<br/>\n&gt; &gt; ClassMap aClassmap) {<br/>\n&gt; &gt; return (IndependentTableMa p)createTable( aTablename, aClassmap,<br/>\n&gt; &gt; &#39;independentTabl e&#39;);<br/>\n&gt; &gt; }<br/>\n&gt; &gt;<br/>\n&gt; &gt; the two methods are like the createMasterTable( ) at the beginning of the<br/>\n&gt; &gt; source code I listed here.<br/>\n&gt; &gt;<br/>\n&gt; &gt; the createTable( ) is invoked recursively, as you can see. I guess that&#39;s<br/>\n&gt; &gt; the point why JUnit wrong.<br/>\n&gt; &gt;<br/>\n&gt; &gt; the Junit errow message screen was captured in the attachement.<br/>\n&gt; &gt;<br/>\n&gt; &gt; ----------<br/>\n&gt; &gt;<br/>\n&gt; &gt; (1) the test case is like this<br/>\n&gt; &gt;<br/>\n&gt; &gt; public void testCreateTableClus ter() {<br/>\n&gt; &gt; mapper2.createTable Cluster() ;<br/>\n&gt; &gt; assertNotNull( mapper.getClassM ap().getTableClu ster());<br/>\n&gt; &gt; }<br/>\n&gt; &gt;<br/>\n&gt; &gt; (2) the createTableCluster( ) source code is like this<br/>\n&gt; &gt;<br/>\n&gt; &gt; public void createTableCluster( ) {<br/>\n&gt; &gt; tableCluster. createMasterTabl e(tableName, classmap);<br/>\n&gt; &gt; }<br/>\n&gt; &gt;<br/>\n&gt; &gt; (3) the createMasterTable( ) source code is like this<br/>\n&gt; &gt;<br/>\n&gt; &gt; public MasterTableMap createMasterTable( String aTablename, ClassMap<br/>\n&gt; &gt; aClassmap)<br/>\n&gt; &gt; {<br/>\n&gt; &gt; return (MasterTableMap) createTable( aTablename, aClassmap, &#39;masterTable&#39;<br/>\n&gt; );<br/>\n&gt; &gt; }<br/>\n&gt; &gt;<br/>\n&gt; &gt; (4) createTable( ) source code<br/>\n&gt; &gt;<br/>\n&gt; &gt; public TableMap createTable( String aTablename, ClassMap aClassmap,<br/>\n&gt; String<br/>\n&gt; &gt; aTabletype)<br/>\n&gt; &gt; {<br/>\n&gt; &gt; pf.ColumnMap colummap=null;<br/>\n&gt; &gt; TableMap result =null;<br/>\n&gt; &gt; if (aTabletype. equals(&#39;masterTa ble&#39;))<br/>\n&gt; &gt; {<br/>\n&gt; &gt; result= new MasterTableMap( aTablename) ;<br/>\n&gt; &gt; this.set_masterTabl eMap(result) ;<br/>\n&gt; &gt; }<br/>\n&gt; &gt; else if (aTabletype. equals(&#39;independ entTable&#39; ))<br/>\n&gt; &gt; result= new IndependentTableMap (aTablename) ;<br/>\n&gt; &gt; else if (aTabletype. equals(&#39;dependen tTable&#39;))<br/>\n&gt; &gt; result= new DependentTableMap( aTablename) ;<br/>\n&gt; &gt; setCurrentTableMap( result);<br/>\n&gt; &gt; aClassmap.setMaster Table(result) ;<br/>\n&gt; &gt;<br/>\n&gt; &gt; java.util.List tempList =aClassmap.getColum nMaps();<br/>\n&gt; &gt;<br/>\n&gt; &gt; Iterator tmpIter = tempList.iterator( );<br/>\n&gt; &gt; while (tmpIter.hasNext( ))<br/>\n&gt; &gt; {<br/>\n&gt; &gt; colummap = (pf.ColumnMap) tmpIter.next( );<br/>\n&gt; &gt; colummap.getAttribu teMapper( ).createTableSql Process(this, colummap,<br/>\n&gt; &gt; aClassmap);<br/>\n&gt; &gt; }<br/>\n&gt; &gt; addTableMaps( result);<br/>\n&gt; &gt; return result;<br/>\n&gt; &gt; }<br/>\n&gt; &gt; (5) one of createTableSqlProce ss() is like this. [many classes which<br/>\n&gt; inherit<br/>\n&gt; &gt; from the same parent have createTableSqlProce ss]<br/>\n&gt; &gt;<br/>\n&gt; &gt; public void createTableSqlProce ss(TableCluster aTablecluster,<br/>\n&gt; pf.ColumnMap<br/>\n&gt; &gt; aColumnmap, pf.ClassMap aMasterClass) {<br/>\n&gt; &gt; ArrayColumnMap arrayColumnmap = (ArrayColumnMap) aColumnmap;<br/>\n&gt; &gt; ClassMap classmap=null;<br/>\n&gt; &gt; pf.PersistenceClass persisClass= null;<br/>\n&gt; &gt; String tableName =null;<br/>\n&gt; &gt; configfiend. RelationshipItem relation=null;<br/>\n&gt; &gt; DependentTableMap depentable=null;<br/>\n&gt; &gt;<br/>\n&gt; &gt; String elementCategory= arrayColumnmap. getElementCatego ry();<br/>\n&gt; &gt; if (elementCategory. equals(&#39;Complex&#39; ))<br/>\n&gt; &gt; {<br/>\n&gt; &gt; classmap =arrayColumnmap. getClassMap( );<br/>\n&gt; &gt; if (classmap==null)<br/>\n&gt; &gt; {<br/>\n&gt; &gt; logger.debug( &#39;The array attribute &#39;+arrayColumnmap. getColumnName( )+&#39;&#39;s<br/>\n&gt; &gt; related class was not there, the system will load it at once!&#39;);<br/>\n&gt; &gt; persisClass= PersistentClassM anager.loadPersi stenceClass(<br/>\n&gt; arrayColumnmap. getFieldType( ));<br/>\n&gt; &gt; if (persisClass! =null)<br/>\n&gt; &gt; {<br/>\n&gt; &gt; classmap=persisClas s.getMapper( ).getClassMap( );<br/>\n&gt; &gt; }<br/>\n&gt; &gt; else<br/>\n&gt; &gt; {<br/>\n&gt; &gt; logger.debug( &#39;couldn&#39;t get the persistence class from peristence class<br/>\n&gt; lib.<br/>\n&gt; &gt; the process will be terminated&#39;) ;<br/>\n&gt; &gt; return;<br/>\n&gt; &gt; }<br/>\n&gt; &gt; }<br/>\n&gt; &gt; tableName=classmap. getTableName( );<br/>\n&gt; &gt; relation=arrayColum nmap.getRelation ship();<br/>\n&gt; &gt; if (arrayColumnmap. isReflectRelatio n())<br/>\n&gt; &gt; {<br/>\n&gt; &gt; if (relation!=null)<br/>\n&gt; &gt; {<br/>\n&gt; &gt; if<br/>\n&gt; &gt; ((relation.getRelat ionshipType( ).equals( &#39;Composition&#39; ))||(relation.<br/>\n&gt; getRelationshipT ype().equals( &#39;Strong<br/>\n&gt; &gt; Aggregation&#39; )))<br/>\n&gt; &gt; {<br/>\n&gt; &gt; depentable=aTablecl uster.createDepe ndentTable( tableName, classmap);<br/>\n&gt; &gt; depentable.setRefer enceTable( aMasterClass. getMasterTable( ));<br/>\n&gt; &gt; }<br/>\n&gt; &gt; else<br/>\n&gt; &gt; aTablecluster. createIndependen tTable(tableName , classmap);<br/>\n&gt; &gt; }<br/>\n&gt; &gt; }<br/>\n&gt; &gt; else<br/>\n&gt; &gt; aTablecluster. createIndependen tTable(tableName , classmap);<br/>\n&gt; &gt; }<br/>\n&gt; &gt; else<br/>\n&gt; &gt; {<br/>\n&gt; &gt; String fieldname=arrayColu mnmap.getFieldNa me();<br/>\n&gt; &gt; String fieldtype=arrayColu mnmap.getFieldTy pe();<br/>\n&gt; &gt; TableField tablefield=new<br/>\n&gt; &gt; TableField(fieldnam e,fieldtype, aMasterClass. getDomainClass( ));<br/>\n&gt; &gt; aTablecluster. getCurrentTableM ap().addField( tablefield) ;<br/>\n&gt; &gt;<br/>\n&gt; &gt; String tempstr<br/>\n&gt; &gt; =aMasterClass. getDomainClass( ).getName( ).substring( aMasterClass.<br/>\n&gt; getDomainClass( ).getName( ).lastIndexOf( &#39;.&#39;)+1)+&#39; oid&#39;;<br/>\n&gt; &gt; if (fieldname.toUpperC ase().indexOf( tempstr.toUpperC ase())!=- 1)<br/>\n&gt; &gt; aTablecluster. getCurrentTableM ap().setPrimaryK ey(tablefield) ;<br/>\n&gt; &gt; }<br/>\n&gt; &gt; }<br/>\n&gt; &gt;<br/>\n&gt; &gt; as you can see the createTable method is invoked recursively in<br/>\n&gt; &gt; createTableSqlProce ss() [the bold statement]<br/>\n&gt; &gt;<br/>\n&gt; &gt; the sourse code of createDependentTabl e() likes this<br/>\n&gt; &gt;<br/>\n&gt; &gt; public DependentTableMap createDependentTabl e(String aTablename,<br/>\n&gt; ClassMap<br/>\n&gt; &gt; aClassmap) {<br/>\n&gt; &gt; return<br/>\n&gt; &gt; (DependentTableMap) createTable( aTablename, aClassmap, &#39;dependentTable&#39;<br/>\n&gt; );<br/>\n&gt; &gt; }<br/>\n&gt; &gt;<br/>\n&gt; &gt; the sourse code of createIndependentTa ble() likes this<br/>\n&gt; &gt;<br/>\n&gt; &gt; public IndependentTableMap createIndependentTa ble(String aTablename,<br/>\n&gt; &gt; ClassMap aClassmap) {<br/>\n&gt; &gt; return<br/>\n&gt; &gt; (IndependentTableMa p)createTable( aTablename, aClassmap,<br/>\n&gt; &#39;independentTabl e&#39;);<br/>\n&gt; &gt; }<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt; the two methods are like the createMasterTable( ) at the beginning of the<br/>\n&gt; &gt; source code I listed here.<br/>\n&gt; &gt;<br/>\n&gt; &gt; the createTable( ) is invoked recursively, as you can see. I guess that&#39;s<br/>\n&gt; the<br/>\n&gt; &gt; point why JUnit wrong.<br/>\n&gt; &gt; the Junit errow message screen was captured in the attachement.<br/>\n&gt; &gt;<br/>\n&gt; &gt; [Non-text portions of this message have been removed]<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; [Non-text portions of this message have been removed]<br/>\n&gt;<br/>\n&gt;  <br/>\n&gt;<br/>\n<br/>\n<br/>\n<br/>\n-- <br/>\nCédric<br/>\n<br/>\n<br/>\n[Non-text portions of this message have been removed] </span></blockquote></div>", 
    "prevInTime": 20788, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1218463088", 
    "canDelete": false, 
    "nextInTopic": 20790, 
    "prevInTopic": 20788, 
    "headers": {
        "inReplyToHeader": "PDIzOTM0Ni45MjkxOC5xbUB3ZWI0NDgwOC5tYWlsLnNwMS55YWhvby5jb20+", 
        "messageIdInHeader": "PGI4NmI2YTljMDgwODExMDY1OG80ODIxYzUzYnY2ZjhkODljMzI5MGVhZDAzQG1haWwuZ21haWwuY29tPg==", 
        "referencesHeader": "PDRmN2RhNmI5MDgwODA2MDMyMmgxNjdkMTg0ZXU4N2RkMzNhODM4ODk0ZjEwQG1haWwuZ21haWwuY29tPgkgPDIzOTM0Ni45MjkxOC5xbUB3ZWI0NDgwOC5tYWlsLnNwMS55YWhvby5jb20+"
    }
}