{
    "numMessagesInTopic": 47, 
    "nextInTime": 15049, 
    "senderId": "tUJ6DDVIXC9Y5lOBzvdQOLt9p5TFevKpYhUXw711GUtScUXYZWTfhXXzquD3WDv4zu0vHfvQwYDVPLbodp5rUBgJv1Y", 
    "systemMessage": true, 
    "subject": "RE: [junit] Proposed parameterized test syntax for JUnit 4", 
    "from": "Eugene Kuleshov &lt;eu@...&gt;", 
    "authorName": "Eugene Kuleshov", 
    "msgSnippet": "Kent, I like that it will be again possible to dynamically generate test data and I believe it is a good change to introduce constructor with test parameters", 
    "msgId": 15048, 
    "profile": "ekuleshov", 
    "topicId": 14820, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 150395705, 
    "messageBody": "<div id=\"ygrps-yiv-1386757473\">Kent,<br/>\n<br/>\n  I like that it will be again possible to dynamically generate test <br/>\ndata and I believe it is a good change to introduce constructor with <br/>\ntest parameters because it is less error prone then using annotated <br/>\nfields for the same purpose.<br/>\n<br/>\n  However there are still few flaws in this design.<br/>\n<br/>\n  First of all you are forcing test runner to create new class instance <br/>\nfor each test, which is probably good thing from the point of unit test <br/>\nisolation enforcement, but from other hand it put a huge limitation for <br/>\ntools and will have memory and performance hit as well. So, it would <br/>\nmake sense to have these parameters passed to the test method (like it <br/>\nis done in TestNG).<br/>\n<br/>\n  Second limitation is that user don&#39;t have will have to declaratively <br/>\nspecify test data sets without writing custom @Parameters method and use <br/>\nsome system property to differentiate between tests. Perhaps you can add <br/>\nsome &quot;name&quot; property to Parameters annotation, so test runner can match <br/>\nthis name with declared test data. Such name property would also allow <br/>\nto have multiple @Parameters methods and match them with @Test methods <br/>\nif you&#39;ll have same name there too. The last would allow to have several <br/>\ntest methods with different kinds of test parameters without creating <br/>\nseparate test classes (so you&#39;ll have single test class for class under <br/>\ntesting).<br/>\n<br/>\n  The last thing I&#39;d like to mention is that current @Parameters methods <br/>\nwon&#39;t scale to large data sets (the same limitation also exists in <br/>\nTestNG). I&#39;ve seen JUnit3 suite() methods that produced thousands of <br/>\ntest permutations and that required lots of memory memory when running <br/>\ntests. So, It think that it would make sense to introduce an interface <br/>\nsimilar to JDBC ResultSet, so test runner can create iterate trough test <br/>\ndata without loading it completely into memory and also have option to <br/>\nget number of tests as well as jump to Nth test. You can also provide an <br/>\nadapter that will take Object[][] and provide all that functionality for <br/>\nusers who don&#39;t want to create test data dynamically.<br/>\n<br/>\n  regards,<br/>\n  Eugene<br/>\n<br/>\n<br/>\n<blockquote><span title=\"qreply\"> &gt; Elliotte,<br/>\n&gt;<br/>\n&gt; Parameterized tests violate an assumption in JUnit that some of which <br/>\n&gt; JUnit GUIs<br/>\n&gt; depend on, that tests can be uniquely identified by a class and method <br/>\n&gt; name.<br/>\n&gt; However, I can see that they are potentially useful. One question is <br/>\n&gt; whether to<br/>\n&gt; add functionality to JUnit only at a speed the test runners can match <br/>\n&gt; or march<br/>\n&gt; ahead, accepting that temporarily-poor GUI support is the price of <br/>\n&gt; architectural<br/>\n&gt; progress. Having not changed JUnit much in years, I am ready to move <br/>\n&gt; forward.<br/>\n&gt;<br/>\n&gt; Here is a revised parameterized test proposal for comment. Three <br/>\n&gt; things have<br/>\n&gt; changed.<br/>\n&gt; * The class is now annotated with a class used to run it:<br/>\n&gt; @Factory(Parameterized.class). This seems like a very general <br/>\n&gt; mechanism to me.<br/>\n&gt; For example, I was able to write a test runnerlet to run JUnit 3.x <br/>\n&gt; AllTests in a<br/>\n&gt; few minutes. Would JUnit extenders find this annotation generally helpful?<br/>\n&gt; * The data comes from a static method instead of a static field. A method<br/>\n&gt; seemed more general than a field and is evaluated later, when the test <br/>\n&gt; is run<br/>\n&gt; instead of when the class is loaded. Totally static data can be simply<br/>\n&gt; implemented by a method which just returns that data.<br/>\n&gt; * Parameters are passed to a constructor instead of stuffed into <br/>\n&gt; fields. This<br/>\n&gt; seems more general as well as reducing the number of annotations by <br/>\n&gt; one. One<br/>\n&gt; limitation of the current implementation is that parameterized test <br/>\n&gt; classes can<br/>\n&gt; only have a single constructor.<br/>\n&gt;<br/>\n&gt; Here is an example:<br/>\n&gt; @Factory(Parameterized.class) //TODO This shouldn&#39;t be called Factory, <br/>\n&gt; because<br/>\n&gt; it doesn&#39;t create anything. &quot;Runner&quot;, perhaps?<br/>\n&gt; public class FibonacciTest {<br/>\n&gt; @Parameters public static Object[] data() {<br/>\n&gt; return new int[][] {{0, 0}, {1, 1}, {2, 1}, {3, 2}, {4, 3}, {5, 5}, <br/>\n&gt; {6, 8}};<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; private int input;<br/>\n&gt; private int expected;<br/>\n&gt;<br/>\n&gt; public FibonacciTest(int input, int expected) {<br/>\n&gt; this.input= input;<br/>\n&gt; this.expected= expected;<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; @Test public void test() {<br/>\n&gt; assertEquals(expected, fib(input));<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; private int fib(int x) {<br/>\n&gt; return 0;<br/>\n&gt; }<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; Comments? </span></blockquote></div>", 
    "prevInTime": 15047, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1128283704", 
    "canDelete": false, 
    "nextInTopic": 15051, 
    "prevInTopic": 15047, 
    "headers": {
        "messageIdInHeader": "PDQzNDAzRTM4LjcwOTAxMDNAbWQucHAucnU+"
    }
}