{
    "numMessagesInTopic": 125, 
    "nextInTime": 14617, 
    "senderId": "Qp4R5p8yoC677_7S2WVp4O98t2_HBbPYuLZ5zA97E4BfqlvB9_uDvErLsZWcwWMh-wIbMqdv85E4YIJ9MaSvrTLrujqhHDfTYgl0JX8QMQ", 
    "systemMessage": false, 
    "subject": "Re: [junit] How to test private methods in a class.", 
    "from": "Elliotte Harold &lt;elharo@...&gt;", 
    "authorName": "Elliotte Harold", 
    "msgSnippet": "... None of which prevents somebody from writing their own implementation of the interface, instantiating it and bypassing the factories completely. ... The", 
    "msgId": 14616, 
    "topicId": 14490, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 12653864, 
    "messageBody": "<div id=\"ygrps-yiv-206050884\">Robert Watkins wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Firstly, if you&#39;ve got factories for your domain objects, you can verify <br/>\n&gt; that your factories are used correctly, via coding conventions and <br/>\n&gt; analysis tools (e.g. checkstyle). Testing your factories is pretty <br/>\n&gt; simply, as a general rule. In general, factories tend to be safer to use <br/>\n&gt; than constructors, anyway, so you actually gain from the factories.<br/>\n<br/>\n </span></blockquote>None of which prevents somebody from writing their own implementation of <br/>\nthe interface, instantiating it and bypassing the factories completely.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Secondly, you can&#39;t rely on objects to define behaviour in stone, <br/>\n&gt; anyway. Maybe someone came along and removed that pesky &quot;final&quot; keyword <br/>\n&gt; (either directly or via bytecode engineering). Or perhaps they&#39;ve simply <br/>\n&gt; swapped the class out with another one that matches the same interface. <br/>\n&gt; In short, you can only rely on &quot;final&quot; to lock down behaviour if you&#39;re <br/>\n&gt; the only one writing the source code.<br/>\n<br/>\n<br/>\n </span></blockquote>The source (or byte) code can always be forked. At that point it&#39;s out <br/>\nof my hands, and not really my responsibility. But they can&#39;t just swap <br/>\nout my class for a different one, if I&#39;ve written the implementation to <br/>\ndepend on classes rather than interfaces. That&#39;s pretty much the point.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Thirdly, interfaces define contracts. Implementations which do not <br/>\n&gt; conform to the contracts aren&#39;t socially responsible - you shouldn&#39;t <br/>\n&gt; build them that way. How do you make sure you build them right? Testing, <br/>\n&gt; peer reviews, and well-defined types.<br/>\n<br/>\n </span></blockquote>All good ideas, but if this were sufficient we never would have needed <br/>\naccess protection in the first place.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Finally: the very fact that you can change the implementation randomly <br/>\n&gt; is a benefit, not a problem. In particular, unit test code gains from <br/>\n&gt; being able to provide an arbitrary implementation of an interface that <br/>\n&gt; it just can&#39;t do with a class.<br/>\n<br/>\n </span></blockquote>In other words, you can write an implementation that passes the test <br/>\neven if the real implementation doesn&#39;t. How does that help?<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; It sounds like you&#39;ve got some fairly serious trust issues about the <br/>\n&gt; competence and/or integrity of the developers you work with, if you&#39;re <br/>\n&gt; trying to lock down their behaviour that tightly. Is that a fair assessment?<br/>\n<br/>\n </span></blockquote>The developers I work with are everyone who downloads my code. Some of <br/>\nthem I trust. Some of them I don&#39;t. They range in skill levels from <br/>\nextremely experienced, wise, knowledgeable developers like Michael Kay <br/>\nto random undergraduates and unreconstructed COBOL hacks. However one <br/>\nthing they all have in common is that they&#39;re using my code because they <br/>\nimplicitly or explicitly trust me and my library(s). I promise that the <br/>\nlibrary behaves in a certain way under certain conditions and <br/>\naccomplishes certain tasks. I can do this only because my libraries are <br/>\ndesigned around concrete classes. Were the library designed around <br/>\ninterfaces instead, I could no no longer make such promises. Even my own <br/>\ncode that I trust could be compromised were someone to inject a <br/>\nmisbehaving implementation they themselves had written. Few classes <br/>\noperate in isolation. I code my FOO class under the assumption that the <br/>\nBAR class behaves in a certain way. If someone replaces the BAR class <br/>\nwith a misbehaving version, then not just BAR but also FOO and <br/>\neverything else that depends on it could be compromised.<br/>\n<br/>\n-- <br/>\nï»¿Elliotte Rusty Harold  <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:elharo@...\">elharo@...</a><br/>\nXML in a Nutshell 3rd Edition Just Published!<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.cafeconleche.org/books/xian3/\">http://www.cafeconleche.org/books/xian3/</a><br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.amazon.com/exec/obidos/ISBN=0596007647/cafeaulaitA/ref=nosim\">http://www.amazon.com/exec/obidos/ISBN=0596007647/cafeaulaitA/ref=nosim</a></div>", 
    "prevInTime": 14615, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1125673743", 
    "canDelete": false, 
    "nextInTopic": 14617, 
    "prevInTopic": 14615, 
    "headers": {
        "inReplyToHeader": "PDQzMTg1OTk2LjUwMDAxMDlAdHdhc2luay5uZXQ+", 
        "messageIdInHeader": "PDQzMTg2QjBGLjMwMTAyQG1ldGFsYWIudW5jLmVkdT4=", 
        "referencesHeader": "PDExMjU2Njg0OTEuNzUzLjQzOTA1Lm0xOUB5YWhvb2dyb3Vwcy5jb20+IDw0MzE4NTk5Ni41MDAwMTA5QHR3YXNpbmsubmV0Pg=="
    }
}