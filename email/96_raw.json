{
    "topicId": 95, 
    "postDate": "976113249", 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "from": "&quot;Jim Jackl-Mochel&quot; &lt;jmochel@...&gt;", 
    "canDelete": false, 
    "replyTo": "LIST", 
    "senderId": "PAd9z7L5CU7G1OJzh2zgVc4eFKJojkmJCwrdmUKCuWLGKjO0eGEDLNB-saT_ckh9bnk4X7G6XXbvMaxs8SNd75l2IO3-PfN1ei2AoHLzqg", 
    "nextInTime": 97, 
    "userId": 0, 
    "prevInTime": 95, 
    "prevInTopic": 95, 
    "headers": {
        "inReplyToHeader": "PDAwNDQwMWMwNWZiYSQ4NzBiYjBlMCQ3MDZlNmJjMEBwYzEyLmJyb2FkY29tLmllPg==", 
        "messageIdInHeader": "PEJBRVBKSUxMRE1PSEZHRUpNTE5LRUVESENPQUEuam1vY2hlbEBmb2xpYWdlLmNvbT4="
    }, 
    "authorName": "Jim Jackl-Mochel", 
    "numMessagesInTopic": 2, 
    "msgSnippet": "There always seems to be one configuration or set of classes that takes up the majority of the test bed work. When I am testing distributed classes there are", 
    "contentTrasformed": false, 
    "msgId": 96, 
    "nextInTopic": 0, 
    "systemMessage": false, 
    "rawEmail": "Return-Path: &lt;jmochel@...&gt;\r\nX-Sender: jmochel@...\r\nX-Apparently-To: junit@egroups.com\r\nReceived: (EGP: mail-6_3_1_3); 6 Dec 2000 16:42:57 -0000\r\nReceived: (qmail 12391 invoked from network); 6 Dec 2000 16:42:55 -0000\r\nReceived: from unknown (10.1.10.27) by l7.egroups.com with QMQP; 6 Dec 2000 16:42:55 -0000\r\nReceived: from unknown (HELO gateway.foliage.com) (63.117.36.2) by mta2 with SMTP; 6 Dec 2000 16:42:55 -0000\r\nReceived: (from root@localhost) by gateway.foliage.com (8.9.3/8.9.3) id JAA13882 for junit@egroups.com.outgoing; Wed, 6 Dec 2000 09:38:22 -0500\r\nReceived: from devilmountain (devilmountain.corp.foliage.com [192.9.200.212]) by gateway.foliage.com (8.9.3/8.9.3) with SMTP id JAA13876 for &lt;junit@egroups.com&gt;; Wed, 6 Dec 2000 09:38:22 -0500\r\nTo: &lt;junit@egroups.com&gt;\r\nSubject: RE: [junit] xUnit testing of distributed systems\r\nDate: Wed, 6 Dec 2000 09:34:09 -0500\r\nMessage-ID: &lt;BAEPJILLDMOHFGEJMLNKEEDHCOAA.jmochel@...&gt;\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=&quot;us-ascii&quot;\r\nContent-Transfer-Encoding: 7bit\r\nX-Priority: 3 (Normal)\r\nX-MSMail-Priority: Normal\r\nX-Mailer: Microsoft Outlook IMO, Build 9.0.2416 (9.0.2910.0)\r\nImportance: Normal\r\nIn-Reply-To: &lt;004401c05fba$870bb0e0$706e6bc0@...&gt;\r\nX-MimeOLE: Produced By Microsoft MimeOLE V5.50.4133.2400\r\nFrom: &quot;Jim Jackl-Mochel&quot; &lt;jmochel@...&gt;\r\n\r\nThere always seems to be one configuration or set of classes that takes\nup the majority of the test bed work. When I am testing distributed classes\nthere are few additional things I do beyond the usual testing for regular\nclasses.\n\nMy basic testing regimen for most classes is:\n(The original ideas for these are stolen from a book on testing Object\nOriented\nClasses that I read so long ago I don&#39;t even remember who the author was.)\n\nFunctionality to be tested:\n\nConstructors\nDestructors\nAccessors/Mutators AKA Properties\nCommon or Core Methods (things like persistence, assignment operators)\nKey Methods (The reason we wrote the class in the first case...)\n\nTypes of tests to be conducted:\n\nTests for Basic Functionality\nTests for Boundary Functionality\nTests for Beyond Boundary Functionality\nTests for Destructive Functionality\n\n\n\nWhen I am testing distributed applications I add the following:\n\nTests for Proof of Existence.\n-----------------------------\nProof of existence demonstrates that a feature has been minimally\nimplemented.\n\nWith the possibility of mismatches between proxy code, idl, type libraries,\nand remote servers it makes sense to test for the basic existence\nof properties and methods. It provides a base test of the connection code as\nwell.\n\n\nOther kinds of testing:\n\nFor the kind of event driven system you are talking about I would\ntypically produce an event generator that kicks out a series of events and\nassociated\ndata in an order than makes sense. It takes some work but it is well worth\nit.\n\nIn addition I would use the event generator to do a specific type of testing\nfor\nthe kind of &quot;protocol&quot; you are talking about. It is called short tour\ntesting\nand is excellent for pounding on a state retaining protocol (an FSM) so that\nit correctly recovers from mis-sequenced communications and such.\n\nThe basic math for this comes from : &quot;Design and Validation of Computer\nProtocols&quot;\nby Holzmann. I first saw it in an article in C++ Journal or JOOPS about 5-6\nyears ago.\nThe basic theory is that for any complex sequence of events and data that\ncause a\nmisbehaviour you can usually reproduce that problem using a short (~3-5\nevents) sequence.\nThe trick is to generate the sequence in a reproducible manner.\n\nThe solution is to take the number of events (or methods) to be executed and\nassign an integer to each.\nThen for each event assign an integer to each set of data (set of\nparameters) that  can be sent out.\nThen the testing looks something like this:\n\nint testNumber = 30000; \t// some large number\nint numberOfEvents = 10; \t// As given by the protocol\nint numberOfDataSetsPerEvent = 5; // As you desire..\n\nint eventToBeSent;\n\nwhile (testNumber != 0)\n{\n\teventNdx = testNumber % numberOfEvents;\n\tdataSetNdx = testNumber % numberOfDataSetsPerEvent;\n\n\t// Send the event associated with eventNdx with the data associated with\ndataSetNdx\n\t// I often use the reflection API for this.\n\n\t// Catch any exceptions thrown by the event execution and log them\n\t// Log the target objects state (if applicable)\n\n\ttestNumber = testNumber - 1;\n}\n\nA very old example:\n\n    private void executeShortTour(int tour)\n    {\n        int            methodNdx;\n        Method         currMethod;\n        String         currMethodName;\n        Vector         currListOfParmLists;\n        Object[]       currParmList;\n\n\n        int numberOfMethods = _Cfg.getMethodCount();\n\n        System.out.println(&quot;Starting Short Tour&quot;);\n\n        while ( tour != numberOfMethods )\n        {\n            methodNdx = tour % numberOfMethods;\n\n            currMethod = (Method) _Cfg.getMethod(methodNdx);\n\n            int numberOfParmLists = _Cfg.getParmListCount(currMethod);\n\n            int parmListNdx = tour % numberOfParmLists;\n\n            Object    returnValue = null;\n\n            currParmList = (Object[])\n_Cfg.getParmList(currMethod,parmListNdx);\n\n            if ( currParmList == null )\n            {\n                throw (new ProxyInitializationException(new String(&quot;Unable\nto find parm list for method&quot;)));\n            }\n\n            System.out.println(&quot;Method(&quot; + methodNdx + &quot;) Parm Set(&quot; +\nparmListNdx + &quot;) tour (&quot; + tour + &quot;)&quot;);\n\n            try\n            {\n                returnValue = currMethod.invoke(_Instance, currParmList);\n\n                invokationSuccessProlog(methodNdx, parmListNdx, returnValue,\ncurrMethod, currParmList);\n                invokationSuccessEpilog(currMethod, currParmList);\n            }\n            catch(java.lang.reflect.InvocationTargetException\ninvocationTargetError)\n            {\n                invokationFailureProlog(methodNdx, parmListNdx, returnValue,\ncurrMethod, currParmList, invocationTargetError.getTargetException());\n                invokationFailureEpilog(currMethod, currParmList,\ninvocationTargetError.getTargetException());\n            }\n            catch(java.lang.IllegalArgumentException illegalArgumentError)\n            {\n                invokationFailureProlog(methodNdx, parmListNdx, returnValue,\ncurrMethod, currParmList, illegalArgumentError);\n                invokationFailureEpilog(currMethod, currParmList,\nillegalArgumentError);\n            }\n            catch(java.lang.IllegalAccessException illegalAccessError)\n            {\n                throw (new ProxyInitializationException(new String(&quot;4&quot;)));\n            }\n            finally\n            {\n            }\n\n            tour--;\n\n        }\n    }\n\n\n\nThe point here is not to produce something that succeeds in every case. The\npoint is to execute this\ntest, check (via by eye review) that it succeeds when it should and fails\nwhen it should, and use this\nfor regression and robustness checking.\n\nThe review can be a pain, but the effort is well worth it. You can also\ncreate an Oracle class that\ntells you what the expected behaviors should be and compares the actual\nresult to the predicted one.\nHow far you go depends on how much you want to pay for a given level of\nrobustness.\n\n\nThus ends my random exposition on how I tested my distribu apps this summer.\nHave fun.\n\nJim JM\n\n-----Original Message-----\nFrom: Jamie Lawrence [mailto:hopeless@...]\nSent: Wednesday, December 06, 2000 2:27 PM\nTo: junit@egroups.com\nSubject: [junit] xUnit testing of distributed systems\n\n\nI have finally got around to using JUnit for some of the development work I\ndo (all in Java).  However, whilst JUnit is fine for testing &quot;normal&quot;\nclasses I&#39;m really stuck on how to apply it to the application I&#39;m building.\n\nThis application is agent-based and is therefore distributed,\nmulti-threaded, asynchronous and acts in response to incoming messages and\nuser interactions.  It sits on top of an agent platform which makes it\nslightly harder to form tests (you must start the platform before any tests\nwill work).\n\nI understand that xUnit tests are normally focused on individual classes but\nin my case the classes include the agent itself, several behaviours (i.e.\ntasks), and utility classes.  The utility classes are quite easy to test as\nthey are usually standard classes devoid of agent complications.  The Agent\nhas very few methods of interest since it responds to messages placed in a\nqueue from either the GUI or other agents.  Each behaviour maintains an\ninternal state which changes in response to messages and can be\ncharacterised by either WAITING_FOR_USER, WAITING_FOR_MESSAGE,\nPERFORMING_ACTION, or SENDING_MESSAGE.  So my ideal tests would be to ensure\nthat the agent makes the correct state transitions in response to\nvalid/invalid messages and that it does this in each of the concurrent\nbehaviours.\n\nNow that I actually write all this down it does seem kinda difficult!!  But\nI think many of the problems exist in systems like Jini, etc.\n\nGiven the large amount of distributed systems work involved in most\napplications today I was hoping that someone would have typical patterns for\ntesting these systems.  Any ideas?\n\nMany thanks,\n\n\n\tJamie\n\n\n\nTo unsubscribe from this group, send an email to:\njunit-unsubscribe@egroups.com\n\n\n\n\n", 
    "subject": "RE: [junit] xUnit testing of distributed systems"
}