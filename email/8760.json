{
    "numMessagesInTopic": 6, 
    "nextInTime": 8761, 
    "senderId": "DNQf5qhbJmcGtNgwRSAyWCRmWYQ0a9FebXYQAPaq1oIqI0nwRPWFoeyuE-KisGU8gRhz2vJaFem-xRY5tTp_IzIhpgC5E6GdVg", 
    "systemMessage": false, 
    "subject": "Re: unit testing philosophy", 
    "from": "&quot;malvoisin&quot; &lt;wforster@...&gt;", 
    "authorName": "malvoisin", 
    "msgSnippet": "ranjan, testing DAS components is pretty straightforward, but you need to get comfortable with using mock objects. the way we test droplets on my current", 
    "msgId": 8760, 
    "profile": "malvoisin", 
    "topicId": 4923, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 125321020, 
    "messageBody": "<div id=\"ygrps-yiv-154877110\">ranjan, <br/>\n<br/>\ntesting DAS components is pretty straightforward, but you need to get<br/>\ncomfortable with using mock objects.  <br/>\n<br/>\nthe way we test droplets on my current project is by using mock<br/>\nversions of DynamoHttpServletResponse and DynamoHttpServletRequest and<br/>\nrunning them through your droplet:<br/>\n<br/>\nvoid testDroplet() {<br/>\n  MockDynamoHttpRequest request=new MockDynamoHttpRequest();<br/>\n  MockDynamoHttpResponse response=new MockDynamoHttpResponse();<br/>\n  MyDroplet droplet=new MyDroplet();<br/>\n  //configuration of request, response, droplet, etc. <br/>\n  droplet.server(request, response);<br/>\n  //test state of droplet, etc.<br/>\n}<br/>\n<br/>\nsince dynamo encourages you to break all of your droplets and objects<br/>\ninto independent components and define their concrete relationships in<br/>\nproperties files, it makes testing fairly straightforward.  iirc,<br/>\nwww.mockobjects.com has some dynamo specific mocks (like the request &<br/>\nresponse objects, as well as a mock nucleus, but they&#39;re all pretty<br/>\neasy to implement on your own.)   <br/>\n<br/>\njust as an aside (and this is a bit more advanced,) extending nucleus<br/>\nto work offline is also fairly straightforward.  extending nucleus <br/>\nallows you to &#39;cache&#39; your test configuration data into .properties<br/>\nfiles and serialized objects or run your whole application independent<br/>\nof DAS for testing, which makes things go much faster.  <br/>\n<br/>\nhope this helps,<br/>\nwill<br/>\n<br/>\n<br/>\n--- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>, &quot;ranjan_chakrab&quot; &lt;ranjan_chakrab@y...&gt;<br/>\nwrote:<br/>\n<blockquote><span title=\"qreply\"> &gt; Hello,<br/>\n&gt; <br/>\n&gt;   Also, I am trying to use JUnit to perform unit testing of ATG Dynamo<br/>\n&gt; Droplets and Form Handlers.<br/>\n&gt; <br/>\n&gt; Please let me know if there are any documents/ papers that discuss <br/>\n&gt; this subject.<br/>\n&gt; <br/>\n&gt; Thank you.<br/>\n&gt; <br/>\n&gt; Ranjan Chakrabarty<br/>\n&gt; e-mail: ranjan_chakrab@y...<br/>\n&gt; <br/>\n&gt; --- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>, &quot;tcfolsom&quot; &lt;Todd.Folsom@s...&gt; wrote:<br/>\n&gt; &gt; Go to www.mockmaker.org and download the mockmaker tool. Then apply <br/>\n&gt; &gt; it to interfaces or classes for which you need mocks. These new <br/>\n&gt; mocks <br/>\n&gt; &gt; will have methods for setting their state, and all support the <br/>\n&gt; verify<br/>\n&gt; &gt; () method. YOur mockRepository can be configured to return a <br/>\n&gt; &gt; mockRepositoryView and to verify that a call was made to that <br/>\n&gt; method. <br/>\n&gt; &gt; For instance if your code should call getRepositoryView(), you set <br/>\n&gt; up <br/>\n&gt; &gt; MockRepository with setExpectedGetRepositoryViewCalls(1). This <br/>\n&gt; method <br/>\n&gt; &gt; is built in the mock for you by the mockmaker tool. Verify() will <br/>\n&gt; &gt; check that a single call of getRepositoryView was made on the mock. <br/>\n&gt; &gt;   This is very useful stuff. However you may have to refactor your <br/>\n&gt; &gt; code to make it possible to supply a mock object instead of the <br/>\n&gt; real <br/>\n&gt; &gt; object. If you work from interfaces, it is easier to handle mocks. <br/>\n&gt; &gt; For example if getRepostoryView returns a RepositoryViewInterface <br/>\n&gt; &gt; rather than a RepositoryView, it is easy to return a <br/>\n&gt; &gt; MockRepositoryView which implemented RepositoryViewInterface.<br/>\n&gt; &gt; <br/>\n&gt; &gt; <br/>\n&gt; &gt; --- In junit@y..., &quot;cilqproj&quot; &lt;cilqproj@y...&gt; wrote:<br/>\n&gt; &gt; &gt; The problem is that I&#39;m struggling to test a pretty complex piece <br/>\n&gt; of<br/>\n&gt; &gt; &gt; code and I&#39;m trying to get some advice ( hints, help, etc .. ) to <br/>\n&gt; &gt; help<br/>\n&gt; &gt; &gt; me tackle it.  <br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; In the real world, I use ATG Dynamo.  If you&#39;ve heard of it or <br/>\n&gt; used<br/>\n&gt; &gt; &gt; it, it&#39;s an App Server / EJB Container.   Dynamo&#39;s entire <br/>\n&gt; framework <br/>\n&gt; &gt; is<br/>\n&gt; &gt; &gt; based off this component known as Nucleus, which does a lot of <br/>\n&gt; work <br/>\n&gt; &gt; in<br/>\n&gt; &gt; &gt; terms of instantiating classes, setting properties, etc..  It&#39;s <br/>\n&gt; also<br/>\n&gt; &gt; &gt; very slow and to test - build - test takes forever if I have to <br/>\n&gt; &gt; start<br/>\n&gt; &gt; &gt; and stop the app-server for every change in the code. <br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; That&#39;s where MockObjects come in.  Dynamo is a very Java Beans <br/>\n&gt; heavy<br/>\n&gt; &gt; &gt; framework, that relies a lot on setters and getters.  ( In fact, <br/>\n&gt; the<br/>\n&gt; &gt; &gt; MockObjects guys at SF have started putting together some Dynamo<br/>\n&gt; &gt; &gt; MockObjects. ) I was looking into MockObjects as a way to lessen <br/>\n&gt; my<br/>\n&gt; &gt; &gt; reliance on the Nucleus namespace so that I could code quickly and<br/>\n&gt; &gt; &gt; only integrate with the Nucleus namespace at the latest possible <br/>\n&gt; &gt; time.<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; However, I can&#39;t get my head around the fact that in certain <br/>\n&gt; cases <br/>\n&gt; &gt; my<br/>\n&gt; &gt; &gt; mock code will need to generate other mock code <br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; Here&#39;s a method from a piece of old code that I wrote before I <br/>\n&gt; &gt; decided<br/>\n&gt; &gt; &gt; to start using JUnit:<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt;     public  Map generateEmptyPreferencesMap( Map m ) throws<br/>\n&gt; &gt; &gt; RepositoryException {<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; \t// get the list of possible preferences<br/>\n&gt; &gt; &gt; \tRepositoryView contactMethodView = getPreferencesRepository<br/>\n&gt; &gt; ().getView(<br/>\n&gt; &gt; &gt; CONTACT_METHOD_REPOSITORY_ITEM );<br/>\n&gt; &gt; &gt; \tRepositoryItem[] contactMethods = <br/>\n&gt; &gt; contactMethodView.executeQuery(<br/>\n&gt; &gt; &gt; contactMethodView.getQueryBuilder().createUnconstrainedQuery() );<br/>\n&gt; &gt; &gt; \t<br/>\n&gt; &gt; &gt; \tif ( ( contactMethods != null ) && ( contactMethods.length &gt; <br/>\n&gt; &gt; 0 ) )  {<br/>\n&gt; &gt; &gt; \t    // add each one to the map<br/>\n&gt; &gt; &gt; \t    for ( int i = 0 ; i &lt; contactMethods.length ; i++ ) {<br/>\n&gt; &gt; &gt; \t\tm.put( contactMethods[i].getPropertyValue(<br/>\n&gt; &gt; &gt; CONTACT_METHOD_CODE_PROPERTY_NAME ), new BooleanPlaceHolder() );<br/>\n&gt; &gt; &gt; \t    }<br/>\n&gt; &gt; &gt; \t}<br/>\n&gt; &gt; &gt;      return m;<br/>\n&gt; &gt; &gt;     }<br/>\n&gt; &gt; &gt;      <br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; The Repository API is Dynamo&#39;s object-oriented data abstraction <br/>\n&gt; &gt; api. <br/>\n&gt; &gt; &gt; In this case, I assume I would setPreferencesRepository( new<br/>\n&gt; &gt; &gt; MyMockRepository()  )<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; but that MockRepository needs to return a MockRepositoryView <br/>\n&gt; which <br/>\n&gt; &gt; in<br/>\n&gt; &gt; &gt; turn needs to return a MockQueryBuilder, or so I seem to believe.<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; In a sentence:  how would one test this?  <br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; As before,<br/>\n&gt; &gt; &gt; Any and all help is greatly appreciated.<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; I apologize for any unnecessary lengthiness.<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; Thanks,<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; Aadi<br/>\n&gt; &gt; &gt; <br/>\n&gt; &gt; &gt; --- In junit@y..., Bob Koss &lt;koss@o...&gt; wrote:<br/>\n&gt; &gt; &gt; &gt; <br/>\n&gt; &gt; &gt; &gt; It would help if you&#39;d tell us what the problem is instead of <br/>\n&gt; &gt; presenting<br/>\n&gt; &gt; &gt; &gt; your solution of the problem as the problem.<br/>\n&gt; &gt; &gt; &gt; <br/>\n&gt; &gt; &gt; &gt; I&#39;ve never needed mocks inside of mocks - it doesn&#39;t even make <br/>\n&gt; &gt; sense.<br/>\n&gt; &gt; &gt; &gt; <br/>\n&gt; &gt; &gt; &gt; </span></blockquote></div>", 
    "prevInTime": 8759, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1058975520", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 8749, 
    "headers": {
        "inReplyToHeader": "PGJma21qZytrNHZjQGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PGJmbWF2MCszZG5xQGVHcm91cHMuY29tPg=="
    }
}