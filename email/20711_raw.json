{
    "numMessagesInTopic": 7, 
    "nextInTime": 20712, 
    "senderId": "rsxk68Pr0VNe5cZLYV0qChpsRq5fsHcpYDgqm7HDiVr44AX-wNjqL30ZxzaF_5iimRJbenhd4jeKpQ-zhICguqAMMfZu36IBRU7sagTXXqtv", 
    "systemMessage": false, 
    "subject": "Re: [junit] Newbie wants to take some JUnit group. Some basic questions.", 
    "from": "&quot;J. B. Rainsberger&quot; &lt;jbrains762@...&gt;", 
    "authorName": "J. B. Rainsberger", 
    "msgSnippet": "... It sounds like a very good place to start. I hope you have enjoyed what you ve read so far. ... I see a deeper design issue here that I want to make you", 
    "msgId": 20711, 
    "rawEmail": "Return-Path: &lt;jbrains762@...&gt;\r\nX-Sender: jbrains762@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nX-Received: (qmail 89941 invoked from network); 25 Jul 2008 01:00:24 -0000\r\nX-Received: from unknown (66.218.67.95)\n  by m57.grp.scd.yahoo.com with QMQP; 25 Jul 2008 01:00:24 -0000\r\nX-Received: from unknown (HELO an-out-0708.google.com) (209.85.132.249)\n  by mta16.grp.scd.yahoo.com with SMTP; 25 Jul 2008 01:00:23 -0000\r\nX-Received: by an-out-0708.google.com with SMTP id c23so708442anc.12\n        for &lt;junit@yahoogroups.com&gt;; Thu, 24 Jul 2008 18:00:23 -0700 (PDT)\r\nX-Received: by 10.100.42.4 with SMTP id p4mr1745745anp.76.1216947623177;\n        Thu, 24 Jul 2008 18:00:23 -0700 (PDT)\r\nX-Received: by 10.101.71.12 with HTTP; Thu, 24 Jul 2008 18:00:23 -0700 (PDT)\r\nMessage-ID: &lt;ce199d0807241800o663778a4r790c3523eb00b68c@...&gt;\r\nDate: Thu, 24 Jul 2008 20:00:23 -0500\r\nTo: junit@yahoogroups.com\r\nIn-Reply-To: &lt;g62neb+55it@...&gt;\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Transfer-Encoding: 7bit\r\nContent-Disposition: inline\r\nReferences: &lt;g62neb+55it@...&gt;\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: &quot;J. B. Rainsberger&quot; &lt;jbrains762@...&gt;\r\nSubject: Re: [junit] Newbie wants to take some JUnit group. Some basic questions.\r\nX-Yahoo-Group-Post: member; u=282027414; y=9nTozSKBUEQ510ccFMX4kTiraQWcoouV4CSqcPyRyv9tpXo\r\nX-Yahoo-Profile: nails762\r\n\r\nOn Mon, Jul 21, 2008 at 2:18 PM, serethos_0 &lt;Serethos@...&gt; wrote:\n\n&gt; I am an quite experienced programmer but new to the philosophy of unit\n&gt; testing. An issue I want to change.\n&gt; I read some articles and took some orientation on Frank Westphal&#39;s\n&gt; very good book about that topic. But in practice, I always run into\n&gt; similar problems, which seem to disturb my view of unit testing. So\n&gt; some thought and questions I would like to discuss.\n\nIt sounds like a very good place to start. I hope you have enjoyed\nwhat you&#39;ve read so far.\n\n&gt; 1. Recently I read that a unit test is no one if you have to touch\n&gt; network, db or filesystem. I understand the point that these accesses\n&gt; really can slow the tests down and usually need extra work of\n&gt; configuration, but how to avoid this?\n&gt; An example of my daily work. I have quite a common task: Fetch some\n&gt; xmls from an ftp server, parse the content and map it into db and vice\n&gt; versa. So the business logic is quite thin. More important is good\n&gt; exception handling and the transport of all data in the right structures.\n\nI see a deeper design issue here that I want to make you aware of, but\nthat I don&#39;t want to tackle yet. You mention you need to fetch XML\ndocuments from an FTP server, parse the content, then map it into a\ndatabase. Already you are describing your design in terms of\nimplementation details, rather than intent. Think about /why/ you need\nto do these things while you read my more immediate advice.\n\nI find good unit tests especially important to help me design\nexception handling, which is why I design to interfaces. When I design\nto interfaces, I can more easily control how collaborators behave, and\nin particular, I can force them to throw exceptions so I can test how\nI handle those exceptions. I don&#39;t know enough about your domain to\nname these classes and methods meaningfully, so I&#39;ll choose\ngeneric-sounding names that make some sense for me for now. Feel free\nto suggest better names.\n\nTo test your Component, you need to tell a Database to\nmapContent(content), so I create an interface Database with method\nmapContent(content) and Component uses it. In this test, I want to\nknow that Component successfully handles an exception that Database\nmight throw it. Suppose if the Database throws an exception, then we\nshould write the XML documents back to a DocumentQueue for later\nprocessing. You might need to do something different, but this gives\nme enough to build a complete example.\n\n@Test public void componentShouldQueueDocumentsOnDatabaseException()\nthrows Exception {\n    Document document = new Document(....);\n\n    CollectingDocumentQueue collectingDocumentQueue = new\nCollectingDocumentQueue();\n\n    Database crashTestDummy = new Database() {\n        public void mapContent(Content content) {\n            throw new RuntimeException(&quot;I blew up on purpose!&quot;);\n        }\n    }\n\n    new Component(crashTestDummy,\ncollectingDocumentQueue).processDocument(document);\n\n    assertEquals(Collections.singletonList(document),\ncollectingDocumentQueue.getDocuments());\n}\n\nI have also introduced interface DocumentQueue with method\nenqueue(document) and implemented it with CollectingDocumentQueue\nwhich simply collects all queued documents so the test can ask about\nthem later. The production implementation of DocumentQueue might talk\nto JMS or a web service or insert the documents into a database table.\nDocument is a simple value or entity object that represents one of the\nXML documents you fetch from your FTP server. It could even be a\nsimple envelope for raw XML: you can choose.\n\nThis test has a narrow focus: when you try to process a document and\nthe database fails, queue the document for later processing. By not\ninvolving a real database I can easily simulate the database failing\nby just implementing the Database anonymously and overriding\nmapContent() to throw an exception. The production implementation of\nDatabase could wrap any database you want: object-based, SQL, flat\nfiles, XStream, anything.\n\nThe key part of the technique is that Component, the class under test,\ntakes the Database and the DocumentQueue as parameters to its\nconstructor. This way I can use stand-ins that make the test easier to\nwrite, but still connect production implementations in the\napplication. In the test, I pass in a crash test dummy Database (a\nstand-in that always throws an exception) and a spy DocumentQueue (a\nstand-in that collects information about how it was used so the test\ncan debrief it afterwards); but in production, I pass in an SQL-based\nimplementation of Database and a JMS-based implementation of\nDocumentQueue. Component can&#39;t tell the difference, and I believe it\nshouldn&#39;t care. This modularity makes both testing and supporting new\nfeatures easier.\n\n&gt; Actually the slowdown of a real ftp transport and the configuration\n&gt; and injection overhead of the db-connection is a major drawback. But\n&gt; on the other hand I see no good way to mock the behaviour of these\n&gt; endpoints.\n\nDoes the above example help you see how to do it? One common technique\nI use is &quot;mock a level higher of abstraction&quot;. Don&#39;t mock SQL, but\nrather mock data storage operations that SQL could implement.\n\n&gt; I could try to mock a database, but how to test, if an sql-statement\n&gt; is correct (especially for a wider range of queries)?\n\nI wrote about this extensively in chapter 10 of JUnit Recipes, and\nothers have written extensively about it as well. Here is a short\nversion:\n\nWhen testing whether you correctly move data from FTP server to\ndatabase, don&#39;t test whether you can fetch from FTP and don&#39;t test\nwhether you can INSERT into the database. Assume you can fetch() and\nassume you can INSERT, then test what happens in between. When you\nimplement your XmlDocumentSource to be an FtpServer, then try fetching\na variety of documents without worrying about what happens after\nthey&#39;ve been fetched, because you tested that elsewhere. When you\nimplement your Database to be an SqlDatabase, then try a bunch of SQL\nstatements without worrying about why you&#39;re executing those\nparticular statements, because you tested that elsewhere.\n\n&gt; It also is a very hard work to write stubs or mocks, which can answer\n&gt; with all error-states an ftp-server/network can generate (timeout,\n&gt; access denied, authentication etc) to test the correct error handling\n&gt; of my code.\n\nDoes the database client handle the different SQL error codes\ndifferently? If not, then maybe one test throwing a generic\nSQLException will suffice.\n\nDoes the FTP client handle the different FTP errors differently? If\nnot, then maybe one test throwing a generic FTP transport exception\nwill suffice.\n\nDon&#39;t assume you have to test every kind of error separately if your\nclient always responds to errors the same way.\n\nIf, on the other hand, you do need to handle all those errors\ndifferently, then you simply have to test for them all. If you do\nless, then you&#39;re not doing your job.\n\n&gt; 2. Another question points to a basic principle of unit testing: the\n&gt; opening of a class in small and public methods. I see an advantage in\n&gt; the possibility to inject every aspect of a class (manually or e.g.\n&gt; via spring) and the code can benefit from a better readability through\n&gt; a chain of self-explanatory method calls.\n&gt; But in some cases I want to hide implementation details from the user.\n\nI know two basic ways to hide implementation details: private methods\nand interfaces. I prefer interfaces, since I use them to reach highly\nmodular designs anyhow.\n\n&gt; Taking my Importer/Exporter example a second time, it is more a cron\n&gt; script than an application: Doing a defined job in a robust and\n&gt; understandable manner but neither designed as a basis for wide\n&gt; enhancements nor for ultimate flexibility.\n\nIn this case, modularity makes it easier to isolate failures and\nprevent defects. I find that convincing enough, even if I don&#39;t need\nthe additional ease-of-maintenance benefits modularity gives me.\n\nIt looks like you&#39;re thinking a lot about this. Whatever you decide to\ndo, thinking carefully about it is probably a great start.\n-- \nJ. B. (Joe) Rainsberger :: http://www.jbrains.ca\nYour guide to software craftsmanship\nJUnit Recipes: Practical Methods for Programmer Testing\n2005 Gordon Pask Award for contribution Agile Software Practice\n\n", 
    "profile": "nails762", 
    "topicId": 20700, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 282027414, 
    "prevInTime": 20710, 
    "contentTrasformed": false, 
    "postDate": "1216947623", 
    "canDelete": false, 
    "nextInTopic": 20716, 
    "prevInTopic": 20705, 
    "headers": {
        "inReplyToHeader": "PGc2Mm5lYis1NWl0QGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PGNlMTk5ZDA4MDcyNDE4MDBvNjYzNzc4YTRyNzkwYzM1MjNlYjAwYjY4Y0BtYWlsLmdtYWlsLmNvbT4=", 
        "referencesHeader": "PGc2Mm5lYis1NWl0QGVHcm91cHMuY29tPg=="
    }
}