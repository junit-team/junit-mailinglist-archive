{
    "topicId": 5102, 
    "postDate": "1023287696", 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "from": "&quot;Alexander Zynevich&quot; &lt;java@...&gt;", 
    "canDelete": false, 
    "replyTo": "LIST", 
    "senderId": "hTnaGiZ3C-PJxCRgVsSvuh_dJoUZKssyiMKCoZ0wiV8UR_uttV-1CVIJZEscEa9sVVi-sVtmEluBo7RJmUjuzDKG5HxBYPaYyA", 
    "nextInTime": 5107, 
    "userId": 106886324, 
    "prevInTime": 5105, 
    "prevInTopic": 5102, 
    "headers": {
        "messageIdInHeader": "PDAwYjIwMWMyMGM5ZSQyZmQzMDVjMCRkYWJlYThjMEB6eW5ldmljaD4=", 
        "referencesHeader": "PDFBQTY5NzFGOTZGQURCNEE5NkNGNzNFNDcyOUIwNUYxNTVFNUJEQFVTRVZTMDEyLmxlaW50ZXJuYWwuY29tPiA8MjAwMjA2MDQxMDQ5NTEuTTI0ODMxQGRpYXNwYXJzb2Z0d2FyZS5jb20+IDwzQ0ZDRjBDMi4yMDMwMjA3QGNsYXJrd2FyZS5jb20+IDwyMDAyMDYwNDEyNDUzNy5NNTkyMDdAZGlhc3BhcnNvZnR3YXJlLmNvbT4gPDNDRkUxNDgzLjcwOTAyQGNsYXJrd2FyZS5jb20+"
    }, 
    "authorName": "Alexander Zynevich", 
    "numMessagesInTopic": 9, 
    "msgSnippet": "Sirs, I am sorry in advance that I may repeat something/somebody... I think this is important point and it is also possible to be added to FAQ: many", 
    "contentTrasformed": false, 
    "msgId": 5106, 
    "nextInTopic": 5110, 
    "systemMessage": false, 
    "rawEmail": "Return-Path: &lt;java@...&gt;\r\nX-Sender: java@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (EGP: mail-8_0_3_2); 5 Jun 2002 14:40:27 -0000\r\nReceived: (qmail 62913 invoked from network); 5 Jun 2002 14:40:27 -0000\r\nReceived: from unknown (66.218.66.218)\n  by m15.grp.scd.yahoo.com with QMQP; 5 Jun 2002 14:40:27 -0000\r\nReceived: from unknown (HELO tut.by) (217.106.234.113)\n  by mta3.grp.scd.yahoo.com with SMTP; 5 Jun 2002 14:40:25 -0000\r\nReceived: from [195.212.157.59] (account java HELO zynevich)\n  by tut.by (CommuniGate Pro SMTP 3.5.6)\n  with ESMTP id 535848 for junit@yahoogroups.com; Wed, 05 Jun 2002 17:40:19 +0300\r\nMessage-ID: &lt;00b201c20c9e$2fd305c0$dabea8c0@zynevich&gt;\r\nTo: &lt;junit@yahoogroups.com&gt;\r\nReferences: &lt;1AA6971F96FADB4A96CF73E4729B05F155E5BD@...&gt; &lt;20020604104951.M24831@...&gt; &lt;3CFCF0C2.2030207@...&gt; &lt;20020604124537.M59207@...&gt; &lt;3CFE1483.70902@...&gt;\r\nSubject: Re: [junit] Re: Testing accessors...\r\nDate: Wed, 5 Jun 2002 17:34:56 +0300\r\nMIME-Version: 1.0\r\nContent-Type: text/plain;\n\tcharset=&quot;iso-8859-1&quot;\r\nContent-Transfer-Encoding: 7bit\r\nX-Priority: 3\r\nX-MSMail-Priority: Normal\r\nX-Mailer: Microsoft Outlook Express 6.00.2600.0000\r\nX-MimeOLE: Produced By Microsoft MimeOLE V6.00.2600.0000\r\nFrom: &quot;Alexander Zynevich&quot; &lt;java@...&gt;\r\nX-Yahoo-Group-Post: member; u=106886324\r\n\r\nSirs,\nI am sorry in advance that I may repeat something/somebody...\n\nI think this is important point and it is also possible to be added to FAQ:\n\nmany programmers writes setters in following style (let&#39;s call it IBM-style)\n\nvoid setValue(ValueType newValue)\n{\n  value=newValue;\n}\n\nwhile others preffer to do it in Sun-style:\n\nvoid setValue(ValueType value)\n{\n  this.value=value;\n}\n\nnow just imagine that while edditing your code you just pressed &quot;del&quot; key in\n&quot;void setValue(ValueType value)&quot; or made other typing mistake and got &quot;void\nsetValue(ValueType vale)&quot;\nin this case code will compile BUT &quot;this.value=value;&quot; will be equivalent to\n&quot;this.value=this.value;&quot;\nsome times such errors are very hard to find it out... If you have special\ntest case for set/get you will find problem within seconds if not you will\nfind problem only because other tests are failed...\n\nSorry, for beating the air...\n\nAlexander\n\n----- Original Message -----\nFrom: &quot;Mike Clark&quot; &lt;mike@...&gt;\nTo: &lt;junit@yahoogroups.com&gt;\nSent: Wednesday, June 05, 2002 4:39 PM\nSubject: [junit] Re: Testing accessors...\n\n\n&gt; I&#39;ve added J.B.&#39;s response below to the FAQ under the question &quot;Under\n&gt; what conditions should I not test get() and set() methods?&quot;.\n&gt;\n&gt; I also added an alternative view that goes something like this:\n&gt;\n&gt; ----\n&gt;\n&gt; Under what conditions should I test get() and set() methods?\n&gt;\n&gt; In general, unit tests are meant to alleviate fear that something might\n&gt; break. If a get() or set() method could reasonably break, or has in fact\n&gt; contributed to a defect, then by all means write a test for them. Be\n&gt; practical and remember to maximize your testing investment.\n&gt;\n&gt; Refer also to &quot;How simple is &#39;too simple to break&#39;?\n&gt;\n&gt; ----\n&gt;\n&gt; If there are viewpoints not represented in these entries, please feel\n&gt; free to contribute.  Perhaps we can defer all related questions to the\n&gt; FAQ in the near future.\n&gt;\n&gt; Mike\n&gt;\n&gt;\n&gt; J. B. Rainsberger wrote:\n&gt;\n&gt; &gt;\n&gt; &gt;Most of the time, get/set methods just can&#39;t break, and if they can&#39;t\nbreak,\n&gt; &gt;then why test them? While it is usually better to test more, there is a\n&gt; &gt;definite curve of diminishing returns on test effort versus &quot;code\ncoverage&quot;.\n&gt; &gt;Remember the maxim: &quot;Test until fear turns to boredom.&quot;\n&gt; &gt;\n&gt; &gt;Assume that the getX() method only does &quot;return x;&quot; and that the setX()\n&gt; &gt;method only does &quot;this.x = x;&quot;. If you write this test\n&gt; &gt;\n&gt; &gt;    testGetSetX() {\n&gt; &gt;        setX(23);\n&gt; &gt;        assertEquals(23, getX());\n&gt; &gt;    }\n&gt; &gt;\n&gt; &gt;then you are testing the equivalent of the following:\n&gt; &gt;\n&gt; &gt;    testGetSetX() {\n&gt; &gt;        x = 23;\n&gt; &gt;        assertEquals(23, x);\n&gt; &gt;    }\n&gt; &gt;\n&gt; &gt;or, if you prefer,\n&gt; &gt;\n&gt; &gt;    testGetSetX() {\n&gt; &gt;        assertEquals(23, 23);\n&gt; &gt;    }\n&gt; &gt;\n&gt; &gt;At this point, you are testing the Java compiler, or possibly the\n&gt; &gt;interpreter, and not your component or application. There is generally no\n&gt; &gt;need for you to do Java&#39;s testing for them.\n&gt; &gt;\n&gt; &gt;If you are concerned about whether a property has already been set at the\n&gt; &gt;point you wish to call getX(), then you want to test the constructor, and\nnot\n&gt; &gt;the getX() method. This kind of test is especially useful if you have\n&gt; &gt;multiple constructors.\n&gt; &gt;\n&gt; &gt;    testCreate() {\n&gt; &gt;        assertEquals(23, new MyClass(23).getX());\n&gt; &gt;    }\n&gt; &gt;\n&gt; &gt;&gt;    Under what conditions should I test get() and set() methods?\n&gt; &gt;&gt;\n&gt; &gt;\n&gt; &gt;See &quot;How simple is &#39;too simple to break?&#39;&quot;\n&gt; &gt;\n&gt; &gt;[Later on...]\n&gt; &gt;\n&gt; &gt;Q. How simple is &#39;too simple to break?&#39;\n&gt; &gt;\n&gt; &gt;The general philosophy is this: if it can&#39;t break *on its own*, it&#39;s too\n&gt; &gt;simple to break.\n&gt; &gt;\n&gt; &gt;First example is the getX() method. Suppose the getX() method only\nanswers\n&gt; &gt;the value of an instance variable. In that case, getX() cannot break\nunless\n&gt; &gt;either the compiler or the interpreter is also broken. For that reason,\ndon&#39;t\n&gt; &gt;test getX(); there is no benefit. The same is true of the setX() method,\n&gt; &gt;although if your setX() method does any parameter validation or has any\nside\n&gt; &gt;effects, you likely need to test it.\n&gt; &gt;\n&gt; &gt;Next example: suppose you have written a method that does nothing but\nforward\n&gt; &gt;parameters into a method called on another object. That method is too\nsimple\n&gt; &gt;to break.\n&gt; &gt;\n&gt; &gt;    public void myMethod(final int a, final String b) {\n&gt; &gt;        myCollaborator.anotherMethod(a, b);\n&gt; &gt;    }\n&gt; &gt;\n&gt; &gt;myMethod cannot possibly break, because it does nothing: it forwards its\n&gt; &gt;input to another object and that&#39;s all.\n&gt; &gt;\n&gt; &gt;The only precondition for this method is &quot;myCollaborator != null&quot;, but\nthat\n&gt; &gt;is generally the responsibility of the constructor, and not of myMethod.\nIf\n&gt; &gt;you are concerned, add a test to verify that myCollaborator is always set\nto\n&gt; &gt;something non-null by every constructor.\n&gt; &gt;\n&gt; &gt;The only way myMethod could break would be if\nmyCollaborator#anotherMethod\n&gt; &gt;were broken. In that case, test myCollaborator, and not the current\nclass.\n&gt; &gt;\n&gt; &gt;It is true that adding tests for even these simple methods guards against\nthe\n&gt; &gt;possibility that someone refactors and makes the methods &quot;not-so-simple&quot;\n&gt; &gt;anymore. In that case, though, the refactorer needs to be aware that the\n&gt; &gt;method is now complex enough to break, and should write tests for it --\nand\n&gt; &gt;preferably before the refactoring.\n&gt; &gt;\n&gt; &gt;Another example: suppose you have a JSP and, like a good programmer, you\nhave\n&gt; &gt;removed all business logic from it. All it does is provide a layout for a\n&gt; &gt;number of JavaBeans and never does anything that could change the value\nof\n&gt; &gt;any object. That JSP is too simple to break, and since JSPs are\nnotoriously\n&gt; &gt;annoying to test, you should strive to make all your JSPs too simple to\nbreak.\n&gt; &gt;\n&gt; &gt;--\n&gt; &gt;J. B. Rainsberger,\n&gt; &gt;President, Diaspar Software Services\n&gt; &gt;Let&#39;s write software that people understand.\n&gt; &gt;http://www.diasparsoftware.com/\n&gt; &gt;telephone: +1 416 791-8603\n&gt; &gt;\n&gt;\n&gt;\n&gt;\n&gt; [Non-text portions of this message have been removed]\n&gt;\n&gt;\n&gt;\n&gt; To unsubscribe from this group, send an email to:\n&gt; junit-unsubscribe@yahoogroups.com\n&gt;\n&gt;\n&gt; Your use of Yahoo! Groups is subject to http://docs.yahoo.com/info/terms/\n&gt;\n&gt;\n\n\n", 
    "subject": "Re: [junit] Re: Testing accessors..."
}