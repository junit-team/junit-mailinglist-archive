{
    "numMessagesInTopic": 67, 
    "nextInTime": 5257, 
    "senderId": "qIhrTY3Ni6C3jSiXC7Y1DS2gS3eeF7mCHxBxF6TCaxQaQ4XDFBJOtsB1wjkWKip2rRbulpJmR7SPjSPk-5zD-VkZWUHxE7DoVNhY0uYni6d8EOi1", 
    "systemMessage": false, 
    "subject": "RE: [junit] Re: distinguishing between failures and errors", 
    "from": "&quot;J. B. Rainsberger&quot; &lt;jbr@...&gt;", 
    "authorName": "J. B. Rainsberger", 
    "msgSnippet": "... I do this by *not* testing that I can handle the null pointer. The absence of a test indicates undefined behavior and you shouldn t rely on undefined ", 
    "msgId": 5256, 
    "profile": "nails762", 
    "topicId": 5186, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 89240252, 
    "messageBody": "<div id=\"ygrps-yiv-325315939\"><blockquote><span title=\"ireply\">&gt; &gt; From: J. B. Rainsberger [mailto:<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:jbr@...\">jbr@...</a>]<br/>\n&gt; &gt;...<br/>\n&gt; &gt; &gt; Isn&#39;t documentation the thing that should be used to tell the<br/>\n&gt; &gt; &gt; writer of code that calls yours what your code is supposed to<br/>\n&gt; &gt; &gt; do, or what the caller is supposed to do (or not do)?  (At<br/>\n&gt; &gt; &gt; least for code meant to be re-used, such as that implementing<br/>\n&gt; &gt; &gt; an API?)<br/>\n&gt; &gt; <br/>\n&gt; &gt; Yes, it is. Please explain to me why unit tests are not <br/>\n&gt; &gt; documentation. :)<br/>\n&gt; <br/>\n&gt; Because tests aren&#39;t specifications. <br/>\n&gt; <br/>\n&gt; (How can a test show that the caller is responsible for not <br/>\n&gt; passing in a null pointer?<br/>\n<br/>\n </span></blockquote>I do this by *not* testing that I can handle the null pointer. The absence of <br/>\na test indicates &quot;undefined behavior&quot; and you shouldn&#39;t rely on undefined <br/>\nbehavior. If the tests don&#39;t define behavior well enough to make the code <br/>\nusable, then likely important tests are missing.<br/>\n<br/>\n&lt;snip /&gt;<br/>\n<blockquote><span title=\"ireply\"> &gt; (How can a test show that a caller is responsible for not<br/>\n&gt; depending on certain current behavior of an implementation<br/>\n&gt; that is not part of the interface contract?)<br/>\n<br/>\n </span></blockquote>Same answer. If you want to rely on my implementation details, you take a <br/>\nrisk. By not providing a test on that behavior, I implicitly state that that <br/>\nbehavior may change at any time.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Because tests are code.  <br/>\n&gt; <br/>\n&gt; (They have syntactic clutter that is necessary for use as tests <br/>\n&gt; but which is just clutter relative to the information useful to a <br/>\n&gt; client programmer.)<br/>\n<br/>\n </span></blockquote>I&#39;m not sure I agree with this. If tests are my primary source of information <br/>\non a class&#39; behavior, then any syntactic clutter is either<br/>\n<br/>\n    * part of the language, or<br/>\n    * a sign of a poor test<br/>\n<br/>\nIn the first case, I&#39;m probably used to the syntactic clutter and can read it <br/>\nas easily as I read English or French. In the second case, the test needs <br/>\nimprovement, which will benefit everyone all round. That&#39;s why it&#39;s good to <br/>\nread your own tests from time to time.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Because tests, being code, can&#39;t relate code to external concepts.  <br/>\n&gt; <br/>\n&gt; (A specification can say that a function f returns the mathematical<br/>\n&gt; sum of two given integers subject to the limitations of 32-bit<br/>\n&gt; signed binary arithmetic.  How can a test say something like that?)<br/>\n<br/>\n </span></blockquote>I would think that the name of the method says it, so the test doesn&#39;t need <br/>\nto. The test *can* say it, of course. If neither does, then there&#39;s trouble.<br/>\n<br/>\nTell me why three tests adding two signed integers together, at least one <br/>\nshowing overflow, wouldn&#39;t communicate the intent &#39;add&#39;? What if the tests <br/>\nwere named testAdd_WithZero, testAdd and testAdd_Overflow?<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Tests are great, but don&#39;t forget the documentation.<br/>\n&gt; <br/>\n&gt; It seems that some people who write tests waste one advantage of it:  <br/>\n&gt; <br/>\n&gt; I agree that testing, especially writing tests even before you <br/>\n&gt; implement, is good because it forces you to think about what your <br/>\n&gt; code is supposed to do and how it&#39;s supposed to be used.  <br/>\n&gt; <br/>\n&gt; Well, if you&#39;re already thinking about the contract, then that&#39;s a<br/>\n&gt; good time to document the contract.<br/>\n<br/>\n </span></blockquote>Please explain why a list of well-named tests with clear implementations <br/>\ndoesn&#39;t provide ample description of the contract. Assume that the person <br/>\nwriting the tests is thorough and only leaves out tests when he decides that <br/>\nsomething is *not* part of the contract.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Yes, I know this has to be modulated by what kind of code we&#39;re<br/>\n&gt; talking about (e.g., intra-program calls versus trans-API calls) <br/>\n&gt; and by how stable the interface contract is.  I just wouldn&#39;t<br/>\n&gt; want to have to read test cases instead of Javadoc to figure <br/>\n&gt; out how, say, Sun&#39;s Servlet API worked and was supposed to be <br/>\n&gt; used. <br/>\n<br/>\n </span></blockquote>OK, so now we see the point: you&#39;d rather read Javadoc than test cases to <br/>\nunderstand enough about something to be able to use it. I understand that <br/>\nwell-written, complete and thorough Javadoc is very useful and even better <br/>\nthan test cases written in code; however:<br/>\n<br/>\n    Most Javadoc is crap<br/>\n<br/>\nbecause:<br/>\n<br/>\n    I can deliver a working system without Javadoc;<br/>\n<br/>\nhowever:<br/>\n<br/>\n    My tests must run all the time, so my tests must be up to date.<br/>\n<br/>\nCode or comments -- which do you trust more, in general? I trust code, since <br/>\nworking code can&#39;t lie.<br/>\n<br/>\nI, for one, would be very interested to see Sun&#39;s servlet API described in a <br/>\ntest suite.<br/>\n<br/>\n--<br/>\nJ. B. Rainsberger,<br/>\nPresident, Diaspar Software Services<br/>\nLet&#39;s write software that people understand.<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.diasparsoftware.com/\">http://www.diasparsoftware.com/</a><br/>\ntelephone: +1 416 791-8603</div>", 
    "prevInTime": 5255, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1025027181", 
    "canDelete": false, 
    "nextInTopic": 5257, 
    "prevInTopic": 5255, 
    "headers": {
        "inReplyToHeader": "PEQ1Nzc2RDA5RDA4NEE3NDBCNUQ3RjI5MjY2ODBGQ0YzMDExRkUyMjhAbXVzMDAxbXVsbGV0Lm1lcmNhdG9yLmNvbT4=", 
        "messageIdInHeader": "PDIwMDIwNjI1MTE0NjIxLk02MTcxNkBkaWFzcGFyc29mdHdhcmUuY29tPg==", 
        "referencesHeader": "PEQ1Nzc2RDA5RDA4NEE3NDBCNUQ3RjI5MjY2ODBGQ0YzMDExRkUyMjhAbXVzMDAxbXVsbGV0Lm1lcmNhdG9yLmNvbT4="
    }
}