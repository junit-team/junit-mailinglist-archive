{
    "numMessagesInTopic": 55, 
    "nextInTime": 13534, 
    "senderId": "cdljPiW1jekbo4HAAKta1qTlXpww6W39WDjXeq47U0eVdhjA7rJFZ7sO1Q8U-ZIdXxEh805Pop0WHLmCnMAgaSlkGWX-GP6EWg", 
    "systemMessage": false, 
    "subject": "RE: [junit] Re: DbUnit & ORM", 
    "from": "John Smith &lt;haefeleuser@...&gt;", 
    "authorName": "John Smith", 
    "msgSnippet": "... I meant something else. Its in J.B. Rainsberger s book on page 185: Ignore a test. Or on this page: http://www.artima.com/weblogs/viewpost.jsp?thread=4603 ", 
    "msgId": 13533, 
    "profile": "haefeleuser", 
    "topicId": 13451, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 174752849, 
    "messageBody": "<div id=\"ygrps-yiv-1615840051\">--- Cedric Beust &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:cbeust@...\">cbeust@...</a>&gt; wrote:<br/>\n<blockquote><span title=\"ireply\"> &gt; Funny you should say that, because that&#39;s exactly<br/>\n&gt; how TestNG supports<br/>\n&gt; dependent tests.<br/>\n&gt; <br/>\n&gt; You can specify that a group B of test methods<br/>\n&gt; &quot;depends on&quot; a group A of<br/>\n&gt; test methods.  In this case, TestNG guarantees that<br/>\n&gt; <br/>\n&gt; - All methods in group A will be run before any<br/>\n&gt; method in group B is<br/>\n&gt; invoked.<br/>\n&gt; - All methods in group A will have succeeded.  If at<br/>\n&gt; least one of them<br/>\n&gt; failed, then all test methods in group B will be<br/>\n&gt; marked as &quot;SKIPPED&quot; (not<br/>\n&gt; run), which makes it much easier for you to figure<br/>\n&gt; out which test exactly<br/>\n&gt; broke the chain (&quot;cascade effect&quot;).<br/>\n<br/>\n </span></blockquote>I meant something else. Its in J.B. Rainsberger&#39;s book<br/>\non page 185: Ignore a test.<br/>\n<br/>\nOr on this page:<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.artima.com/weblogs/viewpost.jsp?thread=4603\">http://www.artima.com/weblogs/viewpost.jsp?thread=4603</a><br/>\n<br/>\nIgnored tests are always skipped, but not because<br/>\nanother test failed but because the programmer set the<br/>\ntest to be ignored, which is a kind of &quot;sleep&quot; mode.<br/>\n<br/>\nNow to your test dependancies. I&#39;ll tell you how our<br/>\ntests are grouped in the suites.<br/>\n<br/>\nThere is a JUnit test suite for every Eclipse project.<br/>\nThen we have a suite for each component in the<br/>\nprojects. The components can have these groups of<br/>\ntests: persistance tests (whether entites are<br/>\npersisted and retrieved correctly according to meta<br/>\ndata, including validation rule testing for these<br/>\nentities and entity factories), batch program tests<br/>\n(which either can be legacy data migration batch tests<br/>\nor fast lane reader batch tests), business logic tests<br/>\n(like ABC analysis, sales forecast, purchase proposals<br/>\nand so on), tests for utility classes and some other<br/>\ngroups of tests (but we have no automated GUI tests).<br/>\n<br/>\nIf persistance tests fail, then it would be no use to<br/>\nrun all other tests. If tests for utility classes<br/>\nfail, then in many cases it is no use to run all other<br/>\ntests. If batch tests fail, it doesn&#39;t mean that<br/>\nbusiness logic tests will fail and vice versa. This is<br/>\na corse grained dependency of our tests. The fine<br/>\ngrained test dependencies are much more of course.<br/>\n<br/>\nIn our team we all know that if persistance tests<br/>\nfail, we don&#39;t have to care about the business logic<br/>\ntest results.<br/>\n<br/>\nWe really have a large project. If the tests reflect<br/>\nthe code structure too close, then refactoring becomes<br/>\nvery time consuming because it affects tests very<br/>\nmuch. Thats for example why it is recommended to only<br/>\ntest public methods. My theoretical objection to<br/>\nmaintain dependency information in the tests is that<br/>\nit is additional work to do and to maintain. If the<br/>\ndependency changes for the worse, the test dependency<br/>\ninformation (annotation) need to be changed. Besides<br/>\nthis, if test group B is no longer dependent of test<br/>\ngroup A, then the tests pass although there is no<br/>\ndependency anymore. It is pure luck for a programmer<br/>\nto detect that test B is no longer dependent of test<br/>\nA. Only if a new dependency is created, the tests will<br/>\nfail. But if a dependency vanishes, the tests will not<br/>\nfail and will contain misleading dependency<br/>\nannotations. Isolated tests are more stable to change<br/>\nthan dependent tests I think.<br/>\n<br/>\nDon&#39;t get me wrong. I argued here against JUnit in<br/>\nfavor of Design by Contract a few years ago. Now I<br/>\nlike JUnit, which can apply to TestNG too, or not, who knows.<br/>\n<br/>\n<br/>\n\t\t<br/>\n__________________________________ <br/>\nYahoo! Mail Mobile <br/>\nTake Yahoo! Mail with you! Check email on your mobile phone. <br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://mobile.yahoo.com/learn/mail\">http://mobile.yahoo.com/learn/mail</a></div>", 
    "prevInTime": 13532, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1116254774", 
    "canDelete": false, 
    "nextInTopic": 13537, 
    "prevInTopic": 13532, 
    "headers": {
        "inReplyToHeader": "NjY2Nw==", 
        "messageIdInHeader": "PDIwMDUwNTE2MTQ0NjE0LjY2MjU1LnFtYWlsQHdlYjYwMDI1Lm1haWwueWFob28uY29tPg=="
    }
}