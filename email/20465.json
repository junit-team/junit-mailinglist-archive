{
    "numMessagesInTopic": 6, 
    "nextInTime": 20466, 
    "senderId": "ikC1mtVP9tZYfmSkxhnP77F2J-Su6fE9C-qhDQHIwO7eg7ud0-DwlisZO8zu2Skg_ePgmzEhRdDQkEmyOx3YMP4FGMC7cDSY9i6ugg", 
    "systemMessage": true, 
    "subject": "Re: TextListener improvement", 
    "from": "&quot;toalexsmail&quot; &lt;toalexsmail@...&gt;", 
    "authorName": "toalexsmail", 
    "msgSnippet": "... See also https://sourceforge.net/tracker/?func=detail&atid=365278&aid=1913115&group_id=15278 (there is a path described below their) Here is my solution: ", 
    "msgId": 20465, 
    "profile": "toalexsmail", 
    "topicId": 20361, 
    "spamInfo": {
        "reason": "6", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 340165037, 
    "messageBody": "<div id=\"ygrps-yiv-1936159905\">--- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>, &quot;toalexsmail&quot; &lt;toalexsmail@...&gt; wrote:<br/>\n<blockquote><span title=\"ireply\"> &gt;<br/>\n&gt; Currently TextListener on every event simply writes to standard output<br/>\n&gt; (or to PrintWriter). If junits or application aslo writes its logs to<br/>\n&gt; standard output then this output is mixed. For example, failures will<br/>\n&gt; be written inside the logs of the application and not in the end.<br/>\n&gt; Moreover, if there is some activity in @AfterClass that also prints to<br/>\n&gt; the standard output than this will be written down AFTER summary of<br/>\n&gt; the Junit.<br/>\n&gt; <br/>\n&gt; I have partial solution to this situation. TextListener (or a new<br/>\n&gt; class, say ConsoleListener) should create new PrintWriter(new<br/>\n&gt; StringWriter()) and collect the result their.  On testRunFinished() it<br/>\n&gt; should flush the information from StringWriter to the PrintStream that<br/>\n&gt; received in the constructor (String.out for example).<br/>\n&gt; This solution doesn&#39;t solve situation when there is some writing to<br/>\n&gt; the standard output in @AfterClass.<br/>\n&gt;<br/>\n<br/>\n </span></blockquote>See also<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"https://sourceforge.net/tracker/?func=detail&atid=365278&aid=1913115&group_id=15278\">https://sourceforge.net/tracker/?func=detail&atid=365278&aid=1913115&group_id=15278</a><br/>\n(there is a path described below their)<br/>\n<br/>\nHere is my solution:<br/>\n<br/>\npublic class JUnitTest{<br/>\n \t<br/>\n\tpublic static void main(String[] args){<br/>\n\t\tRequest r = Request.aClass(JUnitTest.class);<br/>\n\t\tJUnitCore runner = new JUnitCore();<br/>\n\t\tPrintStream out = System.out;<br/>\n\t\tRunListener runListener = new FlushedPrintStreamListener(out);<br/>\n\t\trunner.addListener(runListener);<br/>\n\t\tResult result = runner.run(r);<br/>\n\t\tint code = -1;<br/>\n\t\tint failures = result.getFailureCount();<br/>\n\t\tif(failures&gt;0){<br/>\n\t\t\tcode = -failures;<br/>\n\t\t} else {<br/>\n\t\t\tcode = result.getIgnoreCount();<br/>\n\t\t}<br/>\n\t\tSystem.exit(code); <br/>\n          }<br/>\n<br/>\n}<br/>\n<br/>\npublic class PrintStreamListener extends RunListener{<br/>\n\t//Definition of delimiters is in Description<br/>\n\tprivate static final Pattern DISPAY_NAME_PATTERN =<br/>\nPattern.compile(&quot;()&quot;); <br/>\n\tprivate TextListener textListener;<br/>\n\tprivate PrintStream writer;<br/>\n\t<br/>\n\tpublic PrintStreamListener() {<br/>\n\t\tthis(System.out);<br/>\n\t}<br/>\n<br/>\n\tpublic PrintStreamListener(PrintStream writer) {<br/>\n\t\tsuper();<br/>\n\t\tthis.textListener = new TextListener(writer);<br/>\n\t\tthis.writer = writer;<br/>\n\t}<br/>\n\t<br/>\n\t/**<br/>\n\t * For sub-classes use.<br/>\n\t * <br/>\n\t * @return<br/>\n\t */<br/>\n\tprotected PrintStream getWriter(){<br/>\n\t\treturn writer;<br/>\n\t}<br/>\n\t<br/>\n\tprivate PrintStream getNotNullWriter(){<br/>\n\t\tPrintStream writer = getWriter();<br/>\n\t\tif(writer==null){<br/>\n\t\t\tthrow new IllegalStateException(&quot;writer should be not null&quot;);<br/>\n\t\t}<br/>\n\t\treturn writer;<br/>\n\t}<br/>\n\t<br/>\n\t<br/>\n\t/**<br/>\n\t * This method can be overriden in sub-classes.<br/>\n\t * <br/>\n\t * @param description<br/>\n\t * @throws IllegalArgumentException if description is null.<br/>\n\t */<br/>\n\tprotected void writeMethodName(Description description){<br/>\n\t\tif(description==null){<br/>\n\t\t\tthrow new IllegalArgumentException(&quot;description should be not null&quot;);<br/>\n\t\t}<br/>\n\t\tString displayName = description.getDisplayName();<br/>\n\t\tString[] complexNames = DISPAY_NAME_PATTERN.split(displayName, 3);<br/>\n\t\tString methodName = (complexNames==null ||<br/>\ncomplexNames.length!=2)?displayName:complexNames[1];<br/>\n\t\tPrintStream writer = getNotNullWriter();<br/>\n\t\t<br/>\n\t\twriter.print(methodName);<br/>\n\t\twriter.print(&#39; &#39;);<br/>\n\t}<br/>\n\t<br/>\n\t<br/>\n\t/**<br/>\n\t * Called when an atomic test is about to be started.<br/>\n\t * @param description the description of the test that is about to be<br/>\nrun <br/>\n\t * (generally a class and method name)<br/>\n\t */<br/>\n\t@Override<br/>\n\tpublic void testStarted(Description description)  {<br/>\n\t\ttextListener.testStarted(description);<br/>\n\t}<br/>\n<br/>\n<br/>\n\t/** <br/>\n\t * Called when an atomic test fails.<br/>\n\t * @param failure describes the test that failed and the exception<br/>\nthat was thrown<br/>\n\t */<br/>\n\t@Override<br/>\n\tpublic void testFailure(Failure failure)  {<br/>\n\t\tDescription description = failure.getDescription();<br/>\n\t\tPrintStream writer = getNotNullWriter();<br/>\n<br/>\n\t\twriteMethodName(description);<br/>\n\t\ttextListener.testFailure(failure);<br/>\n\t\twriter.println();<br/>\n\t}<br/>\n<br/>\n\t/**<br/>\n\t * Called when a test will not be run, generally because a test<br/>\nmethod is annotated <br/>\n\t * with {@link org.junit.Ignore}.<br/>\n\t * @param description describes the test that will not be run<br/>\n\t */<br/>\n\t@Override<br/>\n\tpublic void testIgnored(Description description)  {<br/>\n\t\twriteMethodName(description);<br/>\n\t\tPrintStream writer = getNotNullWriter();<br/>\n\t\ttextListener.testIgnored(description);<br/>\n\t\twriter.println();<br/>\n\t}<br/>\n\t<br/>\n\t<br/>\n\t@Override<br/>\n\tpublic void testRunFinished(Result result) {<br/>\n\t\ttextListener.testRunFinished(result);<br/>\n\t}<br/>\n\t<br/>\n\t/**<br/>\n\t * Called before any tests have been run.<br/>\n\t * @param description describes the tests to be run<br/>\n\t */<br/>\n\t@Override<br/>\n\tpublic void testRunStarted(Description description) throws Exception {<br/>\n\t\tPrintStream writer = getNotNullWriter();<br/>\n\t\tString displayName = description.getDisplayName();<br/>\n\t\tString[] complexNames = DISPAY_NAME_PATTERN.split(displayName, 3);<br/>\n\t\tString className = (complexNames==null ||<br/>\ncomplexNames.length!=2)?displayName:complexNames[0];<br/>\n\t\twriter.print(&quot;started to test &quot;+className);<br/>\n\t\twriter.println();\t\t<br/>\n\t}<br/>\n}<br/>\n<br/>\npublic class FlushedPrintStreamListener extends PrintStreamListener{<br/>\n<br/>\n\tpublic FlushedPrintStreamListener() {<br/>\n\t\tsuper();<br/>\n\t}<br/>\n<br/>\n\tpublic FlushedPrintStreamListener(PrintStream writer) {<br/>\n\t\tsuper(writer);<br/>\n\t}<br/>\n\t<br/>\n\t/**<br/>\n\t * Called when an atomic test is about to be started.<br/>\n\t * @param description the description of the test that is about to be<br/>\nrun <br/>\n\t * (generally a class and method name)<br/>\n\t */<br/>\n\t@Override<br/>\n\tpublic void testStarted(Description description)  {<br/>\n\t\tsuper.testStarted(description);<br/>\n\t\tflush();<br/>\n\t}<br/>\n<br/>\n<br/>\n\t/** <br/>\n\t * Called when an atomic test fails.<br/>\n\t * @param failure describes the test that failed and the exception<br/>\nthat was thrown<br/>\n\t */<br/>\n\t@Override<br/>\n\tpublic void testFailure(Failure failure)  {<br/>\n\t\tsuper.testFailure(failure);<br/>\n\t\tflush();<br/>\n\t}<br/>\n<br/>\n\t/**<br/>\n\t * Called when a test will not be run, generally because a test<br/>\nmethod is annotated <br/>\n\t * with {@link org.junit.Ignore}.<br/>\n\t * @param description describes the test that will not be run<br/>\n\t */<br/>\n\t@Override<br/>\n\tpublic void testIgnored(Description description)  {<br/>\n\t\tsuper.testIgnored(description);<br/>\n\t\tflush();<br/>\n\t}<br/>\n\t<br/>\n\t<br/>\n\t<br/>\n<br/>\n\t@Override<br/>\n\tpublic void testRunFinished(Result result) {<br/>\n\t\tsuper.testRunFinished(result);<br/>\n\t\t//flush();<br/>\n\t}<br/>\n\t<br/>\n\t/**<br/>\n\t * Called before any tests have been run.<br/>\n\t * @param description describes the tests to be run<br/>\n\t */<br/>\n\t@Override<br/>\n\tpublic void testRunStarted(Description description) throws Exception {<br/>\n\t\tsuper.testRunStarted(description);<br/>\n\t\tflushRunStarted();<br/>\n\t}<br/>\n<br/>\n\t/**<br/>\n\t * Can be changed in sub-class.<br/>\n\t */<br/>\n\tprotected void flushRunStarted(){<br/>\n\t\t//don&#39; flush<br/>\n\t\t<br/>\n\t}<br/>\n\t<br/>\n\t/**<br/>\n\t * Can be changed in sub-class.<br/>\n\t * <br/>\n\t */<br/>\n\tprotected void flush(){<br/>\n\t\tPrintStream writer = getWriter();<br/>\n\t\tif(writer!=null){<br/>\n\t\t\twriter.flush();<br/>\n\t\t}<br/>\n\t}<br/>\n\t<br/>\n}<br/>\n<br/>\n/**<br/>\n * Redirect an output stream to a logger.<br/>\n * This class is useful to redirect standard output or <br/>\n * standard error to a Logger. An example use is<br/>\n *<br/>\n * &lt;pre&gt;<br/>\n * final LoggerOutputStream outputStream = <br/>\n *     new LoggerOutputStream( log );<br/>\n * final PrintStream output = new PrintStream( outputStream, true );<br/>\n *<br/>\n * System.setOut( output );<br/>\n * &lt;/pre&gt;<br/>\n *<br/>\n */<br/>\npublic class LoggerOutputStream<br/>\n    extends OutputStream<br/>\n{    <br/>\n    ///Logger that we log to<br/>\n    private final Log        m_logger;<br/>\n<br/>\n   <br/>\n    ///The buffered output so far<br/>\n    private final StringBuffer  m_output    = new StringBuffer(1024);<br/>\n<br/>\n    ///Flag set to true once stream closed<br/>\n    private boolean             m_closed;<br/>\n<br/>\n    /**<br/>\n     * Construct OutputStreamLogger to write to a particular logger at<br/>\na particular priority.<br/>\n     *<br/>\n     * @param logger the logger to write to<br/>\n     * @param priority the priority at which to log<br/>\n     */<br/>\n    public LoggerOutputStream( final Log logger)<br/>\n    {<br/>\n        m_logger = logger;<br/>\n    }<br/>\n<br/>\n    /**<br/>\n     * Shutdown stream.<br/>\n     *<br/>\n     */<br/>\n    public void close()<br/>\n        throws IOException<br/>\n    {<br/>\n        flush();<br/>\n        super.close();<br/>\n        m_closed = true;<br/>\n    }<br/>\n<br/>\n    /**<br/>\n     * Write a single byte of data to output stream.<br/>\n     *<br/>\n     * @param data the byte of data<br/>\n     * @exception IOException if an error occurs<br/>\n     */<br/>\n    public void write( final int data ) <br/>\n        throws IOException<br/>\n    {<br/>\n        checkValid();<br/>\n        <br/>\n         //Should we properly convert char using locales etc??<br/>\n        m_output.append( (char)data );<br/>\n<br/>\n     <br/>\n    }<br/>\n<br/>\n    /**<br/>\n     * Flush data to underlying logger.<br/>\n     *<br/>\n     * @exception IOException if an error occurs<br/>\n     */<br/>\n    public synchronized void flush()<br/>\n        throws IOException<br/>\n    {<br/>\n        checkValid();<br/>\n<br/>\n         m_logger.info(m_output.toString() );<br/>\n        m_output.setLength( 0 );<br/>\n        <br/>\n       <br/>\n    }<br/>\n<br/>\n    /**<br/>\n     * Make sure stream is valid.<br/>\n     *<br/>\n     * @exception IOException if an error occurs<br/>\n     */<br/>\n    private void checkValid()<br/>\n        throws IOException<br/>\n    {<br/>\n        if( true == m_closed ) <br/>\n        {<br/>\n            throw new EOFException( &quot;OutputStreamLogger closed&quot; );<br/>\n        }<br/>\n    }<br/>\n}</div>", 
    "prevInTime": 20464, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1209420538", 
    "canDelete": false, 
    "nextInTopic": 20466, 
    "prevInTopic": 20361, 
    "headers": {
        "inReplyToHeader": "PGZyOGV0cytkazJnQGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PGZ2NWh0cStqMm1tQGVHcm91cHMuY29tPg=="
    }
}