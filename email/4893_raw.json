{
    "numMessagesInTopic": 46, 
    "nextInTime": 4894, 
    "senderId": "o7RjdCPX6Q4khSk6qYa7V24WLGOiNz4N3gfSR7uyoScYoELT060y-YVzA08WE8otddFcp8EzVNm1iHUFwpQhmQzE_II7-ESYrc35fZ9l", 
    "systemMessage": false, 
    "subject": "RE: [junit] Re: black box or white box?", 
    "from": "&quot;Berin Loritsch&quot; &lt;bloritsch@...&gt;", 
    "authorName": "Berin Loritsch", 
    "msgSnippet": "... You test for the contracts. You instantiate (or have something else instantiate) the implementation of the Store.  The test works with the interface.  In", 
    "msgId": 4893, 
    "rawEmail": "Return-Path: &lt;bloritsch@...&gt;\r\nX-Sender: bloritsch@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (EGP: mail-8_0_3_2); 7 May 2002 13:04:26 -0000\r\nReceived: (qmail 99309 invoked from network); 7 May 2002 13:04:26 -0000\r\nReceived: from unknown (66.218.66.218)\n  by m15.grp.scd.yahoo.com with QMQP; 7 May 2002 13:04:26 -0000\r\nReceived: from unknown (HELO failover.kc.aoindustries.com) (209.15.201.72)\n  by mta3.grp.scd.yahoo.com with SMTP; 7 May 2002 13:04:25 -0000\r\nReceived: from Gabriel ([65.105.132.131])\n\tby failover.kc.aoindustries.com (8.11.6/8.11.0) with ESMTP id g47D4P623421\n\tfor &lt;junit@yahoogroups.com&gt;; Tue, 7 May 2002 08:04:25 -0500\r\nTo: &lt;junit@yahoogroups.com&gt;\r\nSubject: RE: [junit] Re: black box or white box?\r\nDate: Tue, 7 May 2002 09:04:24 -0400\r\nMessage-ID: &lt;002b01c1f5c7$b6671330$ac00a8c0@Gabriel&gt;\r\nMIME-Version: 1.0\r\nContent-Type: text/plain;\n\tcharset=&quot;us-ascii&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\nX-Priority: 3 (Normal)\r\nX-MSMail-Priority: Normal\r\nX-Mailer: Microsoft Outlook, Build 10.0.2627\r\nIn-Reply-To: &lt;ab6t7k+jii4@...&gt;\r\nImportance: Normal\r\nX-MimeOLE: Produced By Microsoft MimeOLE V6.00.2600.0000\r\nFrom: &quot;Berin Loritsch&quot; &lt;bloritsch@...&gt;\r\nReply-To: &lt;bloritsch@...&gt;\r\nX-Yahoo-Group-Post: member; u=64910131\r\nX-Yahoo-Profile: bloritsch\r\n\r\n&gt; From: ipreussde [mailto:ilja.preuss@...] \n&gt; \n&gt; --- In junit@y..., &quot;Ber=\r\nin Loritsch&quot; &lt;bloritsch@a...&gt; wrote:\n&gt; &gt; interface Store\n&gt; &gt; {\n&gt; &gt;     void=\r\n store(String key, Object val);\n&gt; &gt;     Object retrieve(String key);\n&gt; &gt;   =\r\n  void remove(String key);\n&gt; &gt; }\n&gt; &gt; \n&gt; &gt; That interface is enough to know =\r\nhow to use the object store.\n&gt; \n&gt; Yes. So please explain: What tests do you=\r\n need to sufficiently test \n&gt; every possible implementation of this interfa=\r\nce? How did you find \n&gt; them?\n&gt; \n\nYou test for the contracts.\n\nYou instanti=\r\nate (or have something else instantiate) the implementation\nof the Store.  =\r\nThe test works with the interface.  In fact, because this\nis so flexible, I=\r\n tend to write a test harness that I can use for\nseveral\nsituations like th=\r\nis.  The basic code iterates through the different\nStore objects and perfor=\r\nms the same tests on them.\n\nLooking through the interface, here is how it w=\r\nould go for one impl.\n\nSuppose we have a MemoryStore (stores the object to =\r\nmemory).  We create\nthe MemoryStore object (by factory method for tests) in=\r\n the Setup()\nmethod and store it in a class attribute.  The tests use the c=\r\nlass.\n\nSomething like this:\n\npublic class StoreTestCase extends TestCase\n{\n=\r\n    private Store m_store;\n\n    public StoreTestCase(String name)\n    {\n   =\r\n     super( name );\n    }\n\n    public void Setup()\n        throws Exception=\r\n\n    {\n        // I might have dynamic code to tell which class to use\n    =\r\n    // for demonstration I will hardcode it.\n        m_store =3D\nClass.forN=\r\name(&quot;org.dhaven.store.MemoryStore&quot;).newInstance();\n    }\n\n    public void t=\r\nestRetrieval()\n    {\n        Integer testInt =3D new Integer( 777 );\n      =\r\n  m_store.store(&quot;test&quot;, testInt);\n\n        assertEquals( testInt, m_store.r=\r\netrieve( &quot;test&quot; ) );\n\n        m_store.remove(&quot;test&quot;);\n        assertEquals(=\r\n null, m_store.retrieve( &quot;test&quot; ) );\n    }\n}\n\nThat excercises the interface=\r\n of the Store.  Now, lets assume the\nMemoryStore\nhas a limit of 10 characte=\r\nrs for the name because the implementors are\nmasochistic and stored the nam=\r\ne as an array of chars.  Someone passes in\na bug\nthat proves that there is =\r\nno difference between &quot;0123456789A&quot; and\n&quot;0123456789B&quot;.\nWe add a test case t=\r\no catch that, and the MemoryStore is not living up\nto its\ncontract.  The co=\r\nntract is any String, so the limitations of key values\nshould\nnot be any mo=\r\nre limited than what a String can do.\n\nThat way, all implementations are te=\r\nsted against that same violation.\n\nOne thing I might do at this point is ad=\r\nd a new method to the Store\ninterface\nto examine whether a value is already=\r\n stored.  This is because it would\nhelp\ntesting, and clarify the usage of t=\r\nhe interface.  Another thing I would\ndo\nis add an exception that needs to b=\r\ne caught if we try to store an object\novertop\nanother one.\n\nThe new interfa=\r\nce (after testing and useage proves we need these\nchanges) becomes:\n\npublic=\r\n interface Store\n{\n    void store(String key, Object value) throws StoreExc=\r\neption;\n    boolean hasKey(String key);\n    Object retrieve(String key);\n  =\r\n  void remove(String key);\n}\n\nThe new testcase would only add new methods t=\r\no test that hasKey()\nreturns true\nif a key is already used for a stored obj=\r\nect.  I would also add one that\ntests\nthe exception:\n\nvoid testNoDoubleStor=\r\ne\n{\n    Integer testInt1 =3D new Integer( 777 );\n    Integer testInt2 =3D n=\r\new Integer( 666 );\n\n    try\n    {\n        m_store.store(&quot;test&quot;, testInt1);\n=\r\n        assertTrue( m_store.hasKey(&quot;test&quot;) );\n\n        m_store.store(&quot;test&quot;=\r\n, testInt2);\n        fail(&quot;Must throw StoreException if the store has a key=\r\n&quot;);\n    }\n    catch (StoreException se)\n    {\n        // It did what it was=\r\n supposed to.  Ignore this exception\n    }\n    catch (Exception e)\n    {\n  =\r\n      // It threw a different exception than we were expecting\n        fail=\r\n(&quot;Unexpected Exception: &quot; + e.toString());\n    }\n\n    assertTrue( ! m_store=\r\n.retrieve(&quot;test&quot;).equals( testInt2) );\n    assertEquals( testInt1, m_store.=\r\nretrieve(&quot;test&quot;) );\n\n    m_store.remove(&quot;test&quot;);\n    assertTrue( ! m_store.=\r\nhasKey(&quot;test&quot;) );\n}\n\nEach test reinforces the basic contracts.\n\nAt this poi=\r\nnt, I would probably be satisfied with the interface,\nallowing me to implem=\r\nent different versions of the Store interface.\nAs far as I am concerned, I =\r\ndon&#39;t care about the methodology--I\ncare about the contract.\n\n\n", 
    "profile": "bloritsch", 
    "topicId": 4836, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 64910131, 
    "prevInTime": 4892, 
    "contentTrasformed": false, 
    "postDate": "1020776664", 
    "canDelete": false, 
    "nextInTopic": 4894, 
    "prevInTopic": 4891, 
    "headers": {
        "inReplyToHeader": "PGFiNnQ3aytqaWk0QGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PDAwMmIwMWMxZjVjNyRiNjY3MTMzMCRhYzAwYThjMEBHYWJyaWVsPg=="
    }
}