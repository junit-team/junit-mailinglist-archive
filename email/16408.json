{
    "numMessagesInTopic": 18, 
    "nextInTime": 16409, 
    "senderId": "I2cAK6RziHvYJ72FxfejzptGNj_REbb2Nn1h5uUaT6HGgmGssIyjIhNmejAD1XuxZSlA1C5rTyBTHWp1ACjLmA", 
    "systemMessage": false, 
    "subject": "Re: [junit] chosing between jmock and easymock for mocks?", 
    "from": "David Saff &lt;saff@...&gt;", 
    "authorName": "David Saff", 
    "msgSnippet": "... The places where I ve found mocking frameworks the most useful are: 1) Just getting started on a codebase, using test-driven development. As Mr.", 
    "msgId": 16408, 
    "profile": "dsaff", 
    "topicId": 16387, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 139771899, 
    "messageBody": "<div id=\"ygrps-yiv-701437994\">Andrew McDonagh wrote:<br/>\n<blockquote><span title=\"ireply\"> &gt; Now the depends part.....<br/>\n&gt;<br/>\n&gt; As any class with that amount of methods (00s) is suspect IMO, so I tend<br/>\n&gt; to wrapper the actual interface/class that I&#39;m trying to use with my own<br/>\n&gt; much smaller interface - essentially hiding the dependency of the<br/>\n&gt; ResultSet, CORBA POA, etc from my own code.  My interface/wrapper class<br/>\n&gt; is then tiny - and so a mocking framework just aint worth it.<br/>\n<br/>\n </span></blockquote>The places where I&#39;ve found mocking frameworks the most useful are:<br/>\n<br/>\n1) Just getting started on a codebase, using test-driven development.  <br/>\nAs Mr. Rainsberger has mentioned, here JMock&#39;s flexibility to name <br/>\nmethods without defining them can be key.<br/>\n<br/>\n2) Just getting started on legacy code.  I can often safely introduce a <br/>\nseam between two classes by extracting an interface from one, and then <br/>\nstart characterization tests on the other by mocking the new interface.<br/>\n<br/>\n[In both of the above cases, I&#39;ve found that over time, I have fewer and <br/>\nfewer mock objects in my tests, and even old tests with mock objects <br/>\nstart losing them.  I think that as the abstractions get better, it <br/>\nbecomes easier to think of simple implementations of interfaces that <br/>\nlook less like mocks, and more like useful objects you could actually <br/>\nimagine a client using.]<br/>\n<br/>\n3) Writing plug-ins.  When the ratio of foreign interfaces to lines of <br/>\nnew business code gets high enough, I become suspicious of wrapping <br/>\nevery interface, because then the code begins to look like:<br/>\n<br/>\n// listener callback<br/>\npublic Result somethingHasChanged(FileChange change) {<br/>\n   return mySomethingHasChanged(new <br/>\nBetterAbstractionForFileChange(change)).asClientResult();<br/>\n}<br/>\n<br/>\nWhich doesn&#39;t actually help the reader understand what&#39;s going on.  In <br/>\nthis case, the mock objects tend to stick around until the plug-in <br/>\nstarts growing to the size of an application in its own right.<br/>\n<br/>\nYour mileage may vary.<br/>\n<br/>\n   David Saff</div>", 
    "prevInTime": 16407, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1143488977", 
    "canDelete": false, 
    "nextInTopic": 16413, 
    "prevInTopic": 16407, 
    "headers": {
        "inReplyToHeader": "PDQ0MjgzOTQwLjQwNTA5MDVAYW5kcmV3bWNkb25hZ2guZjJzLmNvbT4=", 
        "messageIdInHeader": "PDQ0Mjg0MUQxLjcwNDAyMDRAbWl0LmVkdT4=", 
        "referencesHeader": "PGEwM2EyMDkzMDYwMzI0MDc1MG42YWIxYTI3OWc0M2QxOTJhMDZmZmNhMjY1QG1haWwuZ21haWwuY29tPiA8NDQyNUQ0RUIuMTA1MDZAYW5kcmV3bWNkb25hZ2guZjJzLmNvbT4gPDQ0MjczNzEzLjgwMjA1MDJAcm9nZXJzLmNvbT4gPDQ0MjgzOTQwLjQwNTA5MDVAYW5kcmV3bWNkb25hZ2guZjJzLmNvbT4="
    }
}