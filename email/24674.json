{
    "numMessagesInTopic": 3, 
    "nextInTime": 24675, 
    "senderId": "oQUl50PbaBipKtwahYJ8BOGRgWYPhGh-hhRYQww_MPeku3-x3DBIHtoIBxqbVSqC7DGHQvczzlcA9P4wszGwNOQnYqWQxR4tLHA_K8yGQa8", 
    "systemMessage": false, 
    "subject": "Using MockitoJUnitRunner.class instead of SpringJUnit4ClassRunner.class", 
    "from": "Ayaskant Swain &lt;ayaskant.swain@...&gt;", 
    "authorName": "Ayaskant Swain", 
    "msgSnippet": "I have a question about the usage of SpringJUnit4ClassRunner.class. For pure Junits or Unit Test cases should we use Spring based annotations such as", 
    "msgId": 24674, 
    "profile": "ayas_swain", 
    "topicId": 24674, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 575769161, 
    "messageBody": "<div id=\"ygrps-yiv-1980524257\"><div dir=\"ltr\"><div>I have a question about the usage of SpringJUnit4ClassRunner.class. For pure Junits or Unit Test cases should we use Spring based annotations such as @Autowired along with SpringJUnit4ClassRunner.class or should we use &quot;MockitoJUnitRunner.class&quot; instead with the @RunWith annotation at the top of the Test class?</div><div><br></div><div>I mean replacing @RunWith(SpringJUnit4ClassRunner.class)</div><div>@ContextConfiguration({ &quot;classpath:test-applicationContext.xml&quot; }) with just @RunWith(MockitoJUnitRunner.class) at the top of the class. It works for me.</div><div><br></div><div>In Junits we normally do not make any external calls such as calls to DB or call to some other web service. We have to mock these external calls using @Mock annotations on this service objects. And then create a real object of the class that we are testing &amp; that depends on these mocks. We can then use @InjectMocks on the real object so that it will be injected with the mocked objects.</div><div><br></div><div>Example Service-A-&gt;Calls-&gt;Service-B-&gt;Calls-&gt;Service-C</div><div><br></div><div>While testing A we should mock Service B &amp; while testing Service-B we should mock Service-C.</div><div><br></div><div>Some code snippet -</div><div><br></div><div>@RunWith(MockitoJUnitRunner.class)<br></div><div>public class TestServiceA {</div><div><br></div><div><span class=\"ygrps-yiv-1980524257\" style=\"white-space:pre;\">\t</span>@Mock</div><div><span class=\"ygrps-yiv-1980524257\" style=\"white-space:pre;\">\t</span>B mockObj;</div><div><br></div><div><span class=\"ygrps-yiv-1980524257\" style=\"white-space:pre;\">\t</span>@InjectMocks</div><div><span class=\"ygrps-yiv-1980524257\" style=\"white-space:pre;\">\t</span>A realObj;</div><div>         </div><div>        private String accId = &quot;a1234&quot;;</div><div><br></div><div>         @Test</div><div>         public void testServiceA() {</div><div>                   Account acc = new Account(&quot;a1234&quot;, &quot;John&quot;, &quot;India&quot;);</div><div>                   when(mockObj.getAccDetails(anyString()).thenReturn(acc);</div><div>                   Account accountObj = realObj.getCustomerAccount(accId);</div><div>                   assertNotNull(accountObj);</div><div>         }</div><div>}       <br></div><div><br></div><div>So, I feel for Unit test cases we need not rely on Spring container to provide us the instance of the class we are testing.</div><div><br></div><div>I might be wrong. Please give your suggestions.</div></div></div>", 
    "prevInTime": 24673, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1435507093", 
    "canDelete": false, 
    "nextInTopic": 24681, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PENBSm84NUpaNDBqT3BaRkhTQ3VwNzh5WUFBcVdncUpuZDBKWTlPR1hHWlhHM1dYUHpnUUBtYWlsLmdtYWlsLmNvbT4="
    }
}