{
    "numMessagesInTopic": 125, 
    "nextInTime": 9570, 
    "senderId": "Zvd_cOlwr4Ae37tVUSgyBr5Z3TVsIsV1kfDyhv2ADCdUbxEfmMPwVLDnTmCffjOyH9cOIkv0q6cloHGM5Xac0Ec9nbiBxwp_fA", 
    "systemMessage": false, 
    "subject": "Re: [junit] Re: Help plz...", 
    "from": "Chris Dollin &lt;chris.dollin@...&gt;", 
    "authorName": "Chris Dollin", 
    "msgSnippet": "... So what? While they haven t run as JITs, I have written compiler back-ends that take stackish code and destack it to at least some extent. Turning load", 
    "msgId": 9569, 
    "profile": "anover_alias", 
    "topicId": 9354, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 155741085, 
    "messageBody": "<div id=\"ygrps-yiv-1828208864\">On Tuesday 30 September 2003 16:43, Jim Dixon wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; I know that this is official Sun doctrine.  But compilation is always<br/>\n&gt; a lossy process, and the smaller the target instruction set, the more<br/>\n&gt; information you lose.  The JVM has a small instruction set.  To increment<br/>\n&gt; a variable, you put a 1 on the stack and say &quot;add&quot;.  Oh my :-(<br/>\n<br/>\n </span></blockquote>So what?<br/>\n<br/>\nWhile they haven&#39;t run as JITs, I have written compiler back-ends that take<br/>\nstackish code and destack it to at least some extent. Turning<br/>\n<br/>\n    load local x; load 1; add; store local x<br/>\n<br/>\ninto<br/>\n<br/>\n    add Rx, Rx, 1   [ARM, &#39;cos I don&#39;t speak x86]<br/>\n<br/>\nwhen local x can be put into a register is not hard, especially if someone&#39;s<br/>\npaying you to do it.<br/>\n<br/>\nRTL/2&#39;s intermediate code was stackish (two stacks, one for addresses,<br/>\none for values, not necessarily nested, ugh), but the SMR-mu back end<br/>\nI-and-others wrote for it regularly turned the sequence for &quot;add 1 to <br/>\nthingy&quot; into some appropriate compact non-stacky code.<br/>\n<br/>\nYes, compilation can be a lossy process. But JVM bytecode isn&#39;t very<br/>\nlossy compared to the source, partly because of the requirement for<br/>\nbytecode verification. You can do a pretty good code code reconstruction,<br/>\nas existing decompilers demonstrate.<br/>\n<br/>\nNow, how much of that effort you want to stuff into a JIT, that&#39;s a legitimate<br/>\nconcern. But optimising x += 1 is, I would have said, a no-brainer.<br/>\n<br/>\n-- <br/>\nChris &quot;electric hedgehog&quot; Dollin<br/>\nC FAQs at: <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.faqs.org/faqs/by-newsgroup/comp/comp.lang.c.html\">http://www.faqs.org/faqs/by-newsgroup/comp/comp.lang.c.html</a><br/>\nC welcome: <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.angelfire.com/ms3/bchambless0/welcome_to_clc.html\">http://www.angelfire.com/ms3/bchambless0/welcome_to_clc.html</a></div>", 
    "prevInTime": 9568, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1064937428", 
    "canDelete": false, 
    "nextInTopic": 9571, 
    "prevInTopic": 9568, 
    "headers": {
        "inReplyToHeader": "PDIwMDMwOTMwMTYzODA5Lko4NzYwLTEwMDAwMEBsb2NhbGhvc3Q+", 
        "messageIdInHeader": "PDIwMDMwOTMwMTY1Ny4wODE3Ny5jaHJpcy5kb2xsaW5AaHAuY29tPg==", 
        "referencesHeader": "PDIwMDMwOTMwMTYzODA5Lko4NzYwLTEwMDAwMEBsb2NhbGhvc3Q+"
    }
}