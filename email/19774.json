{
    "numMessagesInTopic": 5, 
    "nextInTime": 19775, 
    "senderId": "Z1hg6GsJcwPN_yawnXqDflVEAldp9MpAaJWX3lxo-XPJGvLVoua4KMIVrynUaNq-1mDaDfbYPiYTaFqTPO8BJSVL", 
    "systemMessage": false, 
    "subject": "Re: [junit] Re: Junit4 new features ?", 
    "from": "&quot;David Saff&quot; &lt;saff@...&gt;", 
    "authorName": "David Saff", 
    "msgSnippet": "Roger, Thanks for thinking this through. ... My first instinct is to do this with a listener, which appears more configurable. ... Have you seen Filters?  They", 
    "msgId": 19774, 
    "profile": "dsaff", 
    "topicId": 19748, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 139771899, 
    "messageBody": "<div id=\"ygrps-yiv-1895019341\">Roger,<br/>\n<br/>\nThanks for thinking this through.<br/>\n<br/>\n<blockquote><span title=\"qreply\"> On 8/20/07, Roger Chen @ RevZoom &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:coderobochen@...\">coderobochen@...</a>&gt; wrote:<br/>\n&gt; &gt; Me and another colleague at work looked at the Junit sources and felt<br/>\n&gt; &gt; we should do the failure recording in<br/>\n&gt; &gt; org.junit.runner.notification.RunNotifier#fireTestFailure() method.<br/>\n&gt; &gt; That would allow any runner to be able to get a list of failed<br/>\n&gt; &gt; testcases in an XML or a plain text file.<br/>\n<br/>\nMy first instinct is to do this with a listener, which appears more<br/>\nconfigurable.<br/>\n<br/>\n&gt; &gt; To re-run the failed tests, we were envisioning a custom test runner<br/>\n&gt; &gt; and/or modification to the Ant Junit task (since we use Ant heavily)<br/>\n&gt; &gt; that would take a flag to pick up the failed test XML/text file from<br/>\n&gt; &gt; a known location ($HOME/.junit/failed-tests.xml for e.g.) and re-run<br/>\n&gt; them.<br/>\n<br/>\nHave you seen Filters?  They should enable re-running failed tests<br/>\nwithout a separate custom runner.<br/>\n<br/>\n&gt; &gt; &gt; 2) I&#39;ve heard of wanting to only instantiate a test class once (you<br/>\n&gt; &gt; &gt; can do that in JUnit, see<br/>\n&gt; &gt; &gt; <a rel=\"nofollow\" target=\"_blank\" href=\"http://tech.groups.yahoo.com/group/junit/message/19159)\">http://tech.groups.yahoo.com/group/junit/message/19159)</a>.  Is that what<br/>\n&gt; &gt; &gt; you&#39;re looking for, or is there another advantage in having non-static<br/>\n&gt; &gt; &gt; @BeforeClass, etc?<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt; Yes, consider the following usage pattern we see in our testing:<br/>\n&gt; &gt;<br/>\n&gt; &gt;   @BeforeClass(<br/>\n&gt; &gt;   public void setup() throws IOException {<br/>\n&gt; &gt;<br/>\n&gt; &gt;     String cname = getClass().getPackage().getName();<br/>\n&gt; &gt;     String rd = cname.replace(&#39;.&#39;, &#39;/&#39;);<br/>\n&gt; &gt;     File f = MyEnv.getRootDir();<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt;     File newRd = new File(f, &quot;/tests/unit/src/java/&quot;+rd);<br/>\n&gt; &gt;     MyEnv.setRootDir(newRd.getCanonicalPath());<br/>\n&gt; &gt;     MyEnv.setLogPropsFile(newRd.getCanonicalPath()+&quot;/log.properties&quot;);<br/>\n&gt; &gt;     setupModules();<br/>\n&gt; &gt;   }<br/>\n&gt; &gt;<br/>\n&gt; &gt; This works nicely with TestNG as the beforeClass non-static method can<br/>\n&gt; &gt; be used to determine the current testclass name. In the above snippet<br/>\n&gt; &gt; the class name is use to construct the path to the log.properties<br/>\n&gt; &gt; (every test class has its own properties file)<br/>\n&gt; &gt;<br/>\n&gt; &gt; With Juni4 we are forced to use @Before to get the non-static behavior.<br/>\n<br/>\nI appears you primarily want to write before-class configuration in a<br/>\nsuperclass, and have it operate a little differently for each<br/>\nsubclass.  (I&#39;m assuming that setupModules is too expensive to run<br/>\nmultiple times?)  In TestNG, since there&#39;s only a single instance of<br/>\neach test class, that&#39;s the natural place to do this configuration.<br/>\nIn JUnit, there are many instances of each test class, so a different<br/>\nsyntax would be necessary.  Can you open a feature request with a<br/>\nsuggested syntax?<br/>\n<br/>\n&gt; &gt; The reason I like the dependency model is basically software layering.<br/>\n&gt; &gt;   If a module or subsystem is failing unit tests I want to exclude<br/>\n&gt; &gt; subsystems or modules that are consumer of the &#39;bad&#39; modules. Prior to<br/>\n&gt; &gt;  Junit4 assumptions we were using the pattern of invoking test method<br/>\n&gt; &gt; B (if it was a prerequisite for A) again in the test method A:<br/>\n&gt; &gt;<br/>\n&gt; &gt;  void testMethodA() { ..}<br/>\n&gt; &gt;  void testMethod B() {<br/>\n&gt; &gt;    testMethodA();<br/>\n&gt; &gt;    .. now the code for N..<br/>\n&gt; &gt;   }<br/>\n&gt; &gt;<br/>\n&gt; &gt; For some of the methods that have a non-trivial execution time it<br/>\n&gt; &gt; would be great to:<br/>\n&gt; &gt;<br/>\n&gt; &gt; 1) Avoid re-running them as part of assumptions check again and again<br/>\n&gt; &gt; 2) Skip the methods that would fail for sure because of dependent<br/>\n&gt; &gt; methods failing<br/>\n<br/>\nImagine you could set a flag when a test failed.  In another test, you<br/>\ncould assume the flag had not been set.  Would that be a sufficient<br/>\nAPI?<br/>\n<br/>\nIn all of these cases, I&#39;m mindful of Kent and Erich&#39;s initial<br/>\nstrategy.  It&#39;s valuable to be able to hold all of JUnit in your head,<br/>\nso that when looking through someone else&#39;s failing test, you can<br/>\nconcentrate on the test and the code, and not a new, unfamiliar<br/>\nfeature of JUnit.  So there&#39;s a &quot;burden of proof&quot; for each new<br/>\nfeature.  Will it add enough ease of test writing for enough people to<br/>\noutweigh the added complexity of test reading?<br/>\n<br/>\n   David </span></blockquote></div>", 
    "prevInTime": 19773, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1187694915", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 19768, 
    "headers": {
        "inReplyToHeader": "PGZhY2hxZStlYjJpQGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PDRmN2RhNmI5MDcwODIxMDQxNXgzZGUxYjczY2g2YWQxOWJhMGNkN2FiOWI5QG1haWwuZ21haWwuY29tPg==", 
        "referencesHeader": "PGZhNTVjdCtkcGtyQGVHcm91cHMuY29tPiA8ZmFjaHFlK2ViMmlAZUdyb3Vwcy5jb20+"
    }
}