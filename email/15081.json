{
    "numMessagesInTopic": 47, 
    "nextInTime": 15082, 
    "senderId": "x6kgU3RFRE0iDU-j-W8QwGps4xBKWJMOalvYM6hILYFZNGsD-L5IKClBuHdJg3M1fygUH08h7AqsotAOu5mxVthvOfr-NczUg2MmjPdnvA", 
    "systemMessage": false, 
    "subject": "Re: [junit] Proposed parameterized test syntax for JUnit 4", 
    "from": "&quot;J. B. Rainsberger&quot; &lt;jbrains@...&gt;", 
    "authorName": "J. B. Rainsberger", 
    "msgSnippet": "... When a class has common code in two methods, we usually Extract Method. When a class has sets of methods that operate on two different parts of the class", 
    "msgId": 15081, 
    "profile": "nails762", 
    "topicId": 14820, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 127224993, 
    "messageBody": "<div id=\"ygrps-yiv-356217277\">Elliotte Harold wrote:<br/>\n<blockquote><span title=\"ireply\"> &gt; Eugene Kuleshov wrote:<br/>\n&gt;  &gt; Hi Kent,<br/>\n&gt;  &gt;<br/>\n&gt;  &gt;    Are you suggesting that groupping test classes per fixture will be<br/>\n&gt;  &gt; the only supported option in JUnit4?<br/>\n&gt;  &gt;<br/>\n&gt; <br/>\n&gt; This has always been how JUnit is designed and intended to be used. That<br/>\n&gt; said, many testers and test suites (including myself and my suites, and<br/>\n&gt; apparently even some of JUnit&#39;s own suites) tend to gravitate toward one<br/>\n&gt; test class per tested class. This is a very common pattern, even if it&#39;s<br/>\n&gt; one JUnit wasn&#39;t meant to support and one that causes test suites to<br/>\n&gt; take longer to run than they otherwise would.<br/>\n&gt; <br/>\n&gt; This does make me wonder if maybe JUnit has been cutting the wrong way<br/>\n&gt; all these years. Perhaps it should be designed to organize tests by<br/>\n&gt; model class rather than fixture. This certainly seems a lot more natural<br/>\n&gt; to a lot of developers.<br/>\n<br/>\n </span></blockquote>When a class has common code in two methods, we usually Extract Method.<br/>\n<br/>\nWhen a class has sets of methods that operate on two different parts of <br/>\nthe class&#39; internal state, we usually split the class in two.<br/>\n<br/>\nWhy wouldn&#39;t we follow those rules with JUnit test case classes? The <br/>\nfirst rule extracts common setup code into setUp() and fixture objects. <br/>\nThe second splits test case classes that have multiple fixtures into <br/>\nseparate test case classes. This leads to test case classes organized <br/>\naround fixtures.<br/>\n<br/>\nAs for one test case per model class, that&#39;s a natural place to start, <br/>\nbecause it&#39;s simple, but once that test case class becomes complex, <br/>\nrefactor as usual.<br/>\n<br/>\nTo say that JUnit supports or doesn&#39;t support this way of organizing <br/>\ntests sounds odd to me. I don&#39;t organize my tests a certain way; I <br/>\nrefactor the tests, and that&#39;s where they tend to end up.<br/>\n-- <br/>\nJ. B. (Joe) Rainsberger<br/>\nDiaspar Software Services<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.diasparsoftware.com\">http://www.diasparsoftware.com</a><br/>\n2005 Gordon Pask Award Winner for contribution to Agile practice<br/>\nAuthor, JUnit Recipes: Practical Methods for Programmer Testing</div>", 
    "prevInTime": 15080, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1128609649", 
    "canDelete": false, 
    "nextInTopic": 15085, 
    "prevInTopic": 15080, 
    "headers": {
        "inReplyToHeader": "PDQzNDQ2NDRCLjQwNEBtZXRhbGFiLnVuYy5lZHU+", 
        "messageIdInHeader": "PDQzNDUzNzcxLjkwNzA1MDlAcm9nZXJzLmNvbT4=", 
        "referencesHeader": "PEUxRU5HU1ktMDAwNHd3LUFBQHNtdHBhdXRoMDUubWFpbC5hdGwuZWFydGhsaW5rLm5ldD4gPDQzNDQ0NjFELjMwNTA3MDNAbWQucHAucnU+IDw0MzQ0NjQ0Qi40MDRAbWV0YWxhYi51bmMuZWR1Pg=="
    }
}