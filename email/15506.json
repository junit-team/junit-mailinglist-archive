{
    "numMessagesInTopic": 9, 
    "nextInTime": 15507, 
    "senderId": "7L9ce8fJpcxHa5C4QFmkcFVi0uLcryDBkTg4Cd4kXADi9vuVVdng9Os95w0P6Pa2GRZr4ZlhRohcLDqzaLVE9MJT85kGflMi4rtwwRc", 
    "systemMessage": true, 
    "subject": "Parameterisation of tests in JUnit4", 
    "from": "&quot;Jon Skeet&quot; &lt;jon.skeet@...&gt;", 
    "authorName": "Jon Skeet", 
    "msgSnippet": "I ve had a look at the Parameterized runner in JUnit4 (current CVS) and I have a few suggestions. It s probably easiest to demonstrate them in some code which", 
    "msgId": 15506, 
    "profile": "jskeetuk", 
    "topicId": 15506, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 246518675, 
    "messageBody": "<div id=\"ygrps-yiv-2064631573\">I&#39;ve had a look at the Parameterized runner in JUnit4 (current CVS) and<br/>\nI have a few suggestions. It&#39;s probably easiest to demonstrate them in<br/>\nsome code which I&#39;d *like* to work (and I&#39;m quite happy to do the<br/>\nappropriate coding to *make* work):<br/>\n<br/>\n    @RunWith(Parameterized.class)<br/>\n    @Parameters(&quot;classParameters&quot;)<br/>\n//     Or equivalently @Parameters strings={&quot;Oracle&quot;, &quot;SQL&quot;}<br/>\n    public class WishfulTest<br/>\n    {<br/>\n        private String m_dbName;<br/>\n        private static final File RootTestFileDirectory = new<br/>\nFile(&quot;c:&#92;&#92;Tests&quot;); <br/>\n        <br/>\n\t  // In actual code, these would probably be enums, in my<br/>\nexperience -<br/>\n        // they would provide mechanisms for connecting to the<br/>\nappropriate database,<br/>\n        // setting it up and tearing it down etc.<br/>\n        public static String[] classParameters = {&quot;Oracle&quot;, &quot;SQL&quot;};<br/>\n        <br/>\n        public WishfulTest(String dbName)<br/>\n        {<br/>\n            m_dbName = dbName;<br/>\n        }<br/>\n        <br/>\n        // Note - array of arrays here. See comments afterwards.<br/>\n        public static int[][] test1Parameters = {{0,1}, {1, 2}, {3, 4}};<br/>\n        @Test<br/>\n        // Uses a field to get the parameters<br/>\n        @Parameters(&quot;test1Parameters&quot;)<br/>\n        public void test1(int first, int second)<br/>\n        {<br/>\n            assertEquals(first+1, second);<br/>\n        }<br/>\n        <br/>\n        /**<br/>\n         * Finds all the test files for the current database. The File<br/>\nexample<br/>\n         * here isn&#39;t as good as I&#39;d like it to be - hardcoding paths is<br/>\nobviously<br/>\n         * far from ideal. I hope it gives an indication of what&#39;s<br/>\nwanted though<br/>\n         * - a way to get parameters for a specific test, where those<br/>\nparameters<br/>\n         * may vary by test class parameters.<br/>\n         */ <br/>\n        public File[] getTest2Parameters()<br/>\n        {<br/>\n            File directory = new File (RootTestFileDirectory, m_dbName);<br/>\n            return directory.listFiles();<br/>\n        }<br/>\n        <br/>\n        @Test<br/>\n        // Calls a method to get the parameters<br/>\n        @Parameters(&quot;getTest2Parameters&quot;)<br/>\n        public void test2(File testFile)<br/>\n        {<br/>\n            assertNotNull(testFile);<br/>\n        }<br/>\n        <br/>\n        @Test<br/>\n        @Parameters(strings={&quot;hello&quot;, &quot;there&quot;})<br/>\n        public void test3(String input)<br/>\n        {<br/>\n            assertEquals(input, input.toLowerCase());<br/>\n        }<br/>\n        <br/>\n        @Test<br/>\n        @Parameters(ints={1, 2, 3})<br/>\n        public void test4(int input)<br/>\n        {<br/>\n            assertTrue (input &lt; 4);<br/>\n        }<br/>\n        <br/>\n        @Test<br/>\n        public void test5()<br/>\n        {<br/>\n        }<br/>\n        <br/>\n        // etc for all primitives, String and class (but not arrays)<br/>\n        <br/>\n        // Not allowed:<br/>\n        // @Parameters(ints={1,2,3}, strings={&quot;hello&quot;})<br/>\n        // @Parameters(value=&quot;something non-empty&quot;, strings={&quot;hello&quot;})<br/>\n        // Multiple parameters annotations for a single method/class<br/>\n    }<br/>\n<br/>\n<br/>\nSo, the notes:<br/>\n1) Tests are allowed to be parameterised as well as test classes<br/>\n2) Unless multiple parameters are required, a single array (rather than<br/>\nan array of arrays) causes less confusion. I know that the<br/>\ncounter-argument to that is that having two forms, one for<br/>\nsingle-parameter tests/constructors and one for multi-parameter<br/>\ntests/constructors is ugly, but I personally believe that it&#39;s justified<br/>\nin this case.<br/>\n3) Parameters can be specified in two ways:<br/>\n   i) As a simple name of a field or method (currently using the &quot;value&quot;<br/>\nannotation element; possibly specifying field=&quot;...&quot; or method=&quot;...&quot;<br/>\nwould be better though. For constructor parameters, the field/method<br/>\nwould have to be static. For test parameters, it<br/>\ncould be static or instance.<br/>\n   ii) As an array of one of the primitive types, string or class,<br/>\ndirectly in the parameters annotation<br/>\n4) As mentioned in a previous post, it may be worth having yet another<br/>\nlevel of setup/teardown for parameterised test classes - for instance,<br/>\nin the example above, where you&#39;d run all Oracle tests, then all SQL<br/>\nServer tests, it may well be advantageous to set the database up once<br/>\nbefore running all the tests for a particular database (assuming they&#39;re<br/>\nread-only tests). The sequence would then go:<br/>\n<br/>\n   Run @BeforeClass methods<br/>\n   Run @BeforeParameterisedClass methods (with parameter &quot;Oracle&quot;?)<br/>\n   Call constructor with parameter &quot;Oracle&quot;<br/>\n   Run @Before methods<br/>\n   Run test1(0, 1)<br/>\n   Run @After methods<br/>\n   Call constructor with parameter &quot;Oracle&quot;<br/>\n   Run @Before methods<br/>\n   Run test1(1, 2)<br/>\n   ...<br/>\n   Call constructor with parameter &quot;Oracle&quot;<br/>\n   Run test5()<br/>\n   Run @After methods<br/>\n   Run @AfterParameterisedClass methods<br/>\n   Run @BeforeParameterisedClass methods (with parameter &quot;SQL&quot;?)<br/>\n   Call constructor with parameter &quot;SQL&quot;<br/>\n   ...<br/>\n   Call constructor with parameter &quot;SQL&quot;<br/>\n   Run test5()<br/>\n   Run @After methods<br/>\n   Run @AfterParameterisedClass methods<br/>\n   Run @AfterClass methods<br/>\n<br/>\nNote the question over whether @BeforeParameterisedClass (bad name -<br/>\nplease come up with a better one if you can!) should take the same<br/>\nparameters as the constructor. As an alternative, they could be instance<br/>\nmethods called *after* the constructor is called for the first time, and<br/>\nbe parameterless. (Likewise @AfterParameterisedClass could be an<br/>\ninstance method.)<br/>\n<br/>\n5) One nasty problem: you need to construct instances of the test class<br/>\njust to count the test cases - and hope that the parameters you get back<br/>\nthen is the same as the ones you get when you&#39;re ready to run the tests.<br/>\n(You could cache the results, of course...)<br/>\n<br/>\nAnyway, the bottom line is that I can see *huge* benefits in this<br/>\napproach in quite a few of our existing test code. Does anyone have any<br/>\nmajor objections to the above, or shall I give it a whirl?<br/>\n<br/>\nJon Skeet<br/>\nSenior Software Engineer<br/>\nCLEARSWIFT<br/>\nThe MIMEsweeper Company<br/>\n<br/>\nDDI:               +44 (0) 1189  038  109<br/>\nMobile:           +44 (0) 7970 158 865<br/>\nSwitchboard:   +44 (0) 1189  038  903 <br/>\nFax:               +44 (0) 1189  039  000      <br/>\nWeb: www.clearswift.com <br/>\n<br/>\n<br/>\nClearswift monitors, controls and protects all its messaging traffic in compliance with its corporate email policy using Clearswift products.<br/>\nFind out more about Clearswift, its solutions and services at <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.clearswift.com\">http://www.clearswift.com</a><br/>\n<br/>\nThis communication is confidential and may contain privileged information intended solely for the named addressee(s). It may not be used or disclosed except for the purpose for which it has been sent. If you are not the intended recipient, you must not copy, distribute or take any action in reliance on it. Unless expressly stated, opinions in this message are those of the individual sender and not of Clearswift. If you have received this communication in error, please notify Clearswift by emailing <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:support@...\">support@...</a> quoting the sender and delete the message and any attached documents. Clearswift accepts no liability or responsibility for any onward transmission or use of emails and attachments having left the Clearswift domain.<br/>\n<br/>\nThis footnote confirms that this email message has been swept by MIMEsweeper for Content Security threats, including computer viruses.</div>", 
    "prevInTime": 15505, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1132822780", 
    "canDelete": false, 
    "nextInTopic": 15557, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PDZFQUE4QUQ4MkQ3RUJGNDc4Q0NFMjYyRkEzMkM2QzY0MDFCNTY5QjdAR0VNSU5JLkVVUk9QRS5DTEVBUlNXSUZULkNPTT4="
    }
}