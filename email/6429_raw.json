{
    "numMessagesInTopic": 108, 
    "nextInTime": 6430, 
    "senderId": "JjF1B4GMWcti3MoFSeLYAxXcLc6Wx-KuAmTnMCmM4Rv26I1eRa0Q-3fOSsbZNC5vdHAroeskaQ2zLmG5rfJtssUb0KDkHrnvLuuHbjEuJQj-bwnae415Tg", 
    "systemMessage": false, 
    "subject": "Re: Testing Private Methods", 
    "from": "&quot;Dave Astels &lt;dave@...&gt;&quot; &lt;dave@...&gt;", 
    "authorName": "Dave Astels &lt;dave@saorsa.com&gt;", 
    "msgSnippet": "... OK.  A quick job here.  Here s the sectionon all this. Hopefully, someone gets somethign out of it :-) Dave ... Tests, Suies, and Fixtures Tests, cases,", 
    "msgId": 6429, 
    "rawEmail": "Return-Path: &lt;dave@...&gt;\r\nX-Sender: dave@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (EGP: mail-8_2_3_0); 14 Dec 2002 04:33:43 -0000\r\nReceived: (qmail 93852 invoked from network); 14 Dec 2002 04:33:42 -0000\r\nReceived: from unknown (66.218.66.217)\n  by m7.grp.scd.yahoo.com with QMQP; 14 Dec 2002 04:33:42 -0000\r\nReceived: from unknown (HELO n22.grp.scd.yahoo.com) (66.218.66.78)\n  by mta2.grp.scd.yahoo.com with SMTP; 14 Dec 2002 04:33:41 -0000\r\nReceived: from [66.218.67.147] by n22.grp.scd.yahoo.com with NNFMP; 14 Dec 2002 04:33:41 -0000\r\nDate: Sat, 14 Dec 2002 04:33:38 -0000\r\nTo: junit@yahoogroups.com\r\nSubject: Re: Testing Private Methods\r\nMessage-ID: &lt;atecb2+v1m9@...&gt;\r\nIn-Reply-To: &lt;atdk26+jmm6@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Length: 7550\r\nX-Mailer: Yahoo Groups Message Poster\r\nFrom: &quot;Dave Astels &lt;dave@...&gt;&quot; &lt;dave@...&gt;\r\nX-Yahoo-Group-Post: member; u=116713278\r\nX-Yahoo-Profile: astelsd\r\n\r\n--- In junit@yahoogroups.com, &quot;Dave Astels &lt;dave@s...&gt;&quot; &lt;dave@s...&gt; wrote:\n\n&gt; I have a section in the JUnit chapter in my TDD book on the topic. \n&gt; I&#39;m thinking maybe it should be the next Coad Letter issue.\n&gt; \n&gt; I&#39;ll try to do justice to the topic once I&#39;m back at the hotel and\n&gt; post the first draft of the results here.\n\nOK.  A quick job here.  Here&#39;s the sectionon all this.\n\nHopefully, someone gets somethign out of it :-)\n\nDave\n----\n\nTests, Suies, and Fixtures\n\nTests, cases, suites, fixtures.  How do they all fit together?  What\nreally happens when the tests run?  This section will answer these\nquestions.  By the end of it, you should have a much deeper\nunderstanding of what happens when we run our tests.  This will help\nus write and organize groups of tests that are simpler, cleaner, more\nunderstandable, and more maintainable.\n\nLet&#39;s begin by considering TestCase.  It is used to group related\ntests together.  But what does &quot;related&quot; mean? It is often\nmisunderstood to mean all tests for a specific class or specific group\nof related classes.  This misunderstanding is reinforced by some of\nthe IDE plugins that will generate a TestCase for a specified class,\ncreating a test method for each method in the target class.  These\ntest creation facilities are overly simplistic at best, and misleading\nat worst.  They reinforce the view that you should have a TestCase for\neach class being tested, and a test for each method in those classes.\n\nThis structural correspondence of tests misses the point.  You should\nwrite tests for behaviors, not methods.  A test method should test a\nsingle behavior. Examples include:\n\n- The size of an empty list should be zero.\n\n- An empty list should answer true when it is asked if it isEmpty().\n\n- The iterator returned by an empty list should have no elements.\n\nHere&#39;s a TestCase corresponding to the above behaviors:\n\npublic class TestEmptyList extends TestCase {\n  private List emptyList;\n\n  protected void setUp() throws Exception {\n    emptyList = new ArrayList();\n  }\n\n  public void testSize() {\n    assertEquals(&quot;Size of an empty list should be zero.&quot;,\n                  0,\n                  emptyList.size());\n  }\n\n  public void testIsEmpty() {\n    assertTrue(&quot;Empty list should report empty.&quot;,\n                emptyList.isEmpty());\n  }\n\n  public void testIterator() {\n    Iterator emptyListIterator = emptyList.iterator();\n    assertFalse(&quot;Iterator from empty list should be empty.&quot;,\n                 emptyListIterator.hasNext());\n  }\n}\n\nTestCase is a mechanism to allow fixture reuse.  Each TestCase\nsubclass represents a fixture, and contains a group of tests that run\nin the context of that fixture.  A fixture is the set of preconditions\nand assumptions with which a test is run. It is the runtime context\nfor the test, embodied in the instance variables of the TestCase, the\ncode in the setUp() method, and any variables and setup code local to\nthe test method. In the above example, the fixture consisted of\nemptyList, an ArrayList with no elements.\n\nAn instance of a TestCase is created for each individual test method.\nWhen it is run, it builds the fixture, runs its single test, and tears\ndown the fixture.  Note that the two test case objects are the same\nobject, but with methods from the super and subclass.  By allowing\nTestCase to contain multiple tests (i.e. public void testXXX()\nmethods) you are sharing a fixture definition.\n\nThis hardwired fixture-orientation makes TestCase a bad choice for\ngrouping tests structurally or conceptually -- TestSuite is better for\nthat, as we&#39;ll see later.  So instead of using TestCase to group tests\nfor a given class, try thinking about it as a way to group tests that\nneed to be set up in exactly the same way.\n\nA measure of how well your TestCase is mapping to the requirements of\na single fixture is how uniformly that fixture (as described by the\nsetUp() method) is used by all of the test methods.  Whenever you\ndiscover that your setUp() method contains some code for some of your\ntest methods, and different code for other test methods, consider it a\nsmell that indicates that you should refactor the TestCase into two or\nmore TestCases.\n\nOnce you get the hang of defining TestCases this narrowly, you will\nfind that they are easier to understand and maintain. And again, as we\nwill see shortly, there are still lots of ways to organize the tests\nfor a specific class (or for any other natural grouping) so that they\nare easy to identify.\n\nFor example, here is a TestCase similar to the above, but with\na couple more tests:\n\npublic class TestList extends TestCase {\n  private List emptyList;\n\n  protected void setUp() throws Exception {\n    emptyList = new ArrayList();\n  }\n\n  public void testEmptyListSize() {\n    assertEquals(&quot;Size of an empty list should be zero.&quot;,\n                  0,\n                  emptyList.size());\n  }\n\n  public void testEnptyListIsEmpty() {\n    assertTrue(&quot;Empty list should report empty.&quot;,\n                emptyList.isEmpty());\n  }\n\n  public void testEmptyListIterator() {\n    Iterator emptyListIterator = emptyList.iterator();\n    assertFalse(&quot;Iterator from empty list should be empty.&quot;,\n                 emptyListIterator.hasNext());\n  }\n\n  public void testOneItemListSize() {\n    List oneItemList = new ArrayList();\n    oneItemList.add(&quot;One&quot;);\n    assertEquals(&quot;Size of a one item list should be one.&quot;,\n                  1,\n                  oneItemList.size());\n  }\n\n  public void testOneItemListIsEmpty() {\n    List oneItemList = new ArrayList();\n    oneItemList.add(&quot;One&quot;);\n    assertFalse(&quot;One item list should not report empty.&quot;,\n                oneItemList.isEmpty());\n  }\n}\n\nHere, we want to extract the common fixture code in\ntestOneItemListSize() and testOneItemListIsEmpty() into a common\nfixture using the setUp() method.  The problem is that the other three\ntests don&#39;t need it.  This class should be split into two fixtures,\nthe earlier TestEmptyList and the following:\n\npublic class TestoneItemList extends TestCase {\n  private List oneItemList;\n\n  protected void setUp() throws Exception {\n    oneItemList = new ArrayList();\n    oneItemList.add(&quot;One&quot;);\n  }\n\n  public void testOneItemListSize() {\n    assertEquals(&quot;Size of a one item list should be one.&quot;,\n                  1,\n                  oneItemList.size());\n  }\n\n  public void testOneItemListIsEmpty() {\n    assertFalse(&quot;One item list should not report empty.&quot;,\n                oneItemList.isEmpty());\n  }\n}\n\nThis is better, but notice that it leaves a little smell behind:\noverly long test method names that echo the fact that we are testing a\nlist with one item. Because the class name makes it clear what size\nlist we are testing, we can shorten these method names to describe\njust the behaviors being tested: testSize() and testIsEmpty().\n\nTestSuite is a mechanism for grouping a collection of TestCase\ninstances and running them sequentially. \n\nTestCase has the ability to create a TestSuite all possible instances\nof itself.  This is done by using reflection to create an instance for\neach constituent test.  You also have the ability to create explicit\nTestSuites by subclassing TestSuite and writing a custom public static\nTest suite() method.  This is useful for collecting together groups of\nsmaller TestSuites, which can be other custom TestSuites, or\nTestSuites generated by TestCases.\n\nBoth TestSuite and TestCase implement the Test interface. The\nTestRunners work with objects that are Tests, hence we can point a\nrunner at any Test (i.e.  TestSuite or TestCase) and recursively run\nall the contained tests.\n\n\n\n", 
    "profile": "astelsd", 
    "topicId": 1696, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 116713278, 
    "prevInTime": 6428, 
    "contentTrasformed": false, 
    "postDate": "1039840418", 
    "canDelete": false, 
    "nextInTopic": 6430, 
    "prevInTopic": 6427, 
    "headers": {
        "inReplyToHeader": "PGF0ZGsyNitqbW02QGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PGF0ZWNiMit2MW05QGVHcm91cHMuY29tPg=="
    }
}