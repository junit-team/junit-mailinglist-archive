{
    "numMessagesInTopic": 23, 
    "nextInTime": 22550, 
    "senderId": "LM-ZAn18TAm2VvQvHRRRuTDRB19_ekoYDt6LlaHoQ_k1GF1Lgx9R9E5e2DdvhOu92Hr6utS3nmYUPWd-l4jOR7EO3dCufsrISFU_yTAxCXhj52gWzoF-", 
    "systemMessage": false, 
    "subject": "RE: [junit] Re: @DataPoints called several times for Theories", 
    "from": "&quot;Loritsch, Berin C.&quot; &lt;berin.loritsch@...&gt;", 
    "authorName": "Loritsch, Berin C.", 
    "msgSnippet": "This is a good dialog.  Personally, and academically, I think using Iterable would be much better than arrays for @Datapoints.  That would avoid the", 
    "msgId": 22549, 
    "rawEmail": "Return-Path: &lt;prvs=16844309f0=berin.loritsch@...&gt;\r\nX-Sender: prvs=16844309f0=berin.loritsch@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nX-Received: (qmail 55211 invoked from network); 15 Mar 2010 19:11:25 -0000\r\nX-Received: from unknown (98.137.34.46)\n  by m10.grp.re1.yahoo.com with QMQP; 15 Mar 2010 19:11:25 -0000\r\nX-Received: from unknown (HELO camv02-relay2.casc.gd-ais.com) (192.5.164.99)\n  by mta3.grp.sp2.yahoo.com with SMTP; 15 Mar 2010 19:11:23 -0000\r\nX-Received: from ([10.73.100.22])\n\tby camv02-relay2.casc.gd-ais.com with SMTP  id 5203374.18921377;\n\tMon, 15 Mar 2010 11:54:46 -0700\r\nX-Received: from vaff01-mail01.ad.gd-ais.com ([10.13.13.20]) by camv02-fes01.ad.gd-ais.com with Microsoft SMTPSVC(6.0.3790.3959);\n\t Mon, 15 Mar 2010 11:54:44 -0700\r\nX-MimeOLE: Produced By Microsoft Exchange V6.5\r\nContent-class: urn:content-classes:message\r\nMIME-Version: 1.0\r\nDate: Mon, 15 Mar 2010 14:54:12 -0400\r\nMessage-ID: &lt;75F5ED8A5A553646A46E00E6EC854FA30378C7EE@...-ais.com&gt;\r\nX-MS-Has-Attach: \r\nX-MS-TNEF-Correlator: \r\nThread-Topic: [junit] Re: @DataPoints called several times for Theories\r\nthread-index: AcrEaoPmYLsj8ptoTeWl0s+EDUg3wQAAjk3Y\r\nReferences: &lt;58dba2251002180943q238dd8dv11ab48736321e178@...&gt;&lt;hlkif2+3mte@...&gt;&lt;58dba2251003121544p3cd7dd28h1a899ce657f66ad3@...&gt;&lt;a527fddf1003140915l73761ee1r781ba20fc768e42e@...&gt;&lt;75F5ED8A5A553646A46E00E6EC854FA30378C7E4@...-ais.com&gt;&lt;4f7da6b91003150651m12f2796kf9aab17ff312cd93@...&gt; &lt;58dba2251003151056k4bf24ff2xf161e6415abf4aba@...&gt;\r\nTo: &lt;junit@yahoogroups.com&gt;,\n\t&lt;junit@yahoogroups.com&gt;\r\nReturn-Path: Berin.Loritsch@...\r\nX-OriginalArrivalTime: 15 Mar 2010 18:54:44.0602 (UTC) FILETIME=[FA2B8DA0:01CAC470]\r\nX-eGroups-Msg-Info: 2:4:8:0:2\r\nFrom: &quot;Loritsch, Berin C.&quot; &lt;berin.loritsch@...&gt;\r\nSubject: RE: [junit] Re: @DataPoints called several times for Theories\r\nX-Yahoo-Group-Post: member; u=428096731; y=2QuXWGaxPF8_mLXcbOH7Gxr5d7ayMRq_4h1mVRxQNm-p6F3s\r\nX-Yahoo-Profile: bloritsch\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\n\r\nThis is a good dialog.  Personally, and academically, I think using Iterable&lt;?&gt; would be much better than arrays for @Datapoints.  That would avoid the toArray(new Mutable[collection.size()]) I would have to create and reduce the number of objects in the garbage collector.  I guess that would put me on your side with that particular approach.  BTW, arrays are iterable...  I do create data dynamically for testing theories, particularly if I am testing interface contracts.\n \nRegarding extracting the parameters interface, I&#39;m not suggesting making that an API available outside the core.  I&#39;m suggesting a little DRY (Don&#39;t Repeat Yourself) to have a class that is responsible for collecting the raw data points (calling the @DataPoint and @DataPoints once), and copying them as necessary to satisfy the parameter sets on the individual tests.  That same approach can theorhetically feed parameterized tests.  The long and short of it is that I am suggesting the change for code maintenance reasons.  That would also make my feature enhancement to track each parameter set as a separate test (@Theory(runDiscretely=true)) a bit easier to implement.\n \nI think it would be reasonable to include the CloneableStrategy along with the solution.  That way, you have custom copy strategies, a cloning copy strategy, and I guess the default would be an identity strategy (i.e. not copying at all).\n \nWith your code example and the current implementation, if the datapoints are defined in the @DataPoints method then you have a fresh instance of each data point--even when the values are identical.  That&#39;s due to the bug that I mentioned.  The @DataPoints is called the first time, and for each data point, it is called again to make the combinations.  Using an identity copy strategy (i.e. not copying) will introduce problems with mutable data types.\n\n________________________________\n\nFrom: junit@yahoogroups.com on behalf of Brett Daniel\nSent: Mon 3/15/2010 1:56 PM\nTo: junit@yahoogroups.com\nSubject: Re: [junit] Re: @DataPoints called several times for Theories\n\n\n  \n\nDavid, Berin, and Mike,\n\nThank you very much for the great comments. I have asked Shin Hwei and Sang\nto provide their thoughts, but until then, here are my answers to your\nspecific questions (SH&S will correct me if I get anything wrong).\n\nDavid wrote...\n&gt; do you agree the below would work with the current implementation\n&gt; of Theories? It&#39;s four lines more of boilerplate, but not totally\nintractable\n\nYou are correct that copying within a @Datapoint method would create a new\ndata point as needed and would probably be a good workaround for Berin&#39;s\nbug. However, I see two drawbacks in addition to those you mention. First,\none would need to include the copy invocation in every @DataPoint method\nthat used createdOnce. In contrast, annotating the @DataPoint itself would\nprovide all consumers with pristine values. Second, the solution fails when\nusing @DataPoints with a theory that takes multiple parameters:\n\nprivate static Mutable[] createdOnce = new Mutable[] {\nnew Mutable(),\nnew Mutable() };\n\n@DataPoints()\npublic static Mutable[] mutables() {\nreturn new Mutable[] {\nnew Mutable(createdOnce[0]),\nnew Mutable(createdOnce[1])\n};\n}\n\n@Theory\npublic void testNotMutated(Mutable a, Mutable b) {\nassertFalse(a.isMutated);\na.mutate();\nassertFalse(b.isMutated);\nb.mutate();\n}\n\nThe code above fails because a and b can be aliases for the same object. It\nmay of course be desirable to run a theory on identical instances, but in\nthat case, the user could make that behavior explicit in another theory.\n\nDavid wrote...\n&gt; What would you think of allowing fields or methods to\n&gt; return PontentialAssignment, the type of named references to data\n&gt; values used in the Theories runner?\n...\n&gt; After further thought, the ParameterSupplier class is even better for\n&gt; this kind of thing:\n\nDo I understand correctly that you are suggesting pulling the\nPotentialAssignment array out of the internal Theory runner and making it\navailable to developers? I seem to remember that Sang and Shin Hwei\nexperimented with modifications to the PotentialAssignment and\nParameterSupplier classes, but they can describe what they did better than\nI.\n\nDavid wrote...\n&gt; @DataPointSource public static PotentialAssignment&lt;Mutable&gt; =\n&gt; Copy.ofMutable(new Mutable());\n...\n&gt; @DataSupplier public static OneTypeSupplier&lt;Mutable&gt; copyMutable =\n&gt; Copies.of(new Mutable());\n\nI like the idea of allowing data sources that produce things on-demand\nrather than in a pre-constructed array of values. This gets back to a brief\ndiscussion you and I had a long time ago about having the @DataPoints\nannotation return Iterable&lt;DataPointType&gt;. That would make things like the\nfollowing possible:\n\n@DataPoints\npublic static Iterable&lt;Integer&gt; ints = Ints.between(-10, 10);\n\n@DataPoints\npublic static Iterable&lt;Mutable&gt; mutables() {\nreturn Copies.of(...);\n}\n\nI don&#39;t know if it is better to overload @DataPoints or define new\n@DataPointSupplier/@DataPointSource annotations.\n\nBerin wrote...\n&gt; I hope we are not introducing an interface or base class that\n&gt; would be required for the data classes to implement\n\nAbsolutely not. That is one of the benefits of defining copy strategies in\nthe @DataPoint annotations: the data point classes themselves remain\nunchaged.\n\nBerin wrote...\n&gt; Is there a default CloneStrategy available?\n\nSang and Shin Hwei implemented several copy strategies, including one that\nuses clone, but they did not include them in the patch in an effort to\nreduce its size and complexity. Would it be helpful if they pushed some\nexamples?\n\nBerin wrote...\n&gt; Here&#39;s a problem I spotted in the implementation:\n\nThank you very much for looking so closely at Sang and Shin Hwei&#39;s code. I\nhave asked them to address any bugs that you or others find.\n\nBrett\n\nOn Mon, Mar 15, 2010 at 8:51 AM, David Saff &lt;david@... &lt;mailto:david%40saff.net&gt; &gt; wrote:\n\n&gt;\n&gt;\n&gt; On Mon, Mar 15, 2010 at 9:05 AM, Loritsch, Berin C.\n&gt; &lt;berin.loritsch@... &lt;mailto:berin.loritsch%40gd-ais.com&gt;  &lt;berin.loritsch%40gd-ais.com&gt;&gt; wrote:\n&gt; &gt; I&#39;m still going through the patch. Is there a default CloneStrategy\n&gt; available? Any cloneable object (implements the Cloneable interface) will\n&gt; be much quicker than another copy strategy. It&#39;s also an interface and a\n&gt; copy strategy that comes with the JVM since before Java 2.\n&gt; &gt;\n&gt; &gt; Here&#39;s a problem I spotted in the implementation:\n&gt; &gt;\n&gt; &gt; protected Object getCopyStrategyInvokedObject(Object value,\n&gt; &gt; Class&lt;? extends CopyStrategy&gt; copyStrategy, int index) throws\n&gt; CopyStrategyFailureException {\n&gt; &gt; try {\n&gt; &gt; return copyStrategy.newInstance().copyDataPoint(value);\n&gt; &gt; } catch (Exception e) {\n&gt; &gt; throw new CopyStrategyFailureException(value, index,\n&gt; copyStrategy.getSimpleName());\n&gt; &gt; }\n&gt; &gt; }\n&gt; &gt;\n&gt; &gt;\n&gt; &gt; Invoking copyStrategy.newInstance() for every object that needs to be\n&gt; copied is going to be a major performance drain. Not only are we creating\n&gt; more work for the garbage collector, we are going through the overhead of\n&gt; the reflection API to do it. You will have an order of magnitude better\n&gt; performance if you get your instance of the CopyStrategy first, and pass\n&gt; that as necessary.\n&gt; &gt;\n&gt; &gt; Perhaps another point of making the code cleaner would be to pull all the\n&gt; data collection stuff into its own API. It might even be able to support\n&gt; parameterized tests as well as theories. I imagine that was the idea behind\n&gt; ParameterSupplier?\n&gt;\n&gt; Sadly, ParameterSupplier only applies to one parameter at a time, but\n&gt; I could imagine a unified API that included interfaces for both.\n&gt;\n&gt; David\n&gt;\n&gt;\n&gt; &gt;\n&gt; &gt; ________________________________\n&gt; &gt;\n&gt; &gt; From: junit@yahoogroups.com &lt;mailto:junit%40yahoogroups.com&gt;  &lt;junit%40yahoogroups.com&gt; on behalf of Mike\n&gt; Forsberg\n&gt; &gt; Sent: Sun 3/14/2010 12:15 PM\n&gt; &gt; To: junit@yahoogroups.com &lt;mailto:junit%40yahoogroups.com&gt;  &lt;junit%40yahoogroups.com&gt;; Shin Hwei Tan; Sang\n&gt; Y Baik\n&gt; &gt; Subject: Re: [junit] Re: @DataPoints called several times for Theories\n&gt; &gt;\n&gt; &gt;\n&gt; &gt;\n&gt; &gt;\n&gt; &gt; Please feel free to join the mailing list. I would find the discussion\n&gt; &gt; interesting and wish it would not run offline.\n&gt; &gt;\n&gt; &gt; Big Mike\n&gt; &gt;\n&gt; &gt; On Fri, Mar 12, 2010 at 6:44 PM, Brett Daniel &lt;brettdaniel@... &lt;mailto:brettdaniel%40gmail.com&gt; &lt;brettdaniel%40gmail.com&gt;&lt;mailto:\n&gt; brettdaniel%40gmail.com &lt;brettdaniel%2540gmail.com&gt;&gt; &gt; wrote:\n&gt; &gt;\n&gt; &gt;&gt;\n&gt; &gt;&gt;\n&gt; &gt;&gt; The undergrads I am advising recently pushed a patch that addresses the\n&gt; &gt;&gt; issue of mutable data points.\n&gt; &gt;&gt;\n&gt; &gt;&gt;\n&gt; &gt;&gt;\n&gt; http://github.com/stan6/junit/commit/dcfa3c41446c469a4edc7513e9e7a9b610b04020 &lt;http://github.com/stan6/junit/commit/dcfa3c41446c469a4edc7513e9e7a9b610b04020&gt; &lt;\n&gt; http://github.com/stan6/junit/commit/dcfa3c41446c469a4edc7513e9e7a9b610b04020 &lt;http://github.com/stan6/junit/commit/dcfa3c41446c469a4edc7513e9e7a9b610b04020&gt; \n&gt; &gt;\n&gt; &gt;&gt;\n&gt; &gt;&gt; The patch allows developers to define &quot;copy strategies&quot; that duplicate\n&gt; &gt;&gt; marked data points before every theory execution. In this way, every\n&gt; &gt;&gt; execution receives a pristine data point, which removes the problems\n&gt; caused\n&gt; &gt;&gt; when a theory mutates data points. This is orthogonal to datapoint\n&gt; &gt;&gt; (re)creation, but I think copy strategies may help address the bug that\n&gt; &gt;&gt; Berin found.\n&gt; &gt;&gt;\n&gt; &gt;&gt; The patch creates a new, optional &quot;copyStrategy&quot; parameter for the\n&gt; &gt;&gt; @DataPoint and @DataPoints annotations. If the developer wants to copy\n&gt; data\n&gt; &gt;&gt; points, he or she sets the parameter to a class implementing a new\n&gt; &gt;&gt; CopyStrategy interface.\n&gt; &gt;&gt;\n&gt; &gt;&gt; Here is an example:\n&gt; &gt;&gt;\n&gt; &gt;&gt; @RunWith(Theories.class)\n&gt; &gt;&gt; public class TestMutable {\n&gt; &gt;&gt;\n&gt; &gt;&gt; @DataPoint(copyStrategy = MutableWithCopyStrategy.class)\n&gt; &gt;&gt; public static Mutable mutable = new Mutable();\n&gt; &gt;&gt;\n&gt; &gt;&gt; @Theory\n&gt; &gt;&gt; public static testMutate(Mutable a) {\n&gt; &gt;&gt; a.mutate();\n&gt; &gt;&gt; }\n&gt; &gt;&gt;\n&gt; &gt;&gt; @Theory\n&gt; &gt;&gt; public static testNotMutated(Mutable a) {\n&gt; &gt;&gt; assertFalse(a.isMutated());\n&gt; &gt;&gt; }\n&gt; &gt;&gt; }\n&gt; &gt;&gt;\n&gt; &gt;&gt; In the current implementation of JUnit, the second theory may fail\n&gt; because\n&gt; &gt;&gt; the first theory mutates the datapoint. With a copy strategy enabled,\n&gt; both\n&gt; &gt;&gt; theories receive a new value.\n&gt; &gt;&gt;\n&gt; &gt;&gt; Strategies can do almost anything: clone the data point, call a factory\n&gt; &gt;&gt; method, or--as in the following implementation--instantaiate a new\n&gt; object\n&gt; &gt;&gt; with a copy constructor.\n&gt; &gt;&gt;\n&gt; &gt;&gt; public class MutableWithCopyStrategy implements CopyStrategy {\n&gt; &gt;&gt; public Object copyDataPoint(Object toCopy) throws Exception {\n&gt; &gt;&gt; return new Mutable((Mutable)toCopy);\n&gt; &gt;&gt; }\n&gt; &gt;&gt; }\n&gt; &gt;&gt;\n&gt; &gt;&gt; There are several benefits to this implementation. First, the new\n&gt; parameter\n&gt; &gt;&gt; is completely optional; if it is omitted, the theory runner behaves as\n&gt; it\n&gt; &gt;&gt; always has. Second, it doesn&#39;t require modifying the data point&#39;s class\n&gt; &gt;&gt; (for\n&gt; &gt;&gt; example, to add a copy constructor or clone method). Most importantly,\n&gt; it\n&gt; &gt;&gt; makes it clear to the tester that without a copy strategy one theory\n&gt; &gt;&gt; execution can impact another.\n&gt; &gt;&gt;\n&gt; &gt;&gt; I have CC&#39;d the two students in this email. Please direct any questions\n&gt; to\n&gt; &gt;&gt; them.\n&gt; &gt;&gt;\n&gt; &gt;&gt; Brett\n&gt; &gt;&gt;\n&gt; &gt;&gt;\n&gt; &gt;&gt; On Thu, Feb 18, 2010 at 5:28 PM, Berin &lt;berin.loritsch@... &lt;mailto:berin.loritsch%40gd-ais.com&gt; &lt;berin.loritsch%40gd-ais.com&gt;&lt;mailto:\n&gt; berin.loritsch%40gd-ais.com &lt;berin.loritsch%2540gd-ais.com&gt;&gt;\n&gt; &lt;berin.loritsch%40gd-ais.com&gt;&gt;\n&gt; &gt;&gt; wrote:\n&gt; &gt;&gt;\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; I agree with your prognosis, about fresh data points for testing the\n&gt; &gt;&gt; &gt; theories. That is precisely why I proposed reading them once, and\n&gt; cloning\n&gt; &gt;&gt; &gt; them (making a copy) as needed for each theory. With that approach we\n&gt; &gt;&gt; even\n&gt; &gt;&gt; &gt; get the protection from mutated data points when you use the\n&gt; @DataPoint\n&gt; &gt;&gt; to\n&gt; &gt;&gt; &gt; mark a static field.\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; Cloning is a much quicker operation, does not execute any\n&gt; constructors.\n&gt; &gt;&gt; It\n&gt; &gt;&gt; &gt; merely copies the contents of the object memory verbatim.\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; With the current implementation, if you are not prepared for the\n&gt; &gt;&gt; &gt; combinatorial affect of 60 data points combined with 60 data points\n&gt; for\n&gt; &gt;&gt; each\n&gt; &gt;&gt; &gt; theory there is a major disconnect. The majority of the overhead in\n&gt; this\n&gt; &gt;&gt; &gt; particular scenario has to do with creating objects (with the\n&gt; additional\n&gt; &gt;&gt; &gt; overhead of doing it by reflection).\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; When I created only one instance of each class instead of two, the\n&gt; &gt;&gt; &gt; performance was twice as fast (i.e. 37 seconds down to about 16\n&gt; seconds).\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; Essentially the number of times your @DataPoints method is called\n&gt; depends\n&gt; &gt;&gt; &gt; on the number of parameters in your @Theory and how many theories you\n&gt; &gt;&gt; have.\n&gt; &gt;&gt; &gt; Essentially the formula for my theory (ha, ha) of the execution is\n&gt; like\n&gt; &gt;&gt; &gt; this:\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; N^(p-1) + 1\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; where:\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; N is the number of data points returned by the method\n&gt; &gt;&gt; &gt; p is the number of parameters\n&gt; &gt;&gt; &gt; and the + 1 represents the run where the data point is read the first\n&gt; &gt;&gt; time\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; So for 60 data points it is run 61 times for two parameters. With\n&gt; three\n&gt; &gt;&gt; &gt; parameters it would be called 3601 times. I have to verify with three\n&gt; &gt;&gt; &gt; parameters. The theory is called N^p times for sure and that is\n&gt; expected.\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; With the above formula, the mapping of number of calls to parameters\n&gt; for\n&gt; &gt;&gt; 60\n&gt; &gt;&gt; &gt; data points would be:\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; 1 -&gt; 2 (I know this is wrong which gives me doubts on the formula)\n&gt; &gt;&gt; &gt; 2 -&gt; 61\n&gt; &gt;&gt; &gt; 3 -&gt; 3601\n&gt; &gt;&gt; &gt; 3 -&gt; 216001\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; Essentially when the Assignments class needs to make the combinations,\n&gt; it\n&gt; &gt;&gt; &gt; will collect the data points initially for each theory. It then calls\n&gt; the\n&gt; &gt;&gt; &gt; data points again for each existing data point it collected from the\n&gt; &gt;&gt; first\n&gt; &gt;&gt; &gt; read. With a third parameter it would take all those combinations\n&gt; again,\n&gt; &gt;&gt; to\n&gt; &gt;&gt; &gt; add all the permutations for the next round.\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; I might be wrong and the real formula would be like this:\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; N^0 + N^1 ... + N^(p-1)\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; If this is the correct formula, then if you have 60 data points the\n&gt; &gt;&gt; number\n&gt; &gt;&gt; &gt; of times the method is called would map to the number of parameters\n&gt; like\n&gt; &gt;&gt; &gt; this:\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; 1 -&gt; 1\n&gt; &gt;&gt; &gt; 2 -&gt; 61\n&gt; &gt;&gt; &gt; 3 -&gt; 3661\n&gt; &gt;&gt; &gt; 4 -&gt; 219661\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; --- In junit@yahoogroups.com &lt;mailto:junit%40yahoogroups.com&gt;  &lt;junit%40yahoogroups.com&gt; &lt;mailto:\n&gt; junit%40yahoogroups.com &lt;junit%2540yahoogroups.com&gt;&gt; &lt;junit%\n&gt; 40yahoogroups.com&gt; &lt;junit%\n&gt; &gt;&gt; 40yahoogroups.com&gt;, Brett Daniel\n&gt; &gt;&gt;\n&gt; &gt;&gt; &gt; &lt;brettdaniel@...&gt; wrote:\n&gt; &gt;&gt; &gt; &gt;\n&gt; &gt;&gt; &gt; &gt; Berin,\n&gt; &gt;&gt; &gt; &gt;\n&gt; &gt;&gt; &gt; &gt; When a theory mutates data points, it might be beneficial to\n&gt; recreate\n&gt; &gt;&gt; &gt; &gt; the data point for every theory invocation. Doing so prevents one\n&gt; &gt;&gt; &gt; &gt; theory execution from affecting others. I wrote about this issue in\n&gt; &gt;&gt; &gt; &gt; the following weblog post:\n&gt; &gt;&gt; &gt; &gt;\n&gt; &gt;&gt; &gt; &gt; http://www.brettdaniel.com/archives/2009/09/24/200845/ &lt;http://www.brettdaniel.com/archives/2009/09/24/200845/&gt;  &lt;\n&gt; http://www.brettdaniel.com/archives/2009/09/24/200845/ &lt;http://www.brettdaniel.com/archives/2009/09/24/200845/&gt; &gt;\n&gt; &gt;&gt; &gt; &gt;\n&gt; &gt;&gt; &gt; &gt; You are correct, though, that copying would avoid some of the\n&gt; overhead\n&gt; &gt;&gt; &gt; &gt; in calling datapoint methods. It is interesting you mention this\n&gt; idea,\n&gt; &gt;&gt; &gt; &gt; because I am currently overseeing two students who for their senior\n&gt; &gt;&gt; &gt; &gt; thesis project are implementing framework for copying datapoints. I\n&gt; &gt;&gt; &gt; &gt; will post more information to the mailing list as the project\n&gt; &gt;&gt; &gt; &gt; continues.\n&gt; &gt;&gt; &gt; &gt;\n&gt; &gt;&gt; &gt; &gt; Brett\n&gt; &gt;&gt; &gt; &gt;\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt;\n&gt; &gt;&gt; [Non-text portions of this message have been removed]\n&gt; &gt;&gt;\n&gt; &gt;&gt;\n&gt; &gt;&gt;\n&gt; &gt;\n&gt; &gt; [Non-text portions of this message have been removed]\n&gt; &gt;\n&gt; &gt;\n&gt; &gt;\n&gt; &gt;\n&gt; &gt;\n&gt; &gt;\n&gt; &gt; [Non-text portions of this message have been removed]\n&gt; &gt;\n&gt; &gt;\n&gt; &gt;\n&gt; &gt; ------------------------------------\n&gt; &gt;\n&gt; &gt; Yahoo! Groups Links\n&gt; &gt;\n&gt; &gt;\n&gt; &gt;\n&gt; &gt;\n&gt; \n&gt;\n\n[Non-text portions of this message have been removed]\n\n\n\n\n\n\n[Non-text portions of this message have been removed]\n\n\n", 
    "profile": "bloritsch", 
    "topicId": 22425, 
    "spamInfo": {
        "reason": "4", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 428096731, 
    "prevInTime": 22548, 
    "contentTrasformed": false, 
    "postDate": "1268679252", 
    "canDelete": false, 
    "nextInTopic": 22550, 
    "prevInTopic": 22548, 
    "headers": {
        "messageIdInHeader": "PDc1RjVFRDhBNUE1NTM2NDZBNDZFMDBFNkVDODU0RkEzMDM3OEM3RUVAdmFmZjAxLW1haWwwMS5hZC5nZC1haXMuY29tPg==", 
        "referencesHeader": "PDU4ZGJhMjI1MTAwMjE4MDk0M3EyMzhkZDhkdjExYWI0ODczNjMyMWUxNzhAbWFpbC5nbWFpbC5jb20+PGhsa2lmMiszbXRlQGVHcm91cHMuY29tPjw1OGRiYTIyNTEwMDMxMjE1NDRwM2NkN2RkMjhoMWE4OTljZTY1N2Y2NmFkM0BtYWlsLmdtYWlsLmNvbT48YTUyN2ZkZGYxMDAzMTQwOTE1bDczNzYxZWUxcjc4MWJhMjBmYzc2OGU0MmVAbWFpbC5nbWFpbC5jb20+PDc1RjVFRDhBNUE1NTM2NDZBNDZFMDBFNkVDODU0RkEzMDM3OEM3RTRAdmFmZjAxLW1haWwwMS5hZC5nZC1haXMuY29tPjw0ZjdkYTZiOTEwMDMxNTA2NTFtMTJmMjc5NmtmOWFhYjE3ZmYzMTJjZDkzQG1haWwuZ21haWwuY29tPiA8NThkYmEyMjUxMDAzMTUxMDU2azRiZjI0ZmYyeGYxNjFlNjQxNWFiZjRhYmFAbWFpbC5nbWFpbC5jb20+"
    }
}