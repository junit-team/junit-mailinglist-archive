{
    "numMessagesInTopic": 32, 
    "nextInTime": 13251, 
    "senderId": "Z7zm4LRzlEMDobrtKrw_-XV1pT5sOhF1oEdYQQ-eYrLQWSCEtbv1wKYS9b7X0UvbT0BxypeKyf9qZfbKV04gz15ftjfz0A", 
    "systemMessage": false, 
    "subject": "RE: [junit] How does Unit test in a heirarchy works...", 
    "from": "&quot;Ilja Preuss&quot; &lt;preuss@...&gt;", 
    "authorName": "Ilja Preuss", 
    "msgSnippet": "... Don t know what JAK means, and acronymfinder doesn t either... :o Anyway, in my opinion it already is too deep for a sound OO design. ... Why not? I find", 
    "msgId": 13250, 
    "profile": "ipreussde", 
    "topicId": 13233, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 96623270, 
    "messageBody": "<div id=\"ygrps-yiv-1436831992\">Arun J wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; JAK: as I have mentioned this heirarchy is just a sample...in<br/>\n&gt; reality it could be even deeper.<br/>\n<br/>\n </span></blockquote>Don&#39;t know what &quot;JAK&quot; means, and acronymfinder doesn&#39;t either... :o<br/>\n<br/>\nAnyway, in my opinion it already is too deep for a sound OO design.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Let us not question the design for<br/>\n&gt; testing.. <br/>\n<br/>\n </span></blockquote>Why not? I find it to be very valuable to do so.<br/>\n<br/>\nAnyway, if you don&#39;t want to question the design, I think we already<br/>\nprovided solutions to make it possible with Junit. As it&#39;s not the preferred<br/>\nway of working for many Junit users, I think it&#39;s reasonable that the<br/>\nsolution isn&#39;t part of Junit&#39;s core.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; At<br/>\n&gt; different levels it looks up and initializes the composite objects<br/>\n&gt; for that level. Derivatives uses them sometimes or overrides<br/>\n&gt; depending on their needs. <br/>\n<br/>\n </span></blockquote>I see two issues here:<br/>\n<br/>\nFirst, objects are complex. The general advice here is to simplify them. Use<br/>\ncomposition to build a complex web of objects to provide complex behaviour.<br/>\nIn your unit tests, don&#39;t write many tests for the complex web, but for<br/>\nsimple objects it is composed of. Where an object in the web needs to<br/>\ncollaborate with other objects in the web, in your unit tests replace them<br/>\nwith stub/mock implementations.<br/>\n<br/>\nOr, if you think you can&#39;t do that, google for the Object Mother pattern.<br/>\n<br/>\nSecond, I understood you to say that you are reusing objects between tests,<br/>\nso only the first test using an object would instantiate it, the following<br/>\nwould reuse it. Generally, this is a big no-no in unit testing, and I&#39;d like<br/>\nto understand why you think you need to do it.<br/>\n<br/>\n <br/>\n<blockquote><span title=\"ireply\"> &gt;&gt;  So are you saying the Bizdoc objects are global to the tests? What<br/>\n&gt;&gt; does it  mean to &quot;initialize&quot; them? Where are the hold?<br/>\n&gt;&gt; <br/>\n&gt; BizDoc is the System object and BizDocUt is Unit test class<br/>\n&gt; which tests the BizDoc operations/API. Here Parent(s) can<br/>\n&gt; have any name which extends TestCase and BizDocUt and other<br/>\n&gt; tests would inherit and use them as just parents .  These<br/>\n&gt; parent(s) will not have testXXX methods.<br/>\n<br/>\n </span></blockquote>I don&#39;t feel that this answers my question. Perhaps my writings above help<br/>\nyou understand where my question is coming from...<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt;  Frankly, no, I don&#39;t feel it is. It rather looks to me as if your<br/>\n&gt;&gt; design is  suboptimal, and that your testing problems are just a<br/>\n&gt;&gt; symptom of that. I  don&#39;t know enough to be sure, though.<br/>\n&gt;&gt; <br/>\n&gt; System design is for meeting the requirement not meeting the<br/>\n&gt; testing requirement. When we are writing test cases at the<br/>\n&gt; lower level (API testing) we can&#39;t expect a seperate set of API for<br/>\n&gt; testing purpose only. <br/>\n<br/>\n </span></blockquote>Not a separate API. What I&#39;m saying is that many people experience that<br/>\nmaking the API testable improves the design in general. With other words,<br/>\nmeeting unit testing requirements is a great help in meeting the general<br/>\nrequirement of producing a flexible and extensible design.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt;  If you want, you can write a TestSuite implementation that uses<br/>\n&gt;&gt; reflection  to only call the test methods declared directly in a<br/>\n&gt;&gt; class (that is, not the  inherited ones). I think it would take me<br/>\n&gt;&gt; less than an hour to do so. In  years of using Junit, I never felt<br/>\n&gt;&gt; the need to do that, though. <br/>\n&gt;&gt; <br/>\n&gt; I understand you have not encountered this before and that is<br/>\n&gt; the reason why I have explained a scenario which needs this.<br/>\n<br/>\n </span></blockquote>Let me clarify: I certainly encountered code that was hard to test using<br/>\nJunit. My solution until now always was to improve the code, not to extend<br/>\nJunit, though. And I wholeheartedly think it was the better solution.<br/>\n<br/>\nCheers, Ilja</div>", 
    "prevInTime": 13249, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1112958793", 
    "canDelete": false, 
    "nextInTopic": 13251, 
    "prevInTopic": 13249, 
    "headers": {
        "inReplyToHeader": "PGU3MTczMzBlMDUwNDA4MDIwMzZjNWU2MDJAbWFpbC5nbWFpbC5jb20+", 
        "messageIdInHeader": "PDAwNmQwMWM1M2MyYiRmNGMxNWI2MCQ3MDY0YThjMEBkaXN5Lm5ldD4="
    }
}