{
    "numMessagesInTopic": 3, 
    "nextInTime": 17123, 
    "senderId": "j5Q8q-aPbAERWSYYOFYygZG7-m9XyMhBRy8xMRIbpJu_LM7k9SRdC3-Fbrt6IgznwByd92JPJeyuiptk8STG6P3lboFHLVsnHeE", 
    "systemMessage": true, 
    "subject": "non static method testing with JUnit", 
    "from": "Kamal Ahmed &lt;KAhmed@...&gt;", 
    "authorName": "Kamal Ahmed", 
    "msgSnippet": "Hi, Is there a special way to test non static methods with JUnit? Or they are treated the same way as static methods. Here is the reason why I asked this", 
    "msgId": 17122, 
    "topicId": 17122, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 253370470, 
    "messageBody": "<div id=\"ygrps-yiv-664682608\">Hi,<br/>\n<br/>\nIs there a special way to test non static methods with JUnit? Or they are<br/>\ntreated the same way as static methods.<br/>\n<br/>\nHere is the reason why I asked this question. After reading this article<br/>\n(below). It is rather &quot;back to basics&quot; but sometimes I find it useful to go<br/>\nto &quot;root&quot;<br/>\n<br/>\nMr. Happy Object teaches static methods<br/>\nWhen to choose static methods over instance methods<br/>\n<br/>\nBy Tony Sintes<br/>\n<br/>\n<br/>\nNovember 21, 2001<br/>\n<br/>\nQ) When would you create static methods as opposed to instance methods? I<br/>\nunderstand that static methods allow you to use those methods without having<br/>\nto create an instance of that class, and that class methods apply to the<br/>\nclass rather than an object. Are these the only reasons? Could you give an<br/>\nexample of a case where you would use a class method over an instance<br/>\nmethod?<br/>\n<br/>\nA) Many Java developers find it confusing to decide when, and when not to<br/>\ndeclare a method as static. However, making the choice is simple if you have<br/>\na clear understanding of the difference between a class method and an<br/>\ninstance method.<br/>\n<br/>\nNote: You can download the source code that accompanies this article from<br/>\nResources.<br/>\n<br/>\nConsider the following class definition:<br/>\n<br/>\n<br/>\npublic class MrHappyObject {<br/>\n<br/>\n    private String _mood = _HAPPY;<br/>\n<br/>\n    private final static String _HAPPY   = &quot;happy&quot;;<br/>\n    private final static String _ANNOYED = &quot;annoyed&quot;;<br/>\n    private final static String _ANGRY   = &quot;angry&quot;;<br/>\n<br/>\n    public void printMood() {<br/>\n        System.out.println( &quot;I am &quot; + _mood );<br/>\n    }<br/>\n<br/>\n    public void receivePinch() {<br/>\n        if( _mood.equals( _HAPPY ) ) {<br/>\n            _mood = _ANNOYED;<br/>\n        } else {<br/>\n            _mood = _ANGRY;<br/>\n        }<br/>\n    }<br/>\n<br/>\n    public void receiveHug() {<br/>\n        if( _mood.equals( _ANGRY ) ) {<br/>\n            _mood = _ANNOYED;<br/>\n} else {<br/>\n            _mood = _HAPPY;<br/>\n        }<br/>\n    }<br/>\n}<br/>\n<br/>\n<br/>\nFigure 1. Mr. Happy Object<br/>\n<br/>\nFirst, before I get emails about it, there are more object-oriented ways to<br/>\ntrack and transition between states. However, those fancy ways would detract<br/>\nfrom the intent of the example. Now, without further ado...<br/>\n<br/>\nprintMood(), receivePinch(), and receiveHug() are all instance methods.<br/>\nSyntactically, you call these methods instance methods because they are not<br/>\nstatic; but the important distinction concerns why I didn&#39;t declare them as<br/>\nstatic.<br/>\n<br/>\nInstance methods are instance methods because they rely on the state of the<br/>\nspecific object instance. Instance methods are tied to a particular instance<br/>\nbecause the behavior that the method invokes relies upon the state of that<br/>\nparticular instance.<br/>\n<br/>\nConsider the following example:<br/>\n<br/>\n<br/>\nMrHappyObject obj1 = new MrHappyObject();<br/>\nMrHappyObject obj2 = new MrHappyObject();<br/>\n<br/>\nobj1.printMood();<br/>\nobj2.printMood();<br/>\n<br/>\nWhen obj1 and obj2 first instantiate, they have the same state -- they are<br/>\nborn happy. As a result, when the printMood() is called on each instance,<br/>\neach object prints &quot;I am happy&quot; to the screen. However, every object<br/>\ninstance has its own state that can vary independently of all other<br/>\ninstances of that class of object.<br/>\n<br/>\nAs obj1 and obj2 go through their day, their states can vary independently<br/>\nfrom one another. Here I hug obj1 and pinch obj2:<br/>\n<br/>\n<br/>\nobj1.receiveHug();<br/>\nobj2.receivePinch();<br/>\n<br/>\nobj1.printMood();<br/>\nobj2.printMood();<br/>\n<br/>\nNow when I query each instance&#39;s mood, obj1 is happy while obj2 is annoyed.<br/>\nWhile the example is silly, it drives home a point: Every instance possesses<br/>\nits own state, and that state is independent of every other object. Any<br/>\nmethod whose behavior depends upon the particular state of a particular<br/>\ninstance is an instance method. You should not declare such a method as<br/>\nstatic.<br/>\n<br/>\nWhen you declare a method as static, you define that method as being a class<br/>\nmethod. A class method applies to the class as opposed to any particular<br/>\ninstance. The behavior instigated by a class method does not rely on the<br/>\nstate of a particular instance. In fact, a static method cannot rely on an<br/>\ninstance&#39;s state since static methods lack access to this reference.<br/>\nInstead, the behavior of a class method either depends on a state that all<br/>\nobjects share at the class level, or is independent of any state at all.<br/>\n<br/>\nLet&#39;s add the following definitions to the original MrHappyObject:<br/>\n<br/>\n<br/>\nprivate static int _instantiations;<br/>\n<br/>\npublic MrHappyObject() {<br/>\n_instantiations++;<br/>\n}<br/>\n<br/>\npublic static int instances() {<br/>\nreturn _instantiations;<br/>\n}<br/>\n<br/>\ninstances() is a static method. The instances() method returns the number of<br/>\nMrHappyObjects that have been created. The number of instantiations is<br/>\nindependent of any particular MrHappyObject. Instead, MrHappyObject tracks<br/>\nthe number of instantiations at the class level.<br/>\n<br/>\nAgain, this example is a bit contrived but it demonstrates an important<br/>\nlesson: Class methods instigate behavior that is independent of instance<br/>\nstate. instances() returns the number of instances regardless of whether<br/>\nobj1 is happy and obj2 is annoyed. The instance state is simply irrelevant.<br/>\nAny method that is independent of instance state is a candidate for being<br/>\ndeclared as static.<br/>\n<br/>\nNote that I say &quot;candidate for being declared as static.&quot; Even in the<br/>\nprevious example nothing forces you to declare instances() as static.<br/>\nDeclaring it as static just makes it more convenient to call since you do<br/>\nnot need an instance to call the method. Sometimes you will have methods<br/>\nthat don&#39;t seem to rely on instance state. You might not want to make these<br/>\nmethods static. In fact you&#39;ll probably only want to declare them as static<br/>\nif you need to access them without an instance.<br/>\n<br/>\nMoreover, even though you can declare such a method as static, you might not<br/>\nwant to because of the inheritance issues that it interjects into your<br/>\ndesign. Take a look at &quot;Effective Object-Oriented Design&quot; to see some of the<br/>\nissues that you will face.<br/>\n<br/>\nAnyway, simply counting the number of instantiations is a fairly useless<br/>\nexample -- it&#39;s probably not something you will do in your day-to-day<br/>\ncoding. However, sometimes you will want to use statics.<br/>\n<br/>\nStatic methods prove useful for creating utility classes and factory<br/>\nmethods. (See &quot;Factory Methods&quot; for more information.)<br/>\n<br/>\nA utility class simply contains static methods and no public constructor.<br/>\nUtility classes are not meant to be instantiated. As Joshua Bloch points out<br/>\nin Effective Java Programming Language Guide, utility classes have earned a<br/>\nbad reputation because they are easily abused and can lead to procedural<br/>\nprogramming.<br/>\n<br/>\nHowever, utility classes do have valid uses. Take a look at java.lang.Math,<br/>\njava.util.Arrays, and java.util.Collections; each is a utility class. These<br/>\nutilities group related methods on primitive values, arrays, and interfaces.<br/>\nThese related methods are placed in these utility classes since they cannot<br/>\ngo anywhere else (you can&#39;t place methods into a primitive, array, or<br/>\ninterface after all!).<br/>\n<br/>\nUtility classes have another use. Sometimes you cannot extend a class<br/>\nbecause it is declared final. Utility classes are an excellent place to put<br/>\nmethods that you would have otherwise put into a subclass.<br/>\n<br/>\n<br/>\nAbout the author<br/>\nTony Sintes is an independent consultant and founder of First Class<br/>\nConsulting, Inc., a consulting firm that specializes in the bridging of<br/>\ndisparate enterprise systems and training. Outside of First Class<br/>\nConsulting, Tony is an active freelance writer as well as author of Sams<br/>\nTeach Yourself Object-Oriented Programming in 21 Days (Sams, 2001; ISBN:<br/>\n0672321092).<br/>\n<br/>\nThanks,<br/>\n-Kamal.</div>", 
    "prevInTime": 17121, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1152648230", 
    "canDelete": false, 
    "nextInTopic": 17124, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PEM0Qjg4MDA5OEFBNjhCNENCNEEwQjgyQjE0MTlBNDYwMDExMkQ5NUZAbWFpbHZhPg=="
    }
}