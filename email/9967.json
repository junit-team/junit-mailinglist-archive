{
    "numMessagesInTopic": 23, 
    "nextInTime": 9968, 
    "senderId": "DzeZqzjIGttNoj_RfF16hBYpWTu73im4SU_HFVGq41j4C8g-XnP2nfq3gV-cmhAVKF1tVZ4wq9VDyNNxJfz5nUNTlGAyt3swyD92YSEQZw", 
    "systemMessage": false, 
    "subject": "Re: [junit] Parameterized Test Case example", 
    "from": "&quot;J. B. Rainsberger&quot; &lt;jbrains@...&gt;", 
    "authorName": "J. B. Rainsberger", 
    "msgSnippet": "... I override run test because I don t want JUnit to force me to set the test name to the name of the test method I want to invoke. There s only one test, so", 
    "msgId": 9967, 
    "profile": "nails762", 
    "topicId": 9954, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 127224993, 
    "messageBody": "<div id=\"ygrps-yiv-554147191\">Mike Clark wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; <br/>\n&gt; On Nov 20, 2003, at 2:19 PM, J. B. Rainsberger wrote:<br/>\n&gt; <br/>\n&gt;  &gt; This is what I mean by a parameterized test case. The feature<br/>\n&gt;  &gt; &quot;calculate<br/>\n&gt;  &gt; a person&#39;s age by a given date.&quot; Each test is a single assertion, but<br/>\n&gt;  &gt; since only the data changes, this test is data-driven, rather than<br/>\n&gt;  &gt; duplicating the invocation of &quot;getAgeAsOf()&quot; in five tests.<br/>\n&gt;  &gt;<br/>\n&gt;  &gt; -------------------<br/>\n&gt;  &gt; package ca.bluejays.scouting.amateur.model.test;<br/>\n&gt;  &gt;<br/>\n&gt;  &gt; import java.util.Date;<br/>\n&gt;  &gt;<br/>\n&gt;  &gt; import junit.framework.*;<br/>\n&gt;  &gt; import XXX.BiographicalReport;<br/>\n&gt;  &gt; import XXX.PlayerFactory;<br/>\n&gt;  &gt;<br/>\n&gt;  &gt; import com.diasparsoftware.java.util.DateUtil;<br/>\n&gt;  &gt;<br/>\n&gt;  &gt; public class CalculateAgeTest extends TestCase {<br/>\n&gt;  &gt;      private int expectedAge;<br/>\n&gt;  &gt;      private Date futureDate;<br/>\n&gt;  &gt;<br/>\n&gt;  &gt;      public CalculateAgeTest(String testName, int expectedAge,<br/>\n&gt;  &gt;              Date futureDate) {<br/>\n&gt;  &gt;<br/>\n&gt;  &gt;          super(testName);<br/>\n&gt;  &gt;          this.expectedAge = expectedAge;<br/>\n&gt;  &gt;          this.futureDate = futureDate;<br/>\n&gt;  &gt;      }<br/>\n&gt;  &gt;<br/>\n&gt;  &gt;      public static Test suite() {<br/>\n&gt;  &gt;          TestSuite suite = new TestSuite(&quot;Calculate Age&quot;);<br/>\n&gt;  &gt;          suite.addTest(new CalculateAgeTest(&quot;birthday&quot;, 30, DateUtil<br/>\n&gt;  &gt;                  .makeDate(2004, 5, 4)));<br/>\n&gt;  &gt;          suite.addTest(new CalculateAgeTest(&quot;day before birthday&quot;, 29,<br/>\n&gt;  &gt;                  DateUtil.makeDate(2004, 5, 3)));<br/>\n&gt;  &gt;          suite.addTest(new CalculateAgeTest(&quot;day after birthday&quot;, 30,<br/>\n&gt;  &gt;                  DateUtil.makeDate(2004, 5, 5)));<br/>\n&gt;  &gt;          suite.addTest(<br/>\n&gt;  &gt;                  new CalculateAgeTest(&quot;date of birth&quot;, 0, DateUtil<br/>\n&gt;  &gt;                          .makeDate(1974, 5, 4)));<br/>\n&gt;  &gt;          suite.addTest(<br/>\n&gt;  &gt;                  new CalculateAgeTest(&quot;invalid future date&quot;, 0,<br/>\n&gt;  &gt; DateUtil<br/>\n&gt;  &gt;                          .makeDate(1974, 5, 3)));<br/>\n&gt;  &gt;          return suite;<br/>\n&gt;  &gt;      }<br/>\n&gt;  &gt;<br/>\n&gt;  &gt;      protected void runTest() throws Exception {<br/>\n&gt;  &gt;          BiographicalReport biographicalReport = PlayerFactory<br/>\n&gt;  &gt;                  .makeBiographicalReport(&quot;Joe&quot;, &quot;Rainsberger&quot;, DateUtil<br/>\n&gt;  &gt;                          .makeDate(1974, 5, 4));<br/>\n&gt;  &gt;<br/>\n&gt;  &gt;          assertEquals(new Integer(expectedAge), biographicalReport<br/>\n&gt;  &gt;                  .getAgeAsOf(futureDate));<br/>\n&gt;  &gt;      }<br/>\n&gt;  &gt; }<br/>\n&gt; <br/>\n&gt; Could you explain what overriding runTest() buys you over using<br/>\n&gt; something obvious like:<br/>\n&gt; <br/>\n&gt;      public void testCalculateAge() {<br/>\n&gt;           assertEquals(new Integer(expectedAge),<br/>\n&gt;               biographicalReport.getAgeAsOf(futureDate));<br/>\n&gt;      }<br/>\n&gt; <br/>\n&gt; where biographicalReport is an instance variable initialized in<br/>\n&gt; setUp().  As each run of the test method will be data-driven as<br/>\n&gt; intended, it would appear to do the same thing.<br/>\n<br/>\n </span></blockquote>I override run test because I don&#39;t want JUnit to force me to set the <br/>\ntest name to the name of the test method I want to invoke. There&#39;s only <br/>\none test, so why use reflection to get it?<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; I&#39;m guessing it has something to do with not wanting to create a<br/>\n&gt; BiographicalReport instance on every test method.  <br/>\n<br/>\n </span></blockquote>Well, you can&#39;t avoid that anyway. Each invocation of runTest() occurs <br/>\nin its own instance of TestCase.<br/>\n<br/>\n<blockquote><span title=\"ireply\">  &gt; At any rate, it<br/>\n&gt; seems to be reaching fairly deep in the trick bag and I&#39;m wondering<br/>\n&gt; what I&#39;m missing with the obvious approach.<br/>\n<br/>\n </span></blockquote>I avoid this constructor:<br/>\n<br/>\n       public CalculateAgeTest(String testName, int expectedAge,<br/>\n               Date futureDate) {<br/>\n<br/>\n           super(&quot;testCalculateAge&quot;);   &lt;&lt;&lt;&lt;&lt;<br/>\n           this.expectedAge = expectedAge;<br/>\n           this.futureDate = futureDate;<br/>\n       }<br/>\n<br/>\nAlso with the &quot;obvious&quot; approach, I can&#39;t tell one test from another: <br/>\nall the test names look the same. Which one failed?<br/>\n<br/>\nBy making the test name different from the test method name, I can use <br/>\nthe test name to report specifically which line of data led to a failing <br/>\ntest.<br/>\n-- <br/>\nJ. B. Rainsberger,<br/>\nDiaspar Software Services<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.diasparsoftware.com\">http://www.diasparsoftware.com</a> :: +1 416 791-8603<br/>\nLet&#39;s write software that people understand</div>", 
    "prevInTime": 9966, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1069372224", 
    "canDelete": false, 
    "nextInTopic": 9968, 
    "prevInTopic": 9966, 
    "headers": {
        "inReplyToHeader": "PDQ4RjdERTY4LTFCQUQtMTFEOC1COTNGLTAwMEE5NUE1NDdCQ0BjbGFya3dhcmUuY29tPg==", 
        "messageIdInHeader": "PDNGQkQ1MzQwLjEwMDA2MDlAcm9nZXJzLmNvbT4=", 
        "referencesHeader": "PDNGQkQyRkU2LjMwODAzMDlAcm9nZXJzLmNvbT4gPDQ4RjdERTY4LTFCQUQtMTFEOC1COTNGLTAwMEE5NUE1NDdCQ0BjbGFya3dhcmUuY29tPg=="
    }
}