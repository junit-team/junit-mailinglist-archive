{
    "numMessagesInTopic": 12, 
    "nextInTime": 22366, 
    "senderId": "GQq9HvRKFP1_4uMZb-LkdcSPuv4qWle6QOFCupxYEJL-9I70oJd07HiL91JLNl795apawKzU0mHKa_ogC8rlHptAKj8f-OuyHChwLHU2asfLwWSMuKp6", 
    "systemMessage": false, 
    "subject": "Theories Usability", 
    "from": "&quot;Loritsch, Berin C.&quot; &lt;berin.loritsch@...&gt;", 
    "authorName": "Loritsch, Berin C.", 
    "msgSnippet": "Thanks everyone for helping me work through the testing challenge I wanted to address.  I ve written a rudimentary ClassCollector that lets me specify a base", 
    "msgId": 22365, 
    "profile": "bloritsch", 
    "topicId": 22365, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 428096731, 
    "messageBody": "<div id=\"ygrps-yiv-938809376\">Thanks everyone for helping me work through the testing challenge I wanted to address.  I&#39;ve written a rudimentary ClassCollector that lets me specify a base package, what base classes I need, any annotations I need applied, etc.  I supplimented that with a BeanAttributes class that will collect all the attributes (setters/getters) on the class.  It&#39;s working very well.  Unfortunately, there are a few shortcomings with this approach:<br/>\n<br/>\n1. I cannot easily determine what the actual data point combination was that caused the failure.  I have to write those values out to System.out because the test failure does not do that for me.<br/>\n<br/>\n2. It stops on the very first failure, hiding many more failures that may still be lurking beneath the service.<br/>\n<br/>\n3. The theory is the only line shown in the test report, so there is no way to differentiate runs which would handle the above concerns.<br/>\n<br/>\nWhat I would really like to see is that a new test name for each combination of data points.  For example if you had a @Theory named &quot;checkAddWorks&quot; that took two parameters and the data points [1,2] then I&#39;d like to see a set of test names that look like this in the test report:<br/>\n<br/>\ncheckAddWorks(1,1)<br/>\ncheckAddWorks(1,2)<br/>\ncheckAddWorks(2,2)<br/>\n<br/>\nThat will address all of the shortcomings I identified.<br/>\n<br/>\nMy code looks like this:<br/>\n<br/>\n@RunWith(Theories.class)<br/>\nclass TestMyTrackableContract {<br/>\n    @DataPoints<br/>\n    BeanAttribute[] collectAllAttributesToTest() {<br/>\n        ClassCollector collector = new ClassCollector();<br/>\n        collector.within(&quot;com.mycompany.incident.model&quot;).assignableTo(Trackable.class);<br/>\n        Collection&lt;Class&lt;?&gt;&gt; matchedClasses = collector.recurse().collect();<br/>\n<br/>\n        List&lt;BeanAttribute&gt; attributes = new ArrayList&lt;BeanAttribute&gt;();<br/>\n\t\t<br/>\n        for (Class&lt;?&gt; trackable : matchedClasses) {<br/>\n            attributes.addAll(BeanAttribute.collectFrom(trackable));<br/>\n        }<br/>\n\t\t<br/>\n        return attributes.toArray(new BeanAttribute[attributes.size()]);<br/>\n    }<br/>\n<br/>\n    @Theory<br/>\n    public void checkSideEffectsOnAssign() throws Exception {<br/>\n        // This is designed to ensure that setters/getters work in concert<br/>\n        // and that setters set the appropriate message is sent<br/>\n        if ( ! beanAttribute.hasSetter() || ! beanAttribute.hasGetter() ) return;<br/>\n        beanAttribute.assertBalanced();<br/>\n<br/>\n        Trackable entity = beanAttribute.getEntityAs(Trackable.class);<br/>\n        // Unfortunately needed to determine when things go bad<br/>\n        System.out.format(&quot;Testing %s&#92;n&quot;, beanAttribute);<br/>\n\t\t<br/>\n        Object original = beanAttribute.getValue();<br/>\n        Object testValue = beanAttribute.generateTestValue(original);<br/>\n\t\t<br/>\n        // Ensure the setter works as expected<br/>\n        beanAttribute.setValue(testValue);<br/>\n        assertEquals(testValue, beanAttribute.getValue());<br/>\n\t\t<br/>\n        // Ensure properties are set and events were properly<br/>\n        Properties changes = entity.getChanges();<br/>\n        assertEquals( String.valueOf(testValue),<br/>\n            changes.getProperty(beanAttribute.getAttribute()));<br/>\n        assertEquals( String.valueOf(original),<br/>\n            changes.getProperty(beanAttribute.getAttribute() + &quot;.old&quot;));<br/>\n    }<br/>\n}<br/>\n<br/>\n<br/>\n[Non-text portions of this message have been removed]</div>", 
    "prevInTime": 22364, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1265401621", 
    "canDelete": false, 
    "nextInTopic": 22376, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PDc1RjVFRDhBNUE1NTM2NDZBNDZFMDBFNkVDODU0RkEzMDM3OEM3NkJAdmFmZjAxLW1haWwwMS5hZC5nZC1haXMuY29tPg=="
    }
}