{
    "numMessagesInTopic": 9, 
    "nextInTime": 5103, 
    "senderId": "V2DLRnu4gXUP2ph36_c3T27ZFtz8m34WaT9IvL5ErIQkr9WjCsuv1bNDxmr8F_vQ6HzP7j5tKy0A9gQ9IB_TCJGg6rfk6g", 
    "systemMessage": false, 
    "subject": "Re: Testing accessors...", 
    "from": "Mike Clark &lt;mike@...&gt;", 
    "authorName": "Mike Clark", 
    "msgSnippet": "I ve added J.B. s response below to the FAQ under the question Under what conditions should I not test get() and set() methods? . ... Under what conditions", 
    "msgId": 5102, 
    "rawEmail": "Return-Path: &lt;mike@...&gt;\r\nX-Sender: mike@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (EGP: mail-8_0_3_2); 5 Jun 2002 13:42:14 -0000\r\nReceived: (qmail 57251 invoked from network); 5 Jun 2002 13:42:14 -0000\r\nReceived: from unknown (66.218.66.217)\n  by m5.grp.scd.yahoo.com with QMQP; 5 Jun 2002 13:42:14 -0000\r\nReceived: from unknown (HELO dodo.mail.pas.earthlink.net) (207.217.120.99)\n  by mta2.grp.scd.yahoo.com with SMTP; 5 Jun 2002 13:42:14 -0000\r\nReceived: from clarkware.com (user-33qtoj2.dialup.mindspring.com [199.174.226.98])\n\tby dodo.mail.pas.earthlink.net (8.9.3/8.9.3) with ESMTP id GAA24777\n\tfor &lt;junit@yahoogroups.com&gt;; Wed, 5 Jun 2002 06:42:12 -0700 (PDT)\r\nMessage-ID: &lt;3CFE1483.70902@...&gt;\r\nDate: Wed, 05 Jun 2002 07:39:15 -0600\r\nOrganization: Clarkware Consulting, Inc.\r\nUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.0; en-US; rv:0.9.4.1) Gecko/20020314 Netscape6/6.2.2\r\nX-Accept-Language: en-us\r\nMIME-Version: 1.0\r\nTo: junit@yahoogroups.com\r\nSubject: Re: Testing accessors...\r\nReferences: &lt;1AA6971F96FADB4A96CF73E4729B05F155E5BD@...&gt; &lt;20020604104951.M24831@...&gt; &lt;3CFCF0C2.2030207@...&gt; &lt;20020604124537.M59207@...&gt;\r\nFrom: Mike Clark &lt;mike@...&gt;\r\nX-Yahoo-Group-Post: member; u=33026788\r\nX-Yahoo-Profile: clarkware\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\n\r\nI&#39;ve added J.B.&#39;s response below to the FAQ under the question &quot;Under \nwhat conditions should I not test get() and set() methods?&quot;.\n\nI also added an alternative view that goes something like this:\n\n----\n\nUnder what conditions should I test get() and set() methods?\n\nIn general, unit tests are meant to alleviate fear that something might \nbreak. If a get() or set() method could reasonably break, or has in fact \ncontributed to a defect, then by all means write a test for them. Be \npractical and remember to maximize your testing investment.\n\nRefer also to &quot;How simple is &#39;too simple to break&#39;? \n\n----\n\nIf there are viewpoints not represented in these entries, please feel \nfree to contribute.  Perhaps we can defer all related questions to the \nFAQ in the near future.\n\nMike\n\n\nJ. B. Rainsberger wrote:\n\n&gt;\n&gt;Most of the time, get/set methods just can&#39;t break, and if they can&#39;t break, \n&gt;then why test them? While it is usually better to test more, there is a \n&gt;definite curve of diminishing returns on test effort versus &quot;code coverage&quot;. \n&gt;Remember the maxim: &quot;Test until fear turns to boredom.&quot;\n&gt;\n&gt;Assume that the getX() method only does &quot;return x;&quot; and that the setX() \n&gt;method only does &quot;this.x = x;&quot;. If you write this test\n&gt;\n&gt;    testGetSetX() {\n&gt;        setX(23);\n&gt;        assertEquals(23, getX());\n&gt;    }\n&gt;\n&gt;then you are testing the equivalent of the following:\n&gt;\n&gt;    testGetSetX() {\n&gt;        x = 23;\n&gt;        assertEquals(23, x);\n&gt;    }\n&gt;\n&gt;or, if you prefer,\n&gt;\n&gt;    testGetSetX() {\n&gt;        assertEquals(23, 23);\n&gt;    }\n&gt;\n&gt;At this point, you are testing the Java compiler, or possibly the \n&gt;interpreter, and not your component or application. There is generally no \n&gt;need for you to do Java&#39;s testing for them.\n&gt;\n&gt;If you are concerned about whether a property has already been set at the \n&gt;point you wish to call getX(), then you want to test the constructor, and not \n&gt;the getX() method. This kind of test is especially useful if you have \n&gt;multiple constructors.\n&gt;\n&gt;    testCreate() {\n&gt;        assertEquals(23, new MyClass(23).getX());\n&gt;    }\n&gt;\n&gt;&gt;    Under what conditions should I test get() and set() methods?\n&gt;&gt;\n&gt;\n&gt;See &quot;How simple is &#39;too simple to break?&#39;&quot;\n&gt;\n&gt;[Later on...]\n&gt;\n&gt;Q. How simple is &#39;too simple to break?&#39;\n&gt;\n&gt;The general philosophy is this: if it can&#39;t break *on its own*, it&#39;s too \n&gt;simple to break.\n&gt;\n&gt;First example is the getX() method. Suppose the getX() method only answers \n&gt;the value of an instance variable. In that case, getX() cannot break unless \n&gt;either the compiler or the interpreter is also broken. For that reason, don&#39;t \n&gt;test getX(); there is no benefit. The same is true of the setX() method, \n&gt;although if your setX() method does any parameter validation or has any side \n&gt;effects, you likely need to test it.\n&gt;\n&gt;Next example: suppose you have written a method that does nothing but forward \n&gt;parameters into a method called on another object. That method is too simple \n&gt;to break.\n&gt;\n&gt;    public void myMethod(final int a, final String b) {\n&gt;        myCollaborator.anotherMethod(a, b);\n&gt;    }\n&gt;\n&gt;myMethod cannot possibly break, because it does nothing: it forwards its \n&gt;input to another object and that&#39;s all. \n&gt;\n&gt;The only precondition for this method is &quot;myCollaborator != null&quot;, but that \n&gt;is generally the responsibility of the constructor, and not of myMethod. If \n&gt;you are concerned, add a test to verify that myCollaborator is always set to \n&gt;something non-null by every constructor.\n&gt;\n&gt;The only way myMethod could break would be if myCollaborator#anotherMethod \n&gt;were broken. In that case, test myCollaborator, and not the current class.\n&gt;\n&gt;It is true that adding tests for even these simple methods guards against the \n&gt;possibility that someone refactors and makes the methods &quot;not-so-simple&quot; \n&gt;anymore. In that case, though, the refactorer needs to be aware that the \n&gt;method is now complex enough to break, and should write tests for it -- and \n&gt;preferably before the refactoring.\n&gt;\n&gt;Another example: suppose you have a JSP and, like a good programmer, you have \n&gt;removed all business logic from it. All it does is provide a layout for a \n&gt;number of JavaBeans and never does anything that could change the value of \n&gt;any object. That JSP is too simple to break, and since JSPs are notoriously \n&gt;annoying to test, you should strive to make all your JSPs too simple to break.\n&gt;\n&gt;--\n&gt;J. B. Rainsberger,\n&gt;President, Diaspar Software Services\n&gt;Let&#39;s write software that people understand.\n&gt;http://www.diasparsoftware.com/\n&gt;telephone: +1 416 791-8603\n&gt;\n\n\n\n[Non-text portions of this message have been removed]\n\n\n", 
    "profile": "clarkware", 
    "topicId": 5102, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 33026788, 
    "prevInTime": 5101, 
    "contentTrasformed": false, 
    "postDate": "1023284355", 
    "canDelete": false, 
    "nextInTopic": 5106, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PDNDRkUxNDgzLjcwOTAyQGNsYXJrd2FyZS5jb20+", 
        "referencesHeader": "PDFBQTY5NzFGOTZGQURCNEE5NkNGNzNFNDcyOUIwNUYxNTVFNUJEQFVTRVZTMDEyLmxlaW50ZXJuYWwuY29tPiA8MjAwMjA2MDQxMDQ5NTEuTTI0ODMxQGRpYXNwYXJzb2Z0d2FyZS5jb20+IDwzQ0ZDRjBDMi4yMDMwMjA3QGNsYXJrd2FyZS5jb20+IDwyMDAyMDYwNDEyNDUzNy5NNTkyMDdAZGlhc3BhcnNvZnR3YXJlLmNvbT4="
    }
}