{
    "numMessagesInTopic": 4, 
    "nextInTime": 9130, 
    "senderId": "CTadyBoHFVNdIJtpACBQCZrNqLpfu5DVbJ5mpdL15cfwpeNOJ-pisgNcI9Rdp5i63Mvfxj3GB__vL3hS1L510udY5uaaO7nkindZM6iA", 
    "systemMessage": false, 
    "subject": "RE: [junit] Object containment test dependency", 
    "from": "Jonathan Oddy &lt;j.oddy@...&gt;", 
    "authorName": "Jonathan Oddy", 
    "msgSnippet": "... From: Dave Astels [mailto:dave@saorsa.com] Sent: 20 August 2003 17:42 To: junit@yahoogroups.com Subject: [junit] Object containment test dependency Hi ... ", 
    "msgId": 9129, 
    "profile": "jonathanoddy", 
    "topicId": 9126, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 124029770, 
    "messageBody": "<div id=\"ygrps-yiv-1907052988\">-----Original Message-----<br/>\nFrom: Dave Astels [mailto:<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:dave@...\">dave@...</a>]<br/>\nSent: 20 August 2003 17:42<br/>\nTo: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a><br/>\nSubject: [junit] Object containment test dependency<br/>\n<br/>\n<br/>\nHi<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt; Briefly the problem is two &quot;very simple&quot; Java bean classes (A and <br/>\n&gt;&gt; B).  Class A is really simple: a constructor with a number of <br/>\n&gt;&gt; arguments and a host of accessor methods for retrieving this <br/>\n&gt;&gt; (member) data.<br/>\n<br/>\n&gt; This sounds like a data class... why does it exist if it has no behaviour?<br/>\n<br/>\n </span></blockquote>It exists because I did not want duplicate code within B, so I extraced the<br/>\ncommon code out (which seemed reasonable to me at the time).  Also because<br/>\nthese little A objects are used elsewhere it made sense for them not to be<br/>\nin the transport data type which only has a single specific purpose (to<br/>\nserialise data off the wire).<br/>\n<br/>\nAlso we have a lot of code built to an inhouse protocol talking to an<br/>\ninhouse server.  The current chosen method of doing this (and I&#39;m not here<br/>\nto debate the rights and wrongs of that method) is via serialisation of<br/>\nprotocol data types across the wire.  My application code cares not how<br/>\nthese things are created, but that it can use them as it wishes (usually to<br/>\nconstruct it&#39;s own model of how it sees the world).<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; This is something that&#39;s been really pissing me off about Java..<br/>\n&gt; institutionalization of crappy design practices.<br/>\n<br/>\n </span></blockquote>Thank you for your polite phrasing - I simply have to play with what I am<br/>\ngiven.  Please don;t get carried away with my use of the words Java Beans, I<br/>\nused them in this context because it explained the &quot;simplicity&quot; of the<br/>\nclasses in question rather nicely.  My actual question/query has nothing to<br/>\ndo with Java Beans or their use.  <br/>\n<br/>\nMy question was about interdependencies within classes being tested.  Being<br/>\n(still) reasonably new to this area I thought it was worth clarification,<br/>\nespecially when a lot of posts on this list (and within various TDD/Unit<br/>\nTesting stuff I&#39;ve read) talk alot about mocking out components so the<br/>\nbehaviours under test become more self contained.<br/>\n<br/>\nIn my original question, I have (in my example) two classes on totally self<br/>\ncontained and can be tested/re-implemented ad infinitum in its own little<br/>\nworld.  My query comes about when I want to test/develop the other class<br/>\nthat contains an instance of the former.  Now my second class (B) is<br/>\ninextrably coupled to (A) so I was questioning whether anybody (with more<br/>\nexperience than I) had any suggestions about how to remove this dependency,<br/>\nor whether I was/am worrying about it too much.<br/>\n<br/>\nIn my current scenario the dependency is not such an issue, however Iwould<br/>\nlike to pick up good practices so that when I come to a more complex version<br/>\nof the same problem I can then make an informed judgement as to what to do.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt; here comes the dependency.  Class B contains a number of (two) class<br/>\n&gt;&gt; A instances.  The raw data is read within readExternal and then used<br/>\n&gt;&gt; to construct the instances of A.  Class B provides a couple of <br/>\n&gt;&gt; accessors to retrieve those A instances.<br/>\n&gt;&gt; <br/>\n&gt;&gt; Within my unit test for B&#39;s Externalizable implementation is to <br/>\n&gt;&gt; check that what I pass in on the InputStream results in the B <br/>\n&gt;&gt; instance I expect.  But B contains two As so I appear to have two <br/>\n&gt;&gt; points of failure:  A.equals might fail which would result in the <br/>\n&gt;&gt; tests for both A and B failing.<br/>\n<br/>\n&gt; I don&#39;t see a problem.  You have tests for A.  You have tests for B. <br/>\n&gt; The fact that B involves A is a non issue.  If A breaks, it&#39;s tests<br/>\n&gt; will fail... and yes, so will B&#39;s.. so what.  If A&#39;s tests fail, that<br/>\n&gt; indicates that A is broken... don&#39;t worry that B&#39;s tests will fail<br/>\n&gt; since A is broken... go fix A.  All the tests should pass again.<br/>\n<br/>\n </span></blockquote>As outlined previously - I have no &quot;problem&quot;, I have tests for both class A<br/>\nand class B, I was simply quering whether the dependency was sensible.  I<br/>\ndon&#39;t spend much time worrying about whether B fails as a consequence of A.<br/>\n<br/>\nThank you for your time<br/>\nJonathan</div>", 
    "prevInTime": 9128, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1061399095", 
    "canDelete": false, 
    "nextInTopic": 9178, 
    "prevInTopic": 9128, 
    "headers": {
        "messageIdInHeader": "PEU1Qzc5MDQ5RDQ2MUQzMTFCODMxMDAwNjI5NTBCNTRBMDEyN0MxRENAbnQtc3RvYy0wLnNicz4="
    }
}