{
    "numMessagesInTopic": 17, 
    "nextInTime": 6864, 
    "senderId": "E2xgzTYI2v73_pm3NEoNcOFqHeDERiCmwN8CRtfJieWHn43dLi6CFTw-G3LABlsEt4Kd7e--YMcFYI81xSKXrQha1FzGClCxTI3ORxvvgw", 
    "systemMessage": false, 
    "subject": "Testability", 
    "from": "&quot;Scott Stirling&quot; &lt;scottstirling@...&gt;", 
    "authorName": "Scott Stirling", 
    "msgSnippet": "I ve been thinking about Test Driven Development and the question of what is it about it that ensures testability.  As Kent Beck says, if you follow TDD ", 
    "msgId": 6863, 
    "rawEmail": "Return-Path: &lt;scottstirling@...&gt;\r\nX-Sender: scottstirling@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (EGP: mail-8_2_3_4); 4 Feb 2003 05:48:17 -0000\r\nReceived: (qmail 43856 invoked from network); 4 Feb 2003 05:48:17 -0000\r\nReceived: from unknown (66.218.66.218)\n  by m10.grp.scd.yahoo.com with QMQP; 4 Feb 2003 05:48:17 -0000\r\nReceived: from unknown (HELO smtp-hub.mrf.mail.rcn.net) (207.172.4.107)\n  by mta3.grp.scd.yahoo.com with SMTP; 4 Feb 2003 05:48:17 -0000\r\nReceived: from smtp01.mrf.mail.rcn.net ([207.172.4.60])\n\tby smtp-hub.mrf.mail.rcn.net with esmtp (Exim 3.35 #4)\n\tid 18fvwO-0002Ft-00\n\tfor junit@yahoogroups.com; Tue, 04 Feb 2003 00:48:16 -0500\r\nReceived: from 207-172-67-6.c3-0.frm-ubr1.sbo-frm.ma.cable.rcn.com ([207.172.67.6] helo=javalaptop)\n\tby smtp01.mrf.mail.rcn.net with smtp (Exim 3.35 #4)\n\tid 18fvwO-0006Y9-00\n\tfor junit@yahoogroups.com; Tue, 04 Feb 2003 00:48:16 -0500\r\nTo: &lt;junit@yahoogroups.com&gt;\r\nSubject: Testability\r\nDate: Tue, 4 Feb 2003 00:48:05 -0500\r\nMessage-ID: &lt;KIEHIBIOBAELJAHIPNHDMEMNCOAA.scottstirling@...&gt;\r\nMIME-Version: 1.0\r\nContent-Type: text/plain;\n\tcharset=&quot;iso-8859-1&quot;\r\nContent-Transfer-Encoding: 7bit\r\nX-Priority: 3 (Normal)\r\nX-MSMail-Priority: Normal\r\nX-Mailer: Microsoft Outlook IMO, Build 9.0.2416 (9.0.2911.0)\r\nX-MimeOLE: Produced By Microsoft MimeOLE V6.00.2800.1106\r\nImportance: Normal\r\nFrom: &quot;Scott Stirling&quot; &lt;scottstirling@...&gt;\r\nReply-To: &lt;scottstirling@...&gt;\r\nX-Yahoo-Group-Post: member; u=112036634\r\nX-Yahoo-Profile: jrun5\r\n\r\nI&#39;ve been thinking about Test Driven Development and the question of what is\nit about it that ensures testability.  As Kent Beck says, if you follow TDD\nreligiously, you should have 100% statement coverage for your code.  Let me\nrepeat that: 100%.  I&#39;ve also been thinking about this concept of\n&quot;testability&quot; and what it means (incidentally, I think &quot;maintainability&quot; is\nalso pretty reducible to the explanation offered below).\n\nOn this list we recently (1/24/2003) had a simple question:\n&gt; I am currently writing a web application which uses the\n&gt; Websphere connection pool. I can write tests for the rest\n&gt; of my applciation, how to I test connections to the db, and\n&gt; objects which use the db connections without having to run\n&gt; the websphere server? - clairegknowles [mail@...]\n\nAnd a simple answer:\n&gt; Write a provider that wraps the pool, mock the provider,\n&gt; and away you go. - Jason Rogers [jacaetevha@...]\n\nAnother respondent advocated a different approach, which sparked a thought\nprovoking debate:\n&gt; Use separate interfaces to get the connection from the\n&gt; pool and do work with the connection.  I do something\n&gt; like this (the error handling may be a bit simplified):\n&gt;\n&gt; Object doMyThing(Connection con, String something) {\n&gt;     // do stuff on the connection and return the object.\n&gt; }\n&gt;\n&gt; public Object doMyThing(ConnectionFactory factory, String something) {\n&gt;     Connection con = factory.getConnection();\n&gt;     return doMyThing(con, something);\n&gt;     con.close();\n&gt; }\n&gt;\n&gt; The database test code invokes the first method; the\n&gt; real users of the code invoke the second. The second\n&gt; method isn&#39;t tested, because there&#39;s just not much there\n&gt; to break. If something did break in it, the functional\n&gt; tests catch it. - Curt Sampson [mailto:yahoo_sucks@...]\n\nI engaged in a stimulating debate with Curt on his answer, which I tried to\nargue wasn&#39;t as elegant or object oriented, in principle, as a mock object\napproach.  It won&#39;t result in 100% statement coverage, for one thing (which\nwill require you to trust Curt or whomever that the 5% of code that isn&#39;t\ncovered by unit tests, &quot;can&#39;t go wrong,&quot; which might be true, but more\nlikely not).  Most of my objections have been based on the idea that object\noriented design should be influenced by the need for testability, but so\nhave Curt&#39;s.  So why are we arguing such different strategies for solving\nthe problem of &quot;testability?&quot;\n\nObviously, a method added for no other purpose than to make a class&#39;s\nbehavior more directly accessible to external tests (ignore the default\naccess in the first doMyThing() above) enhances the testability of a class.\nA test() method right in the class itself would also enhance testability, as\nwould a main() method that contained a test runnable from the command line.\nBut I don&#39;t think any of these solutions is a very clean object oriented\nsolution because the test method has just been tacked on, irrespective of\nthe object being modeled.\n\nFrom a test driven development standpoint, you would not add a main() or a\ntest() to a class to make it testable because you write the tests before you\nadd any code to the class.  What test could drive you to write a test()\nmethod in a class under test (unless you&#39;re writing a testing framework,\nperhaps)?  I wonder the same thing about any method added to a class.\n\nPut another way, I wonder the same thing about any behavior added to an\nobject.  Testing is not a behavior of most objects.  So we should hope to\ntest most objects without modeling testing in them in any way.  So how do\nyou make things testable without corrupting the object design with behaviors\nadded or modified just to make objects testable?  And why is it that test\ndriven development, practiced religiously, will typically give you 100%\nstatement coverage without adding any such test-only methods to a class?\n\nI think the answer has to do with finite-state machines.  TDD is a\nmethodology that results in the development of clean, working finite-state\nmachines.  It works so well because the methodology of writing tests first\ndrives the mental process to identify and make explicit, in the appropriate\norder of priority:\n1. the desired outputs\n2. the inputs and behaviors needed to transition the machine from an initial\nor existing state to desired output\n3. the objects that compose the machine (one of the least important things\nat first, contrary to more traditional design methodology).  By this I mean\nthe objects are initially just named bags of data and behavior; the naming\nof the objects and definition of their boundaries evolves as the 1st and 2nd\npriorities are realized.\n\nIt seems the best way to build and test a finite-state machine is to make\nthe inputs and outputs explicit, and to make the state transitions step-wise\nand traceable.  It&#39;s a fallout from object oriented programming constraints\nthat the steps become methods in objects, and the traceability of the steps\nbecomes actualized in your unit test methods and TestCases.\n\nAfter doing TDD, traceability and explicit inputs and outputs are what\nyou&#39;ve built into your application and which remain, even if you take away\nthe unit tests when you&#39;re done.\n\nSo going back to the question of testability, I think there are some basic\nthings that automatically result in testability in OOP (this list by no\nmeans accurate or exhaustive, and inspired by some reading about state\nmachines in the testing literature, namely Beizer and Binder):\n  - objects or collaborations of objects modeled as finite-state machines\n  - methods for making state transitions in the objects themselves or in\nother objects\n  - explicit inputs to and outputs from methods\n  - step-wise, traceable state transitions\n\nI think these things become realized in terms of language and design\nspecifics.  For example:\n  - traceability requires state transition methods to be accessible for unit\ntesting\n  - state must be verifiable via attributes or methods that return state\ninformation and can be used in assertions\n  - step-wise means you don&#39;t make monolithic, god methods or classes that\nhide multiple, untraceable transitions\n  - explicit inputs means that something like the method below should be\ntuned based on the fact that the Connection object is the *actual* input\nneeded for the behavior to do its thing:\n  &gt; public Object doMyThing(ConnectionFactory factory, String something) {\n  &gt;     Connection con = factory.getConnection();\n  &gt;     Object o = doMyThing(con, something);\n  &gt;     con.close();\n  &gt;     return o;\n  &gt; }\n\nPassing in the ConnectionFactory, from this perspective, is an *implicit*\ninput of a Connection, which hides the fact that what&#39;s really needed for\nthe doMyThing() state transition is a Connection.    The ConnectionFactory\nis extraneous to the transition enacted by the method.  But in case you left\nthe signature with the ConnectionFactory (or Connection for that matter), a\nMockObject would allow you to keep the design &quot;pure.&quot;  So how important is\npurity of design?  That&#39;s another question.\n\nScott Stirling\nFramingham, MA\n\n\n\n", 
    "profile": "jrun5", 
    "topicId": 6863, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 112036634, 
    "prevInTime": 6862, 
    "contentTrasformed": false, 
    "postDate": "1044337685", 
    "canDelete": false, 
    "nextInTopic": 6865, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PEtJRUhJQklPQkFFTEpBSElQTkhETUVNTkNPQUEuc2NvdHRzdGlybGluZ0ByY24uY29tPg=="
    }
}