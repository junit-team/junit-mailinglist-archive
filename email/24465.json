{
    "numMessagesInTopic": 13, 
    "nextInTime": 24466, 
    "senderId": "_m9sBpPJmWRrMnpQR0jEQS7Fu9bomJWPLZ9WyD9wSiSvlmH8Vs2YRH5D_NALrQ8ELfIcVmx0pkvIr6DVwFdzymbLaw", 
    "systemMessage": false, 
    "subject": "Re: [junit] Tool to create assertions from a running Java application", 
    "from": "David Saff &lt;saff@...&gt;", 
    "authorName": "David Saff", 
    "msgSnippet": "I figured I d chime in, since I also was working for Agitar, which, as far as I know, nearly completely turned over their engineering staff about 5 years ago. ", 
    "msgId": 24465, 
    "profile": "saffatgoogle", 
    "topicId": 24453, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 525765722, 
    "messageBody": "<div id=\"ygrps-yiv-1221250941\"><div dir=\"ltr\">I figured I&#39;d chime in, since I also was working for Agitar, which, as far as I know, nearly completely turned over their engineering staff about 5 years ago.<div><br></div><div>Agitar had some very clever analysis software, based, as some here have guessed, on Daikon, as well as other research packages. &nbsp;One of the clevernesses was how it would prioritize test-input generation to attempt to produce not-yet-seen behaviors. &nbsp;So, if in an initial test run, a method always returned true, the engine would analyze the code to see if there was a way to make it return false. &nbsp;In the beginning, these observations were encoded in a proprietary observations database, but later, they figured out how to use those observations to generate Java code in the form of JUnit tests.</div>\n\n<div><br></div><div>In my opinion, those tests were never really a great idea to use, without reflection, as _tests_ that should be treated identically to human-generated tests. &nbsp;But they still had use:</div><div><br></div>\n\n<div>1) They were a map of the behavior of your program:</div><div><br></div><div>One of the more interesting bugs found was that Agitar found a method that was only ever called with positive floats; the intended input had been for positive and negative floats, and it turned out there was a bug in the calling method.</div>\n\n<div><br></div><div>2) They could indicate the scope of change:</div><div><br></div><div>Even if you never looked at the content of the generated tests, you could generate tests against all the classes on V1 of a package, and then run those tests on V2, and look at what failed (assuming, usually correctly, that even intended behavior changes would cause test failures). &nbsp;If the failures were all in tests against classes whose behavior you expected to change, great. &nbsp;If there were changes in other classes, that might be a problem.</div>\n\n<div><br></div><div>3) They could be used with Theories to automatically find actual bugs.</div><div><br></div><div>If you could specify a desired feature of your code as a Theory (a function asserting an invariant property over a practically infinite set of possible inputs), then you could use Agitar&#39;s corner-case-seeking engine to try to find an input that violated that invariant:</div>\n\n<div><br></div><div><a rel=\"nofollow\" target=\"_blank\" href=\"http://dspace.mit.edu/bitstream/handle/1721.1/40090/MIT-CSAIL-TR-2008-002.pdf\">http://dspace.mit.edu/bitstream/handle/1721.1/40090/MIT-CSAIL-TR-2008-002.pdf</a><br></div><div><br></div><div>I think there&#39;s still room for a lot of progress to be made on these ideas, but my experience with Agitar makes me think that it&#39;s more likely to come from open source efforts, or internal tool building at a large software company, than as a profit-making sellable tool.</div>\n\n<div><br></div><div>&nbsp; &nbsp;David Saff</div></div><div class=\"ygrps-yiv-1221250941gmail_extra\"><br><br><blockquote><span title=\"qreply\"> <div class=\"ygrps-yiv-1221250941gmail_quote\">On Sat, Feb 1, 2014 at 5:00 PM, Malte Finsterwalder <span dir=\"ltr\">&lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:malte@...\">malte@...</a>&gt;</span> wrote:<br>\n\n<blockquote class=\"ygrps-yiv-1221250941gmail_quote\" style=\"margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-left:1ex;\">\n\n\n<u></u>\n\n\n\n\n\n\n\n\n\n\n<div style=\"\">\n<span>&nbsp;</span>\n\n\n<div>\n  <div>\n\n\n    <div>\n      \n      \n      <p></p><div dir=\"ltr\">Maybe you can check out agitar. They provide a system that does exactly this: Generate tests for existing code.<div>They made a big buzz a few years ago. I look into it very briefly and the generated tests where not that bad.</div>\n\n\n<div>The biggest problem was: They were far too numerous and too detailed.</div><div>Writing good tests puts emphasis on the important parts that really needs to be tested and ignores exidential details.</div><div>I never quite understood how a tool like that should be used.</div>\n\n\n<div><br></div><div>I know that Kent Beck was involved into the undertaking, but I think he is no longer. Probably because it didn&#39;t quite work out in practice.</div><div><br></div><div>Greetings,</div><div>&nbsp; &nbsp;Malte</div>\n\n\n</div>\n<p></p>\n\n    </div>\n     \n\n    \n    <div style=\"color:#fff;min-height:0;\"></div>\n\n\n</div>\n\n\n\n  \n\n\n\n\n\n\n</div></div></blockquote></div><br></span></blockquote></div>\n</div>", 
    "prevInTime": 24464, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1391630550", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 24464, 
    "headers": {
        "inReplyToHeader": "PENBTFMxMi1PZEN6S01ZMmJlc2dSa1kzQktmM2tEUUpTX3BSYmpGS3haVC1XVk1mM2lzQUBtYWlsLmdtYWlsLmNvbT4=", 
        "messageIdInHeader": "PENBTHJ3LVB3RUhDNDM5QV91eUg3dlp2N3dnYkswWmRlc2Y2TFBpYWRUeFdIS0xacDlWQUBtYWlsLmdtYWlsLmNvbT4=", 
        "referencesHeader": "PGxjaXRxZysxaHQ1dTNpQFlhaG9vR3JvdXBzLmNvbT4gPDUyRUQ1NUY1LjgwMzA2MDJAZ21haWwuY29tPiA8Q0FMUzEyLU9kQ3pLTVkyYmVzZ1JrWTNCS2Yza0RRSlNfcFJiakZLeFpULVdWTWYzaXNBQG1haWwuZ21haWwuY29tPg=="
    }
}