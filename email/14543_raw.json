{
    "numMessagesInTopic": 14, 
    "nextInTime": 14544, 
    "senderId": "DSxSKaOcyasvV4kAIEwljIKX80tmXH_Kp60Rxy6zBhBIuEg0PEJAooRRk9eJlBxjdgLdpqTb2Fbje_Gypm3JOQZ_Ci-Af9FadSeAeoENU3Hxt6oiAw", 
    "systemMessage": true, 
    "subject": "Re: Unit tests design", 
    "from": "&quot;my_java_questions&quot; &lt;java.questions@...&gt;", 
    "authorName": "my_java_questions", 
    "msgSnippet": "... Mikhail, Thank you for this tip. In fact, I was already wondering if delegation/combination/encapsulation wasn t the right way around single inheritance", 
    "msgId": 14543, 
    "rawEmail": "Return-Path: &lt;java.questions@...&gt;\r\nReceived: (qmail 61352 invoked from network); 31 Aug 2005 19:29:10 -0000\r\nReceived: from unknown (66.218.66.172)\n  by m31.grp.scd.yahoo.com with QMQP; 31 Aug 2005 19:29:10 -0000\r\nReceived: from unknown (HELO n8.bulk.dcn.yahoo.com) (216.155.201.61)\n  by mta4.grp.scd.yahoo.com with SMTP; 31 Aug 2005 19:29:10 -0000\r\nComment: DomainKeys? See http://antispam.yahoo.com/domainkeys\r\nReceived: from [216.155.201.65] by n8.bulk.dcn.yahoo.com with NNFMP; 31 Aug 2005 19:29:10 -0000\r\nReceived: from [66.218.69.1] by mailer2.bulk.dcn.yahoo.com with NNFMP; 31 Aug 2005 19:29:09 -0000\r\nReceived: from [66.218.66.91] by mailer1.bulk.scd.yahoo.com with NNFMP; 31 Aug 2005 19:29:09 -0000\r\nX-Sender: java.questions@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (qmail 25913 invoked from network); 31 Aug 2005 19:23:20 -0000\r\nReceived: from unknown (66.218.66.167)\n  by m33.grp.scd.yahoo.com with QMQP; 31 Aug 2005 19:23:19 -0000\r\nReceived: from unknown (HELO n7.bulk.dcn.yahoo.com) (216.155.201.60)\n  by mta6.grp.scd.yahoo.com with SMTP; 31 Aug 2005 19:23:19 -0000\r\nComment: DomainKeys? See http://antispam.yahoo.com/domainkeys\r\nReceived: from [216.155.201.65] by n7.bulk.dcn.yahoo.com with NNFMP; 31 Aug 2005 19:23:19 -0000\r\nReceived: from [66.218.69.2] by mailer2.bulk.dcn.yahoo.com with NNFMP; 31 Aug 2005 19:23:19 -0000\r\nReceived: from [66.218.66.79] by mailer2.bulk.scd.yahoo.com with NNFMP; 31 Aug 2005 19:23:19 -0000\r\nDate: Wed, 31 Aug 2005 19:23:17 -0000\r\nTo: junit@yahoogroups.com\r\nMessage-ID: &lt;df5035+o8hc@...&gt;\r\nIn-Reply-To: &lt;20050831154326.19375.qmail@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Length: 4118\r\nX-Mailer: Yahoo Groups Message Poster\r\nX-Yahoo-Newman-Property: groups-system\r\nX-eGroups-Msg-Info: 1:12:0:0\r\nFrom: &quot;my_java_questions&quot; &lt;java.questions@...&gt;\r\nSubject: Re: Unit tests design\r\nX-Yahoo-Group-Post: member; u=235663842; y=gRNm_5aqSEE8Gy32mBwj6TiQhUkOEsJ9dCpS7T_vEN_ZfnBFSqHg5zzDGPY\r\nX-Yahoo-Profile: my_java_questions\r\nX-eGroups-Approved-By: vbossica &lt;vladimir@...&gt; via web; 31 Aug 2005 19:29:09 -0000\r\n\r\n--- In junit@yahoogroups.com, Mikhail Shnayderman &lt;mschnayd@y...&gt; wrote:\n&gt; D. and David,\n&gt; \n&gt; I agree with David that incremental approach is\n&gt; proably the best approach for extracting commonalities\n&gt; into a base classes, although I am not sure that in\n&gt; this case you would not be able to have a delegation\n&gt; based approach.  \n&gt; \n&gt; It seems to me that what you are talking about is a \n&gt; way to extract common fixture setup and teardown code\n&gt; and reuse that.  Maybe Abstract test cases is not what\n&gt; you really need and if you are you will be able to\n&gt; refactor to something similar to what I am outlining.\n&gt; \n&gt; Here is a solution that I would probably consider.\n&gt; \n&gt; public interface IFixture {\n&gt;    public void setUp() {\n&gt;    }\n&gt;    public void tearDown() {\n&gt;    }\n&gt; }\n&gt; \n&gt; public interface IBaseFixture extends IFixture {\n&gt;    public void setUp() {\n&gt;    }\n&gt;    public void tearDown() {\n&gt;    }\n&gt; }\n&gt; \n&gt; public class FixtureForInterfaceA implements\n&gt; IBaseFixture {\n&gt; \n&gt;   // public accessors for fixture data\n&gt;   public void ... get\n&gt;   ...\n&gt; \n&gt;   public void setUp() {\n&gt;      // setup fixture data ...\n&gt;   }\n&gt; \n&gt;   public void tearDown() {\n&gt;      // tear down fixture data ...\n&gt;   }\n&gt; }\n&gt; \n&gt; public class FixtureForInterfaceB implements\n&gt; IBaseFixture {\n&gt; \n&gt;   // public accessors for fixture data\n&gt;   public void ... get\n&gt;   ...\n&gt; \n&gt;   public void setUp() {\n&gt;      // setup fixture data ...\n&gt;   }\n&gt; \n&gt;   public void tearDown() {\n&gt;      // tear down fixture data ...\n&gt;   }\n&gt; }\n&gt; \n&gt; public class FixtureForConcreteClassImplementingAandB\n&gt; implements IFixture {\n&gt;    public FixtureForInterfaceA baseFixtureForA = new\n&gt; FixtureForInterfaceA();\n&gt;    public FixtureForInterfaceB baseFixtureForB = new \n&gt; FixtureForInterfaceB();\n&gt; \n&gt;    // public accessors for fixture data\n&gt;    public void ... get\n&gt;    ...\n&gt; \n&gt;    public FixtureForInterfaceA getIAFixture() {\n&gt;       return baseFixtureForA;\n&gt;    }\n&gt; \n&gt;    public FixtureForInterfaceB getIBFixture() {\n&gt;       return baseFixtureForB;\n&gt;    }\n&gt; \n&gt;    public void setUp() {\n&gt;      baseFixtureForA.setUp();\n&gt;      baseFixtureForB.setup();\n&gt;      // ... setup own fixture data\n&gt;    }\n&gt; \n&gt;    public void tearDown() {\n&gt;      // .. teardown own fixture data.\n&gt;      baseFixtureForB.tearDown();\n&gt;      baseFixtureForA.tearDown();   \n&gt;    }\n&gt; \n&gt; }\n&gt; \n&gt; public class\n&gt; MyTestCaseForConcreteClassImplementingAandB extends\n&gt; TestCase {\n&gt; \n&gt;   FixtureForConcreteClassImplementingAandB fixture =\n&gt;       new FixtureForConcreteClassImplementingAandB();\n&gt; \n&gt;   public void setUp() {\n&gt;      fixture.setUp();\n&gt;   }\n&gt; \n&gt;   public testFoo() {\n&gt;      foo(fixture.get...);\n&gt;      ...\n&gt;      foo(fixture.getIAFixture().get...);\n&gt;   }\n&gt; \n&gt;   public void tearDown() {\n&gt;      fixture.tearDown();\n&gt;   }\n&gt; } \n&gt; \n&gt; Ofcourse what I did there is a first shot.  \n&gt; It may seem somewhat complicated but all I really did\n&gt; is encapsulated Fixture and fixture data \n&gt; and created BaseFixtures as well as ConcreteFixtures\n&gt; that will be used in Concrete class test cases.\n&gt; \n&gt; If you need to reuse more than just fixture code, you\n&gt; can create a different abstraction for resuablity,\n&gt; possibly even a set of base test-cases.\n&gt; \n&gt; I know this is not truly LSP solution that you had in\n&gt; mind, but this I think does answer your &quot;requirement&quot; \n&gt; for fixture reusablity.\n&gt; \n&gt; Hope this helps, Mikhail\n&gt; \n\nMikhail,\n\nThank you for this tip. \n\nIn fact, I was already wondering if\ndelegation/combination/encapsulation wasn&#39;t the right way around\nsingle inheritance limitation (isn&#39;t it always :-)). I just couldn&#39;t\nfigure out how exactly to implement it...\n\nI think I will use J.B. Rainsberger&#39;s solution of splitting my\nfixtures in as many different TestCases as there are interfaces\nimplemented. I like the idea of separating the different aspects I&#39;m\ntesting...\n\nYour tip will be usefull too if it occurs that all these\ninterface-specific TestCases share common setUp() and tearDown() code.\n\nAnyway, I am really enjoying my first experience on this mailing list.\nEveryone is really nice and all the answers I&#39;ve received so far have\nbeen very helpfull.\n\nThank you all for making TDD such a bliss ;-)\n\nDimitri\n\n\n\n\n\n\n\n", 
    "profile": "my_java_questions", 
    "topicId": 14519, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 235663842, 
    "prevInTime": 14542, 
    "contentTrasformed": false, 
    "postDate": "1125516197", 
    "canDelete": false, 
    "nextInTopic": 14547, 
    "prevInTopic": 14542, 
    "headers": {
        "inReplyToHeader": "PDIwMDUwODMxMTU0MzI2LjE5Mzc1LnFtYWlsQHdlYjMwODA2Lm1haWwubXVkLnlhaG9vLmNvbT4=", 
        "messageIdInHeader": "PGRmNTAzNStvOGhjQGVHcm91cHMuY29tPg=="
    }
}