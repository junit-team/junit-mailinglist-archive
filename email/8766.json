{
    "numMessagesInTopic": 2, 
    "nextInTime": 8767, 
    "senderId": "cvUyvkzhQ0TEag0kh6yb3PzOQLqROKH4zkfRdbv3QWdeafl-GspeeT36LbSsSVV1T5w4B8cPInast4o4turyDRz4BTNJh23oDqB37by8wLh9RQ", 
    "systemMessage": false, 
    "subject": "Re: unit testing philosophy [LONG]", 
    "from": "&quot;ranjan_chakrab&quot; &lt;ranjan_chakrab@...&gt;", 
    "authorName": "ranjan_chakrab", 
    "msgSnippet": "Hi Steve, I am trying to use JUnit to perform unit testing of ATG Dynamo Droplets and Form Handlers. Please let me know if there are any documents/ papers that", 
    "msgId": 8766, 
    "profile": "ranjan_chakrab", 
    "topicId": 4951, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 132883670, 
    "messageBody": "<div id=\"ygrps-yiv-968304183\">Hi Steve,<br/>\n<br/>\n I am trying to use JUnit to perform unit testing of ATG Dynamo<br/>\nDroplets and Form Handlers.<br/>\n<br/>\nPlease let me know if there are any documents/ papers that discuss <br/>\nthis subject.<br/>\n<br/>\nThank you.<br/>\n<br/>\nRanjan Chakrabarty<br/>\ne-mail: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:ranjan_chakrab@...\">ranjan_chakrab@...</a><br/>\n<br/>\n<blockquote><span title=\"qreply\"> --- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>, &quot;Steve Freeman&quot; &lt;steve@m...&gt; wrote:<br/>\n&gt; &gt; In the real world, I use ATG Dynamo.  If you&#39;ve heard of it or <br/>\nused<br/>\n&gt; &gt; it, it&#39;s an App Server / EJB Container.   Dynamo&#39;s entire <br/>\nframework is<br/>\n&gt; &gt; based off this component known as Nucleus, which does a lot of <br/>\nwork in<br/>\n&gt; &gt; terms of instantiating classes, setting properties, etc..  It&#39;s <br/>\nalso<br/>\n&gt; &gt; very slow and to test - build - test takes forever if I have to <br/>\nstart<br/>\n&gt; &gt; and stop the app-server for every change in the code.<br/>\n&gt; <br/>\n&gt; That&#39;s why we started mocking up Dynamo components. In some ways, <br/>\nthe<br/>\n&gt; Nucleus is very amenable to writing mock-based unit tests given that<br/>\n&gt; it&#39;s all about glueing components together at runtime. If you define<br/>\n&gt; your components in terms of interfaces rather than classes, then <br/>\nit&#39;s<br/>\n&gt; easier to substitute alternative implementations. Once you&#39;ve done<br/>\n&gt; this, it turns out that your code is better structured for coping <br/>\nwith<br/>\n&gt; new requirements.<br/>\n&gt; <br/>\n&gt; &gt; That&#39;s where MockObjects come in.  Dynamo is a very Java Beans <br/>\nheavy<br/>\n&gt; &gt; framework, that relies a lot on setters and getters.  ( In fact, <br/>\nthe<br/>\n&gt; &gt; MockObjects guys at SF have started putting together some Dynamo<br/>\n&gt; &gt; MockObjects. ) I was looking into MockObjects as a way to lessen <br/>\nmy<br/>\n&gt; &gt; reliance on the Nucleus namespace so that I could code quickly and<br/>\n&gt; &gt; only integrate with the Nucleus namespace at the latest possible <br/>\ntime.<br/>\n&gt; <br/>\n&gt; Sadly, our library is getting out of date, because I&#39;m not working<br/>\n&gt; with Dynamo any more. One point is that we&#39;re trying to move away <br/>\nfrom<br/>\n&gt; getters and setters. It&#39;s worth thinking about passing handler and<br/>\n&gt; policy objects around, rather than extracting values via getters. <br/>\nThe<br/>\n&gt; Nucleus supports it just as well.<br/>\n&gt; <br/>\n&gt; &gt; However, I can&#39;t get my head around the fact that in certain <br/>\ncases my<br/>\n&gt; &gt; mock code will need to generate other mock code<br/>\n&gt; <br/>\n&gt; Sometimes that happens, for example with the JDBC library. Where <br/>\nit&#39;s<br/>\n&gt; unavoidable, at least it&#39;s usually repeated across multiple tests <br/>\nand<br/>\n&gt; so worth wrapping in some helper code, or in the TestCase setup. For<br/>\n&gt; something like the Dynamo repository, you&#39;re likely to be using the<br/>\n&gt; infrastructure a lot, so there may be some point in investing in a<br/>\n&gt; little infrastrcuture. Don&#39;t forget that you only need enough<br/>\n&gt; implementation to get through the test (in a modern IDE this is a<br/>\n&gt; matter of a few points-and-clicks). For example, something like:<br/>\n&gt; <br/>\n&gt; class MockRepository extends MockObject {<br/>\n&gt;   private RepositoryView view;<br/>\n&gt;   private ExpectationValue itemDescription =<br/>\n&gt;     new ExpectationValue(&quot;MockRepository.itemDescription&quot;);<br/>\n&gt; <br/>\n&gt;   public void setExpectedGetView(String description,<br/>\n&gt;                                  RepositoryView aView) {<br/>\n&gt;     view = aView;<br/>\n&gt;     itemDescription.setExpected(description);<br/>\n&gt;   }<br/>\n&gt; <br/>\n&gt;   public RepositoryView getView(String description) {<br/>\n&gt;     itemDescription.setActual(description);<br/>\n&gt;     return view;<br/>\n&gt;   }<br/>\n&gt; }<br/>\n&gt; <br/>\n&gt; Another other route to consider is that you can use the Repository<br/>\n&gt; outside Dynamo. Set up a test instance of the database and manage <br/>\ntest<br/>\n&gt; values with something like DBUnit.<br/>\n&gt; <br/>\n&gt; Finally, what makes this code hard to test is that there are too <br/>\nmany<br/>\n&gt; objects involved in the method, can we break them up? One <br/>\nobservation<br/>\n&gt; is that the sequence from the Repository to the array of items is <br/>\nmore<br/>\n&gt; or less independant of the application. Does it repeat often enough <br/>\nto<br/>\n&gt; write something like:<br/>\n&gt; <br/>\n&gt; public Map generateEmptyPreferencesMap(Map map)<br/>\n&gt; {<br/>\n&gt;   RepositoryView contactMethodView =<br/>\n&gt; <br/>\n&gt; <br/>\n&gt;     getPreferencesRepository().getView<br/>\n(CONTACT_METHOD_REPOSITORY_ITEM );<br/>\n&gt;   PropertyFinder finder = finderFactory.make(contactMethodView);<br/>\n&gt;   finder.addPropertyValuesTo(map, <br/>\nCONTACT_METHOD_CODE_PROPERTY_NAME);<br/>\n&gt;   return map;<br/>\n&gt; }<br/>\n&gt; <br/>\n&gt; Where the PropertyFinder encapsulates all that RepositoryView<br/>\n&gt; stuff. If you create PropertyFinder&#39;s via a factory, you can <br/>\nsubsitute<br/>\n&gt; a MockPropertyFinder when testing the Droplet. You can then test the<br/>\n&gt; PropertyFinder separately with a smaller chain of mock<br/>\n&gt; (or real) Repository objects. It would be too much work if this is <br/>\nthe<br/>\n&gt; only place you do this but, more likely, you can refactor in this<br/>\n&gt; direction as you discover repetitions. An example of a test would <br/>\nbe:<br/>\n&gt; <br/>\n&gt; public void testGenerateEmptyPreferencesMap() throws <br/>\nRepositoryException<br/>\n&gt; {<br/>\n&gt;     MockPropertyFinder mockFinder = new MockPropertyFinder();<br/>\n&gt;     Map map = new Hashmap();<br/>\n&gt; <br/>\n&gt;     mockRepository.setupView(mockRepositoryView);<br/>\n&gt;     mockFinderFactory.setupFinder(mockFinder);<br/>\n&gt; <br/>\n&gt;     mockFinderFactory.setExpectedView(mockRepositoryView);<br/>\n&gt;     mockRepository.setExpectedGetView<br/>\n(CONTACT_METHOD_REPOSITORY_ITEM);<br/>\n&gt;     mockFinder.setExpectedAddPropertyValuesTo(map,<br/>\n&gt; CONTACT_METHOD_CODE_PROPERTY_NAME);<br/>\n&gt; <br/>\n&gt;     assertEquals(&quot;Should be same map&quot;, map,<br/>\n&gt; droplet.generateEmptyPreferencesMap(map));<br/>\n&gt;     mockFinderFactory.verify();<br/>\n&gt;     mockRepository.verify();<br/>\n&gt;     mockFinder.verify();<br/>\n&gt; }<br/>\n&gt; <br/>\n&gt; Hmmm, thinking about it, the next version might be:<br/>\n&gt; <br/>\n&gt; public Map generateEmptyPreferencesMap(Map map)<br/>\n&gt; {<br/>\n&gt;     PropertyFinder finder =<br/>\n&gt;         finderFactory.simpleFinder(preferencesRepository,<br/>\n&gt; CONTACT_METHOD_REPOSITORY_ITEM );<br/>\n&gt;     finder.addPropertyValuesTo(map, <br/>\nCONTACT_METHOD_CODE_PROPERTY_NAME);<br/>\n&gt;     return map;<br/>\n&gt; }<br/>\n&gt; <br/>\n&gt; Steve<br/>\n&gt; <br/>\n&gt; &gt; Here&#39;s a method from a piece of old code that I wrote before I <br/>\ndecided<br/>\n&gt; &gt; to start using JUnit:<br/>\n&gt; &gt;<br/>\n&gt; &gt;     public  Map generateEmptyPreferencesMap( Map m ) throws<br/>\n&gt; &gt; RepositoryException {<br/>\n&gt; &gt;<br/>\n&gt; &gt; // get the list of possible preferences<br/>\n&gt; &gt; RepositoryView contactMethodView = getPreferencesRepository<br/>\n().getView(<br/>\n&gt; &gt; CONTACT_METHOD_REPOSITORY_ITEM );<br/>\n&gt; &gt; RepositoryItem[] contactMethods = contactMethodView.executeQuery(<br/>\n&gt; &gt; contactMethodView.getQueryBuilder().createUnconstrainedQuery() );<br/>\n&gt; &gt;<br/>\n&gt; &gt; if ( ( contactMethods != null ) && ( contactMethods.length &gt; <br/>\n0 ) )  {<br/>\n&gt; &gt;     // add each one to the map<br/>\n&gt; &gt;     for ( int i = 0 ; i &lt; contactMethods.length ; i++ ) {<br/>\n&gt; &gt; m.put( contactMethods[i].getPropertyValue(<br/>\n&gt; &gt; CONTACT_METHOD_CODE_PROPERTY_NAME ), new BooleanPlaceHolder() );<br/>\n&gt; &gt;     }<br/>\n&gt; &gt; }<br/>\n&gt; &gt;      return m;<br/>\n&gt; &gt;     } </span></blockquote></div>", 
    "prevInTime": 8765, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1058921216", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 4951, 
    "headers": {
        "inReplyToHeader": "PDAwMzUwMWMxZjlhMSRhNDc1ODJhMCQxMjNiMjdkOUBnYXRld2F5Pg==", 
        "messageIdInHeader": "PGJma2x1MCt2ZWw1QGVHcm91cHMuY29tPg=="
    }
}