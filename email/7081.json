{
    "numMessagesInTopic": 1, 
    "nextInTime": 7082, 
    "senderId": "gcATSIVhx02toQzpgFpOBzY0BpqSn466D5H4j9AZprubrMHbfdaRAm5jR8VhB4xhuc_DiUh9EG7UavP0Ynm9pPCfAw6dyVL6zGvgfI9e", 
    "systemMessage": false, 
    "subject": "Re: [junit] Application Testing Strategy", 
    "from": "Eric Armstrong &lt;eric.armstrong@...&gt;", 
    "authorName": "Eric Armstrong", 
    "msgSnippet": "... My interest in testing stems from a security application I once wrote. Since it had to be secure, I had to be ultra-careful in every phase of it s", 
    "msgId": 7081, 
    "profile": "ericsilverlight", 
    "topicId": 7081, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 78994084, 
    "messageBody": "<div id=\"ygrps-yiv-1777708759\"><blockquote><span title=\"ireply\">&gt; &gt; -----Original Message-----<br/>\n&gt; &gt; From: Sukhvinder Singh Namdhari<br/>\n&gt; &gt; I want to write unit tests for my Server application,<br/>\n&gt; &gt; but till now we haven&#39;t written any testing code...<br/>\n&gt; &gt; Can anyone suggest how I could apply unit<br/>\n&gt; &gt; test technique in the existing Server Application?<br/>\n<br/>\n </span></blockquote>My interest in testing stems from a security application I once wrote.<br/>\nSince it had to be secure, I had to be ultra-careful in every phase of<br/>\nit&#39;s development. This was in the days before the TDD concept, so<br/>\nI methodically worked the design in stages, going from the largest<br/>\nsystem diagram and drilling down, block by block, until I had a<br/>\nrepresentation that was tantamount to a flowchart for the code.<br/>\n<br/>\n(One of the intersting developments along the way was a diagramming<br/>\ntechnique that was equally suited for system block diagrams and code<br/>\nflowcharts, which allowed for the seamless design strategy -- but that&#39;s<br/>\n<br/>\nanother story.)<br/>\n<br/>\nWhen I was done with the design, had desk-checked it, and had it<br/>\nreviewed by the client, I set about the task of implementing.<br/>\n<br/>\nAgain, this was intended to be a secure application, so &quot;bug free&quot; was<br/>\na critical requirement, because any bug can be exploited to compromise<br/>\nsecurity.<br/>\n<br/>\nThe strategy I chose was to implement from the bottom up. While the<br/>\ndesign had been top down, the implementation proceeded from the<br/>\nopposite direction. I implemented the lowest level routines first, and<br/>\nbuilt a test harness side-by-side. After thoroughly testing each routine<br/>\n<br/>\nin the initial library, I built the next level of functionality, and<br/>\nthen created<br/>\nthe tests for the new functionality.<br/>\n<br/>\nNotes:<br/>\n  * One interesting revelation in this process was that, if level 3 was<br/>\nbuilt<br/>\n     on level 2, most bugs were confined to level 3. Occasionally, but<br/>\n     rarely, a bug would be found in level 2 that had been missed by the<br/>\n<br/>\n     previous tests, but no bugs in level 1 *ever* surfaced.<br/>\n<br/>\n  * Another interesting revelation was how good it felt to be developing<br/>\n<br/>\n     this way. I actually had confidence that the code would work, and<br/>\n     do what I expected it to!<br/>\n<br/>\n  * When I delivered the completed application, I did so confidentally.<br/>\n     Interestingly, they did discover one bug in the completed app. But<br/>\n     it was a minor oversight in the very topmost level of the code,<br/>\nthat<br/>\n     the client easily discerned and repaired, without even needing to<br/>\n     call me back. (They told me about it, and praised both the<br/>\nstructure<br/>\n     of the app and its commenting.)<br/>\n<br/>\nAnyway, to get to the moral of the story, I would suggest that to test<br/>\na legacy app, you identify the lowest level of functionality in the<br/>\nsystem,<br/>\nand build a framework to test the heck out of that. Then work up, level<br/>\nby level, to the topmost layers of the system. (I call that process<br/>\n&#39;level<br/>\ntesting&quot;. You are testing individual units at each level, but the units<br/>\nare<br/>\ndoing increasingly more at each level.)<br/>\n<br/>\nFinally, a few specific refactorings are needed to make an application<br/>\ntestable.<br/>\n  * The first is to make it a &quot;bean&quot;.<br/>\n     That means being able to create the application as an object, set<br/>\n     its properties, and invoke run() to kick it off. That achieves two<br/>\n     goals. The first is that some other application you never expected<br/>\n     can invoke it and make use of its results. The second is that you<br/>\n     can now drive it from your test framework.<br/>\n<br/>\n     Note:<br/>\n     For a server, the &quot;processing&quot; part of the system should be a bean<br/>\n     that you can test normally. The &quot;serving&quot; part of the system<br/>\n     undoubtedly needs a special test harness that is intended to drive<br/>\n     a server app. I believe those exist, although I haven&#39;t used any.<br/>\n<br/>\n  * The second is to encapsulate all error handling and output messaging<br/>\n<br/>\n     in one place with<br/>\n        a) a setErrorHandler(ErrorHandler) method, and<br/>\n        b) a setWriter(Writer) method.<br/>\n     The writer can default to new java.io.Writer(System.out) but the<br/>\n     abiliy to set it means that you can set to a StringWriter in your<br/>\ntest<br/>\n     case, and then inspect the StringWriter to see what messages the<br/>\n     server generated.<br/>\n<br/>\n     Note:<br/>\n     It is also possible that having one location error handling and one<br/>\nfor<br/>\n     messaging better -- the ideal picture is still emerging)<br/>\n<br/>\nThese strategies open up a number of testing possibilities:<br/>\n  1) You can create an anonymous subclass of the application object,<br/>\n       overriding a single method for testing purposes. For example, it<br/>\n       could record the list of items that were &quot;processed&quot;, rather than<br/>\n<br/>\n       actually processing them.<br/>\n<br/>\n   2) You can create an anonymous error-handler subclass that<br/>\n        overrides an error condition. It could then set a flag to<br/>\nindicate<br/>\n        that the error occurred, and then exit with a fatal exception.<br/>\n        (The test method would then count the fatal exception as a<br/>\n          success, if and only if the flag was set.)<br/>\n<br/>\n    3) You can run the application with a variety of inputs, and compare<br/>\n<br/>\n         examine the messages it generates. (Less certain, since it<br/>\n         changing text or internationalizing it will cause failures. But<br/>\n<br/>\n         easier.)<br/>\n<br/>\nThat&#39;s as far as I&#39;ve been able to think things out for the moment.<br/>\nI&#39;ll add a writeup to my web page, or possibly to the JUnit site.<br/>\n<br/>\nHope this helps!<br/>\n<br/>\nNote:<br/>\nI&#39;m thinking about writing up the details for this pattern, and some<br/>\nother &quot;application patterns&quot; in a book, which would have code<br/>\nsamples. In the meantime, this rough outline may be enought to<br/>\nget started. (In the meantime, writing up this much has gotten me<br/>\nwell on the way towards writing at least one chapter in the book!)</div>", 
    "prevInTime": 7080, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1046293929", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PDNFNUQyREE4LjhDMjM2M0Q1QHN1bi5jb20+", 
        "referencesHeader": "PEZFRUFJRklNTEhMS0FKQ0VQT05IQ0VBUENHQUEubWdAcGhjLmRrPg=="
    }
}