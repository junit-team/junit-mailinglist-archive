{
    "numMessagesInTopic": 38, 
    "nextInTime": 22248, 
    "senderId": "nJWvDPsNGi6brbfiF_Px-Uj_OKB5S-QbtE-VwcKbqT9-lBpIBmh3tdy6AcQlXjlGpTIk195vGuPdiWwnGLPetrXJ", 
    "systemMessage": false, 
    "subject": "Re: [junit] Re: Order of execution for tests", 
    "from": "David Saff &lt;david@...&gt;", 
    "authorName": "David Saff", 
    "msgSnippet": "I d like to propose the assumption sufficiency hypothesis: any test class expressed in terms of dependent tests can also be expressed in terms of the JUnit", 
    "msgId": 22247, 
    "profile": "dsaff", 
    "topicId": 22219, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 341876227, 
    "messageBody": "<div id=\"ygrps-yiv-1647988961\">I&#39;d like to propose the &quot;assumption sufficiency&quot; hypothesis: any test<br/>\nclass expressed in terms of dependent tests can also be expressed in<br/>\nterms of the JUnit 4.4 concepts of theories, datapoints, and<br/>\nassumptions, and the resulting testcase will<br/>\n- not take meaningfully longer to run in any given situation<br/>\n- produce failure reports that are at least as enlightening<br/>\n- contain code that is at least as clear, and<br/>\n- catch at least as many bugs.<br/>\n<br/>\nNote that I have not promised that the resulting test case will not<br/>\ntake longer to design and write.<br/>\n<br/>\nAs a first example, here&#39;s the test class from the JExample home page:<br/>\n<br/>\n@RunWith(JExample.class)<br/>\npublic class ExampleStack {<br/>\n<br/>\n     @Test<br/>\n     public void whenEmpty() {<br/>\n         Stack stack = new Stack();<br/>\n         assertEquals(true, stack.isEmpty());<br/>\n         return stack;<br/>\n     }<br/>\n<br/>\n     @Given(&quot;#whenEmpty&quot;)<br/>\n     public Stack shouldPush(Stack stack) {<br/>\n         stack.push(&quot;Foo&quot;);<br/>\n         assertEquals(false, stack.isEmpty());<br/>\n         assertEquals(&quot;Foo&quot;, stack.top());<br/>\n         return stack;<br/>\n     }<br/>\n<br/>\n     @Given(&quot;shouldPush&quot;)<br/>\n     public void shouldPop(Stack stack) {<br/>\n         Object top = stack.pop();<br/>\n         assertEquals(true, stack.isEmpty());<br/>\n         assertEquals(&quot;Foo&quot;, top);<br/>\n     }<br/>\n }<br/>\n<br/>\nHere&#39;s the JUnit 4.4 version:<br/>\n<br/>\n@RunWith(Theories.class)<br/>\npublic class ExampleStack {<br/>\n     @DataPoint public static Stack empty() { return new Stack(); }<br/>\n     @DataPoint public static Stack oneItem() {<br/>\n        Stack s = new Stack();<br/>\n        s.push(&quot;Foo&quot;);<br/>\n        return s;<br/>\n     }<br/>\n<br/>\n     @DataPoint public static Object FOO = &quot;Foo&quot;;<br/>\n<br/>\n     @Test<br/>\n     public void newStackIsEmpty() {<br/>\n         Stack stack = new Stack();<br/>\n         assertEquals(true, stack.isEmpty());<br/>\n     }<br/>\n<br/>\n     // note this applies to _any_ stack, not just one example.<br/>\n     @Theory<br/>\n     public void pushedItemIsTop(Stack stack, Object item) {<br/>\n         stack.push(item);<br/>\n         assertEquals(false, stack.isEmpty());<br/>\n         assertEquals(item, stack.top());<br/>\n     }<br/>\n<br/>\n     @Theory<br/>\n     public void popEmptiesStack(Stack stack, Object item) {<br/>\n         assumeTrue(stack.isEmpty());<br/>\n         stack.push(item);<br/>\n         stack.pop();<br/>\n         assertEquals(true, stack.isEmpty());<br/>\n     }<br/>\n<br/>\n     @Theory<br/>\n     public void topIsPopped(Stack stack) {<br/>\n         assumeFalse(stack.isEmpty());<br/>\n         Object top = stack.top();<br/>\n         Object popped = stack.pop();<br/>\n         assertEquals(top, popped);<br/>\n     }<br/>\n }<br/>\n<br/>\nTo me, the bottom code is a win in every case.  I&#39;m worried, though,<br/>\nthat this example written in any style wouldn&#39;t present one of the<br/>\nchief complaints, in which a developer hunts through dozens of<br/>\nfailures to find the one test that best describes the bug introduced.<br/>\nWith only three or four methods, any argument of developer overload is<br/>\ngoing to have scant support.  I&#39;m looking forward to a good example of<br/>\ndeveloper overload we can work through.<br/>\n<br/>\nI&#39;m looking forward to finding exceptions to the assumption<br/>\nsufficiency rule I proposed above.  I think they will prove<br/>\nenlightening to me as jumping-off points for discussion of the<br/>\nevolution of JUnit.  Perhaps the answer is bolting on a feature that<br/>\nalready exists in another framework or extension, but I&#39;d be surprised<br/>\nif there wasn&#39;t a more organic solution.  Thanks,<br/>\n<br/>\n   David Saff<br/>\n<br/>\n<blockquote><span title=\"qreply\"> On Fri, Jan 1, 2010 at 4:02 PM, adrian.kuhn &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:akuhn@...\">akuhn@...</a>&gt; wrote:<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; --- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>, &quot;yogesh.patil&quot; &lt;patilyogeshp@...&gt; wrote:<br/>\n&gt;<br/>\n&gt;&gt; I have a scenario to test where in I need to make sure that tests are<br/>\n&gt;&gt; executed in particular order...<br/>\n&gt;&gt; How can I achieve this?<br/>\n&gt;<br/>\n&gt; JExample is a test runner for JUnit that runs test in order of dependencies.<br/>\n&gt;  You can specify that a test depends on the outcome of another test.<br/>\n&gt;<br/>\n&gt; What follows is considered heretic by some TDD proponents, but we believe that<br/>\n&gt;  the burden of isolating tests should be shifted from developer to framework.<br/>\n&gt;<br/>\n&gt; We call this a producer - consumer relationship. The producer is always run<br/>\n&gt;  before the consumer. When the producer fails, the consumer is skipped. We<br/>\n&gt;  picked the names producer and consumer because the producer may actually<br/>\n&gt;  *return* a value (ie produce a valid example of the class under test) and the<br/>\n&gt;  consumer may take the value as a parameter (ie consumer the produced example).<br/>\n&gt;  If two consumers depend on the same example, the JExample runner takes care to<br/>\n&gt;  clone the example to avoid side-effects.<br/>\n&gt;<br/>\n&gt; The website is <a rel=\"nofollow\" target=\"_blank\" href=\"http://scg.unibe.ch/jexample\">http://scg.unibe.ch/jexample</a><br/>\n&gt;<br/>\n&gt; Feedback and bug reports are welcome.<br/>\n&gt;<br/>\n&gt; PS, we also have a prototype that uses profiling to automatically insert the<br/>\n&gt;  implicit dependencies of legacy tests. If you are interested, drop a mail.<br/>\n&gt;<br/>\n&gt;&gt; Are the test cases added with annotation @Test gets executed in the order<br/>\n&gt;&gt; they are written?<br/>\n&gt;<br/>\n&gt; The order is unspecified.<br/>\n&gt;<br/>\n&gt; cheers,<br/>\n&gt; AA<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; ------------------------------------<br/>\n&gt;<br/>\n&gt; Yahoo! Groups Links<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 22246, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1262400716", 
    "canDelete": false, 
    "nextInTopic": 22249, 
    "prevInTopic": 22244, 
    "headers": {
        "inReplyToHeader": "PGhobG5zditxZnR1QGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PDRmN2RhNmI5MTAwMTAxMTg1MWc1MmI5YmRlOWczYzYxZjhlMzY0NDExNTI1QG1haWwuZ21haWwuY29tPg==", 
        "referencesHeader": "PDI2ODc3MDk3LnBvc3RAdGFsay5uYWJibGUuY29tPiA8aGhsbnN2K3FmdHVAZUdyb3Vwcy5jb20+"
    }
}