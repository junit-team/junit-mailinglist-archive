{
    "numMessagesInTopic": 47, 
    "nextInTime": 15133, 
    "senderId": "XIYJtUKOwAwLDmeOzITWT1IkkrL7SUn_66k5WEkjGhCDL7bkRTj85RbHr6HrdyPmJ7xrTMbfw9wjjSmsWW9bxAuJjb4kXhbFZvUjMqztig", 
    "systemMessage": false, 
    "subject": "Re: [junit] Proposed parameterized test syntax for JUnit 4", 
    "from": "&quot;J. B. Rainsberger&quot; &lt;jbrains@...&gt;", 
    "authorName": "J. B. Rainsberger", 
    "msgSnippet": "... I still don t see the connection yet, so let me ask a question: do these 5 methods (among other things) initialize the same set of fields in the stateful", 
    "msgId": 15132, 
    "profile": "nails762", 
    "topicId": 14820, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 127224993, 
    "messageBody": "<div id=\"ygrps-yiv-704590877\">Eugene Kuleshov wrote:<br/>\n<blockquote><span title=\"ireply\"> &gt; J. B. Rainsberger wrote:<br/>\n&gt; <br/>\n&gt;  &gt;&gt;   For instance, if you look at typical facade pattern, it is quite<br/>\n&gt;  &gt;&gt;often that it would change different parts of the internal state but<br/>\n&gt;  &gt;&gt;we still need to test it as a single entity. I am pretty sure that<br/>\n&gt;  &gt;&gt;facade is not only case for this.<br/>\n&gt;  &gt;<br/>\n&gt;  &gt; I have to admit that I can&#39;t make the connection between this paragraph<br/>\n&gt;  &gt; and the subject of this thread.<br/>\n&gt; <br/>\n&gt;    Let me give an example. Imagine you have a statefull facade under<br/>\n&gt; test with has 5 methods: first one take no params, second - one param,<br/>\n&gt; third - two params, etc.<br/>\n&gt; <br/>\n&gt;    Should we follow your rules and break this facade into 5 classes?<br/>\n&gt; Should we then write separate unit test class for each of those new classes?<br/>\n<br/>\n </span></blockquote>I still don&#39;t see the connection yet, so let me ask a question: do these <br/>\n5 methods (among other things) initialize the same set of fields in the <br/>\nstateful bean? or completely different fields?<br/>\n<br/>\nIf the answer is &quot;the same set of fields&quot;, then I&#39;d keep them on the <br/>\nsame stateful bean class. This is the same as having 5 test cases that <br/>\nuse the same fixture objects.<br/>\n<br/>\nIf the answer is &quot;completely different fields&quot;, then I absolutely would <br/>\nput them on separate stateful bean classes. I would think that was <br/>\nobvious. This is the same as having 5 test cases that use completely <br/>\ndifferent fixture objects (and want them to be fields--that part is <br/>\nimportant).<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;    The way I see it: there should be single test class with several<br/>\n&gt; parameterized test cases (so several parm generators) and test case<br/>\n&gt; would test a single test. In order to keep such construction compact you<br/>\n&gt; can move most of the code into the declarative test definition, like how<br/>\n&gt; input should look like and what to assert on the output, then test code<br/>\n&gt; itself could just iterate trough the rules for each given test case<br/>\n&gt; (before and then after test). Unfortunately this leads to soft-typed<br/>\n&gt; dynamic bindings and evaluation and as a result practically usable only<br/>\n&gt; in completely generated tests.<br/>\n<br/>\n </span></blockquote>That surprises me, since I have been using this technique successfully <br/>\nfor five years with completely hand-written tests. I must be missing <br/>\nsomething you&#39;re trying to tell me.<br/>\n<br/>\nIt seems like you really want a single test case per production code <br/>\nclass. I have never wanted that, and I doubt I&#39;ll be able to convince <br/>\nyou about why that&#39;s a bad idea. I suppose you benefit from it in a way <br/>\nthat I don&#39;t. I doubt arguing over it will get us anywhere, so I&#39;m <br/>\noffering you a draw on that topic.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;  &gt; My point is pretty straightforward: we have these refactoring rules we<br/>\n&gt;  &gt; often follow and we usually say that we should refactor tests like we<br/>\n&gt;  &gt; refactor production code, so why wouldn&#39;t we apply these refactoring<br/>\n&gt;  &gt; rules to tests?<br/>\n&gt; <br/>\n&gt;    I don&#39;t quite agree with this. Tests should be simple enough to<br/>\n&gt; require no refactorings at all. Applying OOP patters to the tests may<br/>\n&gt; lead to fragile test code that will require too much maintenance,<br/>\n&gt; especially if code under test is being structurally changed.<br/>\n<br/>\n </span></blockquote>This is /very/ interesting.<br/>\n<br/>\n&quot;Applying OOP patterns to test may lead to fragile test code that will <br/>\nrequire too much maintenance.&quot;<br/>\n<br/>\nShouldn&#39;t we then conclude that<br/>\n<br/>\n&quot;Applying OOP patterns to any system may lead to fragile code that will <br/>\nrequire too much maintenance&quot;?<br/>\n<br/>\nAre you saying that refactoring makes systems more fragile?<br/>\n<br/>\n(After all, please remember that test code is still just code.)<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;  &gt;&gt; &gt; Why wouldn&#39;t we follow those rules with JUnit test case classes? The<br/>\n&gt;  &gt;&gt; &gt; first rule extracts common setup code into setUp() and fixture <br/>\n&gt; objects.<br/>\n&gt;  &gt;&gt; &gt; The second splits test case classes that have multiple fixtures into<br/>\n&gt;  &gt;&gt; &gt; separate test case classes. This leads to test case classes organized<br/>\n&gt;  &gt;&gt; &gt; around fixtures.<br/>\n&gt;  &gt;&gt; &gt;<br/>\n&gt;  &gt;&gt; &gt; As for one test case per model class, that&#39;s a natural place to start,<br/>\n&gt;  &gt;&gt; &gt; because it&#39;s simple, but once that test case class becomes complex,<br/>\n&gt;  &gt;&gt; &gt; refactor as usual.<br/>\n&gt;  &gt;&gt;<br/>\n&gt;  &gt;&gt;   That usually would lead to confusion and will require special tools<br/>\n&gt;  &gt;&gt;to track down all the test cases for given class.<br/>\n&gt;  &gt;<br/>\n&gt;  &gt; I have /never/, /ever/ wanted to track down all the tests for a given<br/>\n&gt;  &gt; class. I /have/ wanted to track down all the tests for a given /method/,<br/>\n&gt;  &gt; which is dirt simple in any decent IDE. (In Eclipse, I hit Ctrl+Shift+G.)<br/>\n&gt; <br/>\n&gt;    Can you then run ALL tests you found in a search view?<br/>\n<br/>\n </span></blockquote>Yes. I run all the tests, which includes all the tests I found in that <br/>\nsearch view. I run all the tests all the time.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;    Can these results guarantee that changed method under test didn&#39;t<br/>\n&gt; affected other methods and you don&#39;t have to run all tests for them too?<br/>\n<br/>\n </span></blockquote>I suppose not, because I don&#39;t care about that: I run all the tests anyway.<br/>\n<br/>\nLet me ask you: how does keeping one test case class per production cod <br/>\nclass &quot;guarantee that changed method under test didn&#39;t affect other <br/>\nmethods without running all the tests for them too&quot;? How do you know the <br/>\nsystem-wide impact of a change without running all the tests for the <br/>\nentire system? (I don&#39;t think the way we organize tests helps us at all <br/>\nhere.)<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;  &gt; You /believe/ this? or it&#39;s your experience? In my /experience/ it just<br/>\n&gt;  &gt; isn&#39;t that much of an issue.<br/>\n&gt; <br/>\n&gt;    It could be not an issue for unit testing of the isolated classes,<br/>\n&gt; but it is quite different if those classes have more or less complex<br/>\n&gt; dependencies (e.g. those that may be injected by IoC container in real<br/>\n&gt; app, but mocked or stubbed in a test time). That perhaps problem with<br/>\n&gt; the toolset because such testing usually introduces lot of dynamic<br/>\n&gt; dependencies only resolved or even generated in the runtime.<br/>\n<br/>\n </span></blockquote>I notice you didn&#39;t answer my question, even though you wrote this <br/>\ndirectly underneath my question. :) I used to have a lot of very <br/>\npassionate opinions until I started following a simple rule: Don&#39;t claim <br/>\nX is better than Y until you&#39;ve done both for a while and can measure <br/>\nthe difference.<br/>\n<br/>\nTake care.<br/>\n-- <br/>\nJ. B. (Joe) Rainsberger<br/>\nDiaspar Software Services<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.diasparsoftware.com\">http://www.diasparsoftware.com</a><br/>\n2005 Gordon Pask Award Winner for contribution to Agile practice<br/>\nAuthor, JUnit Recipes: Practical Methods for Programmer Testing</div>", 
    "prevInTime": 15131, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1129205584", 
    "canDelete": false, 
    "nextInTopic": 15138, 
    "prevInTopic": 15128, 
    "headers": {
        "inReplyToHeader": "PDQzNERERDIwLjEwNzA2QG1kLnBwLnJ1Pg==", 
        "messageIdInHeader": "PDQzNEU0RjUwLjEwNzAzQHJvZ2Vycy5jb20+", 
        "referencesHeader": "PEUxRU5HU1ktMDAwNHd3LUFBQHNtdHBhdXRoMDUubWFpbC5hdGwuZWFydGhsaW5rLm5ldD4gPDQzNDQ0NjFELjMwNTA3MDNAbWQucHAucnU+IDw0MzQ0NjQ0Qi40MDRAbWV0YWxhYi51bmMuZWR1PiA8NDM0NTM3NzEuOTA3MDUwOUByb2dlcnMuY29tPiA8NDM0RDM1NUUuNzA2MDQwMkBtZC5wcC5ydT4gPDQzNEREM0QwLjEwNTA5MDFAcm9nZXJzLmNvbT4gPDQzNERERDIwLjEwNzA2QG1kLnBwLnJ1Pg=="
    }
}