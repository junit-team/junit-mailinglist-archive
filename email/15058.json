{
    "numMessagesInTopic": 47, 
    "nextInTime": 15059, 
    "senderId": "Veayue-tzwXHtcVBT5UjSwkbWduXZhFePFG6u80riViiceY2iMUSEWrXrqUNzlmMl1hxrI3ccgvMYax7IZqDoU5rz8uItsTi", 
    "systemMessage": false, 
    "subject": "RE: [junit] Proposed parameterized test syntax for JUnit 4", 
    "from": "&quot;Kent Beck&quot; &lt;kentb@...&gt;", 
    "authorName": "Kent Beck", 
    "msgSnippet": "Eugene, I ll address the question of constructor vs. test method parameters now and the rest later. Here is the current implementation: ", 
    "msgId": 15058, 
    "profile": "kentlbeck", 
    "topicId": 14820, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 173198504, 
    "messageBody": "<div id=\"ygrps-yiv-1949928879\">Eugene,<br/>\n<br/>\nI&#39;ll address the question of constructor vs. test method parameters now and<br/>\nthe rest later. Here is the current implementation:<br/>\n<br/>\n@Factory(Parameterized.class)<br/>\npublic class Example {<br/>\n  @Parameters public static Object[] /* or whatever */ data() {...}<br/>\n<br/>\n  public Example(Object parameter1, Object parameter2) {<br/>\n    this.parameter1= parameter1;<br/>\n    this.parameter2= parameter2;<br/>\n  }<br/>\n<br/>\n  @Test public void one() {<br/>\n    ...<br/>\n  }<br/>\n<br/>\n  @Test public void two() {<br/>\n    ...<br/>\n  }<br/>\n} <br/>\n<br/>\nHere is the version with method parameters. It is simpler in that it doesn&#39;t<br/>\nrequire a constructor, but the parameter lists are duplicated in each test<br/>\nmethod.<br/>\n<br/>\n@Factory(Parameterized.class)<br/>\npublic class Example {<br/>\n  @Parameters public static Object[] /* or whatever */ data() {...}<br/>\n<br/>\n  @Test public void one(Object parameter1, Object parameter2) {<br/>\n    ...<br/>\n  }<br/>\n<br/>\n  @Test public void two(Object parameter1, Object parameter2) {<br/>\n    ...<br/>\n  }<br/>\n} <br/>\n<br/>\nI prefer the first version, but I have a pretty good memory for detail so it<br/>\nis generally easy for me to read the tests remembering what data has already<br/>\nbeen set. I like the lack of redundancy. However, another of my goals is for<br/>\neach test to tell a story, to be readable from beginning to end. For this,<br/>\nthe test method parameters read better to me.<br/>\n<br/>\nThe same issue arises with set-up methods. A test with lots of set-up can be<br/>\ncryptic to read:<br/>\n<br/>\n@Test public void lotsOfSetUpFirst() {<br/>\n  smallStimulus();<br/>\n  assertTrue(largeChange());<br/>\n}<br/>\n<br/>\nThis is one of those engineering trade-offs that make design a challenge.<br/>\nThe decision could go either way. My preference is to avoid redundancy and<br/>\ngo with the constructor.<br/>\n<br/>\nSincerely yours,<br/>\n<br/>\nKent Beck<br/>\nThree Rivers Institute<br/>\n<br/>\n<br/>\n<blockquote><span title=\"qreply\"> &gt; -----Original Message-----<br/>\n&gt; From: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a> [mailto:<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>] On <br/>\n&gt; Behalf Of Eugene Kuleshov<br/>\n&gt; Sent: Monday, October 03, 2005 9:15 PM<br/>\n&gt; To: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a><br/>\n&gt; Subject: Re: [junit] Proposed parameterized test syntax for JUnit 4<br/>\n&gt; <br/>\n&gt; Hi Kent,<br/>\n&gt; <br/>\n&gt;   Please see my comments below.<br/>\n&gt; <br/>\n&gt;   regards,<br/>\n&gt;   Eugene<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; Kent Beck wrote:<br/>\n&gt; <br/>\n&gt; &gt;Thank you for your comments. Followup below--<br/>\n&gt; &gt;  <br/>\n&gt; &gt;<br/>\n&gt; &gt;&gt; First of all you are forcing test runner to create new <br/>\n&gt; &gt;&gt;class instance <br/>\n&gt; &gt;&gt;for each test, which is probably good thing from the point of <br/>\n&gt; &gt;&gt;unit test <br/>\n&gt; &gt;&gt;isolation enforcement, but from other hand it put a huge <br/>\n&gt; &gt;&gt;limitation for <br/>\n&gt; &gt;&gt;tools and will have memory and performance hit as well. So, <br/>\n&gt; it would <br/>\n&gt; &gt;&gt;make sense to have these parameters passed to the test method <br/>\n&gt; &gt;&gt;(like it <br/>\n&gt; &gt;&gt;is done in TestNG).<br/>\n&gt; &gt;&gt;    <br/>\n&gt; &gt;&gt;<br/>\n&gt; &gt;I think the performance problems can be solved other ways, <br/>\n&gt; and I still like<br/>\n&gt; &gt;encouraging test isolation by executing tests in separate <br/>\n&gt; instances. The<br/>\n&gt; &gt;JUnit 4 runner creates the instances immediately in advance <br/>\n&gt; of invoking the<br/>\n&gt; &gt;test method. The current design requires less duplication <br/>\n&gt; than passing the<br/>\n&gt; &gt;parameters to the test methods, since the parameters only <br/>\n&gt; appear in the<br/>\n&gt; &gt;constructor. <br/>\n&gt; &gt;<br/>\n&gt;   As I mentioned, passing params in the constructor assume <br/>\n&gt; that all test <br/>\n&gt; methods require the same parameters which is not always the case. Can <br/>\n&gt; you please explain where will be code duplication if test <br/>\n&gt; methods will <br/>\n&gt; have all the params as a method parameters but not fileds? Do <br/>\n&gt; you refer <br/>\n&gt; to same method params that would repeated for several methods? I <br/>\n&gt; wouldn&#39;t say it is that big duplication, but it would give a <br/>\n&gt; better test <br/>\n&gt; isolation and eliminate illusion that test case is statefull. <br/>\n&gt; <br/>\n&gt; &gt;It might be better for the @Parameters method to return an<br/>\n&gt; &gt;Iterator, allowing the lazy creation of substantial data structures,<br/>\n&gt; &gt;however.<br/>\n&gt; &gt;  @Parameters static Iterator&lt;Object[]&gt; data() ...<br/>\n&gt; &gt;  <br/>\n&gt; &gt;<br/>\n&gt;   Iterator won&#39;t allow to jump directly to the specific test. <br/>\n&gt; It would <br/>\n&gt; be useful for IDE runners if user would like to restart only specific <br/>\n&gt; test case (this scenario us currently not supported in <br/>\n&gt; Eclipse&#39;s JUnit <br/>\n&gt; runner).<br/>\n&gt; <br/>\n&gt; &gt;&gt;  Second limitation is that user don&#39;t have will have to <br/>\n&gt; &gt;&gt;declaratively <br/>\n&gt; &gt;&gt;specify test data sets without writing custom @Parameters <br/>\n&gt; &gt;&gt;method and use <br/>\n&gt; &gt;&gt;some system property to differentiate between tests. Perhaps <br/>\n&gt; &gt;&gt;you can add <br/>\n&gt; &gt;&gt;some &quot;name&quot; property to Parameters annotation, so test runner <br/>\n&gt; &gt;&gt;can match <br/>\n&gt; &gt;&gt;this name with declared test data. Such name property would <br/>\n&gt; &gt;&gt;also allow <br/>\n&gt; &gt;&gt;to have multiple @Parameters methods and match them with <br/>\n&gt; &gt;&gt;@Test methods <br/>\n&gt; &gt;&gt;if you&#39;ll have same name there too. The last would allow to <br/>\n&gt; &gt;&gt;have several <br/>\n&gt; &gt;&gt;test methods with different kinds of test parameters <br/>\n&gt; without creating <br/>\n&gt; &gt;&gt;separate test classes (so you&#39;ll have single test class for <br/>\n&gt; &gt;&gt;class under <br/>\n&gt; &gt;&gt;testing).<br/>\n&gt; &gt;&gt;    <br/>\n&gt; &gt;&gt;<br/>\n&gt; &gt;I don&#39;t understand this objection. Can you write an example <br/>\n&gt; of what you<br/>\n&gt; &gt;would like to see?<br/>\n&gt; &gt;  <br/>\n&gt; &gt;<br/>\n&gt;   Ok. I may have several data sets (e.g. small one for smoke <br/>\n&gt; testing and <br/>\n&gt; a really huge one for complete regression testing) and I want <br/>\n&gt; to choose <br/>\n&gt; between them from the runner. For instance:<br/>\n&gt; <br/>\n&gt; @Parameters(name=&quot;smoke&quot;) public static Object[] data() {<br/>\n&gt;   return new int[][] {{0, 0}, {1, 1}};<br/>\n&gt; }<br/>\n&gt; <br/>\n&gt; @Parameters(name=&quot;full&quot;) public static Object[] data() {<br/>\n&gt;   // load data from external file or generate permutations<br/>\n&gt;   return data;<br/>\n&gt; }<br/>\n&gt; <br/>\n&gt;   Then you&#39;ll specify test type &quot;smoke&quot; or &quot;full&quot; on a runner and it <br/>\n&gt; will choose an appropriate set of the test data.<br/>\n&gt; <br/>\n&gt; &gt;&gt;  The last thing I&#39;d like to mention is that current <br/>\n&gt; &gt;&gt;@Parameters methods <br/>\n&gt; &gt;&gt;won&#39;t scale to large data sets (the same limitation also exists in <br/>\n&gt; &gt;&gt;TestNG). I&#39;ve seen JUnit3 suite() methods that produced <br/>\n&gt; thousands of <br/>\n&gt; &gt;&gt;test permutations and that required lots of memory memory <br/>\n&gt; &gt;&gt;when running <br/>\n&gt; &gt;&gt;tests. So, It think that it would make sense to introduce an <br/>\n&gt; &gt;&gt;interface <br/>\n&gt; &gt;&gt;similar to JDBC ResultSet, so test runner can create iterate <br/>\n&gt; &gt;&gt;trough test <br/>\n&gt; &gt;&gt;data without loading it completely into memory and also have <br/>\n&gt; &gt;&gt;option to <br/>\n&gt; &gt;&gt;get number of tests as well as jump to Nth test. You can also <br/>\n&gt; &gt;&gt;provide an <br/>\n&gt; &gt;&gt;adapter that will take Object[][] and provide all that <br/>\n&gt; &gt;&gt;functionality for <br/>\n&gt; &gt;&gt;users who don&#39;t want to create test data dynamically.<br/>\n&gt; &gt;&gt;    <br/>\n&gt; &gt;&gt;<br/>\n&gt; &gt;Would the Iterator version satisfy the need to handle large <br/>\n&gt; data sets?<br/>\n&gt; &gt;  <br/>\n&gt; &gt;<br/>\n&gt;   The limitation of the iterator is that it does not provide a random <br/>\n&gt; access. This would make difficult to rerun only selected test <br/>\n&gt; case (e.g. <br/>\n&gt; failed one)<br/>\n&gt; <br/>\n&gt;   regards,<br/>\n&gt;   Eugene </span></blockquote></div>", 
    "prevInTime": 15057, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1128464395", 
    "canDelete": false, 
    "nextInTopic": 15059, 
    "prevInTopic": 15057, 
    "headers": {
        "inReplyToHeader": "PDQzNDIwMURELjIwMTAzMDVAbWQucHAucnU+", 
        "messageIdInHeader": "PEUxRU12OHEtMDAwODc1LUJiQHNtdHBhdXRoMDgubWFpbC5hdGwuZWFydGhsaW5rLm5ldD4="
    }
}