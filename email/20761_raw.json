{
    "numMessagesInTopic": 12, 
    "nextInTime": 20762, 
    "senderId": "J1D296whxE8-VcSjKZnY_QfLutkedadxZ-DEO9ZWe_eNPmH87zio5Tt096WgG-x79KyvSGOzJ6GFrEwSXtbETCnGAEE", 
    "systemMessage": false, 
    "subject": "Re: [junit] Anyone help me to figure out the java.lang.StackOverflowError problem?", 
    "from": "&quot;David Saff&quot; &lt;david@...&gt;", 
    "authorName": "David Saff", 
    "msgSnippet": "Fuguo, I m sorry this has been bugging you.  It s difficult to understand how JUnit could be encountering a recursion loop that wasn t there in your production", 
    "msgId": 20761, 
    "rawEmail": "Return-Path: &lt;david.saff@...&gt;\r\nX-Sender: david.saff@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nX-Received: (qmail 49390 invoked from network); 6 Aug 2008 10:22:30 -0000\r\nX-Received: from unknown (66.218.67.97)\n  by m54.grp.scd.yahoo.com with QMQP; 6 Aug 2008 10:22:30 -0000\r\nX-Received: from unknown (HELO wf-out-1314.google.com) (209.85.200.175)\n  by mta18.grp.scd.yahoo.com with SMTP; 6 Aug 2008 10:22:30 -0000\r\nX-Received: by wf-out-1314.google.com with SMTP id 27so2664770wfd.17\n        for &lt;junit@yahoogroups.com&gt;; Wed, 06 Aug 2008 03:22:30 -0700 (PDT)\r\nX-Received: by 10.142.164.10 with SMTP id m10mr5895088wfe.60.1218018150616;\n        Wed, 06 Aug 2008 03:22:30 -0700 (PDT)\r\nX-Received: by 10.142.101.9 with HTTP; Wed, 6 Aug 2008 03:22:30 -0700 (PDT)\r\nMessage-ID: &lt;4f7da6b90808060322h167d184eu87dd33a838894f10@...&gt;\r\nDate: Wed, 6 Aug 2008 06:22:30 -0400\r\nTo: junit@yahoogroups.com\r\nIn-Reply-To: &lt;255770.45518.qm@...&gt;\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Transfer-Encoding: 7bit\r\nContent-Disposition: inline\r\nReferences: &lt;255770.45518.qm@...&gt;\r\nX-Google-Sender-Auth: 5c4d6e9c3794ad1a\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: &quot;David Saff&quot; &lt;david@...&gt;\r\nSubject: Re: [junit] Anyone help me to figure out the java.lang.StackOverflowError problem?\r\nX-Yahoo-Group-Post: member; u=341876227; y=1KkJfD5U-Ho-EHiDkzK7ZyDdTn7ZHZO-IpJk2_UJ8dY\r\nX-Yahoo-Profile: dsaff\r\n\r\nFuguo,\n\nI&#39;m sorry this has been bugging you.  It&#39;s difficult to understand how\nJUnit could be encountering a recursion loop that wasn&#39;t there in your\nproduction code.  Have you tried writing a main() method that runs the\nsame test, but has no dependencies on JUnit?  If it also fails with a\nStackOverflowError, then you can rest assured that JUnit is not the\nproblem.\n\n   David Saff\n\nOn Tue, Aug 5, 2008 at 6:29 AM, Fuguo Wei &lt;tawqir_wei@...&gt; wrote:\n&gt;\n&gt;\n&gt; Dear all, I am so upset about the problem I encountered. Wish any one could\n&gt; help me. Thank here first. It&#39;s the StackOverflowError problem. I thought\n&gt; It&#39;s because the recursive program I did. Any way ,I don&#39;t know how to solve\n&gt; this problem.\n&gt; Maybe I used it wrong. I was wandering where I am wrong for a few days. I am\n&gt; confused. Kindly hope you could help me. here is the code.(in the attachment\n&gt; also) if you can not get it, you could check the group file folder as well.\n&gt; I uploaded them to there. By the way, I tried the debug my source code with\n&gt; Eclipse debugger. There is no problem.\n&gt;\n&gt;\n&gt; Best regards\n&gt;\n&gt; WEI FUGUO\n&gt;\n&gt;\n&gt; (1) the test case is like this\n&gt;\n&gt; public void testCreateTableClus ter() {\n&gt; mapper2.createTable Cluster() ;\n&gt; assertNotNull( mapper.getClassM ap().getTableClu ster());\n&gt; }\n&gt;\n&gt; (2) the createTableCluster( ) source code is like this\n&gt;\n&gt; public void createTableCluster( ) {\n&gt; tableCluster. createMasterTabl e(tableName, classmap);\n&gt; }\n&gt;\n&gt; (3) the createMasterTable( ) source code is like this\n&gt;\n&gt; public MasterTableMap createMasterTable( String aTablename, ClassMap\n&gt; aClassmap)\n&gt; {\n&gt; return (MasterTableMap) createTable( aTablename, aClassmap, &#39;masterTable&#39; );\n&gt; }\n&gt;\n&gt; (4) createTable( ) source code\n&gt;\n&gt; public TableMap createTable( String aTablename, ClassMap aClassmap, String\n&gt; aTabletype)\n&gt; {\n&gt; pf.ColumnMap colummap=null;\n&gt; TableMap result =null;\n&gt; if (aTabletype. equals(&#39;masterTa ble&#39;))\n&gt; {\n&gt; result= new MasterTableMap( aTablename) ;\n&gt; this.set_masterTabl eMap(result) ;\n&gt; }\n&gt; else if (aTabletype. equals(&#39;independ entTable&#39; ))\n&gt; result= new IndependentTableMap (aTablename) ;\n&gt; else if (aTabletype. equals(&#39;dependen tTable&#39;))\n&gt; result= new DependentTableMap( aTablename) ;\n&gt; setCurrentTableMap( result);\n&gt; aClassmap.setMaster Table(result) ;\n&gt;\n&gt; java.util.List tempList =aClassmap.getColum nMaps();\n&gt;\n&gt; Iterator tmpIter = tempList.iterator( );\n&gt; while (tmpIter.hasNext( ))\n&gt; {\n&gt; colummap = (pf.ColumnMap) tmpIter.next( );\n&gt; colummap.getAttribu teMapper( ).createTableSql Process(this, colummap,\n&gt; aClassmap);\n&gt; }\n&gt; addTableMaps( result);\n&gt; return result;\n&gt; }\n&gt; (5) one of createTableSqlProce ss() is like this. [many classes which\n&gt; inherit from the same parent have createTableSqlProce ss]\n&gt;\n&gt; public void createTableSqlProce ss(TableCluster aTablecluster, pf.ColumnMap\n&gt; aColumnmap, pf.ClassMap aMasterClass) {\n&gt; ArrayColumnMap arrayColumnmap = (ArrayColumnMap) aColumnmap;\n&gt; ClassMap classmap=null;\n&gt; pf.PersistenceClass persisClass= null;\n&gt; String tableName =null;\n&gt; configfiend. RelationshipItem relation=null;\n&gt; DependentTableMap depentable=null;\n&gt;\n&gt; String elementCategory= arrayColumnmap. getElementCatego ry();\n&gt; if (elementCategory. equals(&#39;Complex&#39; ))\n&gt; {\n&gt; classmap =arrayColumnmap. getClassMap( );\n&gt; if (classmap==null)\n&gt; {\n&gt; logger.debug( &#39;The array attribute &#39;+arrayColumnmap. getColumnName( )+&#39;&#39;s\n&gt; related class was not there, the system will load it at once!&#39;);\n&gt; persisClass= PersistentClassM anager.loadPersi stenceClass( arrayColumnmap.\n&gt; getFieldType( ));\n&gt; if (persisClass! =null)\n&gt; {\n&gt; classmap=persisClas s.getMapper( ).getClassMap( );\n&gt; }\n&gt; else\n&gt; {\n&gt; logger.debug( &#39;couldn&#39;t get the persistence class from peristence class\n&gt; lib.. the process will be terminated&#39;) ;\n&gt; return;\n&gt; }\n&gt; }\n&gt; tableName=classmap. getTableName( );\n&gt; relation=arrayColum nmap.getRelation ship();\n&gt; if (arrayColumnmap. isReflectRelatio n())\n&gt; {\n&gt; if (relation!=null)\n&gt; {\n&gt; if ((relation.getRelat ionshipType( ).equals( &#39;Composition&#39; ))||(relation.\n&gt; getRelationshipT ype().equals( &#39;Strong Aggregation&#39; )))\n&gt; {\n&gt; depentable=aTablecl uster.createDepe ndentTable( tableName, classmap);\n&gt; depentable.setRefer enceTable( aMasterClass. getMasterTable( ));\n&gt; }\n&gt; else\n&gt; aTablecluster. createIndependen tTable(tableName , classmap);\n&gt; }\n&gt; }\n&gt; else\n&gt; aTablecluster. createIndependen tTable(tableName , classmap);\n&gt; }\n&gt; else\n&gt; {\n&gt; String fieldname=arrayColu mnmap.getFieldNa me();\n&gt; String fieldtype=arrayColu mnmap.getFieldTy pe();\n&gt; TableField tablefield=new TableField(fieldnam e,fieldtype, aMasterClass.\n&gt; getDomainClass( ));\n&gt; aTablecluster. getCurrentTableM ap().addField( tablefield) ;\n&gt;\n&gt; String tempstr =aMasterClass. getDomainClass( ).getName( ).substring(\n&gt; aMasterClass. getDomainClass( ).getName( ).lastIndexOf( &#39;.&#39;)+1)+&#39; oid&#39;;\n&gt; if (fieldname.toUpperC ase().indexOf( tempstr.toUpperC ase())!=- 1)\n&gt; aTablecluster. getCurrentTableM ap().setPrimaryK ey(tablefield) ;\n&gt; }\n&gt; }\n&gt;\n&gt; as you can see the createTable method is invoked recursively in\n&gt; createTableSqlProce ss() [the bold statement]\n&gt;\n&gt; the sourse code of createDependentTabl e() likes this\n&gt;\n&gt; public DependentTableMap createDependentTabl e(String aTablename, ClassMap\n&gt; aClassmap) {\n&gt; return (DependentTableMap) createTable( aTablename, aClassmap,\n&gt; &#39;dependentTable&#39; );\n&gt; }\n&gt;\n&gt; the sourse code of createIndependentTa ble() likes this\n&gt;\n&gt; public IndependentTableMap createIndependentTa ble(String aTablename,\n&gt; ClassMap aClassmap) {\n&gt; return (IndependentTableMa p)createTable( aTablename, aClassmap,\n&gt; &#39;independentTabl e&#39;);\n&gt; }\n&gt;\n&gt; the two methods are like the createMasterTable( ) at the beginning of the\n&gt; source code I listed here.\n&gt;\n&gt; the createTable( ) is invoked recursively, as you can see. I guess that&#39;s\n&gt; the point why JUnit wrong.\n&gt;\n&gt; the Junit errow message screen was captured in the attachement.\n&gt;\n&gt; ----------\n&gt;\n&gt; (1) the test case is like this\n&gt;\n&gt; public void testCreateTableCluster() {\n&gt; mapper2.createTableCluster();\n&gt; assertNotNull(mapper.getClassMap().getTableCluster());\n&gt; }\n&gt;\n&gt; (2) the createTableCluster() source code is like this\n&gt;\n&gt; public void createTableCluster() {\n&gt; tableCluster.createMasterTable(tableName, classmap);\n&gt; }\n&gt;\n&gt; (3) the createMasterTable() source code is like this\n&gt;\n&gt; public MasterTableMap createMasterTable(String aTablename, ClassMap\n&gt; aClassmap)\n&gt; {\n&gt; return (MasterTableMap)createTable(aTablename,aClassmap,&#39;masterTable&#39;);\n&gt; }\n&gt;\n&gt; (4) createTable() source code\n&gt;\n&gt; public TableMap createTable(String aTablename, ClassMap aClassmap, String\n&gt; aTabletype)\n&gt; {\n&gt; pf.ColumnMap colummap=null;\n&gt; TableMap result =null;\n&gt; if (aTabletype.equals(&#39;masterTable&#39;))\n&gt; {\n&gt; result= new MasterTableMap(aTablename);\n&gt; this.set_masterTableMap(result);\n&gt; }\n&gt; else if (aTabletype.equals(&#39;independentTable&#39;))\n&gt; result= new IndependentTableMap(aTablename);\n&gt; else if (aTabletype.equals(&#39;dependentTable&#39;))\n&gt; result= new DependentTableMap(aTablename);\n&gt; setCurrentTableMap(result);\n&gt; aClassmap.setMasterTable(result);\n&gt;\n&gt; java.util.List tempList =aClassmap.getColumnMaps();\n&gt;\n&gt; Iterator tmpIter = tempList.iterator();\n&gt; while (tmpIter.hasNext())\n&gt; {\n&gt; colummap = (pf.ColumnMap)tmpIter.next();\n&gt; colummap.getAttributeMapper().createTableSqlProcess(this, colummap,\n&gt; aClassmap);\n&gt; }\n&gt; addTableMaps(result);\n&gt; return result;\n&gt; }\n&gt; (5) one of createTableSqlProcess() is like this. [many classes which inherit\n&gt; from the same parent have createTableSqlProcess]\n&gt;\n&gt; public void createTableSqlProcess(TableCluster aTablecluster, pf.ColumnMap\n&gt; aColumnmap, pf.ClassMap aMasterClass) {\n&gt; ArrayColumnMap arrayColumnmap = (ArrayColumnMap)aColumnmap;\n&gt; ClassMap classmap=null;\n&gt; pf.PersistenceClass persisClass=null;\n&gt; String tableName =null;\n&gt; configfiend.RelationshipItem relation=null;\n&gt; DependentTableMap depentable=null;\n&gt;\n&gt; String elementCategory=arrayColumnmap.getElementCategory();\n&gt; if (elementCategory.equals(&#39;Complex&#39;))\n&gt; {\n&gt; classmap =arrayColumnmap.getClassMap();\n&gt; if (classmap==null)\n&gt; {\n&gt; logger.debug(&#39;The array attribute &#39;+arrayColumnmap.getColumnName()+&#39;&#39;s\n&gt; related class was not there, the system will load it at once!&#39;);\n&gt; persisClass=PersistentClassManager.loadPersistenceClass(arrayColumnmap.getFieldType());\n&gt; if (persisClass!=null)\n&gt; {\n&gt; classmap=persisClass.getMapper().getClassMap();\n&gt; }\n&gt; else\n&gt; {\n&gt; logger.debug(&#39;couldn&#39;t get the persistence class from peristence class lib.\n&gt; the process will be terminated&#39;);\n&gt; return;\n&gt; }\n&gt; }\n&gt; tableName=classmap.getTableName();\n&gt; relation=arrayColumnmap.getRelationship();\n&gt; if (arrayColumnmap.isReflectRelation())\n&gt; {\n&gt; if (relation!=null)\n&gt; {\n&gt; if\n&gt; ((relation.getRelationshipType().equals(&#39;Composition&#39;))||(relation.getRelationshipType().equals(&#39;Strong\n&gt; Aggregation&#39;)))\n&gt; {\n&gt; depentable=aTablecluster.createDependentTable(tableName, classmap);\n&gt; depentable.setReferenceTable(aMasterClass.getMasterTable());\n&gt; }\n&gt; else\n&gt; aTablecluster.createIndependentTable(tableName, classmap);\n&gt; }\n&gt; }\n&gt; else\n&gt; aTablecluster.createIndependentTable(tableName, classmap);\n&gt; }\n&gt; else\n&gt; {\n&gt; String fieldname=arrayColumnmap.getFieldName();\n&gt; String fieldtype=arrayColumnmap.getFieldType();\n&gt; TableField tablefield=new\n&gt; TableField(fieldname,fieldtype,aMasterClass.getDomainClass());\n&gt; aTablecluster.getCurrentTableMap().addField(tablefield);\n&gt;\n&gt; String tempstr\n&gt; =aMasterClass.getDomainClass().getName().substring(aMasterClass.getDomainClass().getName().lastIndexOf(&#39;.&#39;)+1)+&#39;oid&#39;;\n&gt; if (fieldname.toUpperCase().indexOf(tempstr.toUpperCase())!=-1)\n&gt; aTablecluster.getCurrentTableMap().setPrimaryKey(tablefield);\n&gt; }\n&gt; }\n&gt;\n&gt; as you can see the createTable method is invoked recursively in\n&gt; createTableSqlProcess() [the bold statement]\n&gt;\n&gt; the sourse code of createDependentTable() likes this\n&gt;\n&gt; public DependentTableMap createDependentTable(String aTablename, ClassMap\n&gt; aClassmap) {\n&gt; return\n&gt; (DependentTableMap)createTable(aTablename,aClassmap,&#39;dependentTable&#39;);\n&gt; }\n&gt;\n&gt; the sourse code of createIndependentTable() likes this\n&gt;\n&gt; public IndependentTableMap createIndependentTable(String aTablename,\n&gt; ClassMap aClassmap) {\n&gt; return\n&gt; (IndependentTableMap)createTable(aTablename,aClassmap,&#39;independentTable&#39;);\n&gt; }\n&gt;\n&gt;\n&gt;\n&gt; the two methods are like the createMasterTable() at the beginning of the\n&gt; source code I listed here.\n&gt;\n&gt; the createTable() is invoked recursively, as you can see. I guess that&#39;s the\n&gt; point why JUnit wrong.\n&gt; the Junit errow message screen was captured in the attachement.\n&gt;\n&gt; [Non-text portions of this message have been removed]\n&gt;\n&gt; \n\n", 
    "profile": "dsaff", 
    "topicId": 20751, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 341876227, 
    "prevInTime": 20760, 
    "contentTrasformed": false, 
    "postDate": "1218018150", 
    "canDelete": false, 
    "nextInTopic": 20768, 
    "prevInTopic": 20760, 
    "headers": {
        "inReplyToHeader": "PDI1NTc3MC40NTUxOC5xbUB3ZWI0NDgxMy5tYWlsLnNwMS55YWhvby5jb20+", 
        "messageIdInHeader": "PDRmN2RhNmI5MDgwODA2MDMyMmgxNjdkMTg0ZXU4N2RkMzNhODM4ODk0ZjEwQG1haWwuZ21haWwuY29tPg==", 
        "referencesHeader": "PDI1NTc3MC40NTUxOC5xbUB3ZWI0NDgxMy5tYWlsLnNwMS55YWhvby5jb20+"
    }
}