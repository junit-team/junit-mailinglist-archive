{
    "numMessagesInTopic": 74, 
    "nextInTime": 15978, 
    "senderId": "WQcnr3zV6QRrlFiOr_8gfS6BzAKZ885YBoxX-igT6ph8vGwYoOP7M3jDqhBN8luHAfzJUxt7LqmwMnRnC9Mkv9HdYZSKP9LzBWR6QRCVw2ft05H7p0LtBT5uiDjWt9jZuB7ZCG2cCUan", 
    "systemMessage": false, 
    "subject": "Pluggable Selector considered harmful? (Re: [junit] Re: Observations from a prod", 
    "from": "=?iso-8859-1?q?Harald_M._M=FCller?= &lt;harald.m.mueller@...&gt;", 
    "authorName": "Harald M. MÃ¼ller", 
    "msgSnippet": "... [...] ... to use a ... [...] ... I try to repeat the question - if I missed the point, then please ignore the rest: You want to understand why people who", 
    "msgId": 15977, 
    "profile": "harald_m_mueller", 
    "topicId": 15891, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 74507428, 
    "messageBody": "<div id=\"ygrps-yiv-739042438\"><blockquote><span title=\"qreply\">--- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>, &quot;J. B. Rainsberger&quot; &lt;jbrains@...&gt; wrote:<br/>\n[...]<br/>\n&gt; [1] A common way to extract test methods from JUnit (3.x) tests is<br/>\nto use a <br/>\n&gt; naming convention with reflection. Assume that we do not have access to <br/>\n&gt; metainformation such as annotations.<br/>\n[...]<br/>\n&gt; <br/>\n&gt; What I find strange in all this is that I demonstrated doing what JUnit <br/>\n&gt; does in another piece of code, and even people who use JUnit looked at <br/>\n&gt; me like I was high.[2] Why the double standard? Why does JUnit get to <br/>\n&gt; use this pattern and I don&#39;t. It&#39;s just weird, so I&#39;m looking for an <br/>\n&gt; explanation by asking the more general question, &quot;What&#39;s so bad about <br/>\n&gt; Pluggable Selector?&quot;<br/>\n<br/>\nI try to repeat the question - if I missed the point, then please<br/>\nignore the rest: You want to understand why people who are quite<br/>\nunconcerned that JUnit (and JBoss and ...) uses reflection (e.g. for a<br/>\npluggable selector) find it horrible that you want to use it in<br/>\narbitrary application code?<br/>\n<br/>\nOne possible answer that (at least for me - working with &quot;many-peopled<br/>\nprojects&quot;: 20..80 team members or so) appears quite obvious: It&#39;s the<br/>\ntooling support.<br/>\n<br/>\nIf you<br/>\n<br/>\n* need to debug (pressing Fx gets you into the called method)<br/>\n* need to use JProbe for profiling (get simple call traces)<br/>\n* need to use Eclipse to find uses of a method<br/>\n* need to use Eclipse to do refactoring<br/>\n* need to use a number of home-grown tools working on source code or<br/>\nbyte-code<br/>\n<br/>\n(and who wouldn&#39;t need to use all these tools in a technically<br/>\ncomplex, sometimes archtectural/design-level mediocre, sometimes<br/>\noutspoken *bad* environment [high turn-around of arbitrarily selected<br/>\n&quot;consultants&quot; (actually every level of hackers that&#39;s out there)] -<br/>\ncreating mediocre, sometimes bad design, code, tests etc. - in other<br/>\nwords: In a standard real project :-( ),<br/>\nyou are faced with the industry standard that compile-time<br/>\ndependencies are handled nicely by all tools; whereas reflection is<br/>\nalmost 100% unhandled.<br/>\n<br/>\nThat doesn&#39;t mean that a stack trace containing some reflection will<br/>\nstop all developers dead in their tracks - but it means that each<br/>\nsequence of<br/>\nreflection calls more on a stack trace introduces more &quot;noise&quot; that<br/>\nneeds to be understood and dug through and &quot;filtered out&quot;.<br/>\n<br/>\nA good rule-of-the-thumb for reflection in today&#39;s tooling<br/>\nenvironments is, in my experience: <br/>\n<br/>\nIf reflection appears only on top of the stack (i.e., is used by the<br/>\n&quot;calling machine&quot;), it does not disturb that much. If it occurs<br/>\n&quot;between application calls&quot; (e.g. in EJB local calls!), it is hard to<br/>\nuse and disrupts work (e.g. stepping out of a reflectively called<br/>\nmethod, the more so it it threw an exception ...). If it appears<br/>\n&quot;beetween application calls&quot; more than 2 or 3 times, quite a lot of<br/>\ntools bevome hcavy-going ...<br/>\n<br/>\nIt might be that by careful tuning of tools (masking of methods in<br/>\nshown or recorded or navigated [e.g. in debugging] stack traces;<br/>\nsearching also through certain patterns of strings [e.g. in<br/>\nrefacotring]) might alleviate that problem.<br/>\n<br/>\nAnother way might be to push the tool builders to embrace reflection<br/>\nas a &quot;first class programming concept to be encountered anywhere&quot;,<br/>\nwhich hence must be supported by all (or most) standard functionality<br/>\n(however, I&#39;d be hard pressed to design a way to e.g. replace in a<br/>\nrefactoring tool some - or even all - methods &quot;test...&quot; with e.g.<br/>\n&quot;letUsTest...&quot;. Most probably, one would need a way of describing the<br/>\n&quot;meta-rules&quot; of such &quot;meta-programming idioms&quot; to the tool so that it<br/>\ncould handle them on the same level as we humans do. A similar effect<br/>\nis slowly taking place with the presentation of data structures in<br/>\ndebuggers: You can now tell the debugger that it should drill down<br/>\nfrom an ArrayList or even a TreeSet directly to its &quot;elements&quot;,<br/>\ninstead of showing you all that structure of elements[] arrays and<br/>\nlinked TreeMap$Entry objects. Joe: You are also active in the<br/>\nrefactoring community - do you know whether  someone has written an<br/>\nextension e.g. to Eclipse for this?).<br/>\n<br/>\nMy practical experience is also that because of the tooling aspects,<br/>\ncode generation from some higher-level language usually(! ... ?)<br/>\nblends in with standard tools better - because the generator(s) can<br/>\ncreate code which looks quite &quot;hand-written&quot;, at least when looked at<br/>\nat the call stack level.<br/>\n<br/>\nSo in the end, I think the question is NOT AT ALL dynamic typing vs.<br/>\nstatic checking (or even typing): It is the fact that reflection<br/>\nsupport in Java, C# etc. is much *less* than a language with<br/>\nwell-supported dynamic typing. In such a language, I would expect that<br/>\ntools behave according to that dynamic concept, e.g. handle a &quot;string<br/>\ncall&quot; exactly the same as a &quot;fixed name call&quot; ...<br/>\n<br/>\n... another attempt to understand by giving a sort of explanation ...<br/>\n<br/>\nRegards<br/>\nHarald M. </span></blockquote></div>", 
    "prevInTime": 15976, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1139235543", 
    "canDelete": false, 
    "nextInTopic": 15978, 
    "prevInTopic": 15975, 
    "headers": {
        "inReplyToHeader": "PDQzRTY5RjNCLjMwNzAxMDFAcm9nZXJzLmNvbT4=", 
        "messageIdInHeader": "PGRzN2xzbittZGdnQGVHcm91cHMuY29tPg=="
    }
}