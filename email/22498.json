{
    "numMessagesInTopic": 9, 
    "nextInTime": 22499, 
    "senderId": "o1JbH_nS2Bua-gXBWVQeOpvdiBoLBSyPrzqZsAkpc7VxxI0TV3SdshBC9VGucZ-1Z_ZWE-FvMwAgQqotxZuXkuFh", 
    "systemMessage": false, 
    "subject": "Re: [junit] [RT] JUnit Core, Parallelism, Documentation", 
    "from": "David Saff &lt;david@...&gt;", 
    "authorName": "David Saff", 
    "msgSnippet": "On Tue, Mar 2, 2010 at 12:47 PM, Loritsch, Berin C. ... That s very, very, in-progress code, currently very changed from the most recent release (4.8.1), and", 
    "msgId": 22498, 
    "profile": "dsaff", 
    "topicId": 22487, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 341876227, 
    "messageBody": "<div id=\"ygrps-yiv-1291635403\">On Tue, Mar 2, 2010 at 12:47 PM, Loritsch, Berin C.<br/>\n&lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:berin.loritsch@...\">berin.loritsch@...</a>&gt; wrote:<br/>\n<blockquote><span title=\"ireply\"> &gt; Well, getting to the core, it is not very clear what is the _internal_<br/>\n&gt; API and what is the _external_ API.  For something like JUnit there are<br/>\n&gt; actually two external APIs to worry about:<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; *         The API for Test Writers<br/>\n&gt;<br/>\n&gt; *         The API for IDE/tool writers<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; The JavaDocs do have to be very clear on what is likely to change, and<br/>\n&gt; what is meant to be stable.  This approach allows you to clean up cruft<br/>\n&gt; over time.<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; The first misstep I saw was the move from using the Description object<br/>\n&gt; to build the tree of tests to using a Plan to build the tree of tests.<br/>\n&gt; The addChild() and getChildren() methods of the Description object are<br/>\n&gt; deprecated, yet JUnit creates the Plan from the description object.  I<br/>\n&gt; believe that the new direction of using a Plan instead of a hierarchy of<br/>\n&gt; descriptions is the correct one from a conceptual standpoint.<br/>\n<br/>\n </span></blockquote>That&#39;s very, very, in-progress code, currently very changed from the<br/>\nmost recent release (4.8.1), and certain to change before the next<br/>\nrelease (4.9).  This particular point is more about recognizing that<br/>\nwith github, more people are probably watching HEAD, and we should<br/>\nconsider a development branch, than anything to do with the<br/>\npublic/private APIs when a release version does come out.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; The API for testers is pretty well understood, and I would be very<br/>\n&gt; resistant to arbitrarily changing that.  I think most people would be as<br/>\n&gt; well.<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; What is less understood is where JUnit is designed to integrate with<br/>\n&gt; IDEs and tool vendors.  How much of the Computer/Plan/Filtering/Ordering<br/>\n&gt; do we want to expose?  What are we confident with?  The rest, as they<br/>\n&gt; say, making sure our internals work with that spec.  None of the<br/>\n&gt; internals should rely on deprecated features.  Anything in the<br/>\n&gt; &quot;internal&quot; package should be considered, by definition, internal.  That<br/>\n&gt; means anything in there that is deprecated should be free to be removed.<br/>\n<br/>\n </span></blockquote>No disagreement here.  As you see individual steps to take us in that<br/>\ndirection, please bring them to our attention.<br/>\n<br/>\n   David Saff<br/>\n<br/>\n<blockquote><span title=\"qreply\"> &gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; At least, this is how I&#39;ve evolved libraries before (I&#39;ve worked on a<br/>\n&gt; few Apache projects in the past).<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; From: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a> [mailto:<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>] On Behalf Of<br/>\n&gt; David Saff<br/>\n&gt; Sent: Tuesday, March 02, 2010 9:32 AM<br/>\n&gt; To: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a><br/>\n&gt; Subject: Re: [junit] [RT] JUnit Core, Parallelism, Documentation<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; Berin,<br/>\n&gt;<br/>\n&gt; Thanks for this! I can&#39;t touch here on all of your ideas, so feel<br/>\n&gt; free to repeat any points you&#39;d like to prioritize in the discussion.<br/>\n&gt;<br/>\n&gt; With regard to deprecation, we&#39;ve definitely begun to feel the weight<br/>\n&gt; of the old code, but have indeed felt that it&#39;s not clear whether<br/>\n&gt; being very aggressive would be in the best interests of users: thanks<br/>\n&gt; to the fact that many users of tools like Eclipse and Maven have their<br/>\n&gt; JUnit version automatically updated without explicit intervention,<br/>\n&gt; it&#39;s easy to be the cause of breaking something that&#39;s been working<br/>\n&gt; for years. That said, I think it is time for a little housecleaning.<br/>\n&gt; I&#39;ve mentioned to Kent that we should do a codesearch.google.com<br/>\n&gt; smackdown, and start kicking the least-used public method or class<br/>\n&gt; &quot;off the island&quot; with each release.<br/>\n&gt;<br/>\n&gt; As you mention, I think that the biggest obstacle to real parallelism<br/>\n&gt; is an replacement or enhancement of the BeforeClass/AfterClass idiom<br/>\n&gt; that is well-defined outside of a single-threaded execution. As two<br/>\n&gt; examples, (1) it&#39;s not well-defined whether a BeforeClass method<br/>\n&gt; should be able to be run more than once per test suite execution, (2)<br/>\n&gt; it&#39;s not well-defined whether one class can correctly start before<br/>\n&gt; another class&#39;s AfterClass method has been called.<br/>\n&gt;<br/>\n&gt; David<br/>\n&gt;<br/>\n&gt; On Mon, Mar 1, 2010 at 5:17 PM, Loritsch, Berin C.<br/>\n&gt; &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:berin.loritsch@...\">berin.loritsch@...</a> &lt;mailto:berin.loritsch%40gd-ais.com&gt; &gt; wrote:<br/>\n&gt;&gt; RT = Random Thought.  It&#39;s a habit I picked up from Stefano Mazzocchi<br/>\n&gt;&gt; when I used to work with him on the Cocoon project.  Essentially, it&#39;s<br/>\n&gt; a<br/>\n&gt;&gt; structured brain dump based on observations of the internals of a<br/>\n&gt;&gt; project (as such it is longer than most posts).  My apologies if this<br/>\n&gt; is<br/>\n&gt;&gt; not the forum for this.<br/>\n&gt;&gt;<br/>\n&gt;&gt; == Code Maintenance Thoughts ==<br/>\n&gt;&gt;<br/>\n&gt;&gt; I&#39;ve been going through some of the JUnit Core to add some JavaDocs<br/>\n&gt;&gt; (it&#39;s in my forked copy if you want me to do a Push request), and made<br/>\n&gt; a<br/>\n&gt;&gt; few observations.  I can definitely see how JUnit has begun to evolve<br/>\n&gt;&gt; over the years, and as is natural with a couple missteps along the<br/>\n&gt; way.<br/>\n&gt;&gt; It&#39;s hard to get rid of those missteps because some people may have<br/>\n&gt;&gt; extended them.  Some of the classes have been deprecated with the<br/>\n&gt;&gt; promise that they would be removed in the next revision (as of 4.4)<br/>\n&gt; and<br/>\n&gt;&gt; they are still there.  I&#39;m not saying that the current solution is a<br/>\n&gt;&gt; misstep, just that it is hard to separate the past ones from the<br/>\n&gt; current<br/>\n&gt;&gt; preferred solution.<br/>\n&gt;&gt;<br/>\n&gt;&gt; Part of managing a codebase like this includes separating the public<br/>\n&gt; and<br/>\n&gt;&gt; private API.  Some of that has been done with the &quot;internal&quot; package.<br/>\n&gt;&gt; There is no reason to worry about deprecating classes and methods in<br/>\n&gt; the<br/>\n&gt;&gt; internal package because they are not part of the public API.  But I<br/>\n&gt; did<br/>\n&gt;&gt; notice that when some classes got moved, the old class in full was<br/>\n&gt; kept<br/>\n&gt;&gt; in the original location.  A low maintenance way of performing a move<br/>\n&gt;&gt; like that makes use of inheritance.  Essentially the newer class is<br/>\n&gt;&gt; moved so there is one maintenance location, and the deprecated class<br/>\n&gt;&gt; extends the newer class.  Kind of like how the JUnit4 runner provides<br/>\n&gt; a<br/>\n&gt;&gt; preferred alias to the BlockJUnit4Runner class.<br/>\n&gt;&gt;<br/>\n&gt;&gt; Part of the core includes a nice little callback interface (the<br/>\n&gt;&gt; RunListener).  I imagine that a number of integrations make good use<br/>\n&gt; of<br/>\n&gt;&gt; this little class.  However, with the implementation as it is<br/>\n&gt; currently<br/>\n&gt;&gt; written, the RunListener can affect the run performance and<br/>\n&gt; parallelism<br/>\n&gt;&gt; available.  Essentially, the act of calling a method is a synchronous<br/>\n&gt;&gt; function.  That means a poorly written runner can detrimentally affect<br/>\n&gt;&gt; the performance of JUnit.  The one that is included with JUnit is<br/>\n&gt; pretty<br/>\n&gt;&gt; tame, doing the absolute minimum it has to do to track the test<br/>\n&gt;&gt; progress.  However, if your tests execute slower in an IDE than with<br/>\n&gt;&gt; JUnit alone, it&#39;s probably the RunListener slowing things down.<br/>\n&gt;&gt;<br/>\n&gt;&gt; == Parallelism Thoughts ==<br/>\n&gt;&gt;<br/>\n&gt;&gt; Some of the architectural decisions in JUnit&#39;s core definitely reflect<br/>\n&gt;&gt; the synchronous nature that the tests were designed to be written.  I<br/>\n&gt;&gt; don&#39;t think there is going to be an easy solution to that problem,<br/>\n&gt;&gt; unless you stick to a test class per thread model.  More on that a bit<br/>\n&gt;&gt; latter.<br/>\n&gt;&gt;<br/>\n&gt;&gt; When designing for parallel execution of tests (the ParallelComputer<br/>\n&gt;&gt; hints at this), you usually don&#39;t want an unbounded number of threads<br/>\n&gt; to<br/>\n&gt;&gt; be executed in the system.  A fairly common approach to taming the<br/>\n&gt;&gt; thread/work apportioning beast is to use queues and worker threads.<br/>\n&gt;&gt; Essentially, each test (including the set up and tear down parts) gets<br/>\n&gt;&gt; pushed on to the queue, while the executor pops it off on the other<br/>\n&gt; side<br/>\n&gt;&gt; in another process.  Essentially the relationship to executors to work<br/>\n&gt;&gt; queues depends on whatever rules you&#39;ve set up.  For JUnit a simple<br/>\n&gt;&gt; mapping of executors to the number of processors (cores) or some<br/>\n&gt;&gt; multiple of that would be sufficient.  This model is closer to how JMS<br/>\n&gt;&gt; works without all the quality of service overhead.  As the executor<br/>\n&gt; runs<br/>\n&gt;&gt; the test, it sends notification objects to the notification queue.<br/>\n&gt;&gt; Using one line of ASCII art, the process looks like this:<br/>\n&gt;&gt;<br/>\n&gt;&gt; Classes/Suite ==&gt; Executor ==&gt; Notifier<br/>\n&gt;&gt;<br/>\n&gt;&gt; Each &quot;==&gt;&quot; represents a queue.  The notification mechanism then<br/>\n&gt; becomes<br/>\n&gt;&gt; more like Swing events.  We could even cheat and use an Java 5 enum<br/>\n&gt; for<br/>\n&gt;&gt; the types of events.  This provides the same interface for all the<br/>\n&gt;&gt; events, and the convenience of an enum for determining the type of<br/>\n&gt;&gt; event.  If we take this approach a step further, if we substitute a<br/>\n&gt;&gt; PriorityQueue for the first queue, we get a way to prefer some tests<br/>\n&gt;&gt; over others (e.g. using categories as a priority mechanism).<br/>\n&gt; Collecting<br/>\n&gt;&gt; the results in a separate thread than they are being executed protects<br/>\n&gt;&gt; the execution of tests from poorly written listeners.<br/>\n&gt;&gt;<br/>\n&gt;&gt; We could go to a very fine level of detail (i.e. each individual test)<br/>\n&gt;&gt; if it weren&#39;t for the class setup/tear down methods.  Those kind of<br/>\n&gt;&gt; tests would force some sort of ordering.  It&#39;s not entirely<br/>\n&gt; impossible,<br/>\n&gt;&gt; but does require more care.<br/>\n&gt;&gt;<br/>\n&gt;&gt; Such an approach may be over-engineering things a bit, and for short<br/>\n&gt;&gt; runs of a couple hundred tests that takes less than a second to run<br/>\n&gt;&gt; definitely overkill.  However for larger projects with much larger<br/>\n&gt;&gt; execution times, it may be a way to short circuit the execution a bit.<br/>\n&gt;&gt; Essentially the win here would be the ability to execute tests while<br/>\n&gt;&gt; they are still being parsed and prepared.  That can help with things<br/>\n&gt;&gt; like Theories where collecting a large number of DataPoints can have a<br/>\n&gt;&gt; profound impact on the time it takes to run.<br/>\n&gt;&gt;<br/>\n&gt;&gt; It would be pretty easy to ensure that no more than n+2 threads are<br/>\n&gt; used<br/>\n&gt;&gt; in a system, where n = Runtime.availableProcessors().<br/>\n&gt;&gt;<br/>\n&gt;&gt;<br/>\n&gt;&gt; [Non-text portions of this message have been removed]<br/>\n&gt;&gt;<br/>\n&gt;&gt;<br/>\n&gt;&gt;<br/>\n&gt;&gt; ------------------------------------<br/>\n&gt;&gt;<br/>\n&gt;&gt; Yahoo! Groups Links<br/>\n&gt;&gt;<br/>\n&gt;&gt;<br/>\n&gt;&gt;<br/>\n&gt;&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; [Non-text portions of this message have been removed]<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; ------------------------------------<br/>\n&gt;<br/>\n&gt; Yahoo! Groups Links<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 22497, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1267625540", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 22497, 
    "headers": {
        "inReplyToHeader": "PDc1RjVFRDhBNUE1NTM2NDZBNDZFMDBFNkVDODU0RkEzMDQ0Qjk5RTRAdmFmZjAxLW1haWwwMS5hZC5nZC1haXMuY29tPg==", 
        "messageIdInHeader": "PDRmN2RhNmI5MTAwMzAzMDYxMnM1NTEwNzgyNm8zMTEzZTc2NzdjZmJlYWI1QG1haWwuZ21haWwuY29tPg==", 
        "referencesHeader": "PDc1RjVFRDhBNUE1NTM2NDZBNDZFMDBFNkVDODU0RkEzMDQ0Qjk3RjJAdmFmZjAxLW1haWwwMS5hZC5nZC1haXMuY29tPgkgPDRmN2RhNmI5MTAwMzAyMDYzMW82ZjgyMGQyN2tiMTU5NzcwYzlkN2NhMWNhQG1haWwuZ21haWwuY29tPgkgPDc1RjVFRDhBNUE1NTM2NDZBNDZFMDBFNkVDODU0RkEzMDQ0Qjk5RTRAdmFmZjAxLW1haWwwMS5hZC5nZC1haXMuY29tPg=="
    }
}