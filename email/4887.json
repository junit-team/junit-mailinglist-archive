{
    "numMessagesInTopic": 46, 
    "nextInTime": 4888, 
    "senderId": "D4PJdN3oVYRLEh3C1wAZP1n8uheVjrtKjfuQtVtTFAMZGR8_VWHkJfDNwv0YQzXihsRxnKHi0Tlgk2ea_2MuJvcMeDM5fvo", 
    "systemMessage": false, 
    "subject": "Re: black box or white box?", 
    "from": "&quot;ipreussde&quot; &lt;ilja.preuss@...&gt;", 
    "authorName": "ipreussde", 
    "msgSnippet": "... interface ... models ... model. ... environment. ... don t ... Yes. But from the perspective of developing the component, you *do* care. I am sure that", 
    "msgId": 4887, 
    "profile": "ipreussde", 
    "topicId": 4836, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 61114123, 
    "messageBody": "<div id=\"ygrps-yiv-524269511\"><blockquote><span title=\"ireply\">&gt; Imagine buying a radio.  We all know how a radio works.  It&#39;s <br/>\n </span></blockquote>interface<br/>\n<blockquote><span title=\"ireply\"> &gt; is the same no matter where you go--you have a control to change the<br/>\n&gt; station and a control to change the volume.  There are several <br/>\n </span></blockquote>models<br/>\n<blockquote><span title=\"ireply\"> &gt; of the radio, and in a store, there are many instances of each <br/>\n </span></blockquote>model.<br/>\n<blockquote><span title=\"ireply\"> &gt; <br/>\n&gt;[...]<br/>\n&gt; <br/>\n&gt; You can only really do black box testing in this type of <br/>\n </span></blockquote>environment.<br/>\n<blockquote><span title=\"ireply\"> &gt; You have the advantage of knowing what the component does.  You <br/>\n </span></blockquote>don&#39;t<br/>\n<blockquote><span title=\"ireply\"> &gt; know how it does it--and from the perspective of using the component<br/>\n&gt; you don&#39;t care.<br/>\n<br/>\n </span></blockquote>Yes. But from the perspective of developing the component, you *do* <br/>\ncare. I am sure that radios get white box tested at the plant.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; I have created a test harness using JUnit for my components, so <br/>\n </span></blockquote>that I<br/>\n<blockquote><span title=\"ireply\"> &gt; can test several component types with one TestCase.  It&#39;s a <br/>\n </span></blockquote>beautiful<br/>\n<blockquote><span title=\"ireply\"> &gt; thing.<br/>\n&gt; <br/>\n&gt; Now, If I tried to write a white-box test on my component, I run <br/>\n </span></blockquote>into<br/>\n<blockquote><span title=\"ireply\"> &gt; some serious setbacks.  That white-box (or micro test) is tied to <br/>\n </span></blockquote>the<br/>\n<blockquote><span title=\"ireply\"> &gt; component implementation.  I cannot reuse that test on another<br/>\n&gt; implementation of the same component interface.  That is a serious<br/>\n&gt; drawback to me.<br/>\n<br/>\n </span></blockquote>A very serious drawback of not adjusting tests to implementation <br/>\ndetails is that sufficient tests for one implementation are most <br/>\nprobably insufficient for another. That doesn&#39;t mean that you can&#39;t <br/>\nreuse them - it&#39;s just that it isn&#39;t safe relying on them.</div>", 
    "prevInTime": 4886, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1020720700", 
    "canDelete": false, 
    "nextInTopic": 4888, 
    "prevInTopic": 4886, 
    "headers": {
        "inReplyToHeader": "PDNDRDIwRUQ4LjQwOTA1MDFAYXBhY2hlLm9yZz4=", 
        "messageIdInHeader": "PGFiNnNucys0MTh1QGVHcm91cHMuY29tPg=="
    }
}