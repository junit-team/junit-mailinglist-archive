{
    "numMessagesInTopic": 13, 
    "nextInTime": 23640, 
    "senderId": "C1dLhMKhZmq2EW8yxUpS6LlNBa9W01s4c3N52Xxt1lsZgFViRxnUTGbrvX1bZnHoa4MCdcsIt_LOZh_UoQMgat685LI8pRZCv_4hUZjulbSAmhRbgugandE", 
    "systemMessage": false, 
    "subject": "Re: [junit] Feature request: @Assumes", 
    "from": "Stephen Connolly &lt;stephen.alan.connolly@...&gt;", 
    "authorName": "Stephen Connolly", 
    "msgSnippet": "Nope not a mock at all. Say you have a class List (which is not java.util.List but looks a lot like it in terms of interface) This list class is something you", 
    "msgId": 23639, 
    "profile": "stephenalanconnolly", 
    "topicId": 23636, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 458231986, 
    "messageBody": "<div id=\"ygrps-yiv-833172839\">Nope not a mock at all.<br/>\n<br/>\nSay you have a class List (which is not java.util.List but looks a lot<br/>\nlike it in terms of interface)<br/>\n<br/>\nThis list class is something you are developing via TDD.<br/>\n<br/>\nYou write a whole lot of unit tests for it.<br/>\n<br/>\nNow suppose it happens to be a linked list, and you decide to change<br/>\nfrom a null for end of list marker to a sentinel instead. All your<br/>\nmethods are working now, except for the isEmpty() method, but yet 200+<br/>\ntest cases are failing because they all rely on isEmpty working. Which<br/>\nunit test do I try to fix first?<br/>\n<br/>\nwith @Assumes, you would have 1 failing test and 199 skipped tests...<br/>\n<br/>\nNo mocks involved at all<br/>\n<br/>\n<blockquote><span title=\"qreply\"> On 14 September 2011 16:34, Carfield Yim &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:carfield@...\">carfield@...</a>&gt; wrote:<br/>\n&gt; It sound like a mock, isn&#39;t it?<br/>\n&gt;<br/>\n&gt; On Wed, Sep 14, 2011 at 6:02 PM, Stephen Connolly &lt;<br/>\n&gt; <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:stephen.alan.connolly@...\">stephen.alan.connolly@...</a>&gt; wrote:<br/>\n&gt;<br/>\n&gt;&gt; Note: I have also posted this to <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit-devel@...\">junit-devel@...</a> but<br/>\n&gt;&gt; I think that wider input could be beneficial<br/>\n&gt;&gt;<br/>\n&gt;&gt; Consider the case where you are testing a List class...<br/>\n&gt;&gt;<br/>\n&gt;&gt; we have<br/>\n&gt;&gt;<br/>\n&gt;&gt; public class ListTest {<br/>\n&gt;&gt;<br/>\n&gt;&gt;  @Test<br/>\n&gt;&gt;  public void newListIsEmpty() {<br/>\n&gt;&gt;    assertThat(new List().isEmpty(), is(true);<br/>\n&gt;&gt;  }<br/>\n&gt;&gt;<br/>\n&gt;&gt;  @Test<br/>\n&gt;&gt;  public void newListHasSizeZero() {<br/>\n&gt;&gt;    assertThat(new List().size(), is(0));<br/>\n&gt;&gt;  }<br/>\n&gt;&gt;<br/>\n&gt;&gt;  @Test<br/>\n&gt;&gt;  public void addPutsAnElementIntoAnEmptyList() {<br/>\n&gt;&gt;    List l = new List();<br/>\n&gt;&gt;    l.add(new Object());<br/>\n&gt;&gt;    assertThat(l.isEmpty(), is(false));<br/>\n&gt;&gt;  }<br/>\n&gt;&gt;<br/>\n&gt;&gt;  @Test<br/>\n&gt;&gt;  public void addIncreasesSizeOfPopulatedListByOne() {<br/>\n&gt;&gt;    List l = new List();<br/>\n&gt;&gt;    l.add(new Object());<br/>\n&gt;&gt;    int s = l.size();<br/>\n&gt;&gt;    l.add(new Object());<br/>\n&gt;&gt;    assertThat(l.size(), is(s + 1));<br/>\n&gt;&gt;  }<br/>\n&gt;&gt;<br/>\n&gt;&gt; }<br/>\n&gt;&gt;<br/>\n&gt;&gt; We now want to add some tests of the delete functionality... but the<br/>\n&gt;&gt; reality is that until/unless some of the preceding tests are passing,<br/>\n&gt;&gt; the tests for delete are meaningless. We could have a perfectly<br/>\n&gt;&gt; functional List.delete() method but until such time as the above tests<br/>\n&gt;&gt; are passing, there is no way to tell that the method does not work.<br/>\n&gt;&gt;<br/>\n&gt;&gt; Now I could code my tests like such<br/>\n&gt;&gt;<br/>\n&gt;&gt;  @Test<br/>\n&gt;&gt;  public void deleteIsANoOpOnEmptyList() {<br/>\n&gt;&gt;    List l = new List();<br/>\n&gt;&gt;    assumeThat(l.isEmpty(), is(true));<br/>\n&gt;&gt;    l.delete(new Object());<br/>\n&gt;&gt;  }<br/>\n&gt;&gt;<br/>\n&gt;&gt; But all that I am doing is repeating code from the preceding tests,<br/>\n&gt;&gt; having changed all those tests&#39; assertThat(...)s into assumeThat(...)s<br/>\n&gt;&gt;<br/>\n&gt;&gt; That does not seem agile to me, copy & paste & search & replace... ban<br/>\n&gt;&gt; code smell there<br/>\n&gt;&gt;<br/>\n&gt;&gt; I would much rather be able to annotate the tests with an @Assumes<br/>\n&gt;&gt; annotation that indicates that the test assumes that the specified<br/>\n&gt;&gt; tests are passing, e.g.<br/>\n&gt;&gt;<br/>\n&gt;&gt;  @Test<br/>\n&gt;&gt;  @Assumes(&quot;newListIsEmpty&quot;)<br/>\n&gt;&gt;  public void deleteIsANoOpOnEmptyList() {<br/>\n&gt;&gt;    List l = new List();<br/>\n&gt;&gt;    l.delete(new Object());<br/>\n&gt;&gt;  }<br/>\n&gt;&gt;<br/>\n&gt;&gt;  @Test<br/>\n&gt;&gt;  @Assumes({&quot;newListIsEmpty&quot;,&quot;addPutsAnElementIntoAnEmptyList&quot;)<br/>\n&gt;&gt;  public void deleteRemovesAnElement() {<br/>\n&gt;&gt;    List l = new List();<br/>\n&gt;&gt;    Object o = new Object();<br/>\n&gt;&gt;    l.add(o);<br/>\n&gt;&gt;    l.delete(o);<br/>\n&gt;&gt;    assertThat(l.isEmpty(), is(true));<br/>\n&gt;&gt;  }<br/>\n&gt;&gt;<br/>\n&gt;&gt; In fact in my initial example of tests, there are some additional<br/>\n&gt;&gt; assumptions that I didn&#39;t make explicit<br/>\n&gt;&gt;<br/>\n&gt;&gt;<br/>\n&gt;&gt;  @Test<br/>\n&gt;&gt;  @Assumes(&quot;newListIsEmpty&quot;)<br/>\n&gt;&gt;  public void addPutsAnElementIntoAnEmptyList() {<br/>\n&gt;&gt;    ...<br/>\n&gt;&gt;  }<br/>\n&gt;&gt;<br/>\n&gt;&gt; and<br/>\n&gt;&gt;<br/>\n&gt;&gt;  @Test<br/>\n&gt;&gt;  @Assumes({&quot;newListIsEmpty&quot;,&quot;addPutsAnElementIntoAnEmptyList&quot;)<br/>\n&gt;&gt;  public void addIncreasesSizeOfPopulatedListByOne() {<br/>\n&gt;&gt;    ...<br/>\n&gt;&gt;  }<br/>\n&gt;&gt;<br/>\n&gt;&gt; Now you could get some of this functionality via a TestRule...<br/>\n&gt;&gt;<br/>\n&gt;&gt; You could watch tests to see if they pass, and skip tests annotated<br/>\n&gt;&gt; with the annotation if assumed functionality is failing, but that<br/>\n&gt;&gt; would result in sporadic failures of, e.g. deleteRemovesAnElement<br/>\n&gt;&gt; because of the failing newListIsEmpty being executed _after_<br/>\n&gt;&gt; deleteRemovesAnElement rather than before.<br/>\n&gt;&gt;<br/>\n&gt;&gt; The simple point is that the test result of deleteRemovesAnElement is<br/>\n&gt;&gt; meaningless until its assumptions are true, and while I could code the<br/>\n&gt;&gt; assumptions with assumeThat(..)s C&P&S&R is even worse than C&P.<br/>\n&gt;&gt;<br/>\n&gt;&gt; Another alternative to @Assumes would be to invoke the assumed<br/>\n&gt;&gt; method(s) at the start of the test, e.g.<br/>\n&gt;&gt;<br/>\n&gt;&gt;  @Test<br/>\n&gt;&gt;  public void deleteRemovesAnElement() {<br/>\n&gt;&gt;    newListIsEmpty(); // verify assumed functionality<br/>\n&gt;&gt;    addPutsAnElementIntoAnEmptyList();  // verify assumed functionality<br/>\n&gt;&gt;    ...<br/>\n&gt;&gt;  }<br/>\n&gt;&gt;<br/>\n&gt;&gt; That gets rid of the C&P&S&R, but there are two issues with that:<br/>\n&gt;&gt;<br/>\n&gt;&gt;  1. We have to manually invoke any setup/tearDown methods, including<br/>\n&gt;&gt; all those of the rules that the test class has... very messy<br/>\n&gt;&gt;<br/>\n&gt;&gt;  2. The test fails when the assumed test fails. In actuality we can<br/>\n&gt;&gt; say nothing at all about whether deleteRemovesAnElement if a<br/>\n&gt;&gt; newListIsEmpty is not passing... yes we could code the test<br/>\n&gt;&gt; differently, but that is just moving our assumptions somewhere else.<br/>\n&gt;&gt;<br/>\n&gt;&gt; I am sure that there are others out there who feel there is a point 3...<br/>\n&gt;&gt;<br/>\n&gt;&gt;  3. We already ran those tests why waste time running them again?<br/>\n&gt;&gt;<br/>\n&gt;&gt; Well the answer to 3 is that these are UNIT tests which should be very<br/>\n&gt;&gt; fast, so what is the harm...<br/>\n&gt;&gt;<br/>\n&gt;&gt; So, in my view, best practice unit testing needs the ability to mark<br/>\n&gt;&gt; tests as assuming that other tests are passing, so that those tests<br/>\n&gt;&gt; can be skipped when the assumptions are known to be failing or<br/>\n&gt;&gt; skipped. [This is a deliberately loaded criteria... if the<br/>\n&gt;&gt; org.junit.runner.Request does not include the assumed test, then that<br/>\n&gt;&gt; test is neither known failing or known skipped, so we can run the test<br/>\n&gt;&gt; and output a warning that the failure may be because of assumed<br/>\n&gt;&gt; functionality... the use case of executing one and only one test<br/>\n&gt;&gt; repeatedly until you get that test passing]<br/>\n&gt;&gt;<br/>\n&gt;&gt; The annotation would have implications on test sorting, as any assumed<br/>\n&gt;&gt; tests would have to always happen before the assuming tests (as long<br/>\n&gt;&gt; as the assumed tests are in the org.junit.runner.Request)<br/>\n&gt;&gt;<br/>\n&gt;&gt; Also might have to be two annotations, e.g.<br/>\n&gt;&gt;<br/>\n&gt;&gt; @Assumes(methodNames)<br/>\n&gt;&gt; @AssumesClasses(classes)<br/>\n&gt;&gt;<br/>\n&gt;&gt; though in my view the @AssumesClasses is less critical, as these are<br/>\n&gt;&gt; UNIT tests and each test class should be independent to a large<br/>\n&gt;&gt; extent. However I am willing to consider that some people may have<br/>\n&gt;&gt; many test classes for one class under test, one test class containing<br/>\n&gt;&gt; all the tests of the constructors, another testing the Add methods,<br/>\n&gt;&gt; etc. in which case an @AssumesClasses annotation makes sense.<br/>\n&gt;&gt;<br/>\n&gt;&gt; Where tests contain a circular dependency, fail/error both tests<br/>\n&gt;&gt;<br/>\n&gt;&gt; Ok, let the critique begin!<br/>\n&gt;&gt;<br/>\n&gt;&gt; -Stephen<br/>\n&gt;&gt;<br/>\n&gt;&gt; P.S.<br/>\n&gt;&gt;<br/>\n&gt;&gt; I pinged Kent with an earlier version of this idea... but I think that<br/>\n&gt;&gt; he missed the point about eliminating C&P&S&R that this feature would<br/>\n&gt;&gt; provide because I didn&#39;t frame the idea correctly...<br/>\n&gt;&gt;<br/>\n&gt;&gt; ---------- Forwarded message ----------<br/>\n&gt;&gt; From: &quot;Kent Beck&quot;<br/>\n&gt;&gt; Date: 13 Sep 2011 17:11<br/>\n&gt;&gt; Subject: Re: JUnit and test dependencies<br/>\n&gt;&gt; To: &quot;Stephen Connolly&quot;<br/>\n&gt;&gt;<br/>\n&gt;&gt; Stephen,<br/>\n&gt;&gt;<br/>\n&gt;&gt; Thank you for articulating your idea so clearly. The short answer is that<br/>\n&gt;&gt; no, we don&#39;t plan to support dependencies. If I have tests that are slow<br/>\n&gt;&gt; enough that I care about dependencies, my most productive option is<br/>\n&gt;&gt; generally to work on the design of the software until the tests are fast<br/>\n&gt;&gt; enough that I no longer care. That said, my voice is only one of many. The<br/>\n&gt;&gt; longer answer is that I encourage you to post your idea on the JUnit<br/>\n&gt;&gt; mailing<br/>\n&gt;&gt; list for community discussion.<br/>\n&gt;&gt;<br/>\n&gt;&gt; Regards,<br/>\n&gt;&gt;<br/>\n&gt;&gt; Kent<br/>\n&gt;&gt;<br/>\n&gt;&gt; On Sep 13, 2011, at 8:32 AM, Stephen Connolly wrote:<br/>\n&gt;&gt;<br/>\n&gt;&gt; &gt; Kent,<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt; Are there any plans for JUnit to support some test dependencies, such as:<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt; public class OnlyRunTestsThatMakeSenseTest {<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;  @Test<br/>\n&gt;&gt; &gt;  public void basicFunctionalityWorks() {<br/>\n&gt;&gt; &gt;    ...<br/>\n&gt;&gt; &gt;  }<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;  @Test<br/>\n&gt;&gt; &gt;  @AssumesPasses(&quot;basicFunctionalityWorks&quot;)<br/>\n&gt;&gt; &gt;  public void advancedFunctionalityWorks() {<br/>\n&gt;&gt; &gt;    ...<br/>\n&gt;&gt; &gt;  }<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;  @Test<br/>\n&gt;&gt; &gt;  @AssumesPasses(&quot;basicFunctionalityWorks&quot;)<br/>\n&gt;&gt; &gt;  public void basicFunctionalityWorksWithBevel() {<br/>\n&gt;&gt; &gt;    ...<br/>\n&gt;&gt; &gt;  }<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt;  @Test<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt;<br/>\n&gt;&gt;  @AssumesPasses({&quot;basicFunctionalityWorksWithBevel&quot;,&quot;advancedFunctionalityWorks&quot;})<br/>\n&gt;&gt; &gt;  public void advancedFunctionalityWorksWithBevel() {<br/>\n&gt;&gt; &gt;    ...<br/>\n&gt;&gt; &gt;  }<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt; }<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt; In the above example, no matter what sorting is applied,<br/>\n&gt;&gt; &gt; basicFunctionalityWorks will always be run first, and the other three<br/>\n&gt;&gt; &gt; tests will only be run if basicFunctionalityWorks passed.<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt; I see the above being completely in the spirit of unit testing, the<br/>\n&gt;&gt; &gt; point with the above is that the @Before and @After&#39;s will be run<br/>\n&gt;&gt; &gt; around each method, you are just saying that there is no point even<br/>\n&gt;&gt; &gt; trying to test the advanced functionality when the basic functionality<br/>\n&gt;&gt; &gt; is broken, skip those tests which we know cannot pass. That allows the<br/>\n&gt;&gt; &gt; person writing advancedFunctionalityWorks to power through the setup<br/>\n&gt;&gt; &gt; that depends on the basic functionality and not have to litter their<br/>\n&gt;&gt; &gt; advanced test with asserts that are redundant because of the basic<br/>\n&gt;&gt; &gt; functionality. Those people who are relying on side-effects should<br/>\n&gt;&gt; &gt; really, for unit tests at least, be invoking the method who&#39;s<br/>\n&gt;&gt; &gt; side-effects they depend on directly within their test method, rather<br/>\n&gt;&gt; &gt; than relying on accidental ordering.<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt; Having said that, a second feature that I think would be good is<br/>\n&gt;&gt; &gt; something like a @RunAfter and/or @RunBefore which would ensure that<br/>\n&gt;&gt; &gt; the test method is run in sequence even if the before or after tests<br/>\n&gt;&gt; &gt; fail/are skipped. with @RunAfter and @RunBefore I still think the<br/>\n&gt;&gt; &gt; @Before and @After methods should be invoked in-between, this would be<br/>\n&gt;&gt; &gt; moving towards more of a general purpose testing framework as opposed<br/>\n&gt;&gt; &gt; to being unit-testing focused, but JUnit is just too good ;-)<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt; Thoughts?<br/>\n&gt;&gt; &gt;<br/>\n&gt;&gt; &gt; -Stephen<br/>\n&gt;&gt;<br/>\n&gt;&gt;<br/>\n&gt;&gt; ------------------------------------<br/>\n&gt;&gt;<br/>\n&gt;&gt; Yahoo! Groups Links<br/>\n&gt;&gt;<br/>\n&gt;&gt;<br/>\n&gt;&gt;<br/>\n&gt;&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; [Non-text portions of this message have been removed]<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; ------------------------------------<br/>\n&gt;<br/>\n&gt; Yahoo! Groups Links<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 23638, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1316014699", 
    "canDelete": false, 
    "nextInTopic": 23640, 
    "prevInTopic": 23638, 
    "headers": {
        "inReplyToHeader": "PENBQ2ZiT3ZlTTZOTVBKREZuNUI5dXlvNWJjY0ZKeTErcld2czgzNzNjR0hodjcxd1ZXZ0BtYWlsLmdtYWlsLmNvbT4=", 
        "messageIdInHeader": "PENBK25Qbk16eW53NEZ3LTNGQkhGOD1kK2VtaEQzZzdTT3ZYSjZ4M3VONXVqKytBUC1Wd0BtYWlsLmdtYWlsLmNvbT4=", 
        "referencesHeader": "PENBK25Qbk13YmZOdnhiaHFqV1Z5WFc3VUR0MlZNNVR6d1d6d0FpUkphSGtLcm5Iem14UUBtYWlsLmdtYWlsLmNvbT4JPENBK25Qbk15UVB3X2htQjVQWmpZNXRPN0xkaFN2WEprYjdObjlKRlpyZUIxVnk1UDhvd0BtYWlsLmdtYWlsLmNvbT4JPENBQ2ZiT3ZlTTZOTVBKREZuNUI5dXlvNWJjY0ZKeTErcld2czgzNzNjR0hodjcxd1ZXZ0BtYWlsLmdtYWlsLmNvbT4="
    }
}