{
    "numMessagesInTopic": 13, 
    "nextInTime": 23639, 
    "senderId": "lBHJLA27nNEeiViRbJyYxpYh1RaZiXpnGgK-3Y7a0mE9s7UXaB1DisjJJzLuR7ibsDsi5nnQosxQAwwV4z_KX81S3vKpF0s_", 
    "systemMessage": false, 
    "subject": "Re: [junit] Feature request: @Assumes", 
    "from": "Carfield Yim &lt;carfield@...&gt;", 
    "authorName": "Carfield Yim", 
    "msgSnippet": "It sound like a mock, isn t it? On Wed, Sep 14, 2011 at 6:02 PM, Stephen Connolly ", 
    "msgId": 23638, 
    "profile": "c8133594", 
    "topicId": 23636, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 237979346, 
    "messageBody": "<div id=\"ygrps-yiv-98620039\">It sound like a mock, isn&#39;t it?<br/>\n<br/>\nOn Wed, Sep 14, 2011 at 6:02 PM, Stephen Connolly &lt;<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:stephen.alan.connolly@...\">stephen.alan.connolly@...</a>&gt; wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Note: I have also posted this to <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit-devel@...\">junit-devel@...</a> but<br/>\n&gt; I think that wider input could be beneficial<br/>\n&gt;<br/>\n&gt; Consider the case where you are testing a List class...<br/>\n&gt;<br/>\n&gt; we have<br/>\n&gt;<br/>\n&gt; public class ListTest {<br/>\n&gt;<br/>\n&gt;  @Test<br/>\n&gt;  public void newListIsEmpty() {<br/>\n&gt;    assertThat(new List().isEmpty(), is(true);<br/>\n&gt;  }<br/>\n&gt;<br/>\n&gt;  @Test<br/>\n&gt;  public void newListHasSizeZero() {<br/>\n&gt;    assertThat(new List().size(), is(0));<br/>\n&gt;  }<br/>\n&gt;<br/>\n&gt;  @Test<br/>\n&gt;  public void addPutsAnElementIntoAnEmptyList() {<br/>\n&gt;    List l = new List();<br/>\n&gt;    l.add(new Object());<br/>\n&gt;    assertThat(l.isEmpty(), is(false));<br/>\n&gt;  }<br/>\n&gt;<br/>\n&gt;  @Test<br/>\n&gt;  public void addIncreasesSizeOfPopulatedListByOne() {<br/>\n&gt;    List l = new List();<br/>\n&gt;    l.add(new Object());<br/>\n&gt;    int s = l.size();<br/>\n&gt;    l.add(new Object());<br/>\n&gt;    assertThat(l.size(), is(s + 1));<br/>\n&gt;  }<br/>\n&gt;<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; We now want to add some tests of the delete functionality... but the<br/>\n&gt; reality is that until/unless some of the preceding tests are passing,<br/>\n&gt; the tests for delete are meaningless. We could have a perfectly<br/>\n&gt; functional List.delete() method but until such time as the above tests<br/>\n&gt; are passing, there is no way to tell that the method does not work.<br/>\n&gt;<br/>\n&gt; Now I could code my tests like such<br/>\n&gt;<br/>\n&gt;  @Test<br/>\n&gt;  public void deleteIsANoOpOnEmptyList() {<br/>\n&gt;    List l = new List();<br/>\n&gt;    assumeThat(l.isEmpty(), is(true));<br/>\n&gt;    l.delete(new Object());<br/>\n&gt;  }<br/>\n&gt;<br/>\n&gt; But all that I am doing is repeating code from the preceding tests,<br/>\n&gt; having changed all those tests&#39; assertThat(...)s into assumeThat(...)s<br/>\n&gt;<br/>\n&gt; That does not seem agile to me, copy & paste & search & replace... ban<br/>\n&gt; code smell there<br/>\n&gt;<br/>\n&gt; I would much rather be able to annotate the tests with an @Assumes<br/>\n&gt; annotation that indicates that the test assumes that the specified<br/>\n&gt; tests are passing, e.g.<br/>\n&gt;<br/>\n&gt;  @Test<br/>\n&gt;  @Assumes(&quot;newListIsEmpty&quot;)<br/>\n&gt;  public void deleteIsANoOpOnEmptyList() {<br/>\n&gt;    List l = new List();<br/>\n&gt;    l.delete(new Object());<br/>\n&gt;  }<br/>\n&gt;<br/>\n&gt;  @Test<br/>\n&gt;  @Assumes({&quot;newListIsEmpty&quot;,&quot;addPutsAnElementIntoAnEmptyList&quot;)<br/>\n&gt;  public void deleteRemovesAnElement() {<br/>\n&gt;    List l = new List();<br/>\n&gt;    Object o = new Object();<br/>\n&gt;    l.add(o);<br/>\n&gt;    l.delete(o);<br/>\n&gt;    assertThat(l.isEmpty(), is(true));<br/>\n&gt;  }<br/>\n&gt;<br/>\n&gt; In fact in my initial example of tests, there are some additional<br/>\n&gt; assumptions that I didn&#39;t make explicit<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;  @Test<br/>\n&gt;  @Assumes(&quot;newListIsEmpty&quot;)<br/>\n&gt;  public void addPutsAnElementIntoAnEmptyList() {<br/>\n&gt;    ...<br/>\n&gt;  }<br/>\n&gt;<br/>\n&gt; and<br/>\n&gt;<br/>\n&gt;  @Test<br/>\n&gt;  @Assumes({&quot;newListIsEmpty&quot;,&quot;addPutsAnElementIntoAnEmptyList&quot;)<br/>\n&gt;  public void addIncreasesSizeOfPopulatedListByOne() {<br/>\n&gt;    ...<br/>\n&gt;  }<br/>\n&gt;<br/>\n&gt; Now you could get some of this functionality via a TestRule...<br/>\n&gt;<br/>\n&gt; You could watch tests to see if they pass, and skip tests annotated<br/>\n&gt; with the annotation if assumed functionality is failing, but that<br/>\n&gt; would result in sporadic failures of, e.g. deleteRemovesAnElement<br/>\n&gt; because of the failing newListIsEmpty being executed _after_<br/>\n&gt; deleteRemovesAnElement rather than before.<br/>\n&gt;<br/>\n&gt; The simple point is that the test result of deleteRemovesAnElement is<br/>\n&gt; meaningless until its assumptions are true, and while I could code the<br/>\n&gt; assumptions with assumeThat(..)s C&P&S&R is even worse than C&P.<br/>\n&gt;<br/>\n&gt; Another alternative to @Assumes would be to invoke the assumed<br/>\n&gt; method(s) at the start of the test, e.g.<br/>\n&gt;<br/>\n&gt;  @Test<br/>\n&gt;  public void deleteRemovesAnElement() {<br/>\n&gt;    newListIsEmpty(); // verify assumed functionality<br/>\n&gt;    addPutsAnElementIntoAnEmptyList();  // verify assumed functionality<br/>\n&gt;    ...<br/>\n&gt;  }<br/>\n&gt;<br/>\n&gt; That gets rid of the C&P&S&R, but there are two issues with that:<br/>\n&gt;<br/>\n&gt;  1. We have to manually invoke any setup/tearDown methods, including<br/>\n&gt; all those of the rules that the test class has... very messy<br/>\n&gt;<br/>\n&gt;  2. The test fails when the assumed test fails. In actuality we can<br/>\n&gt; say nothing at all about whether deleteRemovesAnElement if a<br/>\n&gt; newListIsEmpty is not passing... yes we could code the test<br/>\n&gt; differently, but that is just moving our assumptions somewhere else.<br/>\n&gt;<br/>\n&gt; I am sure that there are others out there who feel there is a point 3...<br/>\n&gt;<br/>\n&gt;  3. We already ran those tests why waste time running them again?<br/>\n&gt;<br/>\n&gt; Well the answer to 3 is that these are UNIT tests which should be very<br/>\n&gt; fast, so what is the harm...<br/>\n&gt;<br/>\n&gt; So, in my view, best practice unit testing needs the ability to mark<br/>\n&gt; tests as assuming that other tests are passing, so that those tests<br/>\n&gt; can be skipped when the assumptions are known to be failing or<br/>\n&gt; skipped. [This is a deliberately loaded criteria... if the<br/>\n&gt; org.junit.runner.Request does not include the assumed test, then that<br/>\n&gt; test is neither known failing or known skipped, so we can run the test<br/>\n&gt; and output a warning that the failure may be because of assumed<br/>\n&gt; functionality... the use case of executing one and only one test<br/>\n&gt; repeatedly until you get that test passing]<br/>\n&gt;<br/>\n&gt; The annotation would have implications on test sorting, as any assumed<br/>\n&gt; tests would have to always happen before the assuming tests (as long<br/>\n&gt; as the assumed tests are in the org.junit.runner.Request)<br/>\n&gt;<br/>\n&gt; Also might have to be two annotations, e.g.<br/>\n&gt;<br/>\n&gt; @Assumes(methodNames)<br/>\n&gt; @AssumesClasses(classes)<br/>\n&gt;<br/>\n&gt; though in my view the @AssumesClasses is less critical, as these are<br/>\n&gt; UNIT tests and each test class should be independent to a large<br/>\n&gt; extent. However I am willing to consider that some people may have<br/>\n&gt; many test classes for one class under test, one test class containing<br/>\n&gt; all the tests of the constructors, another testing the Add methods,<br/>\n&gt; etc. in which case an @AssumesClasses annotation makes sense.<br/>\n&gt;<br/>\n&gt; Where tests contain a circular dependency, fail/error both tests<br/>\n&gt;<br/>\n&gt; Ok, let the critique begin!<br/>\n&gt;<br/>\n&gt; -Stephen<br/>\n&gt;<br/>\n&gt; P.S.<br/>\n&gt;<br/>\n&gt; I pinged Kent with an earlier version of this idea... but I think that<br/>\n&gt; he missed the point about eliminating C&P&S&R that this feature would<br/>\n&gt; provide because I didn&#39;t frame the idea correctly...<br/>\n&gt;<br/>\n&gt; ---------- Forwarded message ----------<br/>\n&gt; From: &quot;Kent Beck&quot;<br/>\n&gt; Date: 13 Sep 2011 17:11<br/>\n&gt; Subject: Re: JUnit and test dependencies<br/>\n&gt; To: &quot;Stephen Connolly&quot;<br/>\n&gt;<br/>\n&gt; Stephen,<br/>\n&gt;<br/>\n&gt; Thank you for articulating your idea so clearly. The short answer is that<br/>\n&gt; no, we don&#39;t plan to support dependencies. If I have tests that are slow<br/>\n&gt; enough that I care about dependencies, my most productive option is<br/>\n&gt; generally to work on the design of the software until the tests are fast<br/>\n&gt; enough that I no longer care. That said, my voice is only one of many. The<br/>\n&gt; longer answer is that I encourage you to post your idea on the JUnit<br/>\n&gt; mailing<br/>\n&gt; list for community discussion.<br/>\n&gt;<br/>\n&gt; Regards,<br/>\n&gt;<br/>\n&gt; Kent<br/>\n&gt;<br/>\n&gt; On Sep 13, 2011, at 8:32 AM, Stephen Connolly wrote:<br/>\n&gt;<br/>\n&gt; &gt; Kent,<br/>\n&gt; &gt;<br/>\n&gt; &gt; Are there any plans for JUnit to support some test dependencies, such as:<br/>\n&gt; &gt;<br/>\n&gt; &gt; public class OnlyRunTestsThatMakeSenseTest {<br/>\n&gt; &gt;<br/>\n&gt; &gt;  @Test<br/>\n&gt; &gt;  public void basicFunctionalityWorks() {<br/>\n&gt; &gt;    ...<br/>\n&gt; &gt;  }<br/>\n&gt; &gt;<br/>\n&gt; &gt;  @Test<br/>\n&gt; &gt;  @AssumesPasses(&quot;basicFunctionalityWorks&quot;)<br/>\n&gt; &gt;  public void advancedFunctionalityWorks() {<br/>\n&gt; &gt;    ...<br/>\n&gt; &gt;  }<br/>\n&gt; &gt;<br/>\n&gt; &gt;  @Test<br/>\n&gt; &gt;  @AssumesPasses(&quot;basicFunctionalityWorks&quot;)<br/>\n&gt; &gt;  public void basicFunctionalityWorksWithBevel() {<br/>\n&gt; &gt;    ...<br/>\n&gt; &gt;  }<br/>\n&gt; &gt;<br/>\n&gt; &gt;  @Test<br/>\n&gt; &gt;<br/>\n&gt;<br/>\n&gt;  @AssumesPasses({&quot;basicFunctionalityWorksWithBevel&quot;,&quot;advancedFunctionalityWorks&quot;})<br/>\n&gt; &gt;  public void advancedFunctionalityWorksWithBevel() {<br/>\n&gt; &gt;    ...<br/>\n&gt; &gt;  }<br/>\n&gt; &gt;<br/>\n&gt; &gt; }<br/>\n&gt; &gt;<br/>\n&gt; &gt; In the above example, no matter what sorting is applied,<br/>\n&gt; &gt; basicFunctionalityWorks will always be run first, and the other three<br/>\n&gt; &gt; tests will only be run if basicFunctionalityWorks passed.<br/>\n&gt; &gt;<br/>\n&gt; &gt; I see the above being completely in the spirit of unit testing, the<br/>\n&gt; &gt; point with the above is that the @Before and @After&#39;s will be run<br/>\n&gt; &gt; around each method, you are just saying that there is no point even<br/>\n&gt; &gt; trying to test the advanced functionality when the basic functionality<br/>\n&gt; &gt; is broken, skip those tests which we know cannot pass. That allows the<br/>\n&gt; &gt; person writing advancedFunctionalityWorks to power through the setup<br/>\n&gt; &gt; that depends on the basic functionality and not have to litter their<br/>\n&gt; &gt; advanced test with asserts that are redundant because of the basic<br/>\n&gt; &gt; functionality. Those people who are relying on side-effects should<br/>\n&gt; &gt; really, for unit tests at least, be invoking the method who&#39;s<br/>\n&gt; &gt; side-effects they depend on directly within their test method, rather<br/>\n&gt; &gt; than relying on accidental ordering.<br/>\n&gt; &gt;<br/>\n&gt; &gt; Having said that, a second feature that I think would be good is<br/>\n&gt; &gt; something like a @RunAfter and/or @RunBefore which would ensure that<br/>\n&gt; &gt; the test method is run in sequence even if the before or after tests<br/>\n&gt; &gt; fail/are skipped. with @RunAfter and @RunBefore I still think the<br/>\n&gt; &gt; @Before and @After methods should be invoked in-between, this would be<br/>\n&gt; &gt; moving towards more of a general purpose testing framework as opposed<br/>\n&gt; &gt; to being unit-testing focused, but JUnit is just too good ;-)<br/>\n&gt; &gt;<br/>\n&gt; &gt; Thoughts?<br/>\n&gt; &gt;<br/>\n&gt; &gt; -Stephen<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; ------------------------------------<br/>\n&gt;<br/>\n&gt; Yahoo! Groups Links<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n<br/>\n<br/>\n </span></blockquote>[Non-text portions of this message have been removed]</div>", 
    "prevInTime": 23637, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1316014453", 
    "canDelete": false, 
    "nextInTopic": 23639, 
    "prevInTopic": 23636, 
    "headers": {
        "inReplyToHeader": "PENBK25Qbk15UVB3X2htQjVQWmpZNXRPN0xkaFN2WEprYjdObjlKRlpyZUIxVnk1UDhvd0BtYWlsLmdtYWlsLmNvbT4=", 
        "messageIdInHeader": "PENBQ2ZiT3ZlTTZOTVBKREZuNUI5dXlvNWJjY0ZKeTErcld2czgzNzNjR0hodjcxd1ZXZ0BtYWlsLmdtYWlsLmNvbT4=", 
        "referencesHeader": "PENBK25Qbk13YmZOdnhiaHFqV1Z5WFc3VUR0MlZNNVR6d1d6d0FpUkphSGtLcm5Iem14UUBtYWlsLmdtYWlsLmNvbT4JPENBK25Qbk15UVB3X2htQjVQWmpZNXRPN0xkaFN2WEprYjdObjlKRlpyZUIxVnk1UDhvd0BtYWlsLmdtYWlsLmNvbT4="
    }
}