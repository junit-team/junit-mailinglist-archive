{
    "numMessagesInTopic": 80, 
    "nextInTime": 18738, 
    "senderId": "ZJiWUmMAYM8fgd258VC_cKCsVblDWBcbWPb0h12X_8T0ktoHjhh_6TT3oxPaMXcKfYvvqUamSbSPXc067K_P2fmN8kVJKw", 
    "systemMessage": false, 
    "subject": "Re: [junit] Automatically enumerating tests from production code", 
    "from": "Ole Ersoy &lt;ole_ersoy@...&gt;", 
    "authorName": "Ole Ersoy", 
    "msgSnippet": "... True. Personally I prefer to keep a method as simple as possible so that each method addresses a specific concern within the process of mapping some inputs", 
    "msgId": 18737, 
    "profile": "ole_ersoy", 
    "topicId": 18605, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 98908154, 
    "messageBody": "<div id=\"ygrps-yiv-867537962\"><blockquote><span title=\"ireply\">&gt; It is one of the things I&#39;m saying, but even before<br/>\n&gt; we worry about <br/>\n&gt; whether a method is implemented correctly according<br/>\n&gt; to the wishes of the <br/>\n&gt; programmer, we need to worry about how much testable<br/>\n&gt; behavior we can <br/>\n&gt; even infer from a correct implementation that<br/>\n&gt; depends on abstract method <br/>\n&gt; definitions.<br/>\n<br/>\n<br/>\n </span></blockquote>True.<br/>\n<br/>\nPersonally I prefer to keep a method as simple as<br/>\npossible so that each method addresses a specific<br/>\nconcern within the process of mapping some inputs to<br/>\nsome outputs, while catching and dealing with possible<br/>\nexceptions that can occur during mapping (From JDBC or<br/>\nwebservices for instance) and the possibility of<br/>\ninputs that don&#39;t pass invarient constraint<br/>\ndefinitions.<br/>\n<br/>\nThis way I can get a good idea of what goes in, and<br/>\nhow it should come out, and how to enumerate that.<br/>\n<br/>\nThis makes me feel comfortable with respect to what I<br/>\njust wrote.<br/>\n<br/>\nSo if I were to apply this type of approach to legacy<br/>\ncode, I think I would first run something like the<br/>\nbranch analyzers in PMD (Thanks Joakim), to determine<br/>\nwhich methods needs simplification, then simplify, and<br/>\nthen generate unit tests.<br/>\n<br/>\nThen I&#39;d have to go through and analyze whether the<br/>\ncode does what the concept that is being coded<br/>\ndefines.<br/>\n<br/>\nI think this is where the template approach comes in<br/>\nthat Jimm is working on.  For me this type of approach<br/>\nmeans having a domain specific language, like OCL,<br/>\nthat further constrains what is possible in Java,<br/>\ngiving the solution designer a more limited set of<br/>\ntools for expressing an idea, while at the same time<br/>\ngiving the designer an exhaustive set of tools within<br/>\na specific solution domain, like Data Mining for<br/>\ninstance.<br/>\n<br/>\nCheers,<br/>\n- Ole<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n--- &quot;J. B. Rainsberger&quot; &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:jbrains762@...\">jbrains762@...</a>&gt; wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Ole Ersoy wrote:<br/>\n&gt; <br/>\n&gt; &gt; I assume you mean that there&#39;s an interface<br/>\n&gt; &gt; that describes the return value and parameters<br/>\n&gt; &gt; for the method?<br/>\n&gt; &gt; <br/>\n&gt; &gt; Then there&#39;s a class that implements the<br/>\n&gt; interface.<br/>\n&gt; <br/>\n&gt; Indeed, there are perhaps 5 or 50 classes that<br/>\n&gt; implement that interface.<br/>\n&gt; <br/>\n&gt; &gt; I think your point is...how do I know what the<br/>\n&gt; method<br/>\n&gt; &gt; body is, if I&#39;m only given the interface?<br/>\n&gt; &gt; <br/>\n&gt; &gt; True - I can&#39;t test much then.<br/>\n&gt; <br/>\n&gt; Thank you. I wanted to make sure I wasn&#39;t missing<br/>\n&gt; something important.<br/>\n&gt; <br/>\n&gt; &gt; I&#39;m relying on the method body and using it as the<br/>\n&gt; &gt; specification of what the programmer intended for<br/>\n&gt; the<br/>\n&gt; &gt; method to do. If what the programmers code<br/>\n&gt; produces<br/>\n&gt; &gt; is different from what their intention was then<br/>\n&gt; the<br/>\n&gt; &gt; tests are wrong as well.<br/>\n&gt; &gt; <br/>\n&gt; &gt; So the dataset produced for the tests will be<br/>\n&gt; wrong.<br/>\n&gt; &gt; <br/>\n&gt; &gt; I think that&#39;s what you are saying, and it&#39;s a<br/>\n&gt; good<br/>\n&gt; &gt; point.<br/>\n&gt;<br/>\n <br/>\n&gt; -- <br/>\n&gt; J. B. (Joe) Rainsberger :: <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.jbrains.ca\">http://www.jbrains.ca</a><br/>\n&gt; Your guide to software craftsmanship<br/>\n&gt; JUnit Recipes: Practical Methods for Programmer<br/>\n&gt; Testing<br/>\n&gt; 2005 Gordon Pask Award for contribution Agile<br/>\n&gt; Software Practice<br/>\n&gt; <br/>\n<br/>\n<br/>\n<br/>\n <br/>\n </span></blockquote>____________________________________________________________________________________<br/>\nDo you Yahoo!?<br/>\nEveryone is raving about the all-new Yahoo! Mail beta.<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://new.mail.yahoo.com\">http://new.mail.yahoo.com</a></div>", 
    "prevInTime": 18736, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1168811590", 
    "canDelete": false, 
    "nextInTopic": 18738, 
    "prevInTopic": 18736, 
    "headers": {
        "inReplyToHeader": "PDQ1QUE5ODA4LjgwNzAzMDBAZ21haWwuY29tPg==", 
        "messageIdInHeader": "PDI1MDM2MS40MTMyMC5xbUB3ZWI2MDcxMi5tYWlsLnlhaG9vLmNvbT4="
    }
}