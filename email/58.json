{
    "numMessagesInTopic": 8, 
    "nextInTime": 59, 
    "senderId": "7x7O1epqLL64SRaL7s8z2Xg8GC7XQaarUFjyH80Ks7IJTbTODMid9nHYhBzeZ74oYsCW-BMXpVT7-U3BhtgCaCTk14uI2mth3ZCdxIc", 
    "systemMessage": false, 
    "subject": "RE: [junit] Test File Output comparison : Should probably be an F AQ but I didn&#39;t see it so....", 
    "from": "&quot;Blum, Robert&quot; &lt;rblum@...&gt;", 
    "authorName": "Blum, Robert", 
    "msgSnippet": "... UhOh. I didn t have my coffee yet :-) ... Not having an idea about doclets, I don t know if the following is applicable ... For simplicity, let s assume", 
    "msgId": 58, 
    "topicId": 56, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 0, 
    "messageBody": "<div id=\"ygrps-yiv-10308453\"><blockquote><span title=\"ireply\">&gt; I am not sure that I grok what you are saying.<br/>\n<br/>\n </span></blockquote>UhOh. I didn&#39;t have my coffee yet :-)<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; As a concrete example I am currently working on a a templated <br/>\n&gt; code generator implemented as a Javadoc DocLet. So I run Javadoc <br/>\n&gt;, giving it the classname of the doclet and the name<br/>\n&gt; of the code template, and the doclet takes the supplied class <br/>\n&gt; information from Javadoc and produces an output file according to the <br/>\n&gt; template&#39;s instructions. It is a simple program, using the reflection<br/>\n&gt; API and the doclet API to do most of the work.<br/>\n<br/>\n </span></blockquote>Not having an idea about doclets, I don&#39;t know if the following is<br/>\napplicable<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Most of the 9 classes can be quickly and cleanly unit tested <br/>\n&gt; with little work. But the overall transformation from Template <br/>\n&gt; to generated code also needs to be unit testable for refactoring<br/>\n&gt; and maintainence reasons.<br/>\n<br/>\n </span></blockquote>For simplicity, let&#39;s assume that work is done in a class called<br/>\nTransformer...<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; As far as I can tell, I need a standard &quot;oracular&quot; or dummy doclet<br/>\n&gt; information provider to act as the source of class information and <br/>\n&gt; a standard template to test as well as<br/>\n&gt; a piece of transformed output to verify against.<br/>\n<br/>\n&gt; The template and canonical output could be embedded as strings in the<br/>\n&gt; program itself.<br/>\n<br/>\n&gt; But the transformed text (going out via a PrintWriter class) <br/>\n&gt; I believe is only accessible as a file.<br/>\n<br/>\n </span></blockquote>So, basically, you have something like<br/>\nTransformer.DoTransform(DocletInfoProvider info,String template,PrintWriter<br/>\nout)<br/>\n<br/>\nIgnore the first two parameters... the PrintWriter is the important part<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Am I wrong ? Can I restructure this so that it is <br/>\n&gt; unit testable writing to and from buffers and still manageable <br/>\n&gt; as a file output type of tool ?<br/>\n<br/>\n </span></blockquote>If you pass the PrintWriter in, this is directly unit testable.<br/>\n<br/>\nSet up a PrintWriter like this:<br/>\n<br/>\n\t// ... set up Doclet info provider and template<br/>\n<br/>\n\t// set up print writer<br/>\n\tByteArrayOutputStream\tstream = new ByteArrayOutputStream;\t//<br/>\nGet an output stream to hold the results<br/>\n\tPrintWriter out=new PrintWriter(stream);\t\t// all<br/>\noutput ends up in stream<br/>\n<br/>\n\t// call your method<br/>\n\tTransformer.DoTransform(info,template,out);<br/>\n<br/>\n\t// Now, stream should contain the expected result<br/>\n\tassertEquals(expectedOutputString,stream.toString());<br/>\n<br/>\n<br/>\nThat should do the trick...<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; &gt;One of the benefits you reap if you implement your classes <br/>\n&gt; that way is that<br/>\n&gt; &gt;you can add MD5 checksums, compression, etc without any <br/>\n&gt; redesign. If your<br/>\n&gt; &gt;class is writing directly to a file, you would have to <br/>\n&gt; modify that class to<br/>\n&gt; &gt;achieve the same.<br/>\n&gt; <br/>\n&gt; &gt;Of course, that&#39;s only a guess - I could be completely off :-)<br/>\n&gt; <br/>\n&gt; I think it is clear from my question above that I lack an <br/>\n&gt; understanding of<br/>\n&gt; how<br/>\n&gt; this would be achieved within the Javba I/O library.<br/>\n<br/>\n </span></blockquote>Compression and checksums? Checksums are implemented by CheckedOutputStream.<br/>\nCompression is a ZipOutputStream. They all inherit from FilterOutputStream.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; <br/>\n&gt; Awaiting your response with baited breath<br/>\n<br/>\n </span></blockquote>Hopefully I could answer your question. If that&#39;s not what you were looking<br/>\nfor, I&#39;m probably misunderstanding your problem.<br/>\n<br/>\nBye,<br/>\n  Robert<br/>\n<br/>\nPlease be aware that messages sent over the Internet may not be secure and<br/>\nshould not be seen as forming a legally binding contract unless otherwise<br/>\nstated. Furthermore, I am not speaking for Midway Games in any way - this is<br/>\na strictly personal message.</div>", 
    "prevInTime": 57, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "975434661", 
    "canDelete": false, 
    "nextInTopic": 59, 
    "prevInTopic": 57, 
    "headers": {
        "messageIdInHeader": "PDU5MzNFNzk2NjZDQUQyMTFBRUY4MDAxMDVBNUZEQjM3MDJCOERDMDJAY2hpbXNnMS1udC5jaGkud21zLmNvbT4="
    }
}