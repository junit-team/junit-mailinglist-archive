{
    "numMessagesInTopic": 27, 
    "nextInTime": 7267, 
    "senderId": "Ue1dizU8YuDJrjR6qS75ugGHxF_ReofPvjUC2MWwkQYSNEmA0rMi051waaxlRerf7ePivrnMIsMsxOh53QZO_n785axf1jgrchBUPWRl", 
    "systemMessage": false, 
    "subject": "JUnit Design?", 
    "from": "Eric Armstrong &lt;eric.armstrong@...&gt;", 
    "authorName": "Eric Armstrong", 
    "msgSnippet": "(lengthy, philosophical, article-length) (grab a cup of coffee) Summary ... At the same time that SuiteRunner provides some useful extensions to JUnit (api", 
    "msgId": 7266, 
    "rawEmail": "Return-Path: &lt;eric.armstrong@...&gt;\r\nX-Sender: eric.armstrong@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (EGP: mail-8_2_6_5); 20 Mar 2003 00:14:37 -0000\r\nReceived: (qmail 84763 invoked from network); 20 Mar 2003 00:14:35 -0000\r\nReceived: from unknown (66.218.66.218)\n  by m15.grp.scd.yahoo.com with QMQP; 20 Mar 2003 00:14:35 -0000\r\nReceived: from unknown (HELO kathmandu.sun.com) (192.18.98.36)\n  by mta3.grp.scd.yahoo.com with SMTP; 20 Mar 2003 00:14:35 -0000\r\nReceived: from ha1sca-mail1.SFBay.Sun.COM ([129.145.155.51])\n\tby kathmandu.sun.com (8.9.3+Sun/8.9.3) with ESMTP id RAA28090\n\tfor &lt;junit@yahoogroups.com&gt;; Wed, 19 Mar 2003 17:14:34 -0700 (MST)\r\nReceived: from sun.com (d-usca14-129-126 [129.145.129.126])\n\tby ha1sca-mail1.SFBay.Sun.COM (8.11.6+Sun/8.10.2/ENSMAIL,v2.1p1) with ESMTP id h2K0EYr26265\n\tfor &lt;junit@yahoogroups.com&gt;; Wed, 19 Mar 2003 16:14:34 -0800 (PST)\r\nMessage-ID: &lt;3E7907EA.BD38EC4B@...&gt;\r\nDate: Wed, 19 Mar 2003 16:14:34 -0800\r\nX-Mailer: Mozilla 4.8 [en] (Windows NT 5.0; U)\r\nX-Accept-Language: en\r\nMIME-Version: 1.0\r\nTo: JUnit &lt;junit@yahoogroups.com&gt;\r\nSubject: JUnit Design?\r\nContent-Type: text/plain; charset=us-ascii\r\nContent-Transfer-Encoding: 7bit\r\nFrom: Eric Armstrong &lt;eric.armstrong@...&gt;\r\nX-Yahoo-Group-Post: member; u=78994084\r\nX-Yahoo-Profile: ericsilverlight\r\n\r\n(lengthy, philosophical, article-length)\n(grab a cup of coffee)\n\nSummary\n-------\nAt the same time that SuiteRunner provides some \nuseful extensions to JUnit (api signature testing,\nnetwork testing), it also provides some interesting \nsimplifications. Determining whether those simplifications \nare dual-edged swords requires both a better understanding  \nof the motivations behind the JUnit design, and a better\nunderstanding of the motivations for SuiteRunner&#39;s\nrefactoring.\n\nIntroduction\n------------\nI spent a little time looking at Artima SuiteRunner\nhttp://www.artima.com/suiterunner/\n\nAfter looking at the API documentation and the tutorial\nat http://www.artima.com/suiterunner/tutorial.html, I\nfound that I had some questions about some of the\nmotivations behind JUnit&#39;s current design, and I suspect\nthat a comparison of the the two systems will help \nbring out the rationale behind JUnit, to make a better\nbasis for comparison.\n\nThis post compares SuiteRunner and JUnit in several areas:\n  * Conceptual Underpinnings\n  * Test Sequencing\n  * Class Structure\n  * Assertion Syntax\n\nConceptual Underpinnings\n------------------------\nThe most appealing feature of SuiteRunner that I see\nat the moment is it&#39;s conceptual simplicity:\n  * Suites contain tests\n  * Suites are classes, tests are methods\n  * Suites can also contain other suites\n  * You run a suite, and send the results to a reporter\n  * There&#39;s a graphic reporter, an HTML reporter, and\n    a text reporter, as well as examples of custom\n    XML reporters.\n\nThere are also some additional facilities:\n  * SuiteRunner can run existing JUnit tests (since it&#39;s\n    intended as an &quot;upgrade&quot;).\n\n  * You can create &quot;recipes&quot; (property files) for additional\n    control when executing tests. (For example, you can\n    change the directory path settings to select a different\n    version of the libraries used by the tests.)\n\nProbably the nicest thing in all this was that there is no\nconfusion at all as to what is a &quot;test&quot;. In SuiteRunner,\ntests are methods, and suites are collections of tests \n(or other suites). End of Story.\n\nIn JUnit, on the other hand, a &quot;test&quot; is a class. But a\n&quot;test&quot; is also a method. That terminology can lead to \nconfusion, on occasion.\n\nSo if SuiteRunner seems to be more intuitive in this\nrespect, it makes me wonder what it is that motivated\nJUnit&#39;s current architecture?\n\nIt may be that the difference in &quot;test sequencing&quot;\n(discussed next) can help to explain the difference.\n\nTest Sequencing\n---------------\nIn SuiteRunner, a suite (class) object is constructed,\nand all of the tests in it are run. The advantages are:\n  * performance \n    The class isn&#39;t recreated for each method.\n\n  * sequencing \n    It&#39;s easy to create a testA, testB sequence, where the\n    operation of testB uses results generated by testA\n\nIn JUnit, on the other hand, the class is reconstructed \nfor each test method, so each method operates independently.\n\nBut it&#39;s clear that a lot of thought went into JUnit&#39;s design.\nSo what is it that makes &quot;sequential tests&quot; undesirable?\n\nAbout once a week, someone shows up on the JUnit mailing list\nasking a question that is similar to this: &quot;How do I get test2\nto use the results of test1?&quot;, or its equivalent (often\nphrased in the form, &quot;How do I specify the sequence in which\ntests are run?&quot;, where the real goal is the construction of\ndependent tests. So the question would appear to need a good \nanswer.\n\nOn the other hand, suppose there is an indisputable rationale\nfor the independence of test methods. Returning to the \nquestion raised in the &quot;Conceptual Underpinnings&quot; section, \nit&#39;s now clear that at runtime, a test is *both* a class and a \nmethod, because a JUnit test class will only ever run one \ntest method, and it will do so in a pristine object created\nfrom that class.\n\nOn the other hand, the *syntax* of a JUnit test class clearly \ndepicts the class as a collection of test methods. \n\nThe question then becomes, is there a way to eliminate the\nsemantic confusion? At runtime, a test is a class, and a \ntest is a method. They are one and the same. But when we&#39;re\ntalking about Junit &quot;tests&quot;, it&#39;s often not clear whether \nwe are talking about a collection of methods or a\ncollection of classes. (A confusion that led to at least one\nmajor misunderstanding by the author, reflected in an earlier\npost.)\n\nClass Structure\n---------------\nThen there is the matter of class structure. The SuiteRunner\ntutorial says:\n  &quot;you can think of class Suite as the JUnit types\n   TestCase, TestSuite, Assert, and Test all collapsed\n   into one type&quot;\n\nAgain, the major value appears to be conceptual simplicity. \nIn particular, you don&#39;t have the difficult-to-follow\nstructure where TestCase extends Assert and implements Test.\n\nSo that raises the question: What was it that made those 4 class\ntypes appear to be valuable? What motivated that design?\n\n  Sidebar/Note:\n  The SuiteRunner article, &quot;Why We Refactored JUnit&quot;, at\n  http://www.artima.com/suiterunner/why.html\n\n  doesn&#39;t really describe the motivations for refactoring. (A\n  better title would be &quot;Why We Extended JUnit&quot;. That article\n  clearly describes the motivations that led to the SuiteRunner\n  project:\n    * Signature testing, to test API-compliance\n    * Better testing of network components \n\n  But it doesn&#39;t go into the reasons for collapsing the class\n  structure. \n\n  The article does promise a series of refactoring notes to \n  discuss such issues. It&#39;s a series I&#39;m greatly forward to. \n  Between them, and responses to the questions raised here,\n  I figure to become smarter any day now.\n\nAssertion Syntax\n----------------\nFinally, there is the fairly minor matter of how you make the\nclaims that will be validated by the tests. JUnit originally\nchose:\n   assert(x)\n\nThat was a nice, strong word that said what it meant in no-\nnonsense terms. Unfortunately, Java 1.4 usurped it, so \nJUnit had to find an alternative. So it became:\n   assertTrue(x)\n\nThat&#39;s still pretty authoritative, although lenghier.\n\nSuiteRunner, on the other hand, chose\n   verify(x)\n\nI&#39;m not very fond of that, actually, because it&#39;s not as\n&quot;strong&quot; as assert. But then it&#39;s not as long as assertTrue,\neither.\n\n   Note:\n   My personal preference is &quot;expect&quot;. It seems to be \n   strong and assertive, yet short and succinct. So that&#39;s\n   what I chose to implement in my abstract LabExperiment\n   class, where an expectation-failure leads to sudden death,\n   rather than a failure-report. (Labs are like interactive\n   debugging, where test suites are like logging. Both are\n   important.)\n\nBut where JUnit provides a bevy of assertion statements:\n  * assertTrue\n  * assertFalse\n  * assertEquals(String, String)\n  * assertEquals(float, float)\n  * assertEquals(long, long)\n  * assertEquals(boolean, boolean)\n  * assertEquals(char, char)\n  * assertEquals(short, short)\n  * assertEquals(int, int)\n  * assertNotNull\n  * assertNull\n  * assertSame(Object, Object)\n  * assertNotSame(Object, Object)\n  * fail\n  * failSame(Object, Object)\n  * failNotSame(Object, Object)\n  * failNotEquals(Object, Object)\n\nSuiteRunner chose to implement only a few:\n    verify(x)\n    fail\n\nIn general, I&#39;m in favor of that simplification. I don&#39;t\nsee any compelling need to specify:\n    assertEquals(x,y)\n\nrather than\n    verify(x == y)\n\nBut if you want to compare strings in SuiteRunner,\nyou&#39;ll need to say:\n    verify(x.equals(y))\n\nand if there is a problem, its up to you to figure out what\nthe difference is and display it.\n\n   Note:\n   The need to do a good job of displaying string differences\n   motivated LabExperiment to include this method:\n     expect(String expected, String observed)\n\n   (It took quite a while with my nose buried in a \n    thesaurus to come up with a good pair of terms like\n    &quot;expected&quot; and &quot;observed&quot;, that are grammatically\n    parallel and the same length, so that the differences\n    could be displayed in useful fashion, like this:\n       expected: |...what you got...|&quot;\n       observed: |...what you expected...|\n\nJUnit also displays what seems to me to be a defect in \ntheir API construction. The principle I&#39;m used to is that\noptional parameters go at the end of the parameter list. \nSo if you have a version of method x that takes parameter a,\nand one that takes a and b, you define the methods like this:\n   x(a)\n   x(a,b)\n\nJUnit places their optional &quot;message&quot; parameters at the \nbeginning of their assert methods, which produces this:\n   assert(condition)\n   assert(message, condition)\n\nBut SuiteRunner follows the more standard convention:\n   verify(condition)\n   verify(condition, message)\n\nTo my mind, that makes it somewhat easier to see the \ncommonalities when reading the APIs, and a tad easier to\n&quot;tack on&quot; a message at some later date, when using them.\n\nThat convention also contributes to readability when a \npotentially long string is the optional parameter. For\nexample, compare these two:\n   assert(&quot;This is a rather long string that describes &quot;\n         +&quot;the conditions under which the error occurs&quot;,\n          file.exists()\n          );\nand this:\n   assert(file.exists(),\n          &quot;This is a rather long string that describes &quot;\n         +&quot;the conditions under which the error occurs&quot;\n         );\n\nIn the second form, you can see what&#39;s being tested \nimmediately, and skip right over the text. But in the\nfirst form, you have to scan through the text to get\nto the semantics.\n\nSo I&#39;m curious if there was any particular motivation\nfor inverting the expected sequence in JUnit. (It may\nhave been a simple oversight, or it may have been one\nof those ideas that &quot;seemed better at the time&quot;, or it\nmay be that the original authors tended towards very\nshort messages and very long conditional expressions.\nThis is a fairly minor point, so its mostly a matter of\ncuriosity.)\n\nConclusions\n------------\nAt the same time that SuiteRunner provides some \nuseful extensions to JUnit, it also provides some\ninteresting simplifications. Two things are needed\nto understand the value and potential pitfalls of\nthe differences:\n  * A better understanding of the motivations behind\n    JUnit&#39;s original design\n  * A better understanding of the motivations for\n    SuiteRunner&#39;s refactoring.\n\n", 
    "profile": "ericsilverlight", 
    "topicId": 7266, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 78994084, 
    "prevInTime": 7265, 
    "contentTrasformed": false, 
    "postDate": "1048119274", 
    "canDelete": false, 
    "nextInTopic": 7271, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PDNFNzkwN0VBLkJEMzhFQzRCQHN1bi5jb20+"
    }
}