{
    "numMessagesInTopic": 23, 
    "nextInTime": 9736, 
    "senderId": "HRqGnPk_WmzEUKTmmVPaJjjq9YYR1AS1gja2wiEFlnMEcaH6p9yWiNWFBUKxCuxd-ZNe0MvFiFxq_xL7TQJttLOpdcwkRl1DNFKsnoGVvExl_x-B-NVsFIXV", 
    "systemMessage": false, 
    "subject": "RE: [junit] Re: How to test private methods, its urgent", 
    "from": "&quot;Michael Silverstein&quot; &lt;msilverstein@...&gt;", 
    "authorName": "Michael Silverstein", 
    "msgSnippet": "Agile methodologies suggest that we accept and plan for the fact that we don t always know all requirements. If I accept that I as a framework provider will in", 
    "msgId": 9735, 
    "topicId": 9699, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 62742148, 
    "messageBody": "<div id=\"ygrps-yiv-922864537\">Agile methodologies suggest that we accept and plan for the fact that we<br/>\ndon&#39;t always know all requirements. If I accept that I as a framework<br/>\nprovider will in all likelihood not be able to anticipate the myriad<br/>\nways someone might want to extend my framework then I will hesitate to<br/>\nrestrict visibility to methods, except in circumstances where I<br/>\nintentionally want to prevent use or extension.<br/>\n<br/>\nSo you either protect people from themselves or you tell them what the<br/>\nrisks are and let them make their own decisions. Remember that we are<br/>\ntalking about the ability to *extend* a framework as opposed to *using*<br/>\nit. I favor using Java Interfaces to publish real APIs, so this isn&#39;t<br/>\nreally an issue for the case of *using* a framework.<br/>\n<br/>\nOne place this ties in to testing is that you expose internal supporting<br/>\nmethods that have not been tested outside of the context of their use in<br/>\nsupport of real APIs. This is another reason to approach use of these<br/>\nmethods with caution. On the other hand, I&#39;ve often been so grateful to<br/>\nbe able to access internal methods that I&#39;m willing to accept the risks.<br/>\n<br/>\nAnyway, I realize this is straying from the topic of testing and would<br/>\nbe happy to bury this dead horse.<br/>\n<br/>\n-----------------------------<br/>\nMike Silverstein<br/>\nSilverMark, Inc.<br/>\nThe Object Testing Company<br/>\nwww.javatesting.com<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; -----Original Message-----<br/>\n&gt; From: Danijel Arsenovski [mailto:darsenovski@...] <br/>\n&gt; Sent: Tuesday, October 21, 2003 10:09 AM<br/>\n&gt; To: junit@yahoogroups.com<br/>\n&gt; Subject: RE: [junit] Re: How to test private methods, its urgent<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; OK, let&#39;s go a few steps back...<br/>\n&gt; First of all, in a well written framework, you will not <br/>\n&gt; modify or even see original source. (I will not consider <br/>\n&gt; badly written, since majority I have expirience with are fine <br/>\n&gt; in this rescpect). So, when you say only interfaces are <br/>\n&gt; visible (and I mean visibillity in software programming <br/>\n&gt; sence) I understand all classes are not, so there is no way <br/>\n&gt; to extend them (inherit). On the other hand, if classes are <br/>\n&gt; visible, there is nothing preventing a client programmer <br/>\n&gt; instantiating these classes directly (not through interface). <br/>\n&gt; Generally, you will want to permit extending only certain <br/>\n&gt; classes. The same thing happens on the method - field level, <br/>\n&gt; if you don&#39;t make method private, client programmer will <br/>\n&gt; consider it wasn&#39;t ment to be private. OO. Rule No 1: <br/>\n&gt; encapsulate! Only contract two programmers have to obey is <br/>\n&gt; code. What makes you think other programmer will read your <br/>\n&gt; docs or comments? But, if he tries to override private <br/>\n&gt; method, compiler will not permit it. (Actually, he will not <br/>\n&gt; even know the method exist.) <br/>\n&gt; If you can ENFORCE something, you will not leave it to <br/>\n&gt; chance. Making method private or public is a design decision <br/>\n&gt; , not something arbitrary. Leaving important information to <br/>\n&gt; comments, docs etc is extremely dangerous! I suggest you <br/>\n&gt; check out refactoring catalogue www.refactoring.com <br/>\n&gt; (&quot;Comments lie, code does not&quot;) and how refactoring community <br/>\n&gt; treats comments: either you don&#39;t need them  so you eliminate <br/>\n&gt; them or you make code out of them. Similar thing goes for <br/>\n&gt; documentation that is trying to explain code. Making testing <br/>\n&gt; influence your design decision is an example of very <br/>\n&gt; testing-biased paradigm, but this should not conflict with <br/>\n&gt; basic premises of OO, like most of new usefull paradigms <br/>\n&gt; don&#39;t (for example AOP does not make you change OO <br/>\n&gt; principles, it builds on them).<br/>\n&gt;  <br/>\n&gt; &gt;&gt; <br/>\n&gt; &gt;&gt; Hello Michael,<br/>\n&gt; &gt;&gt; <br/>\n&gt; &gt;&gt; <br/>\n&gt; &gt;&gt; &gt;Private methods are difficult to test because, after all, they&#39;re<br/>\n&gt; &gt;&gt; &gt;private. If you adopt a convention that API methods are only <br/>\n&gt; &gt;&gt; presented<br/>\n&gt; &gt;&gt; &gt;via Java Interfaces instead of concrete classes then you <br/>\n&gt; don&#39;t care<br/>\n&gt; &gt;&gt; &gt;about the way the implementers of the Interfaces are <br/>\n&gt; &gt;&gt; written. You can<br/>\n&gt; &gt;&gt; &gt;then make non-API methods within the concrete <br/>\n&gt; implementation public<br/>\n&gt; &gt;&gt; &gt;without implying that they are themselves API methods.<br/>\n&gt; &gt;&gt; <br/>\n&gt; &gt;&gt; I am not sure I follow, but as I can see this only works if<br/>\n&gt; &gt;&gt; you never plan to extend your clases, or leave them to be <br/>\n&gt; &gt;&gt; extended. I guess that in your case only thing visible from <br/>\n&gt; &gt;&gt; the outside are interfaces. If you write frameworks, it is <br/>\n&gt; &gt;&gt; difficult to get by without inheritance. Inheritance breaks <br/>\n&gt; &gt;&gt; encapsulation, keeping methods private helps encapsulate things. <br/>\n&gt; &gt;&gt; Also, I am not shure what you mean by &quot;without implying&quot;, <br/>\n&gt; &gt;&gt; generally you &quot;make statement&quot; with your code, any other <br/>\n&gt; &gt;&gt; method yo imply something (comments, documentation etc...) is <br/>\n&gt; &gt;&gt; superfluous.<br/>\n&gt; &gt;&gt; <br/>\n&gt; &gt;&gt; Regards,<br/>\n&gt; &gt;&gt; <br/>\n&gt; &gt;&gt; Danijel Arsenovski<br/>\n&gt; &gt;<br/>\n&gt; &gt;On the contrary, I think this approach makes it easier to extend <br/>\n&gt; &gt;frameworks. I believe that in the general case, there is no <br/>\n&gt; reason to <br/>\n&gt; &gt;make methods in classes private if their API methods are <br/>\n&gt; only accessed <br/>\n&gt; &gt;by clients via Interface methods.<br/>\n&gt; &gt;<br/>\n&gt; &gt;Here&#39;s an example of what I mean:<br/>\n&gt; &gt;<br/>\n&gt; &gt;Let&#39;s assume we have class MyClass that implements interface <br/>\n&gt; &gt;MyInterface, with methods: public int x(){<br/>\n&gt; &gt;  // return an answer based on y() and z() <br/>\n&gt; &gt;}<br/>\n&gt; &gt;private int y() {...}<br/>\n&gt; &gt;private int z() {...}<br/>\n&gt; &gt;<br/>\n&gt; &gt;And Interface MyInterface with method:<br/>\n&gt; &gt;public int x()<br/>\n&gt; &gt;<br/>\n&gt; &gt;We observe that:<br/>\n&gt; &gt;<br/>\n&gt; &gt;- MyInterface serves to &#39;publish&#39; the API method x().<br/>\n&gt; &gt;<br/>\n&gt; &gt;- Any client of MyClass will only see it in terms of<br/>\n&gt; &gt;<br/>\n&gt; &gt;- We have the choice of testing public method x() by constructing a <br/>\n&gt; &gt;test that &#39;talks&#39; to either MyClass or MyInterface.<br/>\n&gt; &gt;<br/>\n&gt; &gt;- If we have other concrete implementors of MyInterface it <br/>\n&gt; makes sense <br/>\n&gt; &gt;to write the test to talk to MyInterface rather than directly to <br/>\n&gt; &gt;implementors to they can be swapped in and tested.<br/>\n&gt; &gt;<br/>\n&gt; &gt;- x() returns a value based on values returned by private <br/>\n&gt; methods y() <br/>\n&gt; &gt;and z().<br/>\n&gt; &gt;<br/>\n&gt; &gt;- Methods y() and z() may be private for no other reason <br/>\n&gt; than that they <br/>\n&gt; &gt;are not part of the public API interface of MyClass and that the <br/>\n&gt; &gt;developer did not anticipate that anyone would ever need to <br/>\n&gt; use them in <br/>\n&gt; &gt;extending the framework.<br/>\n&gt; <br/>\n&gt; &gt;Continuing:<br/>\n&gt; &gt;Let&#39;s say<br/>\n&gt; &gt; - we want to extend MyClass with MyClass2 that implements method int<br/>\n&gt; &gt;q().<br/>\n&gt; &gt; - we want to override x() so that it uses methods y(),  <br/>\n&gt; z(), and q() to<br/>\n&gt; &gt;calculate its return value. <br/>\n&gt; &gt;<br/>\n&gt; &gt;We have a problem: MyClass2 does not have visibility to <br/>\n&gt; private methods<br/>\n&gt; &gt;y() and z().<br/>\n&gt; &gt;<br/>\n&gt; &gt;If private methods y() and z() were made public there would be no <br/>\n&gt; &gt;adverse effect on the publication of API methods because <br/>\n&gt; users of the <br/>\n&gt; &gt;class would only see those methods published via MyInterface.<br/>\n&gt; &gt;<br/>\n&gt; &gt;We have the question of whether it is *safe* to use y() and <br/>\n&gt; z(). Since <br/>\n&gt; &gt;they are not published as part of the API via MyInterface it may be <br/>\n&gt; &gt;considered too risky to use them. This can be solved with <br/>\n&gt; some notes in <br/>\n&gt; &gt;the javadoc.<br/>\n&gt; &gt;<br/>\n&gt; &gt;Methods that really are too risky to use outside of the class itself <br/>\n&gt; &gt;can always be made private but I would hope that this is the <br/>\n&gt; exception <br/>\n&gt; &gt;and not the rule.<br/>\n&gt; &gt;<br/>\n&gt; &gt;The developer creating the extension can make the decision based on <br/>\n&gt; &gt;those notes whether they are willing to accept fhe risk of using <br/>\n&gt; &gt;methods that may not continue to behave the same way or even <br/>\n&gt; exist in <br/>\n&gt; &gt;the future. At least they have that choice. If they have a <br/>\n&gt; good set of <br/>\n&gt; &gt;tests then changes to those methods in the future will be exposed <br/>\n&gt; &gt;readily enough.<br/>\n&gt; &gt;<br/>\n&gt; &gt;Conclusion<br/>\n&gt; &gt;----------<br/>\n&gt; &gt;If the purpose of making methods private is to indicate that <br/>\n&gt; they are <br/>\n&gt; &gt;not part of a class&#39;s API a better way is to encourage users of the <br/>\n&gt; &gt;class to program to a Java Interface instead. When you make methods <br/>\n&gt; &gt;private it makes the class more difficult to test and short-circuits <br/>\n&gt; &gt;the efforts of people who might need to extend the framework in <br/>\n&gt; &gt;unanticipated ways.<br/>\n&gt; <br/>\n&gt; -----------------------------<br/>\n&gt; Mike Silverstein<br/>\n&gt; SilverMark, Inc.<br/>\n&gt; The Object Testing Company<br/>\n&gt; www.javatesting.com<br/>\n<br/>\n </span></blockquote>---<br/>\nOutgoing mail is certified Virus Free.<br/>\nChecked by AVG anti-virus system (http://www.grisoft.com).<br/>\nVersion: 6.0.528 / Virus Database: 324 - Release Date: 10/16/2003</div>", 
    "prevInTime": 9734, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1066760723", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 9734, 
    "headers": {
        "inReplyToHeader": "PDNDNjc4RERGOTIyMTIzNERBNEYyOTAwRjkzQzZGNjMzMDFFQkFEOTFAYWx0ZWMwMDUuYWx0ZWMubG9jYWw+", 
        "messageIdInHeader": "PDAwMzAwMWMzOTgwMCRiMTRlYTg5MCQ2OTAxYThjMEBsYXRpdHVkZTAxPg=="
    }
}