{
    "numMessagesInTopic": 6, 
    "nextInTime": 24390, 
    "senderId": "s_IEtRwBcoUC02QaYqtFbz21fJdiAcY5YlbxGw7dqOXZoZKv7-ERytmpL6X97WuE-ogjGMEJPOzgyuAbRwEPeJEEiA", 
    "systemMessage": false, 
    "subject": "Re: [junit] Timed Tests and Thread Safety", 
    "from": "David Saff &lt;saff@...&gt;", 
    "authorName": "David Saff", 
    "msgSnippet": "Steve, You raise a great question.  Unfortunately, and perhaps I m missing something obvious, I don t think there s a way to provide timeout semantics,", 
    "msgId": 24389, 
    "profile": "saffatgoogle", 
    "topicId": 24388, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 525765722, 
    "messageBody": "<div id=\"ygrps-yiv-539500922\">Steve,<br/>\n<br/>\nYou raise a great question.  Unfortunately, and perhaps I&#39;m missing<br/>\nsomething obvious, I don&#39;t think there&#39;s a way to provide timeout<br/>\nsemantics, guarantee that @After is called, and guarantee that @After is<br/>\ncalled on the same thread as the @Test method.  Essentially, once the<br/>\nrunner hands over control to the @Test thread, there&#39;s no guarantee that it<br/>\nwill ever return control back--it could go into an infinite loop that<br/>\ncatches InterruptedExceptions.<br/>\n<br/>\nIt would potentially be possible to guarantee that successful tests that<br/>\ncomplete within the timeout have @After methods called on the same thread,<br/>\nbut that would further complicate matters, with questionable (IMHO) payoff.<br/>\n<br/>\nThe biggest payoff would probably be to make sure that the documentation we<br/>\nhave makes it easy to avoid any unexpected behavior.  Can you suggest an<br/>\nedit to that effect?  Thanks,<br/>\n<br/>\n   David Saff<br/>\n<br/>\n<br/>\n<blockquote><span title=\"qreply\"> On Thu, May 23, 2013 at 8:34 PM, Steven Soloff &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:s_soloff@...\">s_soloff@...</a>&gt;wrote:<br/>\n<br/>\n&gt; **<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; Hi All,<br/>\n&gt;<br/>\n&gt; I&#39;ve been using timed tests (i.e. @Test(timeout = ...)) for years but<br/>\n&gt; recently came across an implementation detail of which I was unaware. While<br/>\n&gt; I knew that timed tests are run in a thread other than the main test<br/>\n&gt; thread, I assumed that all aspects of the test (set up, test, and tear<br/>\n&gt; down) were run in that other thread. I was surprised to discover that the<br/>\n&gt; set up and tear down methods are run on the main test thread, while the<br/>\n&gt; test method is run on a different thread.<br/>\n&gt;<br/>\n&gt; This jumped out at me in a recent programming session because the class<br/>\n&gt; under test uses thread isolation to achieve thread safety, and its methods<br/>\n&gt; liberally assert that they are invoked on the same thread on which the<br/>\n&gt; object was instantiated. Once I realized why my timed tests were failing<br/>\n&gt; unexpectedly, I worked around the problem by moving the necessary portions<br/>\n&gt; of my set up and tear down to the test method itself.<br/>\n&gt;<br/>\n&gt; However, this got me thinking about more subtle issues related to timed<br/>\n&gt; tests of code that is inherently NOT thread safe. Consider the following<br/>\n&gt; contrived example, where Bar is the class under test:<br/>\n&gt;<br/>\n&gt; public class Foo {<br/>\n&gt; public void dispose() {<br/>\n&gt; }<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; public class Bar {<br/>\n&gt; private Foo foo = null;<br/>\n&gt;<br/>\n&gt; public void dispose() {<br/>\n&gt; if (foo != null) {<br/>\n&gt; foo.dispose();<br/>\n&gt; foo = null;<br/>\n&gt; }<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; public void setFoo(Foo foo) {<br/>\n&gt; this.foo = foo;<br/>\n&gt; }<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; public class BarTest {<br/>\n&gt; private Bar bar;<br/>\n&gt;<br/>\n&gt; @Before<br/>\n&gt; public void setUp() {<br/>\n&gt; bar = new Bar();<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; @Test<br/>\n&gt; public void testSomethingOnMainThread() {<br/>\n&gt; // ...<br/>\n&gt; bar.setFoo(new Foo());<br/>\n&gt; // ...<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; @Test(timeout = 1000)<br/>\n&gt; public void testSomethingOnDifferentThread() {<br/>\n&gt; // ...<br/>\n&gt; bar.setFoo(new Foo());<br/>\n&gt; // ...<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; @After<br/>\n&gt; public void tearDown() {<br/>\n&gt; bar.dispose();<br/>\n&gt; }<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; When testSomethingOnMainThread() is run, I expect the Foo instance created<br/>\n&gt; in the test will have its dispose() method called in tearDown() because its<br/>\n&gt; assignment to the Bar.foo field occurs on the same thread that invokes<br/>\n&gt; tearDown().<br/>\n&gt;<br/>\n&gt; However, when testSomethingOnDifferentThread() is run, I expect the Foo<br/>\n&gt; instance created in the test MAY NOT have its dispose() method called in<br/>\n&gt; tearDown() because its assignment to the Bar.foo field occurs on a<br/>\n&gt; different thread than the one that invokes tearDown(). Without some kind of<br/>\n&gt; memory barrier, the Bar.foo field may not be safely published from the test<br/>\n&gt; thread to the main thread.<br/>\n&gt;<br/>\n&gt; My concern is that there could be a significant change in the behavior of<br/>\n&gt; a test simply by annotating it with a timeout when the code under test is<br/>\n&gt; not thread safe. I can&#39;t be the first person to ask this question (I<br/>\n&gt; apologize if my search of this group&#39;s archives was not thorough enough),<br/>\n&gt; so I realize my entire premise may be ill-posed or that I&#39;m missing some<br/>\n&gt; fundamental understanding of the Java memory model.<br/>\n&gt;<br/>\n&gt; With that said, is it reasonable to expect that, for a given @Test, all<br/>\n&gt; @Before and @After methods in the fixture be called on the same thread<br/>\n&gt; regardless of how the test is annotated? Or is it simply up to the<br/>\n&gt; programmer to be aware of how timed tests are implemented, and to make it<br/>\n&gt; their responsibility to ensure code that is not thread safe is only ever<br/>\n&gt; invoked on a single thread, or to use external synchronization to ensure<br/>\n&gt; safe publication between threads?<br/>\n&gt;<br/>\n&gt; Cheers,<br/>\n&gt; Steve<br/>\n&gt;<br/>\n&gt; [Non-text portions of this message have been removed]<br/>\n&gt;<br/>\n&gt;  <br/>\n&gt;<br/>\n<br/>\n<br/>\n[Non-text portions of this message have been removed] </span></blockquote></div>", 
    "prevInTime": 24388, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1369409090", 
    "canDelete": false, 
    "nextInTopic": 24390, 
    "prevInTopic": 24388, 
    "headers": {
        "inReplyToHeader": "PDE5MThCMTcwN0U0NjQzRThBNTAyQUJENTc2MkMzNDY1QFN0aW1weT4=", 
        "messageIdInHeader": "PENBTHJ3LVB6a2JPZEJlZ2FMcmd1eTF1RVlQLXpFPXhCbnlvQzUzUUF3QUVVTjU9ZFR0Z0BtYWlsLmdtYWlsLmNvbT4=", 
        "referencesHeader": "PDE5MThCMTcwN0U0NjQzRThBNTAyQUJENTc2MkMzNDY1QFN0aW1weT4="
    }
}