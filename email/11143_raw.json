{
    "numMessagesInTopic": 9, 
    "nextInTime": 11144, 
    "senderId": "tN_4SUefmE3b52KtY00Dnuzpf3R8biJrtkzGsAHkzTloaiIxFIRdaEz1Jv9ggWHmJNvKTBfr7muy1poaefpuJ6SgU0kQ6Q2v8CJ9", 
    "systemMessage": false, 
    "subject": "Re: [junit] using JUnit with derived classes", 
    "from": "Curt Sampson &lt;yahoo_sucks@...&gt;", 
    "authorName": "Curt Sampson", 
    "msgSnippet": "... Oh, it s often more to do with changing the testing framework itself. I ve found that in Java I m often stymied because someone has not declared an", 
    "msgId": 11143, 
    "rawEmail": "Return-Path: &lt;yahoo_sucks@...&gt;\r\nX-Sender: yahoo_sucks@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (qmail 88916 invoked from network); 8 Jun 2004 01:03:07 -0000\r\nReceived: from unknown (66.218.66.166)\n  by m21.grp.scd.yahoo.com with QMQP; 8 Jun 2004 01:03:07 -0000\r\nReceived: from unknown (HELO academic.cynic.net) (66.92.125.172)\n  by mta5.grp.scd.yahoo.com with SMTP; 8 Jun 2004 01:03:06 -0000\r\nReceived: from angelic.cynic.net (angelic-platonic.cvpn.cynic.net [198.73.220.224])\n\tby academic.cynic.net (Postfix) with ESMTP id 740B476BF\n\tfor &lt;junit@yahoogroups.com&gt;; Tue,  8 Jun 2004 01:03:04 +0000 (UTC)\r\nReceived: from localhost (localhost [127.0.0.1])\n\tby angelic.cynic.net (Postfix) with ESMTP id AE2958736\n\tfor &lt;junit@yahoogroups.com&gt;; Tue,  8 Jun 2004 10:03:02 +0900 (JST)\r\nDate: Tue, 8 Jun 2004 10:03:02 +0900 (JST)\r\nX-X-Sender: cjs@...\r\nTo: junit@yahoogroups.com\r\nIn-Reply-To: &lt;40C44C2B.2050309@...&gt;\r\nMessage-ID: &lt;Pine.NEB.4.58.0406080950020.479@...&gt;\r\nReferences: &lt;c7tsu3+fcsb@...&gt; &lt;40A2ACF7.9030704@...&gt;\n &lt;Pine.NEB.4.58.0405251309540.9233@...&gt;\n &lt;40B3829A.2040603@...&gt; &lt;Pine.NEB.4.58.0406071217050.448@...&gt;\n &lt;40C44C2B.2050309@...&gt;\r\nMIME-Version: 1.0\r\nContent-Type: TEXT/PLAIN; charset=US-ASCII\r\nX-eGroups-Remote-IP: 66.92.125.172\r\nFrom: Curt Sampson &lt;yahoo_sucks@...&gt;\r\nSubject: Re: [junit] using JUnit with derived classes\r\nX-Yahoo-Group-Post: member; u=110189933\r\nX-Yahoo-Profile: cjstokyo\r\n\r\nOn Mon, 7 Jun 2004, J. B. Rainsberger wrote:\n\n&gt; Curt Sampson wrote:\n&gt;\n&gt; &gt; I think [things like declaring a test without extending TestCase are]\n&gt; &gt; valuable because [they give] you a lot more leway to play with\n&gt; &gt; the design of your testing framework within a particular application. I\n&gt; &gt; know that I often feel that certain refactoring directions I&#39;d like to\n&gt; &gt; try are closed to me because of the fairly strict structure of the JUnit\n&gt; &gt; testing framework.\n&gt;\n&gt; Do you have a specific example? Given that the structure (hierarchy) of\n&gt; test classes does not need to reflect the structure of production\n&gt; classes, what kinds of refactorings are difficult in JUnit but easy in\n&gt; NUnit? This is the kind of thing I need to explore, because my JUnit\n&gt; preconceptions hold me back when thinking in NUnit. You could jump-start\n&gt; me. :)\n\nOh, it&#39;s often more to do with changing the testing framework itself.\nI&#39;ve found that in Java I&#39;m often stymied because someone has not\ndeclared an interface for something I wish he had, and so I can&#39;t\nreplace his object with my own when I want to do something he&#39;s not\nconsidered. With languages such as SmallTalk and Ruby, this tends to be\nless of a problem because I so long as I supply an object that answers\nthe necessary messages, it will work.\n\nI&#39;ve been doing some work with Ruby lately, but I&#39;ve not spent enough\ntime with it really to discover how useful this will be. (As well,\nTest::Unit in Ruby has some unpleasant problems, such a TestCase class\nthat seems very difficult to subclass due to the way the run method\ncalls the actual test method. Really, that framework code should be\nmixed in from a module, not be embedded class, I think.)\n\nAnyway, I&#39;ve appended a little example I was playing with this morning\nwhere I ended up making a test suite that was just a hash of inputs\nand expected results, something you&#39;d typically have to build up a\nparameterized test case for. The key code ends up being, instead, just:\n\n\n    fibtest_hash = { 0 =&gt; 0, 1 =&gt; 1, 2 =&gt; 1, 3 =&gt; 2, 4 =&gt; 3, 5 =&gt; 5, 6 =&gt; 8 }\n\n    def fibtest_hash.calculate_result(input)\n\tFib.new.fib(input)\n    end\n\n    fibtest_hash.extend(TestEachInputExpectedPair)\n\n    Test::Unit::UI::Console::TestRunner.run(fibtest_hash)\n\nOf course, that object doesn&#39;t have to be a Hash. It might be, for\nexample, a database query that pulls data from test runs against an\noracle, or even the oracle itself:\n\n    suite = SQLQuery.new(&quot;SELECT input, result FROM old_test_run&quot;)\n\n    def suite.calculate_result(input)\n\t...\n    end\n\n    suite.extend(TestEachInputExpectedPair)\n\n    Test::Unit::UI::Console::TestRunner.run(suite)\n\nUnfortunately, I&#39;m out of time today to think about this further....\n\ncjs\n-- \nCurt Sampson  &lt;cjs@...&gt;   +81 90 7737 2974   http://www.NetBSD.org\n    Don&#39;t you know, in this new Dark Age, we&#39;re all light.  --XTC\n\n\n\nrequire &#39;test/unit/testcase&#39;\nrequire &#39;test/unit/testsuite&#39;\nrequire &#39;test/unit/ui/console/testrunner&#39;\n\n######################################################################\n# Given the ordinal position of a Fibonacci number, return its value.\n\nclass Fib\n\n    def fib(ordinal)\n\tcase ordinal\n\t    when 0\n\t\treturn 0\n\t    when 1\n\t\treturn 1\n\t    else\n\t\treturn fib(ordinal - 1) + fib(ordinal - 2)\n\tend\n    end\n\nend\n\n\n######################################################################\n# Here&#39;s is J. B. Rainsberger&#39;s example of a parameterized test case\n# in Java, followed by the Ruby equivalant for testing the Fib class.\n\n=begin\npublic class CalculateAgeTest extends TestCase {\n    private int expectedAge;\n    private Date futureDate;\n\n    public CalculateAgeTest(String testName,\n\tint expectedAge, Date futureDate) {\n\tsuper(testName);\n\tthis.expectedAge = expectedAge;\n\tthis.futureDate = futureDate;\n    }\n\n    public static Test suite() {\n\tTestSuite suite = new TestSuite(&quot;Calculate Age&quot;);\n\tsuite.addTest(new CalculateAgeTest(&quot;birthday&quot;,\n\t    30, DateUtil .makeDate(2004, 5, 4)));\n\tsuite.addTest(new CalculateAgeTest(&quot;day before birthday&quot;,\n\t    29, DateUtil.makeDate(2004, 5, 3)));\n\tsuite.addTest(new CalculateAgeTest(&quot;day after birthday&quot;,\n\t    30, DateUtil.makeDate(2004, 5, 5)));\n\tsuite.addTest(new CalculateAgeTest(&quot;date of birth&quot;,\n\t    0, DateUtil .makeDate(1974, 5, 4)));\n\tsuite.addTest(new CalculateAgeTest(&quot;invalid future date&quot;,\n\t    0, DateUtil .makeDate(1974, 5, 3)));\n\treturn suite;\n    }\n\n    protected void runTest() throws Exception {\n\tBiographicalReport biographicalReport\n\t    = PlayerFactory.makeBiographicalReport(\n\t    &quot;Joe&quot;, &quot;Rainsberger&quot;, DateUtil .makeDate(1974, 5, 4));\n\n\tassertEquals(new Integer(expectedAge),\n\t    biographicalReport.getAgeAsOf(futureDate));\n    }\n}\n=end\n\nclass TC_Fib_JBRStyle &lt; Test::Unit::TestCase\n\n    def initialize(input, expected)\n\tsuper(&quot;run_test&quot;)\n\t@input = input\n\t@expected = expected\n    end\n\n    def name\n\treturn &quot;input #{@input}&quot;\n    end\n\n    def self.suite\n\tsuite = Test::Unit::TestSuite.new(self.to_s)\n\tsuite &lt;&lt; new(0, 0)\n\tsuite &lt;&lt; new(1, 1)\n\tsuite &lt;&lt; new(2, 1)\n\tsuite &lt;&lt; new(3, 2)\n\tsuite &lt;&lt; new(4, 3)\n\tsuite &lt;&lt; new(5, 5)\n\tsuite &lt;&lt; new(6, 8)\n\treturn suite\n    end\n\n    def run_test\n\tassert_equal(@expected, Fib.new.fib(@input))\n    end\n\nend\n\nputs &quot;&#92;n#{&#39;=&#39; * 60}&#92;n&quot;\nTest::Unit::UI::Console::TestRunner.run(TC_Fib_JBRStyle.suite)\n\n\n######################################################################\n# However, with a helper class and a simple suite method that we\n# can mix in to another object, we can use any object that responds\n# to the each_pair message, such as a Hash,  as a set of inputs and\n# expected output values. We merely need to make it answer to a\n# calculate_result message to tell us what the actual output is for\n# a given input. Here&#39;s the helper class and the module with the\n# method we mixin.\n\nclass InputAndExpectedTestCase &lt; Test::Unit::TestCase\n\n    def initialize(input, expected, &calculate_result)\n\tsuper(&quot;run_test&quot;)\n\t@input = input\n\t@expected = expected\n\t@calculate_result = calculate_result\n    end\n\n    def name\n\treturn &quot;input #{@input}&quot;\n    end\n\n    def run_test\n\tassert_equal(@expected, @calculate_result.call(@input))\n    end\n\nend\n\nmodule TestEachInputExpectedPair\n\n    def suite\n\tsuite = Test::Unit::TestSuite.new(self.to_s)\n\teach_pair { |input, expected|\n\t    suite &lt;&lt; InputAndExpectedTestCase.new(input, expected) { |i|\n\t\tself.calculate_result(i)\n\t    }\n\t}\n\treturn suite\n    end\n\nend\n\n\n######################################################################\n# Now let&#39;s see how easy it is to set up our test.\n# Note that below we never extend any class in Test::Unit.\n\nfibtest_hash = { 0 =&gt; 0, 1 =&gt; 1, 2 =&gt; 1, 3 =&gt; 2, 4 =&gt; 3, 5 =&gt; 5, 6 =&gt; 8 }\n\ndef fibtest_hash.calculate_result(input)\n    Fib.new.fib(input)\nend\n\nfibtest_hash.extend(TestEachInputExpectedPair)\n\nputs &quot;&#92;n#{&#39;=&#39; * 60}&#92;n&quot;\nTest::Unit::UI::Console::TestRunner.run(fibtest_hash)\n\n\n######################################################################\n# But, as it turns out, if we&#39;re iterating through every number of\n# a Fibonacci sequence from the beginning, we know a very easy\n# algorithm to calculate the result; it&#39;s just the sum of the last\n# two results (after the first two special cases). So we can automate\n# the test using that algorithm. (This could actually have been done\n# in a very similar way using J. B. Rainsberger&#39;s style above.)\n\nclass Fibtest_Programmatic\n\n    def calculate_result(input)\n\tFib.new.fib(input)\n    end\n\n    def each_pair\n\tyield(0, 0)\n\tyield(1, 1)\n\tlast = 0; current = 1\n\t(2..15).each { |next_ordinal|\n\t    yield(next_ordinal, last + current)\n\t    last, current = current, last + current\n\t}\n    end\n\nend\n\nprogrammatic_suite = Fibtest_Programmatic.new\nprogrammatic_suite.extend(TestEachInputExpectedPair)\n\nputs &quot;&#92;n#{&#39;=&#39; * 60}&#92;n&quot;\nTest::Unit::UI::Console::TestRunner.run(programmatic_suite)\n\n", 
    "profile": "cjstokyo", 
    "topicId": 11010, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 110189933, 
    "prevInTime": 11142, 
    "contentTrasformed": false, 
    "postDate": "1086656582", 
    "canDelete": false, 
    "nextInTopic": 11144, 
    "prevInTopic": 11134, 
    "headers": {
        "inReplyToHeader": "PDQwQzQ0QzJCLjIwNTAzMDlAcm9nZXJzLmNvbT4=", 
        "messageIdInHeader": "PFBpbmUuTkVCLjQuNTguMDQwNjA4MDk1MDAyMC40NzlAYW5nZWxpYy12dGZ3LmN2cG4uY3luaWMubmV0Pg==", 
        "referencesHeader": "PGM3dHN1MytmY3NiQGVHcm91cHMuY29tPiA8NDBBMkFDRjcuOTAzMDcwNEByb2dlcnMuY29tPiA8UGluZS5ORUIuNC41OC4wNDA1MjUxMzA5NTQwLjkyMzNAYW5nZWxpYy12dGZ3LmN2cG4uY3luaWMubmV0PiA8NDBCMzgyOUEuMjA0MDYwM0Byb2dlcnMuY29tPiA8UGluZS5ORUIuNC41OC4wNDA2MDcxMjE3MDUwLjQ0OEBhbmdlbGljLXZ0ZncuY3Zwbi5jeW5pYy5uZXQ+IDw0MEM0NEMyQi4yMDUwMzA5QHJvZ2Vycy5jb20+"
    }
}