{
    "numMessagesInTopic": 1, 
    "nextInTime": 24448, 
    "senderId": "uPdS1izQslQz44KqKTrnr_GHA_286sHg-8lkB01Ob6xHEE6bFkUbe9qfO_ccS2onJf2kb7UXXkAiZyOrImcVx9bk0WVuiPJw-MVVZtnIcQ", 
    "systemMessage": false, 
    "subject": "Hierarchical Context Runner für JUnit", 
    "from": "Stefan Bechtold &lt;stefan.bechtold@...&gt;", 
    "authorName": "Stefan Bechtold", 
    "msgSnippet": "Hi everybody Anyone familiar with Ruby Specs knows, that using hierarchical contexts to structure your unit tests helps to keep your tests clean and readable,", 
    "msgId": 24447, 
    "topicId": 24447, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 558173103, 
    "messageBody": "<div id=\"ygrps-yiv-1070191810\">Hi everybody<br/>\n<br/>\nAnyone familiar with Ruby Specs knows, that using hierarchical contexts to structure your unit tests helps to keep your tests clean and readable, while it also reduces the number of boilerplate setup code tremendously.<br/>\n<br/>\nAfter watching episode 20 of Uncle Bob�s CleanCoders screencast, I found myself disappointed about the missing context ability of JUnit&#39;s default test runner. Also Uncle Bob came up with a workaround of creating contexts by using inner static classes and inheritance (this is all the experimental Enclosed runner supports). I felt like this was wrong and also, that it should be possible to come up with a test runner that supports something like the Ruby Specs Contexts.<br/>\n<br/>\nThe idea was born and I started to work on a hierarchical context runner for JUnit, supporting a structure like the following:<br/>\n<br/>\n@RunWith(HierarchicalContextRunner.class)<br/>\npublic class MainTest {<br/>\n  // ... some constants and helpers ...<br/>\n<br/>\n  @BeforeClass<br/>\n  public static void runsOnlyOnce_Before_AllTestsInMainTest() throws Exception {...}<br/>\n<br/>\n  @AfterClass<br/>\n  public static void runsOnlyOnce_After_AllTestsInMainTest() throws Exception {...}<br/>\n<br/>\n  @Test<br/>\n  public void simpleTestInTheMainContext() throws Exception {...}<br/>\n<br/>\n  @Test<br/>\n  public void anotherTestInTheMainContext() throws Exception {...}<br/>\n<br/>\n  // ... more tests in the main context ...<br/>\n<br/>\n  public class SubContext {<br/>\n    @Before<br/>\n    public void runs_Before_EachTestWithinSubContextAndAllContainingContexts() {...}<br/>\n<br/>\n    @After<br/>\n    public void runs_After_EachTestWithinSubContextAndAllContainingContexts() {...}<br/>\n<br/>\n    @Test<br/>\n    public void simpleTestInTheSubContext() throws Exception {...}<br/>\n<br/>\n    // ... more tests in the sub context ...<br/>\n<br/>\n    public class SubSubContext1 {<br/>\n      @Before<br/>\n      public void runs_Before_EachTestWithinSubSubContext1AndAllContainingContexts() {...}<br/>\n<br/>\n      @After<br/>\n      public void runs_After_EachTestWithinSubSubContext1AndAllContainingContexts() {...}<br/>\n<br/>\n      @Test<br/>\n      public void simpleTestInTheSubSubContext1() throws Exception {...}<br/>\n<br/>\n      // ... more tests in the sub sub context 1 ...<br/>\n    }<br/>\n<br/>\n    public class SubSubContext2 {<br/>\n      @Before<br/>\n      public void runs_Before_EachTestWithinSubSubContext2AndAllContainingContexts() {...}<br/>\n<br/>\n      @After<br/>\n      public void runs_After_EachTestWithinSubSubContext2AndAllContainingContexts() {...}<br/>\n<br/>\n      @Test<br/>\n      public void simpleTestInTheSubSubContext2() throws Exception {...}<br/>\n<br/>\n      // ... more tests in the sub sub context 2 ...<br/>\n    }<br/>\n}<br/>\nIn this example one can see, that tests with equal preconditions can be grouped into contexts. It doesn&#39;t matter how many contexts you have and it doesn&#39;t matter how deep your context hierarchy grows. The HierarchicalContextRunner supports as many contexts as you are required to create to structure your tests well and nicely. (More examples can be found within the samples folder)<br/>\n<br/>\nInstead of using inner static classes, the hierarchical context runner supports member classes to create a context. This has several advantages over the use of static classes:<br/>\n\t� No inheritance!<br/>\n\t� Well structured tests<br/>\n\t� The context hierarchy is represented within the outline of your IDE<br/>\n\t� The tests within an inner context have access to all members of a higher level context.<br/>\n\t� Static inner classes are not scanned for tests (according to the BlockJUnit4ClassRunner) and can be used to create stubs and helpers<br/>\nThe tricky parts were to support the creation of the test instance and to execute all @Before, @After and @Rule statements along the context hierarchy for each test.<br/>\n<br/>\nThe test instance needs to be built top-down, i.e. create the top level instance, which is required to create the first level instance, which is required to create the second level instance, etc., until the actual test instance can be created. In order to execute all @Before, @After and @Rule statements defined along the hierarchy of a context another extension needs to be placed to scan all classes along the context hierarchy and gather the statements accordingly.<br/>\n<br/>\nWith these changes in place the runner works great. As it was built upon the BlockJUnit4ClassRunner it also supports all features that are supported by this runner. Therefore, no need to hesitate. Check it out today and give it a try. Feedback is very welcomed and appreciated. :)<br/>\n<br/>\nTo use the runner, simply add the following maven dependency to your project or click one of the downloads below:<br/>\n&lt;dependency&gt;<br/>\n  &lt;groupId&gt;de.bechte.junit&lt;/groupId&gt;<br/>\n  &lt;artifactId&gt;junit-hierarchicalcontextrunner&lt;/artifactId&gt;<br/>\n  &lt;version&gt;4.11.1&lt;/version&gt;<br/>\n  &lt;scope&gt;test&lt;/scope&gt;<br/>\n&lt;/dependency&gt;<br/>\nOr simply download it from the wiki page where all this stuff is also explained:<br/>\nhttps://github.com/bechte/junit-hierarchicalcontextrunner/wiki<br/>\n<br/>\nI really appreciate all kind of feedbacks and hope you give the runner a chance to evaluate your tests. I use it almost for all my tests and group this into a context whenever they have a common setup. This leads to a style where your contexts are all your &quot;GIVEN&quot; statements, and the tests express themselves by &quot;WHEN_THEN&quot;. Very nice. Give it a try, please. :-)<br/>\n<br/>\nI am looking forward to getting any feedback.<br/>\n<br/>\nThanks<br/>\nbechte<br/>\n<br/>\n-- <br/>\n<br/>\nStefan Bechtold<br/>\n<br/>\neCard: http://ecard.bechte.de/<br/>\n<br/>\nhttp://www.bechte.de, http://twitter.com/bechte <br/>\n<br/>\n<br/>\n<br/>\n[Non-text portions of this message have been removed]</div>", 
    "prevInTime": 24446, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1386230756", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PDQwQTJFRUNCLUJDMEMtNEQ2Qi1CNEU2LUUwN0JGMjM4NUM0N0BtZS5jb20+"
    }
}