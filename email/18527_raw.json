{
    "numMessagesInTopic": 23, 
    "nextInTime": 18528, 
    "senderId": "tXWfGfF59wzY8bLZipo8kwdumm-DCea-6x-M05iNi2I_P2X_Gc5rd-gqc2pAccC0W_0dmPJwdaackpCXM_cbDTYYIpADtF3uYmZpBOkinwSPY_XGtdi0C_s8", 
    "systemMessage": false, 
    "subject": "Re: Essay: The Trouble With JUnit", 
    "from": "&quot;Jan Theodore Galkowski&quot; &lt;jtgalkowski@...&gt;", 
    "authorName": "Jan Theodore Galkowski", 
    "msgSnippet": "Hi David, Well, it s from the work of Tony Hoare and others that if programs are annotated with a rich enough (minimally complete) set of pre- and post- ", 
    "msgId": 18527, 
    "rawEmail": "Return-Path: &lt;jtgalkowski@...&gt;\r\nReceived: (qmail 86744 invoked by uid 7800); 11 Dec 2006 19:14:02 -0000\r\nX-Sender: jtgalkowski@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (qmail 14424 invoked from network); 11 Dec 2006 17:12:27 -0000\r\nReceived: from unknown (66.218.66.218)\n  by m38.grp.scd.yahoo.com with QMQP; 11 Dec 2006 17:12:27 -0000\r\nReceived: from unknown (HELO out3.smtp.messagingengine.com) (66.111.4.27)\n  by mta3.grp.scd.yahoo.com with SMTP; 11 Dec 2006 17:12:26 -0000\r\nReceived: from out1.internal (unknown [10.202.2.149])\n\tby out1.messagingengine.com (Postfix) with ESMTP id B9E1E4D49A\n\tfor &lt;junit@yahoogroups.com&gt;; Mon, 11 Dec 2006 12:09:02 -0500 (EST)\r\nReceived: from web3.messagingengine.com ([10.202.2.212])\n  by out1.internal (MEProxy); Mon, 11 Dec 2006 12:09:02 -0500\r\nReceived: by web3.messagingengine.com (Postfix, from userid 99)\n\tid A1F4639E4E; Mon, 11 Dec 2006 12:09:02 -0500 (EST)\r\nMessage-Id: &lt;1165856942.10025.279904023@...&gt;\r\nX-Sasl-Enc: WU/W6rauILLhbkYQFalf3qee8zwV3G21ww3V4bDd9oaT 1165856942\r\nTo: junit@yahoogroups.com\r\nContent-Disposition: inline\r\nContent-Transfer-Encoding: 7bit\r\nContent-Type: text/plain; charset=&quot;ISO-8859-1&quot;\r\nMIME-Version: 1.0\r\nX-Mailer: MessagingEngine.com Webmail Interface\r\nDate: Mon, 11 Dec 2006 12:09:02 -0500\r\nX-eGroups-Msg-Info: 1:0:0:0\r\nFrom: &quot;Jan Theodore Galkowski&quot; &lt;jtgalkowski@...&gt;\r\nSubject: Re: Essay: The Trouble With JUnit\r\nX-Yahoo-Group-Post: member; u=280430; y=VhBMus0UEEYdjCIPNozqob4LOIULNeB8Em2XvDlADJ8Wq_ZHyGU\r\nX-Yahoo-Profile: ekzept\r\nX-eGroups-Approved-By: ddoss_2006 &lt;didoss@...&gt; via email; 11 Dec 2006 19:14:01 -0000\r\n\r\nHi David,\n\nWell, it&#39;s from the work of Tony Hoare and others that if programs are\nannotated with a rich enough (minimally complete) set of pre- and post-\nconditions describing state changes using predicate assertions, it&#39;s\npossible to delete the intervening program (or state transformation)\nsteps and &quot;execute&quot; the program using just the stated pre- and post-\nconditions.  This is part of the motivation behind Bertrand Meyer&#39;s work\nwith Eiffel and Design By Contract.\n\nThis is not, at present, a part of the test-driven methodology, as far\nas I know, but it is implicit in the sense that by writing tests first,\nthe requirements for the code under test are supposed to be expressed in\nthe tests.  Then, one invests in the &quot;throw anything at it&quot; cycle where\ncode is written, tested using an xUnit, if it&#39;s red, add another\nassertion to cover the case missed. If it&#39;s green, extend the scope of\nthe requirements to better approximate what&#39;s wanted.  There&#39;s cleanup\nvia refactoring needed for code.\n\nAs mentioned, refactoring should probably be applied to the tests as\nwell, assuming they are complicated enough.  And, what I&#39;m getting at is\nthat perhaps the language of predicates, as well known and studied as it\nis, isn&#39;t quite enough to make truly requirements-level test\nprescriptions easy.\n\nLet&#39;s get narrow and specific for a moment.  Suppose you have a Python-\nlike language and want to assert that the head of a list L is &#39;foo&#39;:\n\n  &#39;foo&#39; == L[0]\n\nSure, but you&#39;re obligated also to test first that L has at least one\nelement, lest the assertion itself fail.  Yes, you can check first\n\n  1 &lt;= L.count(&#39;foo&#39;)\n\nthen\n\n   &#39;foo&#39; == L[0]\n\nor even\n\n   1 &lt;= L.count(&#39;foo&#39;) and &#39;foo&#39; == L[0]\n\nrelying upon short-circuiting evaluation, but wouldn&#39;t it be easier to\nuse some kind of Prolog-like matching notation\n\n    L == [: &#39;foo&#39; . % :]\n\nwhere I&#39;ve arbitrarily co-opted special brackets &quot;[:&quot; and &quot;:]&quot; to\nindicate the (LISP) CONS-like pairing?  If actually realized in Python\nthe notation could be built into a tuple, but the idea would be if the\nmatch fails, the assertion fails.\n\nIf requirements are the focus of a test-driven approach, then the (a)\nlanguage for expressing tests ought to not tie up the hands of the\nprogrammer with worries about ancillary conditions, (b) it ought to be\nperspicacious, and (c) it should allow an economy of expression which\npredicates and the base language don&#39;t.  The problems of writing &quot;bigger\nrequirements&quot; get, well, bigger if the conditions tested rely upon\nexogenous factors, like status of external resources or the execution of\nother whole subsystems.  At present, I suppose try-except-else could be\nput into the tests, but I think that&#39;s really a distraction.  I&#39;d\nprobably encapsulate it in a function and then call the function in the\nassertion.  All I&#39;m asking is why? and can&#39;t we do better?\n\nI&#39;m sure once such a natural patterns sublanguage was decided, it could\nbe built with present facilities in something like Python, Smalltalk,\nSCHEME, LISP, probably Java and C#.  As for jsunit,  phpunit,  other\nsuch,  I have my doubts.  There&#39;s a point of separation here: xUnit is a\nubiquitous metapattern for testing.  Here, when seeing &quot;tests&quot; as a\nmeans of stating program requirements, we&#39;re leaving ubiquity aside and\nreaching for bigger things.\n\nLeaving the narrow and specific, don&#39;t we really want to separate tests\nof a program fragment into two different kinds?  One kind tests whether\nthe conditions we expect to be established for the fragment to execute\nare actually there, the precondition.  The other kind tests whether the\nfragment actually achieved what we expect it to, the postcondition.\nPreconditions are in part a check that our tests themselves are properly\nformed.  In fact, although there&#39;s value in the unit-testing emphasis of\ntest-driven, we might carry these new kinds of test assertions over to\n&quot;string testing&quot;, where each program fragment brings its precondition\nwith it preceding it, and a postcondition with it succeeding it, and we\ncan then test a series of fragments at once.\n\nThis is a small step away from Meyer&#39;s ultimate world.  I&#39;ve often\nthought how nice it would be if the methods of a class could be\ndiscriminated among not only by their signature (argument numbers and\ntypes), but by an Eiffel-like &quot;require&quot; precondition that needs to be\nsatisfied before the method is picked.  This would further suppress the\nneed for case analysis in nested if-then-else structures.\n\nThere&#39;s more opportunity for innovation in notation with postconditions,\ntoo.  How often have *you* wanted to readily express a test relating the\nvalue of a variable after a fragment to that before it?  Sure, you can\ndo this by introducing new variables in the test fixture, declaring them\nappropriately where that&#39;s needed, but wouldn&#39;t it be nice to have a\nsimple notation for it, like for a list L, checking that &#39;foo&#39; was\nproperly appended (using Python terminology again):\n\n    +L == -L.append(&#39;foo&#39;)\n\nif the prefix operators &quot;+&quot; and &quot;-&quot; were used to denote &quot;after&quot; and\n&quot;before&quot;, respectively.\n\nWhether there should also be a special class of tests for loop or\nrecursion invariants is something that needs further thought.\n\nDavid, does this help?\n\n -- Jan\n\n", 
    "profile": "ekzept", 
    "topicId": 18392, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 280430, 
    "prevInTime": 18526, 
    "contentTrasformed": false, 
    "postDate": "1165856942", 
    "canDelete": false, 
    "nextInTopic": 18528, 
    "prevInTopic": 18525, 
    "headers": {
        "messageIdInHeader": "PDExNjU4NTY5NDIuMTAwMjUuMjc5OTA0MDIzQHdlYm1haWwubWVzc2FnaW5nZW5naW5lLmNvbT4="
    }
}