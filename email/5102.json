{
    "numMessagesInTopic": 9, 
    "nextInTime": 5103, 
    "senderId": "krH--8Vpcl2PLS0nW-5NC5LdF-lcx6p4L8vC1_Scq1yldDC3hlUAkaRIso8lOEW-RFLULl3ieFts5pL3oDUjROREK6Xe2Q", 
    "systemMessage": false, 
    "subject": "Re: Testing accessors...", 
    "from": "Mike Clark &lt;mike@...&gt;", 
    "authorName": "Mike Clark", 
    "msgSnippet": "I ve added J.B. s response below to the FAQ under the question Under what conditions should I not test get() and set() methods? . ... Under what conditions", 
    "msgId": 5102, 
    "profile": "clarkware", 
    "topicId": 5102, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 33026788, 
    "messageBody": "<div id=\"ygrps-yiv-1473862645\">I&#39;ve added J.B.&#39;s response below to the FAQ under the question &quot;Under <br/>\nwhat conditions should I not test get() and set() methods?&quot;.<br/>\n<br/>\nI also added an alternative view that goes something like this:<br/>\n<br/>\n----<br/>\n<br/>\nUnder what conditions should I test get() and set() methods?<br/>\n<br/>\nIn general, unit tests are meant to alleviate fear that something might <br/>\nbreak. If a get() or set() method could reasonably break, or has in fact <br/>\ncontributed to a defect, then by all means write a test for them. Be <br/>\npractical and remember to maximize your testing investment.<br/>\n<br/>\nRefer also to &quot;How simple is &#39;too simple to break&#39;? <br/>\n<br/>\n----<br/>\n<br/>\nIf there are viewpoints not represented in these entries, please feel <br/>\nfree to contribute.  Perhaps we can defer all related questions to the <br/>\nFAQ in the near future.<br/>\n<br/>\nMike<br/>\n<br/>\n<br/>\nJ. B. Rainsberger wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;<br/>\n&gt;Most of the time, get/set methods just can&#39;t break, and if they can&#39;t break, <br/>\n&gt;then why test them? While it is usually better to test more, there is a <br/>\n&gt;definite curve of diminishing returns on test effort versus &quot;code coverage&quot;. <br/>\n&gt;Remember the maxim: &quot;Test until fear turns to boredom.&quot;<br/>\n&gt;<br/>\n&gt;Assume that the getX() method only does &quot;return x;&quot; and that the setX() <br/>\n&gt;method only does &quot;this.x = x;&quot;. If you write this test<br/>\n&gt;<br/>\n&gt;    testGetSetX() {<br/>\n&gt;        setX(23);<br/>\n&gt;        assertEquals(23, getX());<br/>\n&gt;    }<br/>\n&gt;<br/>\n&gt;then you are testing the equivalent of the following:<br/>\n&gt;<br/>\n&gt;    testGetSetX() {<br/>\n&gt;        x = 23;<br/>\n&gt;        assertEquals(23, x);<br/>\n&gt;    }<br/>\n&gt;<br/>\n&gt;or, if you prefer,<br/>\n&gt;<br/>\n&gt;    testGetSetX() {<br/>\n&gt;        assertEquals(23, 23);<br/>\n&gt;    }<br/>\n&gt;<br/>\n&gt;At this point, you are testing the Java compiler, or possibly the <br/>\n&gt;interpreter, and not your component or application. There is generally no <br/>\n&gt;need for you to do Java&#39;s testing for them.<br/>\n&gt;<br/>\n&gt;If you are concerned about whether a property has already been set at the <br/>\n&gt;point you wish to call getX(), then you want to test the constructor, and not <br/>\n&gt;the getX() method. This kind of test is especially useful if you have <br/>\n&gt;multiple constructors.<br/>\n&gt;<br/>\n&gt;    testCreate() {<br/>\n&gt;        assertEquals(23, new MyClass(23).getX());<br/>\n&gt;    }<br/>\n&gt;<br/>\n&gt;&gt;    Under what conditions should I test get() and set() methods?<br/>\n&gt;&gt;<br/>\n&gt;<br/>\n&gt;See &quot;How simple is &#39;too simple to break?&#39;&quot;<br/>\n&gt;<br/>\n&gt;[Later on...]<br/>\n&gt;<br/>\n&gt;Q. How simple is &#39;too simple to break?&#39;<br/>\n&gt;<br/>\n&gt;The general philosophy is this: if it can&#39;t break *on its own*, it&#39;s too <br/>\n&gt;simple to break.<br/>\n&gt;<br/>\n&gt;First example is the getX() method. Suppose the getX() method only answers <br/>\n&gt;the value of an instance variable. In that case, getX() cannot break unless <br/>\n&gt;either the compiler or the interpreter is also broken. For that reason, don&#39;t <br/>\n&gt;test getX(); there is no benefit. The same is true of the setX() method, <br/>\n&gt;although if your setX() method does any parameter validation or has any side <br/>\n&gt;effects, you likely need to test it.<br/>\n&gt;<br/>\n&gt;Next example: suppose you have written a method that does nothing but forward <br/>\n&gt;parameters into a method called on another object. That method is too simple <br/>\n&gt;to break.<br/>\n&gt;<br/>\n&gt;    public void myMethod(final int a, final String b) {<br/>\n&gt;        myCollaborator.anotherMethod(a, b);<br/>\n&gt;    }<br/>\n&gt;<br/>\n&gt;myMethod cannot possibly break, because it does nothing: it forwards its <br/>\n&gt;input to another object and that&#39;s all. <br/>\n&gt;<br/>\n&gt;The only precondition for this method is &quot;myCollaborator != null&quot;, but that <br/>\n&gt;is generally the responsibility of the constructor, and not of myMethod. If <br/>\n&gt;you are concerned, add a test to verify that myCollaborator is always set to <br/>\n&gt;something non-null by every constructor.<br/>\n&gt;<br/>\n&gt;The only way myMethod could break would be if myCollaborator#anotherMethod <br/>\n&gt;were broken. In that case, test myCollaborator, and not the current class.<br/>\n&gt;<br/>\n&gt;It is true that adding tests for even these simple methods guards against the <br/>\n&gt;possibility that someone refactors and makes the methods &quot;not-so-simple&quot; <br/>\n&gt;anymore. In that case, though, the refactorer needs to be aware that the <br/>\n&gt;method is now complex enough to break, and should write tests for it -- and <br/>\n&gt;preferably before the refactoring.<br/>\n&gt;<br/>\n&gt;Another example: suppose you have a JSP and, like a good programmer, you have <br/>\n&gt;removed all business logic from it. All it does is provide a layout for a <br/>\n&gt;number of JavaBeans and never does anything that could change the value of <br/>\n&gt;any object. That JSP is too simple to break, and since JSPs are notoriously <br/>\n&gt;annoying to test, you should strive to make all your JSPs too simple to break.<br/>\n&gt;<br/>\n&gt;--<br/>\n&gt;J. B. Rainsberger,<br/>\n&gt;President, Diaspar Software Services<br/>\n&gt;Let&#39;s write software that people understand.<br/>\n&gt;<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.diasparsoftware.com/\">http://www.diasparsoftware.com/</a><br/>\n&gt;telephone: +1 416 791-8603<br/>\n&gt;<br/>\n<br/>\n<br/>\n<br/>\n </span></blockquote>[Non-text portions of this message have been removed]</div>", 
    "prevInTime": 5101, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1023284355", 
    "canDelete": false, 
    "nextInTopic": 5106, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PDNDRkUxNDgzLjcwOTAyQGNsYXJrd2FyZS5jb20+", 
        "referencesHeader": "PDFBQTY5NzFGOTZGQURCNEE5NkNGNzNFNDcyOUIwNUYxNTVFNUJEQFVTRVZTMDEyLmxlaW50ZXJuYWwuY29tPiA8MjAwMjA2MDQxMDQ5NTEuTTI0ODMxQGRpYXNwYXJzb2Z0d2FyZS5jb20+IDwzQ0ZDRjBDMi4yMDMwMjA3QGNsYXJrd2FyZS5jb20+IDwyMDAyMDYwNDEyNDUzNy5NNTkyMDdAZGlhc3BhcnNvZnR3YXJlLmNvbT4="
    }
}