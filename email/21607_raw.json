{
    "numMessagesInTopic": 7, 
    "nextInTime": 21608, 
    "senderId": "pYWtkuzoRScFfL5IR-h1YaqiV4ok89I1B6_jC63WHZX-poajv4E-sXJxvYSe_d65WcP6Iv6GtaWpHXG7fBV7mE9L", 
    "systemMessage": false, 
    "subject": "Re: [junit] Re: Non-static inner classes of test classes using \tenclosing fixtures?", 
    "from": "David Saff &lt;david@...&gt;", 
    "authorName": "David Saff", 
    "msgSnippet": "... Glad to hear that. ... I think there were two different directions going on here.  It sounds like you want JUnit, when given the outer class, to", 
    "msgId": 21607, 
    "rawEmail": "Return-Path: &lt;david.saff@...&gt;\r\nX-Sender: david.saff@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nX-Received: (qmail 71283 invoked from network); 14 May 2009 13:50:36 -0000\r\nX-Received: from unknown (69.147.108.202)\n  by m4.grp.re1.yahoo.com with QMQP; 14 May 2009 13:50:36 -0000\r\nX-Received: from unknown (HELO fk-out-0910.google.com) (209.85.128.187)\n  by mta3.grp.re1.yahoo.com with SMTP; 14 May 2009 13:50:36 -0000\r\nX-Received: by fk-out-0910.google.com with SMTP id z22so557704fkz.12\n        for &lt;junit@yahoogroups.com&gt;; Thu, 14 May 2009 06:50:19 -0700 (PDT)\r\nMIME-Version: 1.0\r\nX-Received: by 10.239.160.67 with SMTP id b3mr144434hbd.23.1242309018732; Thu, \n\t14 May 2009 06:50:18 -0700 (PDT)\r\nIn-Reply-To: &lt;gufac9+abt1@...&gt;\r\nReferences: &lt;4f7da6b90905110806q14c881e3vb7e1defea8cc0c62@...&gt;\n\t &lt;gufac9+abt1@...&gt;\r\nDate: Thu, 14 May 2009 09:50:18 -0400\r\nX-Google-Sender-Auth: 495fc6dafa6b5d13\r\nMessage-ID: &lt;4f7da6b90905140650o34dd68ddm2c233cfb556fce6c@...&gt;\r\nTo: junit@yahoogroups.com\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Transfer-Encoding: quoted-printable\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: David Saff &lt;david@...&gt;\r\nSubject: Re: [junit] Re: Non-static inner classes of test classes using \n\tenclosing fixtures?\r\nX-Yahoo-Group-Post: member; u=341876227; y=o1nFFwhD7UvUOhLPflyjUF_zTvqwp1QgTdtLjSaJffc\r\nX-Yahoo-Profile: dsaff\r\n\r\nOn Wed, May 13, 2009 at 4:25 PM, Paul Holser &lt;pholser@...&gt; wrote:\n&gt; H=\r\ni JUnit,\n&gt;\n&gt; Regarding my previous post, about the desire to have non-stati=\r\nc inner\n&gt; test classes of a test class instantiated and run with an enclosi=\r\nng\n&gt; instance: I found a solution that seems workable. I used JUnit 4.5. It=\r\n\n&gt; involves the following:\n&gt; [snip]\n&gt; So, I was able to leverage existing J=\r\nUnit extension points to accomplish\n&gt; my goal.\n\nGlad to hear that.\n\n&gt; I won=\r\nder if this would be useful functionality for JUnit to\n&gt; have in general: w=\r\nhen a test class is detected, and that test class has\n&gt; non-static inner cl=\r\nasses which may themselves be test classes, when\n&gt; building up tests for th=\r\ne enclosing class, also instantiate the inner\n&gt; test classes and attach to =\r\nthe (an?) enclosing test class instance. I\n&gt; saw some previous discussion a=\r\nbout such fixtures in JDave.\n\nI think there were two different directions g=\r\noing on here.  It sounds\nlike you want JUnit, when given the outer class, t=\r\no automatically\ninstantiate the inner classes.  It sounded like JDave wante=\r\nd JUnit,\nwhen given the inner class, to automatically consult the outer cla=\r\nss\nwhen instantiating.\n\nAm I getting both requests right?  If not, then we&#39;=\r\nre getting close to\na Rule of Three threshold for reuse.  If I am, then I s=\r\nee the same\nJava idiom having two different &quot;obvious&quot; interpretations to tw=\r\no\ndifferent classes of user.\n\n   David Saff\n\n&gt;\n&gt; What do you think? Some co=\r\nde from my solution is below.\n&gt;\n&gt; Thanks,\n&gt; Paul Holser\n&gt;\n&gt;\n&gt; =3D=3D=3D=3D=\r\n=3D=3D\n&gt;\n&gt; public abstract class UnmodifiableCollectionTestSupport&lt;T&gt; {\n&gt; =\r\n=A0 =A0 protected Collection&lt;T&gt; items;\n&gt; =A0 =A0 private T containedItem;\n&gt;=\r\n\n&gt; =A0 =A0 @Before\n&gt; =A0 =A0 public final void initializeHarness() {\n&gt; =A0 =\r\n=A0 =A0 =A0 this.items =3D newCollection();\n&gt; =A0 =A0 =A0 =A0 this.containe=\r\ndItem =3D containedItem();\n&gt; =A0 =A0 =A0 =A0 // ...\n&gt; =A0 =A0 }\n&gt;\n&gt; =A0 =A0=\r\n @Test(expected =3D UnsupportedOperationException.class) {\n&gt; =A0 =A0 public=\r\n final void\n&gt; shouldPreventOperationThatWouldModifyTheCollection() {\n&gt; =A0 =\r\n=A0 =A0 =A0 // ...\n&gt; =A0 =A0 }\n&gt;\n&gt; =A0 =A0 // tests...\n&gt;\n&gt; =A0 =A0 protecte=\r\nd abstract Collection&lt;T&gt; newCollection();\n&gt;\n&gt; =A0 =A0 protected abstract T =\r\nnewItem();\n&gt;\n&gt; =A0 =A0 protected abstract T containedItem();\n&gt; }\n&gt;\n&gt; public=\r\n abstract class UnmodifiableListTestSupport&lt;T&gt; extends\n&gt; UnmodifiableCollec=\r\ntionTestSupport&lt;T&gt; {\n&gt; =A0 =A0 // ...\n&gt; }\n&gt;\n&gt; @RunWith(AllTests.class)\n&gt; pu=\r\nblic abstract class UnmodifiableMapTestSupport&lt;K, V&gt; {\n&gt; =A0 =A0 private Ma=\r\np&lt;K, V&gt; entries;\n&gt; =A0 =A0 private K containedKey;\n&gt; =A0 =A0 private V cont=\r\nainedValue;\n&gt;\n&gt; =A0 =A0 @Before\n&gt; =A0 =A0 public final void initializeHarne=\r\nss() {\n&gt; =A0 =A0 =A0 =A0 this.entries =3D newMap();\n&gt; =A0 =A0 =A0 =A0 this.=\r\ncontainedKey =3D containedKey();\n&gt; =A0 =A0 =A0 =A0 this.containedValue =3D =\r\ncontainedValue();\n&gt; =A0 =A0 =A0 =A0 // ...\n&gt; =A0 =A0 }\n&gt;\n&gt; =A0 =A0 @Test(ex=\r\npected =3D UnsupportedOperationException.class) {\n&gt; =A0 =A0 public final vo=\r\nid shouldPreventOperationThatWouldModifyTheMap() {\n&gt; =A0 =A0 =A0 =A0 // ...=\r\n\n&gt; =A0 =A0 }\n&gt;\n&gt; =A0 =A0 // tests...\n&gt;\n&gt; =A0 =A0 protected abstract Map&lt;K, =\r\nV&gt; newMap();\n&gt;\n&gt; =A0 =A0 protected abstract K newKey();\n&gt;\n&gt; =A0 =A0 protect=\r\ned abstract K containedKey();\n&gt;\n&gt; =A0 =A0 protected abstract V containedVal=\r\nue();\n&gt;\n&gt; =A0 =A0 protected static junit.framework.Test\n&gt; buildUnmodifiable=\r\nMapSuite(UnmodifiableMapTestSupport&lt;?, ?&gt; test) {\n&gt; =A0 =A0 =A0 =A0 TestSui=\r\nte suite =3D new TestSuite();\n&gt; =A0 =A0 =A0 =A0 suite.addTest(new JUnit4Tes=\r\ntInstanceAdapter(test));\n&gt; =A0 =A0 =A0 =A0 suite.addTest(new JUnit4TestInst=\r\nanceAdapter(test.new\n&gt; KeySetTest()));\n&gt; =A0 =A0 =A0 =A0 suite.addTest(new =\r\nJUnit4TestInstanceAdapter(test.new\n&gt; ValuesTest()));\n&gt; =A0 =A0 =A0 =A0 suit=\r\ne.addTest(new JUnit4TestInstanceAdapter(test.new\n&gt; EntriesTest()));\n&gt; =A0 =\r\n=A0 =A0 =A0 return suite;\n&gt; =A0 =A0 }\n&gt;\n&gt; =A0 =A0 class KeySetTest extends =\r\nUnmodifiableCollectionTestSupport&lt;K&gt; {\n&gt; =A0 =A0 =A0 =A0 @Override protecte=\r\nd K containedItem() {\n&gt; =A0 =A0 =A0 =A0 =A0 =A0 return containedKey;\n&gt; =A0 =\r\n=A0 =A0 =A0 }\n&gt;\n&gt; =A0 =A0 =A0 =A0 @Override protected Collection&lt;K&gt; newColl=\r\nection() {\n&gt; =A0 =A0 =A0 =A0 =A0 =A0 return entries.keySet();\n&gt; =A0 =A0 =A0=\r\n =A0 }\n&gt;\n&gt; =A0 =A0 =A0 =A0 @Override protected K newItem() {\n&gt; =A0 =A0 =A0 =\r\n=A0 =A0 =A0 return newKey();\n&gt; =A0 =A0 =A0 =A0 }\n&gt; =A0 =A0 }\n&gt;\n&gt; =A0 =A0 cl=\r\nass ValuesTest extends UnmodifiableCollectionTestSupport&lt;V&gt; {\n&gt; =A0 =A0 =A0=\r\n =A0 @Override protected V containedItem() {\n&gt; =A0 =A0 =A0 =A0 =A0 =A0 retu=\r\nrn containedValue;\n&gt; =A0 =A0 =A0 =A0 }\n&gt;\n&gt; =A0 =A0 =A0 =A0 @Override protec=\r\nted Collection&lt;V&gt; newCollection() {\n&gt; =A0 =A0 =A0 =A0 =A0 =A0 return entrie=\r\ns.values();\n&gt; =A0 =A0 =A0 =A0 }\n&gt;\n&gt; =A0 =A0 =A0 =A0 @Override protected V n=\r\newItem() {\n&gt; =A0 =A0 =A0 =A0 =A0 =A0 return null;\n&gt; =A0 =A0 =A0 =A0 }\n&gt; =A0=\r\n =A0 }\n&gt;\n&gt; =A0 =A0 class EntriesTest extends\n&gt; UnmodifiableCollectionTestSu=\r\npport&lt;Map.Entry&lt;K, V&gt;&gt; {\n&gt; =A0 =A0 =A0 =A0 @Override protected Entry&lt;K, V&gt; =\r\ncontainedItem() {\n&gt; =A0 =A0 =A0 =A0 =A0 =A0 return /* new Map.Entry impl wh=\r\nose key is containedKey and\n&gt; whose value is containedValue */;\n&gt; =A0 =A0 =\r\n=A0 =A0 }\n&gt;\n&gt; =A0 =A0 =A0 =A0 @Override protected Collection&lt;Entry&lt;K, V&gt;&gt; n=\r\newCollection() {\n&gt; =A0 =A0 =A0 =A0 =A0 =A0 return entries.entrySet();\n&gt; =A0=\r\n =A0 =A0 =A0 }\n&gt;\n&gt; =A0 =A0 =A0 =A0 @Override protected Entry&lt;K, V&gt; newItem(=\r\n) {\n&gt; =A0 =A0 =A0 =A0 =A0 =A0 return null;\n&gt; =A0 =A0 =A0 =A0 }\n&gt; =A0 =A0 }\n=\r\n&gt; }\n&gt;\n&gt; // sample implementor\n&gt; public class UnmodifiableMapTest extends\n&gt; =\r\nUnmodifiableMapTestSupport&lt;String, String&gt; {\n&gt; =A0 =A0 public static junit.=\r\nframework.Test suite() {\n&gt; =A0 =A0 =A0 =A0 return UnmodifiableMapTestSuppor=\r\nt.buildUnmodifiableMapSuite(new\n&gt; UnmodifiableMapTest());\n&gt; =A0 =A0 }\n&gt;\n&gt; =\r\n=A0 =A0 @Override protected String containedKey() {\n&gt; =A0 =A0 =A0 =A0 retur=\r\nn &quot;foo&quot;;\n&gt; =A0 =A0 }\n&gt;\n&gt; =A0 =A0 @Override protected String containedValue(=\r\n) {\n&gt; =A0 =A0 =A0 =A0 return &quot;value&quot;;\n&gt; =A0 =A0 }\n&gt;\n&gt; =A0 =A0 @Override pro=\r\ntected String newKey() {\n&gt; =A0 =A0 =A0 =A0 return &quot;bar&quot;;\n&gt; =A0 =A0 }\n&gt;\n&gt; =\r\n=A0 =A0 @Override protected Map&lt;String, String&gt; newMap() {\n&gt; =A0 =A0 =A0 =\r\n=A0 return\n&gt; Collections.unmodifiableMap(Collections.singletonMap(&quot;foo&quot;, &quot;v=\r\nalue&quot;));\n&gt; =A0 =A0 }\n&gt; }\n&gt;\n&gt; --- In junit@yahoogroups.com, David Saff &lt;davi=\r\nd@...&gt; wrote:\n&gt;&gt;\n&gt;&gt; Paul,\n&gt;&gt;\n&gt;&gt; Have you looked at Theory support in JUnit =\r\n&gt; 4.4? =A0It may not give you\n&gt;&gt; everything you want, but I&#39;d be curious to=\r\n know how close it gets.\n&gt;&gt; Thanks,\n&gt;&gt;\n&gt;&gt; =A0 =A0David\n&gt;&gt;\n&gt;&gt; On Sat, May 9,=\r\n 2009 at 1:37 PM, Paul Holser pholser@... wrote:\n&gt;&gt; &gt; Hello JUnit,\n&gt;&gt; &gt;\n&gt;&gt; =\r\n&gt; I have some abstract classes that enable a caller to check that\n&gt; classes=\r\n which expose collection fields via accessor methods do so via\n&gt; the java.u=\r\ntil.Collections#unmodifiable___() facilities. =A0Here are some\n&gt; snippets:\n=\r\n&gt;&gt; &gt;\n&gt;&gt; &gt; public abstract class UnmodifiableCollectionTestSupport&lt;T&gt; {\n&gt;&gt; &gt;=\r\n =A0 =A0protected Collection&lt;T&gt; items;\n&gt;&gt; &gt; =A0 =A0private T containedItem;=\r\n\n&gt;&gt; &gt;\n&gt;&gt; &gt; =A0 =A0@Before\n&gt;&gt; &gt; =A0 =A0public final void initializeHarness()=\r\n {\n&gt;&gt; &gt; =A0 =A0 =A0 =A0this.items =3D newCollection();\n&gt;&gt; &gt; =A0 =A0 =A0 =A0=\r\nthis.containedItem =3D containedItem();\n&gt;&gt; &gt;\n&gt;&gt; &gt; =A0 =A0 =A0 =A0assertFals=\r\ne(&quot;need a non-empty collection&quot;, items.isEmpty());\n&gt;&gt; &gt; =A0 =A0 =A0 =A0asse=\r\nrtTrue(&quot;need an item that is in the collection&quot;,\n&gt; items.contains(contained=\r\nItem));\n&gt;&gt; &gt; =A0 =A0}\n&gt;&gt; &gt;\n&gt;&gt; &gt; =A0 =A0@Test(expected =3D UnsupportedOperat=\r\nionException.class)\n&gt;&gt; &gt; =A0 =A0public final void shouldPreventAdd() {\n&gt;&gt; &gt;=\r\n =A0 =A0 =A0 =A0// ...\n&gt;&gt; &gt; =A0 =A0}\n&gt;&gt; &gt;\n&gt;&gt; &gt; =A0 =A0// etc...\n&gt;&gt; &gt;\n&gt;&gt; &gt; =\r\n=A0 =A0protected abstract Collection&lt;T&gt; newCollection();\n&gt;&gt; &gt;\n&gt;&gt; &gt; =A0 =A0p=\r\nrotected abstract T newItem();\n&gt;&gt; &gt;\n&gt;&gt; &gt; =A0 =A0protected abstract T contai=\r\nnedItem();\n&gt;&gt; &gt; }\n&gt;&gt; &gt;\n&gt;&gt; &gt; public abstract class UnmodifiableListTestSuppo=\r\nrt&lt;T&gt; extends\n&gt; UnmodifiableCollectionTestSupport&lt;T&gt; {\n&gt;&gt; &gt; =A0 =A0@Test(ex=\r\npected =3D UnsupportedOperationException.class)\n&gt;&gt; &gt; =A0 =A0public final vo=\r\nid shouldPreventAddAtIndex() {\n&gt;&gt; &gt; =A0 =A0 =A0 =A0// ...\n&gt;&gt; &gt; =A0 =A0}\n&gt;&gt; =\r\n&gt;\n&gt;&gt; &gt; =A0 =A0// etc...\n&gt;&gt; &gt;\n&gt;&gt; &gt; =A0 =A0protected final Collection&lt;T&gt; newC=\r\nollection() {\n&gt;&gt; &gt; =A0 =A0 =A0 =A0return newList();\n&gt;&gt; &gt; =A0 =A0}\n&gt;&gt; &gt;\n&gt;&gt; &gt;=\r\n =A0 =A0protected abstract List&lt;T&gt; newList();\n&gt;&gt; &gt;\n&gt;&gt; &gt; =A0 =A0private List=\r\n&lt;T&gt; list() {\n&gt;&gt; &gt; =A0 =A0 =A0 =A0return (List&lt;T&gt;) items;\n&gt;&gt; &gt; =A0 =A0}\n&gt;&gt; &gt;=\r\n }\n&gt;&gt; &gt;\n&gt;&gt; &gt; public class UnmodifiableListTest extends\n&gt; UnmodifiableListTe=\r\nstSupport&lt;String&gt; {\n&gt;&gt; &gt; =A0 =A0@Override\n&gt;&gt; &gt; =A0 =A0protected List&lt;String=\r\n&gt; newList() {\n&gt;&gt; &gt; =A0 =A0 =A0 =A0return unmodifiableList(asList(&quot;foo&quot;));\n&gt;=\r\n&gt; &gt; =A0 =A0}\n&gt;&gt; &gt;\n&gt;&gt; &gt; =A0 =A0protected String newItem() {\n&gt;&gt; &gt; =A0 =A0 =A0=\r\n =A0return &quot;bar&quot;;\n&gt;&gt; &gt; =A0 =A0}\n&gt;&gt; &gt;\n&gt;&gt; &gt; =A0 =A0protected String contained=\r\nItem() {\n&gt;&gt; &gt; =A0 =A0 =A0 =A0return &quot;foo&quot;;\n&gt;&gt; &gt; =A0 =A0}\n&gt;&gt; &gt; }\n&gt;&gt; &gt;\n&gt;&gt; &gt; I=\r\n am imagining an UnmodifiableMapTestSupport abstract class to do\n&gt; similar =\r\ntests for unmodifiable maps:\n&gt;&gt; &gt;\n&gt;&gt; &gt; public abstract class UnmodifiableMa=\r\npTestSupport&lt;K, V&gt; {\n&gt;&gt; &gt; =A0 =A0private Map&lt;K, V&gt; entries;\n&gt;&gt; &gt; =A0 =A0pri=\r\nvate K containedKey;\n&gt;&gt; &gt; =A0 =A0private V containedValue;\n&gt;&gt; &gt;\n&gt;&gt; &gt; =A0 =\r\n=A0@Before\n&gt;&gt; &gt; =A0 =A0public final void initializeHarness() {\n&gt;&gt; &gt; =A0 =A0=\r\n =A0 =A0this.entries =3D newMap();\n&gt;&gt; &gt; =A0 =A0 =A0 =A0this.containedKey =\r\n=3D containedKey();\n&gt;&gt; &gt; =A0 =A0 =A0 =A0this.containedValue =3D containedVa=\r\nlue();\n&gt;&gt; &gt;\n&gt;&gt; &gt; =A0 =A0 =A0 =A0assertFalse(&quot;need a non-empty map&quot;, entries=\r\n.isEmpty());\n&gt;&gt; &gt; =A0 =A0 =A0 =A0assertTrue(&quot;need a key that is in the map&quot;=\r\n,\n&gt; entries.containsKey(containedKey));\n&gt;&gt; &gt; =A0 =A0 =A0 =A0assertTrue(&quot;nee=\r\nd a value that is in the map&quot;,\n&gt; entries.containsValue(containedValue));\n&gt;&gt;=\r\n &gt; =A0 =A0}\n&gt;&gt; &gt;\n&gt;&gt; &gt; =A0 =A0@Test(expected =3D UnsupportedOperationExcepti=\r\non.class)\n&gt;&gt; &gt; =A0 =A0public final void shouldPreventPut() {\n&gt;&gt; &gt; =A0 =A0 =\r\n=A0 =A0// ...\n&gt;&gt; &gt; =A0 =A0}\n&gt;&gt; &gt;\n&gt;&gt; &gt; =A0 =A0protected abstract Map&lt;K, V&gt; n=\r\newMap();\n&gt;&gt; &gt;\n&gt;&gt; &gt; =A0 =A0protected abstract K newKey();\n&gt;&gt; &gt;\n&gt;&gt; &gt; =A0 =A0p=\r\nrotected abstract K containedKey();\n&gt;&gt; &gt;\n&gt;&gt; &gt; =A0 =A0protected abstract V c=\r\nontainedValue();\n&gt;&gt; &gt; }\n&gt;&gt; &gt;\n&gt;&gt; &gt; Not just would I like to test that a map =\r\ncannot be modified via its\n&gt; Map methods, but also I would like to test tha=\r\nt the map cannot be\n&gt; mutated via the keySet(), values(), and entrySet() vi=\r\news. =A0It would be\n&gt; really nice if, when someone subclasses UnmodifiableM=\r\napTestSupport, they\n&gt; could get an Un modifiableCollectionTestSupport&lt;K&gt;,\n&gt;=\r\n UnmodifiableCollectionTestSupport&lt;V&gt;, and an\n&gt; UnmodifiableCollectionTestS=\r\nupport&lt;Map.Entry&lt;K, V&gt;&gt; instantiated, run,\n&gt; and result reported on for the=\r\n keySet(), values(), and entrySet() views\n&gt; of the newMap() result. =A0Othe=\r\nrwise, they would have to hand-roll three\n&gt; more concretes of UnmodifiableC=\r\nollectionTestSupport for testing the\n&gt; keySet(), values(), and entrySet() v=\r\niews of a given map.\n&gt;\n&gt;\n&gt;\n&gt;\n&gt;\n&gt; ------------------------------------\n&gt;\n&gt; Y=\r\nahoo! Groups Links\n&gt;\n&gt;\n&gt;\n&gt;\n\n", 
    "profile": "dsaff", 
    "topicId": 21578, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 341876227, 
    "prevInTime": 21606, 
    "contentTrasformed": false, 
    "postDate": "1242309018", 
    "canDelete": false, 
    "nextInTopic": 21611, 
    "prevInTopic": 21600, 
    "headers": {
        "inReplyToHeader": "PGd1ZmFjOSthYnQxQGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PDRmN2RhNmI5MDkwNTE0MDY1MG8zNGRkNjhkZG0yYzIzM2NmYjU1NmZjZTZjQG1haWwuZ21haWwuY29tPg==", 
        "referencesHeader": "PDRmN2RhNmI5MDkwNTExMDgwNnExNGM4ODFlM3ZiN2UxZGVmZWE4Y2MwYzYyQG1haWwuZ21haWwuY29tPgkgPGd1ZmFjOSthYnQxQGVHcm91cHMuY29tPg=="
    }
}