{
    "topicId": 9699, 
    "postDate": "1066614399", 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "from": "&quot;Michael Silverstein&quot; &lt;msilverstein@...&gt;", 
    "canDelete": false, 
    "replyTo": "LIST", 
    "senderId": "BPmEuet07O2gdzaLfcc3wA-sE4pJT7t9kQi1I2asXOfc7j4kI85Vki8nvDRghSMWxjjJhT6HiHUEjsL2gA1SwWeop-5HE-G8ause34kI6mUH3JTyvPpjC1qE", 
    "nextInTime": 9726, 
    "userId": 62742148, 
    "prevInTime": 9724, 
    "prevInTopic": 9724, 
    "headers": {
        "inReplyToHeader": "PDAwNDMwMWMzOTY1OSQwNTk5ODlmMCQ2NDAxYThjMEBYUDE+", 
        "messageIdInHeader": "PDAwMWMwMWMzOTZhYyQwMTgwYjdhMCQ2NDAxYThjMEBsYXRpdHVkZTAxPg=="
    }, 
    "authorName": "Michael Silverstein", 
    "numMessagesInTopic": 23, 
    "msgSnippet": "My opinion is that if you want to make it possible for others to extend your framework in ways that haven t anticipated you don t make your methods private,", 
    "contentTrasformed": false, 
    "msgId": 9725, 
    "nextInTopic": 9731, 
    "systemMessage": false, 
    "rawEmail": "Return-Path: &lt;msilverstein@...&gt;\r\nX-Sender: msilverstein@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (qmail 5728 invoked from network); 20 Oct 2003 01:46:51 -0000\r\nReceived: from unknown (66.218.66.216)\n  by m4.grp.scd.yahoo.com with QMQP; 20 Oct 2003 01:46:51 -0000\r\nReceived: from unknown (HELO ms-smtp-01-eri0.southeast.rr.com) (24.93.67.82)\n  by mta1.grp.scd.yahoo.com with SMTP; 20 Oct 2003 01:46:51 -0000\r\nReceived: from latitude01 (cpe-024-211-140-157.nc.rr.com [24.211.140.157])\n\tby ms-smtp-01-eri0.southeast.rr.com (8.12.10/8.12.7) with ESMTP id h9K1ko2I017045\n\tfor &lt;junit@yahoogroups.com&gt;; Sun, 19 Oct 2003 21:46:50 -0400 (EDT)\r\nTo: &lt;junit@yahoogroups.com&gt;\r\nSubject: RE: [junit] Re: How to test private methods, its urgent\r\nDate: Sun, 19 Oct 2003 21:46:39 -0400\r\nMessage-ID: &lt;001c01c396ac$0180b7a0$6401a8c0@latitude01&gt;\r\nMIME-Version: 1.0\r\nContent-Type: text/plain;\n\tcharset=&quot;Windows-1252&quot;\r\nContent-Transfer-Encoding: 7bit\r\nX-Priority: 3 (Normal)\r\nX-MSMail-Priority: Normal\r\nX-Mailer: Microsoft Outlook, Build 10.0.3416\r\nX-MimeOLE: Produced By Microsoft MimeOLE V6.00.2727.1300\r\nImportance: Normal\r\nIn-Reply-To: &lt;004301c39659$059989f0$6401a8c0@XP1&gt;\r\nFrom: &quot;Michael Silverstein&quot; &lt;msilverstein@...&gt;\r\nX-Yahoo-Group-Post: member; u=62742148\r\n\r\n\nMy opinion is that if you want to make it possible for others to extend\nyour framework in ways that haven&#39;t anticipated you don&#39;t make your\nmethods private, but you do add in enough &#39;buyer beware&#39; documentation\nto indicate methods that probably should be private and may be\ndangerous. Something like a @private javadoc tag would be plenty. Its up\nto the person who extends the framework to decide whether to take on the\nrisk of calling those methods, and the maintenance headaches that may\nfollow. It usually helps if the source for the methods is available as\nwell.\n\nAs an example, I extended JUnit for load testing to distribute tests on\nmultiple machines, execute them in parallel  and then collate the\nresults on a central machine. It was pretty easy to do except for\nseveral private methods that made things very difficult. This was a year\nago so I don&#39;t remember the specifics. I could have created my own\nversion of JUnit with the private methods made public but then I would\nhave had to maintain and ship my own version of JUnit, which was not an\noption. \n\nFor another example, I worked on a GUI capture/playback tool for\nSmalltalk. This required accessing a lot of internal widget methods. Had\nthose methods been private the task would probably have been impossible.\nInstead we accepted the risk and went ahead. When a new release of\nSmalltalk comes out we have to re-test with it and make some adjustments\nbecause of our use of private methods but it is all very containable.\n\nOn the other hand, if you don&#39;t anticipate anyone is going to extend\nyour framework or you don&#39;t want anyone to extend it then it makes sense\nto make methods private. For example, if your business model is built on\nyour being the only one capable of extending a system to meet your\ncustomers specific needs, you don&#39;t want to make it too easy for them to\nextend the system.\n\n-----------------------------\nMike Silverstein\nSilverMark, Inc.\nThe Object Testing Company\nwww.javatesting.com\n\n&gt; -----Original Message-----\n&gt; From: David Vydra [mailto:david@...] \n&gt; Sent: Sunday, October 19, 2003 11:53 AM\n&gt; To: junit@yahoogroups.com\n&gt; Subject: Re: [junit] Re: How to test private methods, its urgent\n&gt; \n&gt; \n&gt; Michael,\n&gt; I usually like your approach, however according to this \n&gt; article, http://www.artima.com/intv/nonvirtual.html, C# \n&gt; creators propose that methods should not be made \n&gt; automatically overridable. I suppose we can do the same in \n&gt; java with the &#39;final&#39; modifier. Do you think there is any \n&gt; merit to this strategy for large, long-lived systems? Any \n&gt; other opinions? Regards, David www.testdriven.com\n&gt; \n&gt; ----- Original Message ----- \n&gt; From: &quot;Michael Silverstein&quot; &lt;msilverstein@...&gt;\n&gt; To: &lt;junit@yahoogroups.com&gt;\n&gt; Sent: Thursday, October 16, 2003 6:49 PM\n&gt; Subject: RE: [junit] Re: How to test private methods, its urgent\n&gt; \n&gt; \n&gt; &gt; &gt; -----Original Message-----\n&gt; &gt; &gt; From: Danijel Arsenovski [mailto:darsenovski@...]\n&gt; &gt; &gt; Sent: Thursday, October 16, 2003 4:00 PM\n&gt; &gt; &gt; To: junit@yahoogroups.com\n&gt; &gt; &gt; Subject: RE: [junit] Re: How to test private methods, its urgent\n&gt; &gt; &gt;\n&gt; &gt; &gt;\n&gt; &gt; &gt; Hello Michael,\n&gt; &gt; &gt;\n&gt; &gt; &gt;\n&gt; &gt; &gt; &gt;Private methods are difficult to test because, after \n&gt; all, they&#39;re \n&gt; &gt; &gt; &gt;private. If you adopt a convention that API methods are only\n&gt; &gt; &gt; presented\n&gt; &gt; &gt; &gt;via Java Interfaces instead of concrete classes then you \n&gt; don&#39;t care \n&gt; &gt; &gt; &gt;about the way the implementers of the Interfaces are\n&gt; &gt; &gt; written. You can\n&gt; &gt; &gt; &gt;then make non-API methods within the concrete \n&gt; implementation public \n&gt; &gt; &gt; &gt;without implying that they are themselves API methods.\n&gt; &gt; &gt;\n&gt; &gt; &gt; I am not sure I follow, but as I can see this only works if you \n&gt; &gt; &gt; never plan to extend your clases, or leave them to be extended. I \n&gt; &gt; &gt; guess that in your case only thing visible from the outside are \n&gt; &gt; &gt; interfaces. If you write frameworks, it is difficult to get by \n&gt; &gt; &gt; without inheritance. Inheritance breaks encapsulation, keeping \n&gt; &gt; &gt; methods private helps encapsulate things. Also, I am not \n&gt; shure what \n&gt; &gt; &gt; you mean by &quot;without implying&quot;, generally you &quot;make \n&gt; statement&quot; with \n&gt; &gt; &gt; your code, any other method yo imply something (comments, \n&gt; &gt; &gt; documentation etc...) is superfluous.\n&gt; &gt; &gt;\n&gt; &gt; &gt; Regards,\n&gt; &gt; &gt;\n&gt; &gt; &gt; Danijel Arsenovski\n&gt; &gt;\n&gt; &gt; On the contrary, I think this approach makes it easier to extend \n&gt; &gt; frameworks. I believe that in the general case, there is no \n&gt; reason to \n&gt; &gt; make methods in classes private if their API methods are \n&gt; only accessed \n&gt; &gt; by clients via Interface methods.\n&gt; &gt;\n&gt; &gt; Here&#39;s an example of what I mean:\n&gt; &gt;\n&gt; &gt; Let&#39;s assume we have class MyClass that implements interface \n&gt; &gt; MyInterface, with methods: public int x(){\n&gt; &gt;   // return an answer based on y() and z()\n&gt; &gt; }\n&gt; &gt; private int y() {...}\n&gt; &gt; private int z() {...}\n&gt; &gt;\n&gt; &gt; And Interface MyInterface with method:\n&gt; &gt; public int x()\n&gt; &gt;\n&gt; &gt; We observe that:\n&gt; &gt;\n&gt; &gt; - MyInterface serves to &#39;publish&#39; the API method x().\n&gt; &gt;\n&gt; &gt; - Any client of MyClass will only see it in terms of\n&gt; &gt;\n&gt; &gt; - We have the choice of testing public method x() by constructing a \n&gt; &gt; test that &#39;talks&#39; to either MyClass or MyInterface.\n&gt; &gt;\n&gt; &gt; - If we have other concrete implementors of MyInterface it \n&gt; makes sense \n&gt; &gt; to write the test to talk to MyInterface rather than directly to \n&gt; &gt; implementors to they can be swapped in and tested.\n&gt; &gt;\n&gt; &gt; - x() returns a value based on values returned by private \n&gt; methods y() \n&gt; &gt; and z().\n&gt; &gt;\n&gt; &gt; - Methods y() and z() may be private for no other reason than that \n&gt; &gt; they are not part of the public API interface of MyClass \n&gt; and that the \n&gt; &gt; developer did not anticipate that anyone would ever need to \n&gt; use them \n&gt; &gt; in extending the framework.\n&gt; &gt;\n&gt; &gt; Continuing:\n&gt; &gt; Let&#39;s say\n&gt; &gt;  - we want to extend MyClass with MyClass2 that implements \n&gt; method int \n&gt; &gt; q().\n&gt; &gt;  - we want to override x() so that it uses methods y(),  \n&gt; z(), and q() \n&gt; &gt; to calculate its return value.\n&gt; &gt;\n&gt; &gt; We have a problem: MyClass2 does not have visibility to private \n&gt; &gt; methods\n&gt; &gt; y() and z().\n&gt; &gt;\n&gt; &gt; If private methods y() and z() were made public there would be no \n&gt; &gt; adverse effect on the publication of API methods because \n&gt; users of the \n&gt; &gt; class would only see those methods published via MyInterface.\n&gt; &gt;\n&gt; &gt; We have the question of whether it is *safe* to use y() and \n&gt; z(). Since \n&gt; &gt; they are not published as part of the API via MyInterface it may be \n&gt; &gt; considered too risky to use them. This can be solved with \n&gt; some notes \n&gt; &gt; in the javadoc.\n&gt; &gt;\n&gt; &gt; Methods that really are too risky to use outside of the \n&gt; class itself \n&gt; &gt; can always be made private but I would hope that this is \n&gt; the exception \n&gt; &gt; and not the rule.\n&gt; &gt;\n&gt; &gt; The developer creating the extension can make the decision based on \n&gt; &gt; those notes whether they are willing to accept fhe risk of using \n&gt; &gt; methods that may not continue to behave the same way or \n&gt; even exist in \n&gt; &gt; the future. At least they have that choice. If they have a \n&gt; good set of \n&gt; &gt; tests then changes to those methods in the future will be exposed \n&gt; &gt; readily enough.\n&gt; &gt;\n&gt; &gt; Conclusion\n&gt; &gt; ----------\n&gt; &gt; If the purpose of making methods private is to indicate \n&gt; that they are \n&gt; &gt; not part of a class&#39;s API a better way is to encourage users of the \n&gt; &gt; class to program to a Java Interface instead. When you make methods \n&gt; &gt; private it makes the class more difficult to test and \n&gt; short-circuits \n&gt; &gt; the efforts of people who might need to extend the framework in \n&gt; &gt; unanticipated ways.\n&gt; &gt;\n&gt; &gt; -----------------------------\n&gt; &gt; Mike Silverstein\n&gt; &gt; SilverMark, Inc.\n&gt; &gt; The Object Testing Company\n&gt; &gt; www.javatesting.com\n\n---\nOutgoing mail is certified Virus Free.\nChecked by AVG anti-virus system (http://www.grisoft.com).\nVersion: 6.0.528 / Virus Database: 324 - Release Date: 10/16/2003\n \n\n\n", 
    "subject": "RE: [junit] Re: How to test private methods, its urgent"
}