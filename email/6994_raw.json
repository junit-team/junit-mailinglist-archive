{
    "topicId": 6994, 
    "postDate": "1045634711", 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "from": "skss2002@...", 
    "canDelete": false, 
    "replyTo": "LIST", 
    "senderId": "6u6cxAG-_72A_5zpm6e8HJ-h6sdG3kM0VB_kdbRKelK8tZ2x3gGl8Ulk7Dr1T9J7gkpyZHJwJQ", 
    "nextInTime": 6995, 
    "userId": 107426134, 
    "prevInTime": 6993, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PDFlOC4yM2NiMGIwLjJiODQ3ODk3QGFvbC5jb20+"
    }, 
    "authorName": "skss2002@aol.com", 
    "numMessagesInTopic": 3, 
    "msgSnippet": "Hello everyone, I am working on a programming assignment, in which I am given a class that implements a simple database using a random access file.  The class", 
    "contentTrasformed": false, 
    "msgId": 6994, 
    "nextInTopic": 6997, 
    "systemMessage": false, 
    "rawEmail": "Return-Path: &lt;Skss2002@...&gt;\r\nReceived: (qmail 46458 invoked from network); 19 Feb 2003 16:23:14 -0000\r\nReceived: from unknown (66.218.66.217)\n  by m9.grp.scd.yahoo.com with QMQP; 19 Feb 2003 16:23:14 -0000\r\nReceived: from unknown (HELO n16.grp.scd.yahoo.com) (66.218.66.71)\n  by mta2.grp.scd.yahoo.com with SMTP; 19 Feb 2003 16:23:14 -0000\r\nX-eGroups-Return: Skss2002@...\r\nReceived: from [66.218.67.191] by n16.grp.scd.yahoo.com with NNFMP; 19 Feb 2003 16:23:14 -0000\r\nX-Sender: Skss2002@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (EGP: mail-8_2_3_4); 19 Feb 2003 06:05:24 -0000\r\nReceived: (qmail 5175 invoked from network); 19 Feb 2003 06:05:24 -0000\r\nReceived: from unknown (66.218.66.217)\n  by m14.grp.scd.yahoo.com with QMQP; 19 Feb 2003 06:05:24 -0000\r\nReceived: from unknown (HELO imo-m07.mx.aol.com) (64.12.136.162)\n  by mta2.grp.scd.yahoo.com with SMTP; 19 Feb 2003 06:05:24 -0000\r\nReceived: from Skss2002@...\n\tby imo-m07.mx.aol.com (mail_out_v34.21.) id r.1e8.23cb0b0 (3890)\n\t for &lt;junit@yahoogroups.com&gt;; Wed, 19 Feb 2003 01:05:12 -0500 (EST)\r\nMessage-ID: &lt;1e8.23cb0b0.2b847897@...&gt;\r\nDate: Wed, 19 Feb 2003 01:05:11 EST\r\nSubject: Unit testing multi-threads access to one database\r\nTo: junit@yahoogroups.com\r\nMIME-Version: 1.0\r\nX-Mailer: 7.0 for Windows sub 537\r\nFrom: skss2002@...\r\nX-Yahoo-Group-Post: member; u=107426134\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\nX-eGroups-Approved-By: clarkware &lt;mike@...&gt; via web; 19 Feb 2003 16:23:12 -0000\r\n\r\nHello everyone,\n\nI am working on a programming assignment, in which I am given a class that \nimplements a\nsimple database using a random access file.  The class provides public \nsynchronized methods such\nas getRecord(), add(), find(), modify(), delete() to access records in the \ndatabase.  I am asked to\ndesign lock(), unlock() methods for locking/unlocking a record to maintain \ndatabase integerity in multi-\nusers environment.\n\nThe idea is if two database clients attempt to perform the sequence lock(), \ngetRecord(), modify(),\nunlock() concurrently, then both modification attempts will be handled \ncorrectly.  For example, if the\ndatabase has 4 fields: record number, product name, price, and quantity in \nstock, the below statements\nwould be typical in the client code to update an inventory after a sale.\n\n/* requestedProduct and orderQuantity are input parameters */\n            ...\nint recordNumberFound = find(requestedProduct);\nlock(recordNumberFound);\nRecord rec = getRecord(recordNumberFound);\nif (rec.quantityInStock &gt;= orderQuantity) {\n    Record newRec = new Record();\n\n    /* The following look cumbersome and the Record constructor should be \nable to take all the fields\n    as parameters.  The actual implementation is a little more complex than \nthis, just to demonstrate\n    there is process needed to create a new record. */\n    newRec.recordNumber = rec.recordNumber;\n    newRec.productName = rec.productName;\n    newRec.price = rec.price;\n    newRec.quantityInStock = rec.quantityInStock - orderQuantity;\n\n    modify(newRec);  // this will overwrite the existing record in the \ndatabase\n    unlock(recordNumberFound);\n} else {\n    unlock(recordNumberFound);\n    throw new DatabaseException(&quot;Not enough stock to fulfil the order.&quot;);\n}\n\nBasically, lock() and unlock methods use a HashSet to traffic-control access \nto a record.  lock()\nchecks if the record is already in the HashSet, if so then call wait(), if \nnot then adds it in.  unlock()\nremoves the record from the HashSet and call notifyAll().  So by puposely \nomitting the lock() method,\none or more of the concurrent users can get pass the if-test before the \nrecord is modified, and the\nquantityInStock may be overly reduced to negative.\n\nTo unit test the above scenario, my TestCase&#39;s setUp() creates a test \ndatabase by copying all the\nrecords from the original database, thus creates a new random access file.  \nIn tearDown(), the random\naccess file for the test database is deleted.  I thought I could use \nJunitPerf&#39;s loadTest() method to\nsimulate multi-users environment by multi-threads.\n\nThe first problem I went into was each thread tried to create a new database, \nwhich was not allowed\nby the database class supplied to me (it saw there was a random access file \nwith the same name exist\nand threw an IOException), and it didn&#39;t exactly serve my test objective \neither because I tried to\nsimulate multi-users accessing the same database.\n\nAfter some investigation, I found out junit.extensions.TestSetup could force \none time setUp()\nand tearDown(), and came up with something like below:\n\n    public class DataLockTest {\n        private static Data testDatabase;\n        private static final int MAX_USERS = 10;\n\n          public static Test suite() {\n\n                /*\n                    1. Open the supplied database class\n                    2. Copy every record from the original database to \ntestDatabase\n\n                */\n\n                // Pass the testDatabase to the test case contained in the \nDataLockTestHelper class\n                Test testCase = new DataLockTestHelper(&quot;testModifyWit\nhNoLock&quot;, testDatabase);\n\n                Test loadTest = new LoadTest(testCase, MAX_USERS);\n                TestSuite suite = new TestSuite();\n                suite.addTest(loadTest);\n\n                // Anonymous TestSetup object for one time tearDown method\n                TestSetup wrapper = new TestSetup(suite) {\n\n                    protected void tearDown() {\n\n                        /*\n                            1. Close testDatabases,\n                            2. Delete the underlying random access file\n                                ...\n                        */\n                    }\n                };\n                return wrapper;\n    }\n\n    public class DataLockTestHelper extends TestCase {\n        private Data dataSource;\n        private static final int RECORD_NO = 24;\n\n        // Each user uses the same data source provided by DataLockTest\n        public DataLockTestHelper(String name, Data source) {\n            super(name);\n            dataSource = source;\n        }\n\n        /**\n         * Test fixture is setup in DataLockTest.\n         */\n        protected void setUp() {}\n\n        /**\n         * Test fixture is torn down in DataLockTest.\n         */\n        protected void tearDown() {}\n\n        public void testModifyWithNoLock() throws DatabaseException {\n            Record record, newRecord;\n\n            try {\n\n            // comment out lock() method call ----&gt;           \ndataSource.lock(RECORD_NO);\n                record = dataSource.getRecord(RECORD_NO);\n                if (record.quantityInStock &gt;= 3) {\n                    newRecord = new Record();\n                    newRecord.recordNumber = record.recordNumber;\n                    newRecord.price = record.price;\n\n                    /* the field has 10 original, so if running 10 threads \nconcurrently, very like it will become\n                    negative */\n                newRecord.quantityInStock = record.quantityInStock - 3;\n\n                    dataSource.modify(newRecord);\n                }\n            //  comment out unlock() method call ---&gt;        \ndataSource.unlock(RECORD_NO);\n\n                /* Test if the quantity in stock field becomes negative. */\n                dataSource.lock(RECORD_NO);\n                record = dataSource.getRecord(RECORD_NO);\n             int quantity = record.quantityInStock;\n                dataSource.unlock(RECORD_NO);\n\n                /* The test is successful if the field has been overly \nreduced to negative */\n                if (quantity &lt; 0) {\n                    assertTrue(true);\n                }\n            } catch(DatabaseException fail) {\n                fail(&quot;Shouldn&#39;t raise DatabaseException.&quot;);\n            }\n        }\n\n    }\n\n    Now the test is successful, however, I have very skeptical about it.  I \ndon&#39;t know if it&#39;s ok to pass the\n    testDatabase to the test case like this, and would some of the concurrent \nthreads simply leave the\n    test case gracefully without doing anything if the condition &quot;if \n(quantity &lt; 0)&quot; is not met.\n\n    I appreciate any comment, please help, thanks!\n\n\n[Non-text portions of this message have been removed]\n\n\n\n", 
    "subject": "Unit testing multi-threads access to one database"
}