{
    "numMessagesInTopic": 46, 
    "nextInTime": 4894, 
    "senderId": "33hnYdT8t-DW9cpyAEjbmanhbbeV2zM83CHDiQvKjaWeM3R-ZJlbWCq7YWuw2unsxeoFoRIc5PFyfuTdhoBd6KTW10zq_mzHBfe4Y7YJ", 
    "systemMessage": false, 
    "subject": "RE: [junit] Re: black box or white box?", 
    "from": "&quot;Berin Loritsch&quot; &lt;bloritsch@...&gt;", 
    "authorName": "Berin Loritsch", 
    "msgSnippet": "... You test for the contracts. You instantiate (or have something else instantiate) the implementation of the Store.  The test works with the interface.  In", 
    "msgId": 4893, 
    "profile": "bloritsch", 
    "topicId": 4836, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 64910131, 
    "messageBody": "<div id=\"ygrps-yiv-587823539\"><blockquote><span title=\"ireply\">&gt; From: ipreussde [mailto:<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:ilja.preuss@...\">ilja.preuss@...</a>] <br/>\n&gt; <br/>\n&gt; --- In junit@y..., &quot;Berin Loritsch&quot; &lt;bloritsch@a...&gt; wrote:<br/>\n&gt; &gt; interface Store<br/>\n&gt; &gt; {<br/>\n&gt; &gt;     void store(String key, Object val);<br/>\n&gt; &gt;     Object retrieve(String key);<br/>\n&gt; &gt;     void remove(String key);<br/>\n&gt; &gt; }<br/>\n&gt; &gt; <br/>\n&gt; &gt; That interface is enough to know how to use the object store.<br/>\n&gt; <br/>\n&gt; Yes. So please explain: What tests do you need to sufficiently test <br/>\n&gt; every possible implementation of this interface? How did you find <br/>\n&gt; them?<br/>\n&gt; <br/>\n<br/>\n </span></blockquote>You test for the contracts.<br/>\n<br/>\nYou instantiate (or have something else instantiate) the implementation<br/>\nof the Store.  The test works with the interface.  In fact, because this<br/>\nis so flexible, I tend to write a test harness that I can use for<br/>\nseveral<br/>\nsituations like this.  The basic code iterates through the different<br/>\nStore objects and performs the same tests on them.<br/>\n<br/>\nLooking through the interface, here is how it would go for one impl.<br/>\n<br/>\nSuppose we have a MemoryStore (stores the object to memory).  We create<br/>\nthe MemoryStore object (by factory method for tests) in the Setup()<br/>\nmethod and store it in a class attribute.  The tests use the class.<br/>\n<br/>\nSomething like this:<br/>\n<br/>\npublic class StoreTestCase extends TestCase<br/>\n{<br/>\n    private Store m_store;<br/>\n<br/>\n    public StoreTestCase(String name)<br/>\n    {<br/>\n        super( name );<br/>\n    }<br/>\n<br/>\n    public void Setup()<br/>\n        throws Exception<br/>\n    {<br/>\n        // I might have dynamic code to tell which class to use<br/>\n        // for demonstration I will hardcode it.<br/>\n        m_store =<br/>\nClass.forName(&quot;org.dhaven.store.MemoryStore&quot;).newInstance();<br/>\n    }<br/>\n<br/>\n    public void testRetrieval()<br/>\n    {<br/>\n        Integer testInt = new Integer( 777 );<br/>\n        m_store.store(&quot;test&quot;, testInt);<br/>\n<br/>\n        assertEquals( testInt, m_store.retrieve( &quot;test&quot; ) );<br/>\n<br/>\n        m_store.remove(&quot;test&quot;);<br/>\n        assertEquals( null, m_store.retrieve( &quot;test&quot; ) );<br/>\n    }<br/>\n}<br/>\n<br/>\nThat excercises the interface of the Store.  Now, lets assume the<br/>\nMemoryStore<br/>\nhas a limit of 10 characters for the name because the implementors are<br/>\nmasochistic and stored the name as an array of chars.  Someone passes in<br/>\na bug<br/>\nthat proves that there is no difference between &quot;0123456789A&quot; and<br/>\n&quot;0123456789B&quot;.<br/>\nWe add a test case to catch that, and the MemoryStore is not living up<br/>\nto its<br/>\ncontract.  The contract is any String, so the limitations of key values<br/>\nshould<br/>\nnot be any more limited than what a String can do.<br/>\n<br/>\nThat way, all implementations are tested against that same violation.<br/>\n<br/>\nOne thing I might do at this point is add a new method to the Store<br/>\ninterface<br/>\nto examine whether a value is already stored.  This is because it would<br/>\nhelp<br/>\ntesting, and clarify the usage of the interface.  Another thing I would<br/>\ndo<br/>\nis add an exception that needs to be caught if we try to store an object<br/>\novertop<br/>\nanother one.<br/>\n<br/>\nThe new interface (after testing and useage proves we need these<br/>\nchanges) becomes:<br/>\n<br/>\npublic interface Store<br/>\n{<br/>\n    void store(String key, Object value) throws StoreException;<br/>\n    boolean hasKey(String key);<br/>\n    Object retrieve(String key);<br/>\n    void remove(String key);<br/>\n}<br/>\n<br/>\nThe new testcase would only add new methods to test that hasKey()<br/>\nreturns true<br/>\nif a key is already used for a stored object.  I would also add one that<br/>\ntests<br/>\nthe exception:<br/>\n<br/>\nvoid testNoDoubleStore<br/>\n{<br/>\n    Integer testInt1 = new Integer( 777 );<br/>\n    Integer testInt2 = new Integer( 666 );<br/>\n<br/>\n    try<br/>\n    {<br/>\n        m_store.store(&quot;test&quot;, testInt1);<br/>\n        assertTrue( m_store.hasKey(&quot;test&quot;) );<br/>\n<br/>\n        m_store.store(&quot;test&quot;, testInt2);<br/>\n        fail(&quot;Must throw StoreException if the store has a key&quot;);<br/>\n    }<br/>\n    catch (StoreException se)<br/>\n    {<br/>\n        // It did what it was supposed to.  Ignore this exception<br/>\n    }<br/>\n    catch (Exception e)<br/>\n    {<br/>\n        // It threw a different exception than we were expecting<br/>\n        fail(&quot;Unexpected Exception: &quot; + e.toString());<br/>\n    }<br/>\n<br/>\n    assertTrue( ! m_store.retrieve(&quot;test&quot;).equals( testInt2) );<br/>\n    assertEquals( testInt1, m_store.retrieve(&quot;test&quot;) );<br/>\n<br/>\n    m_store.remove(&quot;test&quot;);<br/>\n    assertTrue( ! m_store.hasKey(&quot;test&quot;) );<br/>\n}<br/>\n<br/>\nEach test reinforces the basic contracts.<br/>\n<br/>\nAt this point, I would probably be satisfied with the interface,<br/>\nallowing me to implement different versions of the Store interface.<br/>\nAs far as I am concerned, I don&#39;t care about the methodology--I<br/>\ncare about the contract.</div>", 
    "prevInTime": 4892, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1020776664", 
    "canDelete": false, 
    "nextInTopic": 4894, 
    "prevInTopic": 4891, 
    "headers": {
        "inReplyToHeader": "PGFiNnQ3aytqaWk0QGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PDAwMmIwMWMxZjVjNyRiNjY3MTMzMCRhYzAwYThjMEBHYWJyaWVsPg=="
    }
}