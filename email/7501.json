{
    "numMessagesInTopic": 4, 
    "nextInTime": 7502, 
    "senderId": "hY8SSmw9Bq5TYle6Auf2ZgOm5VobIjzhh1LAH8EHsBJMJ3CQ5rfnQs-dE9Bkcswd7kkvu99AGDWoRbAbIXRvemLZPL7fjzy776RhD0NYaBm4-XdtXY-hGURAY0aboe6f5w", 
    "systemMessage": false, 
    "subject": "Re: [junit] JUnit considered problematic. Part III", 
    "from": "Herr Christian Wolfgang Hujer &lt;Christian.Hujer@...&gt;", 
    "authorName": "Herr Christian Wolfgang Hujer", 
    "msgSnippet": "... Hash: SHA1 Hi javainsel, dear list members, okay now, Again I respond to you. But it will be my last response to this thread if you again refuse to reply ", 
    "msgId": 7501, 
    "topicId": 7490, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 108505539, 
    "messageBody": "<div id=\"ygrps-yiv-1736304863\">-----BEGIN PGP SIGNED MESSAGE-----<br/>\nHash: SHA1<br/>\n<br/>\nHi javainsel, dear list members,<br/>\n<br/>\n<br/>\nokay now,<br/>\n<br/>\nAgain I respond to you.<br/>\nBut it will be my last response to this thread if you again refuse to reply <br/>\nand to be responsive to my arguments.<br/>\n<br/>\nAm Donnerstag, 3. April 2003 09:15 schrieb javainsel:<br/>\n<blockquote><span title=\"ireply\"> &gt; Now let me again try to convince you that JUnit is only accepted<br/>\n&gt; today because of a powerty of Java language.<br/>\n </span></blockquote>You try again, okay.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; It is very simple.<br/>\n </span></blockquote>No, it&#39;s not that simple.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; If you try to correct yourself all the time as a developer then you<br/>\n&gt; will apply this principle to the question, whether JUnit and Test<br/>\n&gt; Driven Development (TDD) are really useful or whether they should be<br/>\n&gt; replaced by something better as soon as possible.<br/>\n </span></blockquote>That&#39;s very plausible, but that&#39;s not a factual argument, just an ethical <br/>\nfingertip. Don&#39;t think we&#39;re all closed-minded, not willingly to adopt modern <br/>\nand useful programming techniques. If we were, we weren&#39;t on this list. (That <br/>\nof course also is not a factual argument)<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Using Design by Contract can completely make JUnit und TDD obsolete.<br/>\n </span></blockquote>No.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Right now I&#39;m not sure if it can make it obsolete for all appliances.<br/>\n </span></blockquote>So then why do you make such statements?<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; But it can replace at least most usages of JUnit and TDD.<br/>\n </span></blockquote>No. s/most/many/ and I will agree.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; And it can provide many more benefits than JUnit and TDD can offer.<br/>\n </span></blockquote>No.<br/>\nIt can provide *different* and frequently the same benefits JUnit and TDD, <br/>\nthen perhaps in a more convenient way - because of being more declarative.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Look at that example.<br/>\n&gt;<br/>\n&gt; \t/*<br/>\n&gt; \t * precondition:  dividers[n] != 0<br/>\n&gt; \t * postcondition: result[n] == denominator/dividers[n]<br/>\n&gt; \t */<br/>\n&gt; \tint[] divide(int denominator, int[] dividers) {<br/>\n&gt; \t  int[] divisions = new int[dividers.length];<br/>\n&gt;<br/>\n&gt; \t  for (int i = 0; i &lt; dividers.length; i++) {<br/>\n&gt; \t\tint divider = dividers[i];<br/>\n&gt; \t\tdivisions[i] = denominator / divider;<br/>\n&gt; \t  }<br/>\n&gt; \t  return divisions;<br/>\n&gt; \t}<br/>\n </span></blockquote>This is a very convenient example of how DBC works.<br/>\nBut it covers only 1% of what is covered by Unit Tests. Testing preconditions, <br/>\npostconditions and invariants is just a very small part of the whole fields <br/>\nof Unit Testing.<br/>\nAs well as the example doesn&#39;t show everything covered by DBC but just some <br/>\naspects of DBC, of course preconditions and postconditions.<br/>\nThat is a point of intersection between DBC and Unit Testing. But DBC is far <br/>\naway from covering all aspects covered by Unit Testing.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Invariants would not be used here since invariants apply to the class<br/>\n&gt; and not to methods. They can be used for interactions or dependencies<br/>\n&gt; between methods.<br/>\n </span></blockquote>Yes.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; It should be very easy to modify the java compiler to check whether<br/>\n&gt; the implementation obeys the preconditions and postconditions and<br/>\n&gt; invariants. If not, then either the implementation is buggy or the<br/>\n&gt; contract.<br/>\n </span></blockquote>Well, as I already said, don&#39;t discuss that specific subtopic (modifying the <br/>\njava compiler) on this list, instead complain to someone working in SUN&#39;s <br/>\nJava team, go ahead and start a JSR in the JCP or start an open source <br/>\nproject about DBC for Java, I&#39;m sure if you go such a constructive way you <br/>\nwill have really much support.<br/>\n<br/>\nI request that you a) don&#39;t blame JUnit users for using JUnit (my impression <br/>\nis that you do) and b) don&#39;t try to convince JUnit users of using a different <br/>\napproach that virtually doesn&#39;t exist - as far as I know there are no <br/>\nstandard tools for DBC in Java, especially no JSR, just a small set of <br/>\ncommercial tools, so DBC in Java is much too far from being mature and <br/>\napplicable.<br/>\n<br/>\nYou of course may request support for an open source project or a JSR within <br/>\nthe JCP, as already said I&#39;m pretty sure you&#39;ll find much support for that.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; As an alternative you can use Design by Contract to automatically<br/>\n&gt; create test cases (including test data).<br/>\n </span></blockquote>Sometimes DBC can do that, sometimes DBC can&#39;t, especially if the problem is <br/>\ntoo complex.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; However you use Design by Contract: You save a lot of time compared<br/>\n&gt; to JUnit and TDD. And you aren&#39;t driven to use TDD. You are free.<br/>\n </span></blockquote>Wherever DBC can replace Unit Testing, this will probably be true.<br/>\nBut what about all those many cases where DBC can&#39;t?<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Besides this you have a very nice documentation (Contracts), much<br/>\n&gt; more helpful than the JUnit test &quot;documentation&quot;.<br/>\n </span></blockquote>It is true that a documentation derived from declarations like those from DBC <br/>\ncan be much more convenient than treating JUnit test suites as part of the <br/>\ndocumentation, especially if it&#39;s all about the contract of a class, not <br/>\nabout it&#39;s implementation.<br/>\n<br/>\nBut DBC can&#39;t replace Unit Testing in general, only in some specific cases.<br/>\n<br/>\n<br/>\nNow I provide a still quite simple example where I believe DBC will not be <br/>\nable to replace Unit Testing. Documentation and other parts of the code not <br/>\nrelated to testing / DBC are omitted for brevity.<br/>\n<br/>\npublic class ARGVEnumeration implements Enumeration {<br/>\n    private String[] args;<br/>\n    private int index;<br/>\n    private InputStream currentStream;<br/>\n    public ARGVEnumeration(final String[] args) {<br/>\n        this.args = args;<br/>\n    }<br/>\n    public boolean hasMoreElements() {<br/>\n        return args.length == 0 && currentStream == null || args.length &gt; 0 && <br/>\nindex &lt; args.length;<br/>\n    }<br/>\n    public Object nextElement() {<br/>\n        if (!hasMoreElements()) {<br/>\n            throw new NoSuchElementException();<br/>\n        } else {<br/>\n            if (args.length == 0) {<br/>\n                return currentStream = System.in;<br/>\n            } else {<br/>\n                if (currentStream != null) {<br/>\n                    try {<br/>\n                        currentStream.close();<br/>\n                    } catch (IOException e) {<br/>\n                        /* ... */<br/>\n                    }<br/>\n                }<br/>\n                try {<br/>\n                    return currentStream = new FileInputStream(args[index++]);<br/>\n                } catch (IOException e) {<br/>\n                   try { return nextElement(); } catch (NoSuchElementException <br/>\nne) { return null; }<br/>\n                }<br/>\n            }<br/>\n        }<br/>\n    }<br/>\n}<br/>\n<br/>\nAnd now a simple test:<br/>\npublic class ARGVEnumerationTest extends TestCase {<br/>\n    public void testEmpty() {<br/>\n        ARGVEnumeration ae = new ARGVEnumeration(new String[0]);<br/>\n        assertTrue(ae.hasMoreElements());<br/>\n        assertSame(ae.nextElement(), System.in);<br/>\n        assertFalse(ae.hasMoreElements());<br/>\n    }<br/>\n    public void testOneElement() throws IOException {<br/>\n        ARGVEnumeration ae = new ARGVEnumeration(new String[] <br/>\n{&quot;/etc/passwd&quot;});<br/>\n        assertTrue(ae.hasMoreElements());<br/>\n        InputStream in = (InputStream) ae.nextElement();<br/>\n        assertTrue(in instanceof FileInputStream);<br/>\n        in.close();<br/>\n        assertFalse(ae.hasMoreElements());<br/>\n    }<br/>\n    public void testMoreElements() throws IOException {<br/>\n        String[] filelist = {&quot;/etc/passwd&quot;, &quot;/etc/group&quot;, &quot;/etc/hosts&quot;, <br/>\n&quot;/etc/services&quot;};<br/>\n        ARGVEnumeration ae = new ARGVEnumeration(filelist);<br/>\n        for (int i = 0; i &lt; filelist.length; i++) {<br/>\n            assertTrue(ae.hasMoreElements());<br/>\n            InputStream in = (InputStream) ae.nextElement();<br/>\n            assertTrue(in instanceof FileInputStream);<br/>\n            in.close();<br/>\n        }<br/>\n        assertFalse(ae.hasMoreElements());<br/>\n    }<br/>\n}<br/>\n<br/>\n(Note that I am aware of that ARGVEnumeration will run a program into an <br/>\nendless loop if System.setOut() is invoked with null as argument, but I am <br/>\nsure that this will not be the only problem arising from invoking <br/>\nSystem.setOut(null) and I intentionally dropped a solution for that issue as <br/>\nbeing a) consuming much time and b) providing no business value)<br/>\n<br/>\n<br/>\nI&#39;m really keen on reading how these tests could be replaced by DBC.<br/>\n<br/>\n<br/>\nOr try using DBC for the following issues that are also addressed by Unit <br/>\nTesting:<br/>\n* Test network protocol timeout features<br/>\n* Test that class A uses classes through interface B more restricted than the <br/>\ncontract of B allows (in Unit Testing, you use a mock object implementing B <br/>\nto protocol how A accesses B)<br/>\n* Test that the file generated by a class adheres to a specification<br/>\n* Performance tests<br/>\n* Get code coverage (imagine you have a broken code and a contract but the <br/>\ncode is only executed in some critical abnormal situations?) and statistics<br/>\n* Test something that&#39;s not just a simple precondition, postcondition or <br/>\ninvariant? Even not all problems addressed by &quot;normal&quot; Unit Testing can be <br/>\nreduced to simple preconditions, postconditions and invariants expressible by <br/>\nDBC.<br/>\n<br/>\nI persist in my point of view that Exceptions, Assertions, Unit Testing and <br/>\nDesign by Contract are not competing but complementary approaches on the same <br/>\naspect: Increase the stability and robustness of code and decrease the number <br/>\nof bugs.<br/>\nBut &quot;DBC is better than JUnit&quot; is like saying &quot;Bolts are better than glue&quot;. <br/>\nEspecially when there are many things you can do with Unit Testing / JUnit <br/>\nthat you can&#39;t do with DBC.<br/>\n<br/>\nUnit Testing is not a subset of DBC and DBC is not a subset of Unit Testing. <br/>\nThere&#39;s just an intersection where one of these can replace the other, but <br/>\nthat intersection is much smaller than you believe.<br/>\n<br/>\n<br/>\nBye<br/>\n- -- <br/>\nITCQIS GmbH<br/>\nChristian Wolfgang Hujer<br/>\nGeschäftsführender Gesellschafter<br/>\nTelefon: +49  (0)89  27 37 04 37<br/>\nTelefax: +49  (0)89  27 37 04 39<br/>\nE-Mail: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:Christian.Hujer@...\">Christian.Hujer@...</a><br/>\nWWW: <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.itcqis.com/\">http://www.itcqis.com/</a><br/>\n-----BEGIN PGP SIGNATURE-----<br/>\nVersion: GnuPG v1.0.7 (GNU/Linux)<br/>\n<br/>\niD8DBQE+jLmBzu6h7O/MKZkRAhdXAJ0R3H4jr0wjRVhzEMJlVEFBeC3KmQCdGlqX<br/>\nBH2u8o8rcR3bAf8lrIIyJNk=<br/>\n=alTY<br/>\n-----END PGP SIGNATURE-----</div>", 
    "prevInTime": 7500, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1049409921", 
    "canDelete": false, 
    "nextInTopic": 7529, 
    "prevInTopic": 7499, 
    "headers": {
        "inReplyToHeader": "PGI2Z24yZStxNjhsQGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PDIwMDMwNDA0MDA0NS4yMjE4NS5DaHJpc3RpYW4uSHVqZXJAaXRjcWlzLmNvbT4=", 
        "referencesHeader": "PGI2Z24yZStxNjhsQGVHcm91cHMuY29tPg=="
    }
}