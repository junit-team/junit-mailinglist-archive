{
    "numMessagesInTopic": 17, 
    "nextInTime": 7559, 
    "senderId": "jjqdkPFm10fbRriA1lkxj0GcuVEI4C6QKlkeGzz1AXMfaZujFcBTMbANrLn-y7l2T6CG9mn4Ni7FXewaT_2lG1V5wW169g", 
    "systemMessage": false, 
    "subject": "Re: [junit] Junit and RMI, please help ...", 
    "from": "Levi Cook &lt;levicook@...&gt;", 
    "authorName": "Levi Cook", 
    "msgSnippet": "... Or not :) ... Is yahoo any happier w/ .java attachments? Here s console output that occurs while ServerImplFunctionalTest.testMemoryOfDisconnectedClients ", 
    "msgId": 7558, 
    "profile": "lcook53703", 
    "topicId": 7374, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 72977190, 
    "messageBody": "<div id=\"ygrps-yiv-772423379\">On Sunday, April 6, 2003, at 08:35  PM, Levi Cook wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; I&#39;ve attached my spike in case anyone is interested.<br/>\n<br/>\n </span></blockquote>Or not :)<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; [Non-text portions of this message have been removed]<br/>\n<br/>\n </span></blockquote>Is yahoo any happier w/ .java attachments?<br/>\n<br/>\nHere&#39;s console output that occurs while<br/>\nServerImplFunctionalTest.testMemoryOfDisconnectedClients<br/>\nis running.<br/>\n<br/>\n  1) ServerImpl STDOUT&gt; server bound @ rmi://localhost/Server<br/>\n  2) ServerImpl STDOUT&gt; serverThread started<br/>\n<br/>\n  3) GoodClientScenario STDOUT&gt; Starting<br/>\n  4) ServerImpl STDOUT&gt; +++ adding: ClientImpl_Stub[...]<br/>\n  5) ServerImpl STDOUT&gt; --- removing: ClientImpl_Stub[...]<br/>\n  6) GoodClientScenario STDOUT&gt; Exiting<br/>\n<br/>\n  7) BadClientScenario STDOUT&gt; Starting<br/>\n  8) ServerImpl STDOUT&gt; +++ adding: ClientImpl_Stub[...]<br/>\n  9) BadClientScenario STDOUT&gt; Exiting<br/>\n10) ServerImpl STDOUT&gt; --- removing: ClientImpl_Stub[...]<br/>\n<br/>\n<br/>\nLines 1-2  Are just confirming that the server is started and<br/>\n            available to rmi clients.<br/>\n<br/>\nLines 3-6  Show what happens during the &quot;good&quot; client scenario.<br/>\n            Basically, the &quot;good&quot; client connects to the server,<br/>\n            hangs out a second or two, then calls disconnect.<br/>\n<br/>\nLines 7-10 Demonstrate the &quot;bad&quot; client scenario. Basically,<br/>\n            a bad client fails or forgets to call disconnect().<br/>\n<br/>\n<br/>\nThe interesting part of this whole exercise (in my mind anyway)<br/>\nwas figuring out what a &quot;reasonable&quot; test-fixture for working w/<br/>\nrmi might look like. In other words, getting the production-code<br/>\nto pass my test was easy, creating a test-fixture...not so much.<br/>\n<br/>\nThe interesting bit for me was realizing that functional tests<br/>\n(ala launching/forking jvms for each client & server) was the only<br/>\nrealistic way to perform developer tests in this domain.<br/>\n<br/>\nDoes anyone else an alternate technique for testing rmi apps?<br/>\n<br/>\n-- Levi<br/>\n<br/>\n<br/>\n<br/>\n  ----------<br/>\n<br/>\npublic final class BadClientScenario extends ClientScenario <br/>\n{<br/>\n\tstatic final String CLIENT_NAME = &quot;BadClient (does _not_ call disconnect)&quot;;<br/>\n\tstatic final int RETURN_CODE = 1;<br/>\n\t<br/>\n\tpublic static void main(String[] args) throws Exception<br/>\n\t{<br/>\n        System.out.println(&quot;Starting&quot;);<br/>\n        <br/>\n\t\tServer s = ClientScenario.getRemoteServer();<br/>\n\t\t<br/>\n\t\tClient badGuy = new ClientImpl(CLIENT_NAME);<br/>\n\t\t<br/>\n\t\ts.connect(badGuy);<br/>\n\t\t<br/>\n\t\tThread.sleep(ClientScenario.SLEEP_TIME);<br/>\n\t\t<br/>\n\t\t// s.disconnect(badGuy);<br/>\n\t\t// ^^^^^^^^^^^^^^^^^^^^<br/>\n\t\t// Doesn&#39;t happen on purpose...<br/>\n        <br/>\n        System.out.println(&quot;Exiting&quot;);<br/>\n        System.exit(RETURN_CODE);<br/>\n\t}<br/>\n}<br/>\n  ----------<br/>\n<br/>\nimport java.rmi.Remote;<br/>\nimport java.rmi.RemoteException;<br/>\n<br/>\npublic interface Client extends Remote<br/>\n{<br/>\n    void ping() throws RemoteException;<br/>\n    String getName() throws RemoteException;<br/>\n}<br/>\n  ----------<br/>\n<br/>\nimport java.io.Serializable;<br/>\nimport java.rmi.RemoteException;<br/>\nimport java.rmi.server.UnicastRemoteObject;<br/>\n<br/>\npublic class ClientImpl implements Serializable, Client<br/>\n{<br/>\n    private String name;<br/>\n<br/>\n    ClientImpl(String itsName) throws RemoteException<br/>\n    {<br/>\n        name = itsName;<br/>\n        UnicastRemoteObject.exportObject(this);<br/>\n    }<br/>\n    <br/>\n    public void ping()<br/>\n    {<br/>\n    }<br/>\n<br/>\n    public String getName()<br/>\n    {<br/>\n        return name;<br/>\n    }<br/>\n<br/>\n    public String toString()<br/>\n    {<br/>\n        return name + &quot; : &quot; + super.toString();<br/>\n    }<br/>\n<br/>\n    public boolean equals(Object obj)<br/>\n    {<br/>\n        try<br/>\n        {<br/>\n            return name.equals(((Client) obj).getName());<br/>\n        }<br/>\n        catch(RemoteException e)<br/>\n        {<br/>\n            return false;<br/>\n        }<br/>\n    }<br/>\n<br/>\n    public int hashCode()<br/>\n    {<br/>\n        return name.hashCode();<br/>\n    }<br/>\n}<br/>\n<br/>\n  ----------<br/>\n<br/>\nimport java.rmi.Naming;<br/>\n<br/>\nabstract class ClientScenario<br/>\n{<br/>\n\tstatic final long SLEEP_TIME = ServerImpl.SLEEP_TIME * 3;<br/>\n\t<br/>\n\tprivate static Server myServer;<br/>\n\t<br/>\n\tprotected static Server getRemoteServer() throws Exception<br/>\n\t{<br/>\n\t\tif(ClientScenario.myServer == null)<br/>\n\t\t{<br/>\n\t\t\tClientScenario.myServer = (Server) Naming.lookup(ServerImpl.REGISTRY_NAME);<br/>\n\t\t}<br/>\n\t\treturn ClientScenario.myServer;<br/>\n\t}<br/>\n}<br/>\n  ----------<br/>\n<br/>\npublic final class GoodClientScenario extends ClientScenario <br/>\n{<br/>\n\tstatic final int RETURN_CODE = 0;<br/>\n\t<br/>\n\tpublic static void main(String[] args) throws Exception<br/>\n\t{<br/>\n        System.out.println(&quot;Starting&quot;);<br/>\n        <br/>\n\t\tServer s = ClientScenario.getRemoteServer();<br/>\n\t\t<br/>\n\t\tClient goodGuy = new ClientImpl(&quot;GoodClient (calls disconnect)&quot;);<br/>\n\t\t<br/>\n\t\ts.connect(goodGuy);<br/>\n\t\t<br/>\n\t\tThread.sleep(ClientScenario.SLEEP_TIME);<br/>\n\t\t<br/>\n\t\ts.disconnect(goodGuy);<br/>\n        <br/>\n        System.out.println(&quot;Exiting&quot;);<br/>\n        <br/>\n        System.exit(RETURN_CODE);<br/>\n\t}<br/>\n}<br/>\n  ----------<br/>\n<br/>\nimport java.rmi.Remote;<br/>\nimport java.rmi.RemoteException;<br/>\nimport java.util.List;<br/>\n<br/>\npublic interface Server extends Remote<br/>\n{<br/>\n\tpublic void connect(Client theClient) throws RemoteException;<br/>\n<br/>\n\tpublic void disconnect(Client theClient) throws RemoteException;<br/>\n\t<br/>\n\tpublic List activeClientList() throws RemoteException;<br/>\n}<br/>\n<br/>\n  ----------<br/>\n<br/>\nimport java.io.PrintStream;<br/>\nimport java.rmi.Naming;<br/>\nimport java.rmi.RemoteException;<br/>\nimport java.rmi.server.UnicastRemoteObject;<br/>\nimport java.util.ArrayList;<br/>\nimport java.util.List;<br/>\n<br/>\npublic class ServerImpl extends UnicastRemoteObject implements Server, Runnable<br/>\n{<br/>\n\tprivate List clientList;<br/>\n\tprivate PrintStream out;<br/>\n<br/>\n\tServerImpl(PrintStream outputStream) throws RemoteException<br/>\n\t{<br/>\n\t\tsuper();<br/>\n\t\tout = outputStream;<br/>\n\t\tclientList = new ArrayList();<br/>\n\t}<br/>\n<br/>\n\tpublic void connect(Client theClient)<br/>\n\t{<br/>\n\t\tout.println(&quot;+++ adding: &quot; + theClient);<br/>\n\t\tclientList.add(theClient);<br/>\n\t}<br/>\n<br/>\n\tpublic void disconnect(Client theClient)<br/>\n\t{<br/>\n\t\tout.println(&quot;--- removing: &quot; + theClient);<br/>\n\t\tclientList.remove(theClient);<br/>\n\t}<br/>\n<br/>\n\tpublic List activeClientList()<br/>\n\t{<br/>\n\t\treturn clientList;<br/>\n\t}<br/>\n<br/>\n\tpublic void run()<br/>\n\t{<br/>\n\t\tout.println(&quot;serverThread started&quot;);<br/>\n<br/>\n\t\twhile (true)<br/>\n\t\t{<br/>\n\t\t\tfor (int i = 0; i &lt; clientList.size(); i++)<br/>\n\t\t\t{<br/>\n\t\t\t\tClient curClient = (Client) clientList.get(i);<br/>\n<br/>\n\t\t\t\ttry<br/>\n\t\t\t\t{<br/>\n\t\t\t\t\tcurClient.ping();<br/>\n\t\t\t\t}<br/>\n\t\t\t\tcatch (RemoteException e)<br/>\n\t\t\t\t{<br/>\n\t\t\t\t\tdisconnect(curClient);<br/>\n\t\t\t\t}<br/>\n\t\t\t}<br/>\n\t\t\ttry<br/>\n\t\t\t{<br/>\n\t\t\t\tThread.sleep(SLEEP_TIME);<br/>\n\t\t\t}<br/>\n\t\t\tcatch (Exception e)<br/>\n\t\t\t{<br/>\n\t\t\t\te.printStackTrace(out);<br/>\n\t\t\t}<br/>\n\t\t}<br/>\n\t}<br/>\n<br/>\n\tstatic final String REGISTRY_NAME = &quot;rmi://localhost/Server&quot;;<br/>\n\tstatic final long SLEEP_TIME = 1000L;<br/>\n<br/>\n\tpublic static void main(String[] args) throws Exception<br/>\n\t{<br/>\n\t\tServerImpl server = new ServerImpl(System.out);<br/>\n\t\tNaming.rebind(REGISTRY_NAME, server);<br/>\n\t\tSystem.out.println(&quot;server bound @ &quot; + REGISTRY_NAME);<br/>\n<br/>\n\t\tThread serverThread = new Thread(server);<br/>\n\t\tserverThread.start();<br/>\n\t}<br/>\n}<br/>\n<br/>\n  ----------<br/>\n<br/>\nimport junit.framework.TestCase;<br/>\n<br/>\npublic abstract class ServerImplBaseTest extends TestCase<br/>\n{<br/>\n    protected void setUpDerivedFixture() throws Exception<br/>\n    {<br/>\n    };<br/>\n<br/>\n    protected final void setUp() throws Exception<br/>\n    {<br/>\n        TestUtils.rmicRemoteObjects();<br/>\n        //        ^^^^^^^^^^^^^^^^^^^^<br/>\n        // Unfortunate, but necessary since ServerImpl derives<br/>\n        // from UnicastRemoteObject.<br/>\n        <br/>\n        setUpDerivedFixture();<br/>\n    }<br/>\n<br/>\n    protected abstract Server getTestServer() throws Exception;<br/>\n<br/>\n    public final void testClientManagement() throws Exception<br/>\n    {<br/>\n        Server serverUT = getTestServer();<br/>\n<br/>\n        Client a = new ClientImpl(&quot;A&quot;);<br/>\n        Client b = new ClientImpl(&quot;B&quot;);<br/>\n<br/>\n        serverUT.connect(a);<br/>\n<br/>\n        assertTrue(serverUT.activeClientList().contains(a));<br/>\n        assertFalse(serverUT.activeClientList().contains(b));<br/>\n<br/>\n        serverUT.connect(b);<br/>\n<br/>\n        assertTrue(serverUT.activeClientList().contains(a));<br/>\n        assertTrue(serverUT.activeClientList().contains(b));<br/>\n<br/>\n        serverUT.disconnect(a);<br/>\n<br/>\n        assertFalse(serverUT.activeClientList().contains(a));<br/>\n        assertTrue(serverUT.activeClientList().contains(b));<br/>\n<br/>\n        serverUT.disconnect(b);<br/>\n<br/>\n        assertFalse(serverUT.activeClientList().contains(a));<br/>\n        assertFalse(serverUT.activeClientList().contains(b));<br/>\n    }<br/>\n}<br/>\n  ----------<br/>\n<br/>\nimport java.rmi.Naming;<br/>\n<br/>\nimport junit.swingui.TestRunner;<br/>\n<br/>\npublic final class ServerImplFunctionalTest extends ServerImplBaseTest<br/>\n{<br/>\n    protected final Server getTestServer() throws Exception<br/>\n    {<br/>\n        return (Server) Naming.lookup(ServerImpl.REGISTRY_NAME);<br/>\n    }<br/>\n<br/>\n    protected final void setUpDerivedFixture() throws Exception<br/>\n    {<br/>\n        TestUtils.startRmiRegistry();<br/>\n        TestUtils.startServerImpl();<br/>\n    }<br/>\n<br/>\n    public void testMemoryOfDisconnectedClients() throws Exception<br/>\n    {<br/>\n        TestUtils.runGoodClientToCompletion();<br/>\n        TestUtils.runBadClientToCompletion();<br/>\n<br/>\n        // Give Server a couple cycles to cleanup.<br/>\n        Thread.sleep(ServerImpl.SLEEP_TIME * 2);<br/>\n<br/>\n        Server serverUT = getTestServer();<br/>\n<br/>\n        assertEquals(0, serverUT.activeClientList().size());<br/>\n    }<br/>\n<br/>\n    protected final void tearDown() throws Exception<br/>\n    {<br/>\n        TestUtils.stopServerImpl();<br/>\n        TestUtils.stopRmiRegistry();<br/>\n    }<br/>\n<br/>\n    public static void main(String[] args)<br/>\n    {<br/>\n        TestRunner.run(ServerImplFunctionalTest.class);<br/>\n    }<br/>\n}<br/>\n<br/>\n  ----------<br/>\n<br/>\nimport junit.swingui.TestRunner;<br/>\n<br/>\npublic final class ServerImplUnitTest extends ServerImplBaseTest<br/>\n{<br/>\n\tprotected final Server getTestServer() throws Exception<br/>\n\t{<br/>\n\t\treturn new ServerImpl(System.out);<br/>\n\t}<br/>\n\t<br/>\n\tpublic static void main(String[] args)<br/>\n\t{<br/>\n\t\tTestRunner.run(ServerImplUnitTest.class);<br/>\n\t}<br/>\n}<br/>\n<br/>\n  ----------<br/>\n<br/>\nimport java.io.BufferedReader;<br/>\nimport java.io.IOException;<br/>\nimport java.io.InputStream;<br/>\nimport java.io.InputStreamReader;<br/>\n<br/>\nimport junit.framework.Assert;<br/>\n<br/>\nfinal class TestUtils<br/>\n{<br/>\n\tprivate TestUtils()<br/>\n\t{<br/>\n\t\tsuper();<br/>\n\t}<br/>\n<br/>\n\tstatic Process rmiregistryProcess = null;<br/>\n\tstatic Process serverProcess = null;<br/>\n<br/>\n\tstatic Process goodClientProcess = null;<br/>\n\tstatic Process badClientProcess = null;<br/>\n<br/>\n\tstatic void runBadClientToCompletion() throws Exception<br/>\n\t{<br/>\n\t\tString cmd = &quot;java &quot; + BadClientScenario.class.getName();<br/>\n\t\tString jobLabel = BadClientScenario.class.getName();<br/>\n<br/>\n\t\tbadClientProcess = startProcess(badClientProcess, cmd, jobLabel);<br/>\n<br/>\n\t\tAssert.assertEquals(<br/>\n\t\t\t&quot;abnormal termination&quot;,<br/>\n\t\t\tBadClientScenario.RETURN_CODE,<br/>\n\t\t\tbadClientProcess.waitFor());<br/>\n<br/>\n\t\tbadClientProcess = null;<br/>\n\t}<br/>\n<br/>\n\tstatic void runGoodClientToCompletion() throws Exception<br/>\n\t{<br/>\n\t\tString cmd = &quot;java &quot; + GoodClientScenario.class.getName();<br/>\n\t\tString jobLabel = GoodClientScenario.class.getName();<br/>\n<br/>\n\t\tgoodClientProcess = startProcess(goodClientProcess, cmd, jobLabel);<br/>\n<br/>\n\t\tAssert.assertEquals(<br/>\n\t\t\t&quot;abnormal termination&quot;,<br/>\n\t\t\tGoodClientScenario.RETURN_CODE,<br/>\n\t\t\tgoodClientProcess.waitFor());<br/>\n<br/>\n\t\tgoodClientProcess = null;<br/>\n\t}<br/>\n<br/>\n\tstatic void startServerImpl() throws Exception<br/>\n\t{<br/>\n\t\tString cmd = &quot;java &quot; + ServerImpl.class.getName();<br/>\n\t\tString jobLabel = ServerImpl.class.getName();<br/>\n\t\tserverProcess = startProcess(serverProcess, cmd, jobLabel);<br/>\n\t\tThread.sleep(4000);<br/>\n\t}<br/>\n<br/>\n\tstatic void stopServerImpl()<br/>\n\t{<br/>\n\t\tserverProcess = stop(serverProcess);<br/>\n\t}<br/>\n<br/>\n\tstatic void startRmiRegistry() throws Exception<br/>\n\t{<br/>\n\t\tString cmd = &quot;rmiregistry&quot;;<br/>\n\t\tString jobLabel = cmd;<br/>\n\t\trmiregistryProcess = startProcess(rmiregistryProcess, cmd, jobLabel);<br/>\n\t}<br/>\n<br/>\n\tstatic void stopRmiRegistry()<br/>\n\t{<br/>\n\t\trmiregistryProcess = stop(rmiregistryProcess);<br/>\n\t}<br/>\n<br/>\n\tstatic void rmicRemoteObjects() throws Exception<br/>\n\t{<br/>\n\t\tProcess rmicProcess = null;<br/>\n\t\tString cmd =<br/>\n\t\t\t&quot;rmic -classpath . -d . &quot;<br/>\n\t\t\t\t+ ServerImpl.class.getName()<br/>\n\t\t\t\t+ &quot; &quot;<br/>\n\t\t\t\t+ ClientImpl.class.getName();<br/>\n\t\tString jobName = &quot;rmic&quot;;<br/>\n<br/>\n\t\trmicProcess = startProcess(rmicProcess, cmd, jobName);<br/>\n\t\t<br/>\n\t\trmicProcess.waitFor();<br/>\n\t}<br/>\n<br/>\n\tprivate static Process startProcess(<br/>\n\t\tProcess staticRef,<br/>\n\t\tString cmd,<br/>\n\t\tString jobLabel)<br/>\n\t\tthrows Exception<br/>\n\t{<br/>\n\t\tif (staticRef != null)<br/>\n\t\t{<br/>\n\t\t\tstaticRef.destroy();<br/>\n\t\t}<br/>\n<br/>\n\t\tstaticRef = Runtime.getRuntime().exec(cmd);<br/>\n<br/>\n\t\tnew StreamGobbler(staticRef.getErrorStream(), jobLabel + &quot; STDERR&quot;);<br/>\n\t\tnew StreamGobbler(staticRef.getInputStream(), jobLabel + &quot; STDOUT&quot;);<br/>\n<br/>\n\t\treturn staticRef;<br/>\n\t}<br/>\n<br/>\n\tprivate static Process stop(Process process)<br/>\n\t{<br/>\n\t\ttry<br/>\n\t\t{<br/>\n\t\t\tif (process != null)<br/>\n\t\t\t\tprocess.destroy();<br/>\n\t\t}<br/>\n\t\tcatch (Exception e)<br/>\n\t\t{<br/>\n\t\t\te.printStackTrace();<br/>\n\t\t}<br/>\n\t\tfinally<br/>\n\t\t{<br/>\n\t\t\tprocess = null;<br/>\n\t\t\treturn process; // yes its always null<br/>\n\t\t}<br/>\n\t}<br/>\n<br/>\n\tprivate static class StreamGobbler extends Thread<br/>\n\t{<br/>\n\t\tprivate InputStream is;<br/>\n\t\tprivate String type;<br/>\n<br/>\n\t\tStreamGobbler(InputStream is, String type)<br/>\n\t\t{<br/>\n\t\t\tthis.is = is;<br/>\n\t\t\tthis.type = type;<br/>\n<br/>\n\t\t\tthis.start();<br/>\n\t\t}<br/>\n<br/>\n\t\tpublic void run()<br/>\n\t\t{<br/>\n\t\t\ttry<br/>\n\t\t\t{<br/>\n\t\t\t\tInputStreamReader isr = new InputStreamReader(is);<br/>\n\t\t\t\tBufferedReader br = new BufferedReader(isr);<br/>\n\t\t\t\tString line = null;<br/>\n\t\t\t\twhile ((line = br.readLine()) != null)<br/>\n\t\t\t\t{<br/>\n\t\t\t\t\tSystem.out.println(type + &quot;&gt; &quot; + line);<br/>\n\t\t\t\t}<br/>\n\t\t\t}<br/>\n\t\t\tcatch (IOException ioe)<br/>\n\t\t\t{<br/>\n\t\t\t\tioe.printStackTrace();<br/>\n\t\t\t}<br/>\n\t\t}<br/>\n\t}<br/>\n}<br/>\n<br/>\n[Non-text portions of this message have been removed]</div>", 
    "prevInTime": 7557, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1049698713", 
    "canDelete": false, 
    "nextInTopic": 7590, 
    "prevInTopic": 7557, 
    "headers": {
        "inReplyToHeader": "PDMxMzIzRDgyLTY4OTktMTFENy1CRTE0LTAwMDM5M0FEMjczMkBwYXBham8uY29tPg==", 
        "messageIdInHeader": "PDU5NDAyNTY0LTY4QzYtMTFENy05NkM4LTAwMDM5M0FEMjczMkBwYXBham8uY29tPg=="
    }
}