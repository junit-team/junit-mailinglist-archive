{
    "numMessagesInTopic": 8, 
    "nextInTime": 2216, 
    "senderId": "iv4Tb7iLXlDBrCB5LpgpjIprAA0QvM5t3RCEopaVJQ4a18XP2a_Cuw8vk0ZbO0pMMvg-Rfvuh71_UQ", 
    "systemMessage": false, 
    "subject": "Re: SwingUI and AWTUI don&#39;t work with PROJECTX?", 
    "from": "tooleojim@...", 
    "authorName": "tooleojim@yahoo.com", 
    "msgSnippet": "Hello, I ve been following the various threads to do with the JUnit TestCaseClassLoader on the JUnit mailing list because I ve been having a similar sort of", 
    "msgId": 2215, 
    "topicId": 2000, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 0, 
    "messageBody": "<div id=\"ygrps-yiv-625716740\">Hello,<br/>\n<br/>\nI&#39;ve been following the various threads to do with the JUnit<br/>\nTestCaseClassLoader on the JUnit mailing list because I&#39;ve<br/>\nbeen having a similar sort of problem.<br/>\n<br/>\nI&#39;m using Ant 1.3 to run JUnit 3.7 tests for an application<br/>\nthat uses Xerces 1.4.1 and Xalan 2.1. However, my tests fail on trying<br/>\nto parse a DOM document because of a problem with a class loader (I&#39;m not sure which loader).<br/>\n<br/>\njava.lang.LinkageError<br/>\n&quot;loader constraints violated when linking org/xml/sax/InputSource class&quot;<br/>\n<br/>\nI&#39;ve had the same problem when running the same tests on the same application using the Swing or AWT JUnit test runner (and NOT using Ant). I managed to fix  this problem thanks to a suggestion on the JUnit mailing list from Scott Stirling. He suggests a change to the exclude.properties file in the JUnit jar. This file tells the JUnit TestCaseClassLoader which classes it should not try to load. Instead these classes should be left to the JVM class loader. His suggestion was to supplement the list of excluded classes to exclude all<br/>\norg.w3c.dom.* and or.xml.sax.* classes.<br/>\n<br/>\nHowever, this workaround does not fix the problem of running JUnit tests from Ant where the tests (or the application being tested) involve org.xml.sax.* classes. <br/>\n<br/>\nHas anyone else experienced this problem? Does anyone know of any other fix that could solve this problem? Perhaps, it&#39;s a flaw in the AntClassLoader but as I don&#39;t know much about class loading matters I need some assistance in pin pointing the problem. Does anyone have any  suggestions?<br/>\n<br/>\nIncidentally, I tried removing the JAXP jars (jaxp.jar and parser.jar) that come with Ant and replacing them with the Xalan and Xerces jars that my application uses. Ant continues to work fine but the tests still won&#39;t run. The reason I made this change was that I was under the impression (from reading the Java Spec <a rel=\"nofollow\" target=\"_blank\" href=\"http://java.sun.com/docs/books/vmspec/2nd-edition/html/ConstantPool.doc.html)\">http://java.sun.com/docs/books/vmspec/2nd-edition/html/ConstantPool.doc.html)</a> that there would be no problem having two class loaders loading the same class.<br/>\n<br/>\nI also tried adding org.* to the excluded.properties file (so that junit wouldn&#39;t try loading Ant/Xerces/Xalan/etc classes!) but although Ant continues to work, the JUnit tests still won&#39;t.<br/>\n<br/>\nThanks,<br/>\nJim.<br/>\n<br/>\nP.S. This is what Scott Stirling had to say about the matter:<br/>\n<br/>\nThe JUnit TestCaseClassLoader (the reloadable one) has a fundamental problem that results in frequent LinkageErrors under the following conditions:<br/>\n<br/>\n1.  You use the JUnit Swing UI.<br/>\n2.  You use JAXP in your test cases or any classes referenced in your test cases, or even any &quot;instanceof&quot; expressions that reference JAXP classes. (By JAXP I mean the whole set of javax.* classes plus the org.w3c.dom.* and org.xml.sax.* classes)<br/>\n<br/>\nI can go into this in depth, but the bottom line problems are that JUnit loads classes from the same place as the JVM&#39;s system loader; the classpath. This necessitates the use of an exclusion list to filter out certain class names that either must be loaded by the system loader, or you would like to have loaded by the system loader.  The JUnit loader does not always delegate to the system loader when it should, particularly in the case of JAXP, which is a weird mix of classes whose names begin with the filtered &quot;javax.*&quot; and<br/>\nthe unfiltered &quot;org.w3c.*&quot; and org.xml.*&quot;.<br/>\n<br/>\nJAXP is a special case because it is based on a set of javax.* classes.  All javax.* classes are excluded from the JUnit loader by default (in the default excluded.properties file) in junit.jar.  But JAXP, as shipped from Sun, comes with a bunch of other classes in org.w3c.* and org.xml.*.  The interesting thing is a direct dependency between javax.* classes and some other classes not in the usual exclusion list of com.sun.*, javax.*, etc.<br/>\n<br/>\nSo what can happen, and frequently does when using the JUnit Swing UI with test cases or other classes, such as Log4J, that use JAXP, is that the JUnit class loader (properly) delegates javax.xml.* classes it &quot;sees&quot; to the system loader.  But then the system loader loads up a bunch of org.w3c.dom and/or org.xml.sax classes as the result of initializing and loading that JAXP class.  Later, if the JUnit loader comes across some org.w3c/xml class that it&#39;s never seen before, it tries to load it because the classname doesn&#39;t match one of the patterns in the exclude list.<br/>\n<br/>\nBut it&#39;s already been loaded through the &quot;backdoor&quot; as the result of some other class loaded by the system loader (remember, the JVM keeps classes in their own namespace by identifying them by their fully qualified name plus the instance of their _defining_ (not initiating) loader, AND, the JVM will attempt to assign all unloaded classes referenced by a defined class to that defining class&#39;s loader).  The JVM&#39;s classresolver routine keeps track of all these class loading events and &quot;sees&quot; that the JUnit loader is attempting to define a class that has already been defined by the system loader.  That&#39;s wrong because according to the rules of loader constraints, JUnit should delegate this load to the system loader.<br/>\n<br/>\nYou can hack around this (I did) by catching the LinkageError in<br/>\nTestCaseClassLoader&#39;s loadClass() method and then making a recovery call to findSystemClass() -- thereby delegating to the system loader after the fact (which is OK).  This hack only works some of the time, though, because now you can have the reverse problem where the JUnit loader loads a host of org.*.* classes, and then the system loader violates the loader constraints at some point when it tries to do exactly what I described above with JAXP because it doesn&#39;t ever delegate to its child (the JUnit loader). Inevitably, if your test cases use many JAXP and related XML classes, one or the other ClassLoader will end violating the constraints whatever you do.<br/>\n<br/>\nSo the solution in the existing JUnit is to definitely add org.w3c.dom.* and org.xml.sax.* to your excluded.properties if you&#39;re using any JAXP stuff.<br/>\n<br/>\nWhat can we learn from this?  Well, one thing is that it&#39;s a good idea to have your custom class loaders load classes from repositories other than the system classpath.  Note that the JVM&#39;s built-in classloaders work that way (one for the jre/ext dirs, another for the java.class.path).<br/>\n<br/>\nAnyway, the excluded.properties fix is just a matter of time before it<br/>\nbecomes standard in JUnit, since JAXP will be a standard part of the 1.4 JDK.  It&#39;ll be just like having org.omg.* excluded.</div>", 
    "prevInTime": 2214, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "996591107", 
    "canDelete": false, 
    "nextInTopic": 2664, 
    "prevInTopic": 2021, 
    "headers": {
        "inReplyToHeader": "PEM3QUJBMzE1MjA1Q0Q0MTE4Q0U2MDA1MDhCOTUyRDk2NTVGQkFFQHNhbHNhLmFsbGFpcmUuY29tPg==", 
        "messageIdInHeader": "PDlrNmdtMys5MmJmQGVHcm91cHMuY29tPg=="
    }
}