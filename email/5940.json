{
    "numMessagesInTopic": 17, 
    "nextInTime": 5941, 
    "senderId": "bv6W9GmpgQ9H3gl2PO11kCVYFjtMEKbgSrfPNvzodzYNcrnxRB4PFfD8t99HcNqJNobCcIWLkZ9F9QsPFztEFfOxVtBHQExeSJwCzskNd78", 
    "systemMessage": false, 
    "subject": "unsubscribe", 
    "from": "Alagusundaram Paulraj &lt;apaulra@...&gt;", 
    "authorName": "Alagusundaram Paulraj", 
    "msgSnippet": "", 
    "msgId": 5940, 
    "topicId": 2153, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 80162584, 
    "messageBody": "<div id=\"ygrps-yiv-1357678981\">Steven Taschuk wrote:<br/>\n<br/>\n<blockquote><span title=\"qreply\"> &gt; Quoth Berin Loritsch:<br/>\n&gt;   [...]<br/>\n&gt; &gt; The whole Name thing is irrelevant at this point.  If a Test<br/>\n&gt; &gt; implements the TestFixture interface, then it will use reflection<br/>\n&gt; &gt; to pull all the interfaces.  So the interface should be something<br/>\n&gt; &gt; like this:<br/>\n&gt; &gt;<br/>\n&gt; &gt; interface TestFixture<br/>\n&gt; &gt; {}<br/>\n&gt; &gt;<br/>\n&gt; &gt; When the Test Collector/Test Runner runs across any Class<br/>\n&gt; &gt; implementing TestFixture, it is converted into a group of<br/>\n&gt; &gt; Test objects.  [...]<br/>\n&gt;<br/>\n&gt; Um.  Perhaps I&#39;m missing the point, but I&#39;d prefer to have the<br/>\n&gt; Test-creation logic outside of the TestRunner.  For example:<br/>\n&gt;<br/>\n&gt;         interface TestFactory {<br/>\n&gt;                 Test makeTest();<br/>\n&gt;         }<br/>\n&gt;<br/>\n&gt;         class OneMethodTest implements Test {<br/>\n&gt;                 OneMethodTest( Class c, Method m ) {<br/>\n&gt;                         // ...<br/>\n&gt;                 }<br/>\n&gt;                 void run( TestResult result ) {<br/>\n&gt;                         // instantiate c<br/>\n&gt;                         // execute instance.setUp()<br/>\n&gt;                         // execute instance.m<br/>\n&gt;                         // execute instance.tearDown()<br/>\n&gt;                 }<br/>\n&gt;                 // ...<br/>\n&gt;         }<br/>\n&gt;<br/>\n&gt;         class ReflectiveTestFactory implements TestFactory {<br/>\n&gt;                 ReflectiveTestFactory() {<br/>\n&gt;                         // factory based on self<br/>\n&gt;                 }<br/>\n&gt;                 ReflectiveTestFactory( Class c ) {<br/>\n&gt;                         // factory based on class c<br/>\n&gt;                 }<br/>\n&gt;                 Test makeTest() {<br/>\n&gt;                         // scan c (or self) for test* methods<br/>\n&gt;                         // make a OneMethodTest for each<br/>\n&gt;                         // return a TestSuite containing those<br/>\n&gt;                 }<br/>\n&gt;         }<br/>\n&gt;<br/>\n&gt; For backwards compatibility, a TestRunner encountering a TestCase<br/>\n&gt; can make a ReflectiveFactory for it.  In general it expects to<br/>\n&gt; encounter TestFactory implementations and let them make the Tests.<br/>\n&gt;<br/>\n&gt; For new test implementations, it is sufficient to put test*<br/>\n&gt; methods in a subclass of ReflectiveFactory.  This is just like<br/>\n&gt; subclassing TestCase now, but there&#39;s no need for the String<br/>\n&gt; constructor (which might, as Meyers implied elsewhere in the<br/>\n&gt; thread, encourage novice users to put setup in setUp() instead of<br/>\n&gt; in the constructor).<br/>\n&gt;<br/>\n&gt; If it is inconvenient to subclass ReflectiveFactory (as when the<br/>\n&gt; tests rely on partaking of some other inheritance hierarchy), it<br/>\n&gt; is convenient enough to write<br/>\n&gt;<br/>\n&gt;         class MyTests implements TestFactory {<br/>\n&gt;                 Test makeTest() {<br/>\n&gt;                         return new ReflectiveTestFactory(<br/>\n&gt;                                 this.getClass() ).makeTest();<br/>\n&gt;                 }<br/>\n&gt;                 // ...<br/>\n&gt;         }<br/>\n&gt;<br/>\n&gt; As with the static suite() method, the advantage of this approach<br/>\n&gt; is that tests can be generated however is desired.  Unlike<br/>\n&gt; suite(), makeTest() above is an instance method, which as<br/>\n&gt; Silverstein points out elsewhere in the thread makes it easier to<br/>\n&gt; make tests from other frameworks work as JUnit tests.<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; To unsubscribe from this group, send an email to:<br/>\n&gt; <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit-unsubscribe@yahoogroups.com\">junit-unsubscribe@yahoogroups.com</a><br/>\n&gt;<br/>\n&gt;<br/>\n&gt; Your use of Yahoo! Groups is subject to <a rel=\"nofollow\" target=\"_blank\" href=\"http://docs.yahoo.com/info/terms/\">http://docs.yahoo.com/info/terms/</a> </span></blockquote></div>", 
    "prevInTime": 5939, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1033713684", 
    "canDelete": false, 
    "nextInTopic": 5941, 
    "prevInTopic": 2734, 
    "headers": {
        "messageIdInHeader": "PDNEOUQzODE0LkQ2RDA5REFBQHF3ZXN0LmNvbT4=", 
        "referencesHeader": "PGFuaTNsditxMmNxQGVHcm91cHMuY29tPiA8M0Q5Qzk5NEYuMzA2MDhAYXBhY2hlLm9yZz4gPDIwMDIxMDAzMjI1MDI2LkE2MTg3QHRpYmlhLmFtb3RscGFhLmJvZ3VzPg=="
    }
}