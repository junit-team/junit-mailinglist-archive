{
    "numMessagesInTopic": 11, 
    "nextInTime": 9280, 
    "senderId": "ShMYEVHytYVEjAyrC0K8kkXW5MgKV_O2aWaemcaR7duBH6RJz3_h-QDEDi0sFNTmENF9hD_ARrlxXVZk6SKu7NK_QtWH1whGfs7FhkNI9w", 
    "systemMessage": false, 
    "subject": "Re: [junit] Re: Domain specific question", 
    "from": "&quot;J. B. Rainsberger&quot; &lt;jbrains@...&gt;", 
    "authorName": "J. B. Rainsberger", 
    "msgSnippet": "... You test each link in isolation by verifying the contracts of each interface, then subtituting simpler collaborators as needed in tests. My experience is", 
    "msgId": 9279, 
    "profile": "nails762", 
    "topicId": 9274, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 127224993, 
    "messageBody": "<div id=\"ygrps-yiv-1170871536\">Venkatesh Prasad Ranganath wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; J. B. Rainsberger wrote:<br/>\n&gt;  &gt; Venkatesh Prasad Ranganath wrote:<br/>\n&gt;  &gt;<br/>\n&gt;  &gt;<br/>\n&gt;  &gt;&gt;Hi,<br/>\n&gt;  &gt;&gt;<br/>\n&gt;  &gt;&gt;I have read about JUnit and TDD and the mailing list about using these<br/>\n&gt;  &gt;&gt;in real world.  However I am still not convinced how<br/>\n&gt;  &gt;&gt;would one apply these in large systems.  In particular, in compilers and<br/>\n&gt;  &gt;&gt;related topics.<br/>\n&gt;  &gt;<br/>\n&gt;  &gt;<br/>\n&gt;  &gt; How to apply them to large systems is something that&#39;s well-worn by this<br/>\n&gt;  &gt; point. Large systems are just larger collections of objects, so not much<br/>\n&gt;  &gt; is different.<br/>\n&gt;  &gt;<br/>\n&gt;  &gt; As for compilers, your message seems to claim that building a compiler<br/>\n&gt;  &gt; incrementally is not possible, or perhaps just not feasible. The way to<br/>\n&gt;  &gt; build a compiler incrementally -- assuming you do not use any existing<br/>\n&gt;  &gt; tools like parser generators -- is to pick one language feature and<br/>\n&gt;  &gt; support it, then another, then another until you support the entire<br/>\n&gt;  &gt; language.<br/>\n&gt;  &gt;<br/>\n&gt;  &gt; Another approach is to start by implementing an interpreter, work to<br/>\n&gt;  &gt; support the entire language, then use the interpreter as a test<br/>\n&gt;  &gt; environment to write the corresponding compiler. That&#39;s just an idea<br/>\n&gt;  &gt; that comes off the top of my head and I have no idea whether it&#39;s <br/>\n&gt; feasible.<br/>\n&gt;  &gt;<br/>\n&gt;  &gt; Your question, it seems to me, is about incremental development and not<br/>\n&gt;  &gt; TDD and not JUnit. Is that accurate? I only mention that because it&#39;s<br/>\n&gt;  &gt; easier to answer a question once I understand the question.<br/>\n&gt; <br/>\n&gt; No, the question is when you have many phases that setup the data on <br/>\n&gt; which an analysis works, how do you unit test the<br/>\n&gt; analysis efficiently?  It may take a long time to setup the data, hence, <br/>\n&gt; the code-test-refactor cycle will prove rather costly.<br/>\n&gt; <br/>\n&gt; To make things simple, consider a report generation application which <br/>\n&gt; adds some interesting facts to the report based on the<br/>\n&gt; data being reported.  Now the nature of the report per say is dictated <br/>\n&gt; by the data, however, the data being generated may<br/>\n&gt; depend on relation between various pieces of the data.  In the example, <br/>\n&gt; the report generator has a strong coupling with the<br/>\n&gt; data generator but this is purely restricted to input data and no more <br/>\n&gt; (I am just clearing things in case people start saying<br/>\n&gt; &quot;reduce the coupling&quot;).  Now the information about input data (call it <br/>\n&gt; meta-data) which is also of relevance to report<br/>\n&gt; generator and this is not captured as a programmable software entity. <br/>\n&gt; How does one use TDD and/or JUnit in such cases is my<br/>\n&gt; question?<br/>\n&gt; <br/>\n&gt; All examples of JUnit or TDD I have seen are Money and things on those <br/>\n&gt; lines which are stand alone classes.  However, things<br/>\n&gt; change radically when you move to frameworks.  Referring to my first <br/>\n&gt; posting, in my opinion, a compiler is more of a framework<br/>\n&gt; rather than a single large application.  It is put together from peices <br/>\n&gt; and not grown from a single blob.  The Type checker is<br/>\n&gt; dependent on the AST and the AST is dependent on the Parser Tree which <br/>\n&gt; is dependent on parsing and the Parser.  Given this<br/>\n&gt; chain, how do you unit test each link in the chain?<br/>\n<br/>\n </span></blockquote>You test each link in isolation by verifying the contracts of each <br/>\ninterface, then subtituting simpler collaborators as needed in tests.<br/>\n<br/>\nMy experience is in J2EE, so I can best describe it there. The short <br/>\nversion follows. The long version will be published this winter and in <br/>\nbookstores early next year.<br/>\n<br/>\nMy web application consists of a controller (Servlet), presentation <br/>\nlayer (JavaBeans and Velocity templates), business layer (POJOs) and <br/>\ndata access layer (JDBC). It has several key behaviors:<br/>\n<br/>\n  * control navigation from one page to another<br/>\n  * select business logic based on a request<br/>\n  * update data based on business logic<br/>\n  * display data on a web page<br/>\n<br/>\nThere are others. Each behavior, like your compiler example, is <br/>\nimplemented by collaborations of objects, which gives you pause. Well, <br/>\nhow do I test the navigation rules? Simple, really: for each <br/>\naction/outcome pair, decide which page should come next and with which <br/>\ndata. Now simulate that action/outcome pair as simply as you can, then <br/>\ninvoke the Navigator (usually part of the controller) and verify the <br/>\nnext page the Navigator chooses.<br/>\n<br/>\nUsually this is as simple as sending a URL (the action) and a single <br/>\nvalue (the outcome) with perhaps some data (an object, such as a Map) to <br/>\na Navigator object invoking a method called &quot;getForwardUri()&quot;, which <br/>\nanswers a URI (a String). The controller can use this information to <br/>\nforward the request to that URI.<br/>\n<br/>\nI can verify that the controller actually does forward to a URI I give <br/>\nit with a single ServletUnit test.<br/>\n<br/>\nNotice that we are not performing the action. We are simulating the <br/>\naction and forcing it to a specific outcome for the purposes of <br/>\nanswering the question, &quot;Where does the Navigator want to go if I tell <br/>\nit that Action XXX ends with outcome YYY?&quot; For testing the Navigator, <br/>\nthat&#39;s all we need to do.<br/>\n<br/>\nOnce you apply this technique everywhere, all that is left -- and it&#39;s <br/>\nstill a fair amount of work -- is to verify that the Application <br/>\nconfigures the pieces correctly. A run of end-to-end tests shows that we <br/>\nhave put correctly-working pieces together correctly.<br/>\n<br/>\nNow let me see whether I can apply this to your domain.<br/>\n<br/>\n<blockquote><span title=\"ireply\">  &gt; The Type checker is<br/>\n &gt; dependent on the AST and the AST is dependent on the Parser Tree which<br/>\n &gt; is dependent on parsing and the Parser.<br/>\n<br/>\n </span></blockquote>OK. I assume that the Parser turns source code into a ParserTree, then <br/>\nthe ParserTree transforms itself into an AbstractSyntaxTree, then the <br/>\nTypeChecker analyzes the AbstractSyntaxTree and generators errors if <br/>\nany. Even if that&#39;s not entirely correct, it&#39;s close enough for this <br/>\ndiscussion. Feel free to correct me, but read what I write below anyway, <br/>\nbecause I think it&#39;ll help.<br/>\n<br/>\nSo to test the Parser, give it bits of source code. Not big bits; small <br/>\nbits. A few statements. Single constructs. Since its output is a Tree, <br/>\nas long as the Parser spits out the expected Tree for each atomic <br/>\nconstruct *and* can put those AtomicConstructTree objects in the right <br/>\nplace in a big ParserTree (for big source code), you&#39;re done. The <br/>\nrecursive nature of tree structures makes this particularly easy to <br/>\nreduce to smaller problems. In other words, verify that the Parser <br/>\norders constructs correctly in a Tree *and* knows how to translate each <br/>\nkind of construct. I don&#39;t know how many tests that is, but my guess is <br/>\nroughly 3 tests per construct plus perhaps 5 tests for the tree. 3n+5, <br/>\nthen, for n different kinds of constructs.<br/>\n<br/>\nWhen I read &quot;All the TDD examples are so simple,&quot; I think of arithmetic.<br/>\n<br/>\nThere is no such thing as a complex arithmetic question (+, -, *, /). I <br/>\nam amazed when a young person -- say 15 years old -- is impressed when I <br/>\nadd a couple of five-digit numbers in my head. (Wow! That&#39;s hard!) But <br/>\nthere is no such things as a &quot;hard&quot; arithmetic question; only a long <br/>\none. Every arithmetic question reduces to single-digit addition. The <br/>\nonly question is, &quot;How many single-digit addition operations do I need <br/>\nto do?&quot; Sometimes the answer is in the thousands. That may make it <br/>\ntime-consuming, but it isn&#39;t complex.<br/>\n<br/>\nThe good news is that as we practise single-digit addition, and then <br/>\nsingle-digit multiplication, and so on... we come to do it very quickly, <br/>\nso then adding a column for four-digit numbers is no longer so <br/>\ntime-consuming.<br/>\n<br/>\nSo I&#39;ll say this: there are no complex TDD problems; only long ones.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; I hope I am making sense.  If not then may be someone can present a <br/>\n&gt; plausible solution to the above problem or something<br/>\n&gt; similar?  I would really appreciate it as I want to use TDD and JUnit, <br/>\n&gt; but somehow I cannot see a way to make it fit into my<br/>\n&gt; work/application model.<br/>\n<br/>\n </span></blockquote>One piece at a time. The tricky part is decoupling the application, and <br/>\nthat takes practise.<br/>\n-- <br/>\nJ. B. Rainsberger,<br/>\nDiaspar Software Services<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.diasparsoftware.com\">http://www.diasparsoftware.com</a> :: +1 416 791-8603<br/>\nLet&#39;s write software that people understand</div>", 
    "prevInTime": 9278, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1062765536", 
    "canDelete": false, 
    "nextInTopic": 9280, 
    "prevInTopic": 9277, 
    "headers": {
        "inReplyToHeader": "PGJqOGNqNCRiNTMkMUBzZWEuZ21hbmUub3JnPg==", 
        "messageIdInHeader": "PDNGNTg4M0UwLjYwNjAxMDJAcm9nZXJzLmNvbT4=", 
        "referencesHeader": "PGJqODAzZSRuMTkkMUBzZWEuZ21hbmUub3JnPiA8M0Y1N0FFRjMuOTA2MDIwNkByb2dlcnMuY29tPiA8Ymo4Y2o0JGI1MyQxQHNlYS5nbWFuZS5vcmc+"
    }
}