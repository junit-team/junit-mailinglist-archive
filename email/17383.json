{
    "numMessagesInTopic": 287, 
    "nextInTime": 17384, 
    "senderId": "ELu59CGc3tIY2NBPFKC28w2QsEIwC6BEntIKs-LJLD8tMpAaYwT9BrgSJvZp1JgWDIFR1z66kn4yGXVjdoQyr7dBq6y3OZ1Q6WHoGfRVGQ", 
    "systemMessage": false, 
    "subject": "Re: [junit] Re: Are you really using JUnit during your development?", 
    "from": "&quot;J. B. Rainsberger&quot; &lt;jbrains@...&gt;", 
    "authorName": "J. B. Rainsberger", 
    "msgSnippet": "... Why are you happy with this v1 ? To me, that s the problem: why would one be happy with code that only sorta kinda works? ... Of course, if the code", 
    "msgId": 17383, 
    "profile": "nails762", 
    "topicId": 17266, 
    "spamInfo": {
        "reason": "4", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 127224993, 
    "messageBody": "<div id=\"ygrps-yiv-1968296217\">Cédric Beust ♔ wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; On 8/7/06, J. B. Rainsberger &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:jbrains@...\">jbrains@...</a> <br/>\n&gt; &lt;mailto:jbrains%40rogers.com&gt;&gt; wrote:<br/>\n&gt;  &gt;<br/>\n&gt;  &gt;<br/>\n&gt;  &gt;<br/>\n&gt;  &gt; * write the code, write the tests, they pass, all is well<br/>\n&gt;  &gt; * write the code, write the tests, one fails, debug<br/>\n&gt;  &gt; * write the code, find it difficult to write the tests, rewrite the<br/>\n&gt; <br/>\n&gt; Interestingly, you leave out the case that I was precisely making my<br/>\n&gt; argument on:<br/>\n&gt; <br/>\n&gt; * write the code, rewrite the code, rewrite the code, and finally you&#39;re<br/>\n&gt; happy with this v1 and you check it in.<br/>\n<br/>\n </span></blockquote>Why are you &quot;happy with this v1&quot;? To me, that&#39;s the problem: why would <br/>\none be happy with code that only sorta kinda works?<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; This is fairly common in my experience, and I was simply arguing that in<br/>\n&gt; such cases, TDD might end up introducing extra work.<br/>\n<br/>\n </span></blockquote>Of course, if the code doesn&#39;t have to work, then TDD is more effort <br/>\nthan you need.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;  &gt; If you postpone your testing a bit, you have: Code v1, Code v2, Code v3,<br/>\n&gt;  &gt; Test v0.1, Code v3.1, Test v0.2, Code v3.2, Test v1, Code v3.3, Commit.<br/>\n&gt;  &gt; This is because the act of writing the tests exposes flaws in the design<br/>\n&gt;  &gt; that make the test difficult to write.<br/>\n&gt; <br/>\n&gt; Sometimes, sure. Other times, you&#39;re just wasting time writing tests for<br/>\n&gt; code that you will throw away.<br/>\n<br/>\n </span></blockquote>I think you might be describing some kind of exploratory design by <br/>\nwriting code. It looks like you mean you write code, rewrite it to <br/>\nimprove the design, rewrite it to improve the design, then check it in. <br/>\nIf that&#39;s the case, the TDD is not extra work, it&#39;s less. Here&#39;s why:<br/>\n<br/>\nIf you don&#39;t to TDD, then you end up reworking code until you like the <br/>\ndesign, but then afterwards you need to test it to see whether it works. <br/>\nEither you test it manually, say in a debugger, which is slow; or you <br/>\ntest it with printf()s, which generally requires you to add them at the <br/>\nright place, check the results, then remove them, which is slow; or you <br/>\nadd automated tests, which is often slow because you probably (1) wrote <br/>\ntoo much code at once and (2) wrote code that isn&#39;t easily tested. As a <br/>\nresult, you usually (p &gt; 0.5) rewrite the code to make it testable, then <br/>\nadd tests.<br/>\n<br/>\nIf you do TDD, then when you write the tests, you are designing before <br/>\nyou cast the algorithm into code. You get the opportunity to evaluate <br/>\nthe external design before you fill in the details. By refactoring in <br/>\nsmall steps, you get the opportunity to improve the internal design as <br/>\nyou fill in the details, with the freedom to change the internal design <br/>\nwith confidence, rather than dipping into the debugger every few <br/>\nminutes. You finally end up with code that is both well-tested and <br/>\nwell-designed, and almost certainly in less time than it takes to write <br/>\nthe code first, be happy with the design, then test is afterwards.<br/>\n<br/>\nBut, of course, if you don&#39;t need to test your code, then TDD is more <br/>\neffort than not doing TDD. But then, there are two cases:<br/>\n<br/>\n1. You&#39;re shipping shit, or<br/>\n2. You&#39;re not shipping shit, which means you&#39;re a genius, which means <br/>\nyou go faster than everyone else, anyway, whether you practise TDD or not.<br/>\n<br/>\nI just can&#39;t buy the notion that it&#39;s possible to write good, untested <br/>\ncode. Show it to me. Where is this good, untested code?<br/>\n-- <br/>\nJ. B. (Joe) Rainsberger :: <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.jbrains.info\">http://www.jbrains.info</a><br/>\nYour guide to software craftsmanship<br/>\nJUnit Recipes: Practical Methods for Programmer Testing<br/>\n2005 Gordon Pask Award for contribution Agile Software Practice</div>", 
    "prevInTime": 17382, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1155294255", 
    "canDelete": false, 
    "nextInTopic": 17384, 
    "prevInTopic": 17382, 
    "headers": {
        "inReplyToHeader": "PGI4NmI2YTljMDYwODEwMjEyMW0xYzZkMjcyZHI2YjU0ZjlmNzcxODY2ZThlQG1haWwuZ29vZ2xlLmNvbT4=", 
        "messageIdInHeader": "PDQ0REM2NDJGLjcwMTA5MDRAcm9nZXJzLmNvbT4=", 
        "referencesHeader": "PDExNTQ2MTY4ODIuMTYxMi44NjM3Ni5tMTlAeWFob29ncm91cHMuY29tPgkgPEQ5MzQ2Rjc1LUQ4MjEtNEFGMS1BRDYwLTU0RjczNTcwMkVDREBvYmplY3RtZW50b3IuY29tPgkgPGI4NmI2YTljMDYwODAzMTcxM200NjQ5N2MzZmo4Y2I3ZjI5OGZmYmYzZDUwQG1haWwuZ29vZ2xlLmNvbT4JIDw0NEQyOUZEMS45MDMwMjA5QG1pdC5lZHU+CSA8Yjg2YjZhOWMwNjA4MDMxODQ0cDU0NmQ0YzM1eTJmMjE5MGYyZDE4ODEwZjVAbWFpbC5nb29nbGUuY29tPgkgPDQ0RDdGMzczLjQwOTA3MDJAcm9nZXJzLmNvbT4gPGI4NmI2YTljMDYwODEwMjEyMW0xYzZkMjcyZHI2YjU0ZjlmNzcxODY2ZThlQG1haWwuZ29vZ2xlLmNvbT4="
    }
}