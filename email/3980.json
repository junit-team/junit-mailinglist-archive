{
    "numMessagesInTopic": 6, 
    "nextInTime": 3981, 
    "senderId": "si01mxyLlQiRmVBJt1Sap6ycS5TykhKMNj_LwwhkCqf27WpmxVan-Bbsnxmk2EHfr1M-hOm9NaiT4j-eIpgQL2ZBKVFbxyN0X-s", 
    "systemMessage": false, 
    "subject": "Re: [junit] time overhead", 
    "from": "&quot;David Stagner&quot; &lt;dstagner@...&gt;", 
    "authorName": "David Stagner", 
    "msgSnippet": "... Or to put it another way, there is overhead relative to the usual approach, which is to *not* test code at all except in a simplistic way. In that case,", 
    "msgId": 3980, 
    "profile": "d_stagner", 
    "topicId": 3973, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 75470680, 
    "messageBody": "<div id=\"ygrps-yiv-1489241743\">Heath, Joseph wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Isn&#39;t the whole point that there is no overhead in Test First. You still<br/>\n&gt; have to write the tests if you test after. It&#39;s just that you&#39;re able to<br/>\n&gt; test *while* coding : I won&#39;t list the benefits as they are quite well<br/>\n&gt; documented..<br/>\n&gt; joe<br/>\n<br/>\n </span></blockquote>Or to put it another way, there is overhead relative to the usual <br/>\napproach, which is to *not* test code at all except in a simplistic way. <br/>\nIn that case, test-first has the advantage of knowing that the code <br/>\nactually works.  The same amount of test coverage done after the fact <br/>\nwill definitely take longer, because programmers will need to study code <br/>\nwritten much earlier to devise good tests.  Moreover, newer layers of <br/>\nthe code may well have been written based on untested older layers which <br/>\nhave bugs.<br/>\n<br/>\nI think the biggest payoff, though, is in maintenance and refactoring. <br/>\nMaintenance is a pain on most big systems because you&#39;re never sure what <br/>\nyou&#39;ll break when you make a change, especially a change at a low level <br/>\nof the system.  If you have a suite of unit tests in place, you&#39;ll KNOW <br/>\nwhat you break.  And if you find you broke something untested, you write <br/>\na test, add it to the suite, fix it, and never encounter it again.  This <br/>\nalso greatly simplifies refactoring, or cleaning the code as you touch <br/>\nit - something else avoided in classic systems because you don&#39;t know <br/>\nwhat you might break by, say, moving a method or changing a parameter <br/>\ntype.  With good tests, you can do that without fear.  This adds up to <br/>\n*greatly* reduced maintenance costs in the long run.<br/>\n<br/>\nQuite frankly, the biggest test most programmers apply on most jobs is <br/>\n&quot;Does it compile?&quot;  To them, test-first looks like overhead.<br/>\n<br/>\n-- <br/>\n<br/>\nDavid Stagner<br/>\n<br/>\nNational Marrow Donor Program<br/>\n3001 Broadway Street NE<br/>\nBroadway Ridge Suite 500<br/>\nMinneapolis, MN  55413<br/>\n<br/>\nEmail: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:dstagner@...\">dstagner@...</a></div>", 
    "prevInTime": 3979, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1013009078", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 3979, 
    "headers": {
        "messageIdInHeader": "PDNDNjE0QUI2LjQwMjA4MDNAbm1kcC5vcmc+", 
        "referencesHeader": "PDI5Nzc2QzFGNDIyQkQ0MTFCODY4MDA5MDI3RTJBOUU1MDExRjkyMEZAYmFja3VzLmxvZ2ljYS5jby51az4="
    }
}