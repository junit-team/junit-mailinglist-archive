{
    "numMessagesInTopic": 23, 
    "nextInTime": 22549, 
    "senderId": "HUBmR-kkh5QIJWHfxr57uePmt92-OJ3gFA3peSdXnWvF4XznMsDzY3UPymaRkhPBlfP_tWf1bTZuqdkBU-PWYTbUTDMxpTJNMQix", 
    "systemMessage": false, 
    "subject": "Re: [junit] Re: @DataPoints called several times for Theories", 
    "from": "Brett Daniel &lt;brettdaniel@...&gt;", 
    "authorName": "Brett Daniel", 
    "msgSnippet": "David, Berin, and Mike, Thank you very much for the great comments. I have asked Shin Hwei and Sang to provide their thoughts, but until then, here are my", 
    "msgId": 22548, 
    "rawEmail": "Return-Path: &lt;brettdaniel@...&gt;\r\nReceived: (qmail 23051 invoked by uid 7800); 15 Mar 2010 18:07:55 -0000\r\nX-Sender: brettdaniel@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nX-Received: (qmail 60502 invoked from network); 15 Mar 2010 17:56:15 -0000\r\nX-Received: from unknown (66.196.94.105)\n  by m13.grp.re1.yahoo.com with QMQP; 15 Mar 2010 17:56:15 -0000\r\nX-Received: from unknown (HELO mail-yw0-f189.google.com) (209.85.211.189)\n  by mta1.grp.re1.yahoo.com with SMTP; 15 Mar 2010 17:56:14 -0000\r\nX-Received: by ywh27 with SMTP id 27so1694457ywh.22\n        for &lt;junit@yahoogroups.com&gt;; Mon, 15 Mar 2010 10:56:14 -0700 (PDT)\r\nMIME-Version: 1.0\r\nX-Received: by 10.101.142.28 with SMTP id u28mr2370111ann.86.1268675774022; Mon, \n\t15 Mar 2010 10:56:14 -0700 (PDT)\r\nIn-Reply-To: &lt;4f7da6b91003150651m12f2796kf9aab17ff312cd93@...&gt;\r\nReferences: &lt;58dba2251002180943q238dd8dv11ab48736321e178@...&gt;\n\t &lt;hlkif2+3mte@...&gt;\n\t &lt;58dba2251003121544p3cd7dd28h1a899ce657f66ad3@...&gt;\n\t &lt;a527fddf1003140915l73761ee1r781ba20fc768e42e@...&gt;\n\t &lt;75F5ED8A5A553646A46E00E6EC854FA30378C7E4@...-ais.com&gt;\n\t &lt;4f7da6b91003150651m12f2796kf9aab17ff312cd93@...&gt;\r\nDate: Mon, 15 Mar 2010 12:56:13 -0500\r\nX-Google-Sender-Auth: 989183f907d7a0c3\r\nMessage-ID: &lt;58dba2251003151056k4bf24ff2xf161e6415abf4aba@...&gt;\r\nTo: junit@yahoogroups.com\r\nX-eGroups-Msg-Info: 2:4:8:0:0\r\nX-eGroups-From: Brett Daniel &lt;bdaniel3@...&gt;\r\nFrom: Brett Daniel &lt;brettdaniel@...&gt;\r\nSubject: Re: [junit] Re: @DataPoints called several times for Theories\r\nX-Yahoo-Group-Post: member; u=416009989; y=lJcTBy68xPmc6YtQSzUpe1kMO8OEEsGjucxcujI53JBYUb0LogLR\r\nX-Yahoo-Profile: brettddaniel\r\nContent-Type: text/plain\r\nContent-Transfer-Encoding: quoted-printable\r\nX-eGroups-Approved-By: dsaff &lt;david@...&gt; via email; 15 Mar 2010 18:07:55 -0000\r\n\r\nDavid, Berin, and Mike,\n\nThank you very much for the great comments. I have=\r\n asked Shin Hwei and Sang\nto provide their thoughts, but until then, here a=\r\nre my answers to your\nspecific questions (SH&S will correct me if I get any=\r\nthing wrong).\n\nDavid wrote...\n&gt; do you agree the below would work with the =\r\ncurrent implementation\n&gt; of Theories? It&#39;s four lines more of boilerplate, =\r\nbut not totally\nintractable\n\nYou are correct that copying within a @Datapoi=\r\nnt method would create a new\ndata point as needed and would probably be a g=\r\nood workaround for Berin&#39;s\nbug. However, I see two drawbacks in addition to=\r\n those you mention.  First,\none would need to include the copy invocation i=\r\nn every @DataPoint method\nthat used createdOnce. In contrast, annotating th=\r\ne @DataPoint itself would\nprovide all consumers with pristine values.  Seco=\r\nnd, the solution fails when\nusing @DataPoints with a theory that takes mult=\r\niple parameters:\n\n    private static Mutable[] createdOnce =3D new Mutable[=\r\n] {\n        new Mutable(),\n        new Mutable() };\n\n    @DataPoints()\n    =\r\npublic static Mutable[] mutables() {\n        return new Mutable[] {\n       =\r\n         new Mutable(createdOnce[0]),\n                new Mutable(createdOn=\r\nce[1])\n        };\n    }\n\n    @Theory\n    public void testNotMutated(Mutable=\r\n a, Mutable b) {\n        assertFalse(a.isMutated);\n        a.mutate();\n    =\r\n    assertFalse(b.isMutated);\n        b.mutate();\n    }\n\nThe code above fai=\r\nls because a and b can be aliases for the same object. It\nmay of course be =\r\ndesirable to run a theory on identical instances, but in\nthat case, the use=\r\nr could make that behavior explicit in another theory.\n\nDavid wrote...\n&gt; Wh=\r\nat would you think of allowing fields or methods to\n&gt; return PontentialAssi=\r\ngnment, the type of named references to data\n&gt; values used in the Theories =\r\nrunner?\n...\n&gt; After further thought, the ParameterSupplier class is even be=\r\ntter for\n&gt; this kind of thing:\n\nDo I understand correctly that you are sugg=\r\nesting pulling the\nPotentialAssignment array out of the internal Theory run=\r\nner and making it\navailable to developers? I seem to remember that Sang and=\r\n Shin Hwei\nexperimented with modifications to the PotentialAssignment and\nP=\r\narameterSupplier classes, but they can describe what they did better than\nI=\r\n.\n\nDavid wrote...\n&gt; @DataPointSource public static PotentialAssignment&lt;Muta=\r\nble&gt; =3D\n&gt; Copy.ofMutable(new Mutable());\n...\n&gt; @DataSupplier public static=\r\n OneTypeSupplier&lt;Mutable&gt; copyMutable =3D\n&gt; Copies.of(new Mutable());\n\nI li=\r\nke the idea of allowing data sources that produce things on-demand\nrather t=\r\nhan in a pre-constructed array of values. This gets back to a brief\ndiscuss=\r\nion you and I had a long time ago about having the @DataPoints\nannotation r=\r\neturn Iterable&lt;DataPointType&gt;. That would make things like the\nfollowing po=\r\nssible:\n\n  @DataPoints\n  public static Iterable&lt;Integer&gt; ints =3D Ints.betw=\r\neen(-10, 10);\n\n  @DataPoints\n  public static Iterable&lt;Mutable&gt; mutables() {=\r\n\n    return Copies.of(...);\n  }\n\nI don&#39;t know if it is better to overload @=\r\nDataPoints or define new\n@DataPointSupplier/@DataPointSource annotations.\n\n=\r\nBerin wrote...\n&gt; I hope we are not introducing an interface or base class t=\r\nhat\n&gt; would be required for the data classes to implement\n\nAbsolutely not. =\r\nThat is one of the benefits of defining copy strategies in\nthe @DataPoint a=\r\nnnotations: the data point classes themselves remain\nunchaged.\n\nBerin wrote=\r\n...\n&gt; Is there a default CloneStrategy available?\n\nSang and Shin Hwei imple=\r\nmented several copy strategies, including one that\nuses clone, but they did=\r\n not include them in the patch in an effort to\nreduce its size and complexi=\r\nty. Would it be helpful if they pushed some\nexamples?\n\nBerin wrote...\n&gt; Her=\r\ne&#39;s a problem I spotted in the implementation:\n\nThank you very much for loo=\r\nking so closely at Sang and Shin Hwei&#39;s code. I\nhave asked them to address =\r\nany bugs that you or others find.\n\nBrett\n\nOn Mon, Mar 15, 2010 at 8:51 AM, =\r\nDavid Saff &lt;david@...&gt; wrote:\n\n&gt;\n&gt;\n&gt; On Mon, Mar 15, 2010 at 9:05 AM, =\r\nLoritsch, Berin C.\n&gt; &lt;berin.loritsch@... &lt;berin.loritsch%40gd-ais.co=\r\nm&gt;&gt; wrote:\n&gt; &gt; I&#39;m still going through the patch.  Is there a default Clone=\r\nStrategy\n&gt; available?  Any cloneable object (implements the Cloneable inter=\r\nface) will\n&gt; be much quicker than another copy strategy.  It&#39;s also an inte=\r\nrface and a\n&gt; copy strategy that comes with the JVM since before Java 2.\n&gt; =\r\n&gt;\n&gt; &gt; Here&#39;s a problem I spotted in the implementation:\n&gt; &gt;\n&gt; &gt; protected O=\r\nbject getCopyStrategyInvokedObject(Object value,\n&gt; &gt;        Class&lt;? extends=\r\n CopyStrategy&gt; copyStrategy, int index) throws\n&gt; CopyStrategyFailureExcepti=\r\non {\n&gt; &gt;      try {\n&gt; &gt;        return copyStrategy.newInstance().copyDataPo=\r\nint(value);\n&gt; &gt;      } catch (Exception e) {\n&gt; &gt;        throw new CopyStrat=\r\negyFailureException(value, index,\n&gt; copyStrategy.getSimpleName());\n&gt; &gt;     =\r\n }\n&gt; &gt;    }\n&gt; &gt;\n&gt; &gt;\n&gt; &gt; Invoking copyStrategy.newInstance() for every objec=\r\nt that needs to be\n&gt; copied is going to be a major performance drain.  Not =\r\nonly are we creating\n&gt; more work for the garbage collector, we are going th=\r\nrough the overhead of\n&gt; the reflection API to do it.  You will have an orde=\r\nr of magnitude better\n&gt; performance if you get your instance of the CopyStr=\r\nategy first, and pass\n&gt; that as necessary.\n&gt; &gt;\n&gt; &gt; Perhaps another point of=\r\n making the code cleaner would be to pull all the\n&gt; data collection stuff i=\r\nnto its own API.  It might even be able to support\n&gt; parameterized tests as=\r\n well as theories.  I imagine that was the idea behind\n&gt; ParameterSupplier?=\r\n\n&gt;\n&gt; Sadly, ParameterSupplier only applies to one parameter at a time, but\n=\r\n&gt; I could imagine a unified API that included interfaces for both.\n&gt;\n&gt; Davi=\r\nd\n&gt;\n&gt;\n&gt; &gt;\n&gt; &gt; ________________________________\n&gt; &gt;\n&gt; &gt; From: junit@yahoogro=\r\nups.com &lt;junit%40yahoogroups.com&gt; on behalf of Mike\n&gt; Forsberg\n&gt; &gt; Sent: Su=\r\nn 3/14/2010 12:15 PM\n&gt; &gt; To: junit@yahoogroups.com &lt;junit%40yahoogroups.com=\r\n&gt;; Shin Hwei Tan; Sang\n&gt; Y Baik\n&gt; &gt; Subject: Re: [junit] Re: @DataPoints ca=\r\nlled several times for Theories\n&gt; &gt;\n&gt; &gt;\n&gt; &gt;\n&gt; &gt;\n&gt; &gt; Please feel free to joi=\r\nn the mailing list. I would find the discussion\n&gt; &gt; interesting and wish it=\r\n would not run offline.\n&gt; &gt;\n&gt; &gt; Big Mike\n&gt; &gt;\n&gt; &gt; On Fri, Mar 12, 2010 at 6:=\r\n44 PM, Brett Daniel &lt;brettdaniel@...&lt;brettdaniel%40gmail.com&gt;&lt;mailto:=\r\n\n&gt; brettdaniel%40gmail.com &lt;brettdaniel%2540gmail.com&gt;&gt; &gt; wrote:\n&gt; &gt;\n&gt; &gt;&gt;\n&gt;=\r\n &gt;&gt;\n&gt; &gt;&gt; The undergrads I am advising recently pushed a patch that addresse=\r\ns the\n&gt; &gt;&gt; issue of mutable data points.\n&gt; &gt;&gt;\n&gt; &gt;&gt;\n&gt; &gt;&gt;\n&gt; http://github.com=\r\n/stan6/junit/commit/dcfa3c41446c469a4edc7513e9e7a9b610b04020&lt;\n&gt; http://gith=\r\nub.com/stan6/junit/commit/dcfa3c41446c469a4edc7513e9e7a9b610b04020\n&gt; &gt;\n&gt; &gt;&gt;=\r\n\n&gt; &gt;&gt; The patch allows developers to define &quot;copy strategies&quot; that duplicat=\r\ne\n&gt; &gt;&gt; marked data points before every theory execution. In this way, every=\r\n\n&gt; &gt;&gt; execution receives a pristine data point, which removes the problems\n=\r\n&gt; caused\n&gt; &gt;&gt; when a theory mutates data points. This is orthogonal to data=\r\npoint\n&gt; &gt;&gt; (re)creation, but I think copy strategies may help address the b=\r\nug that\n&gt; &gt;&gt; Berin found.\n&gt; &gt;&gt;\n&gt; &gt;&gt; The patch creates a new, optional &quot;copy=\r\nStrategy&quot; parameter for the\n&gt; &gt;&gt; @DataPoint and @DataPoints annotations. If=\r\n the developer wants to copy\n&gt; data\n&gt; &gt;&gt; points, he or she sets the paramet=\r\ner to a class implementing a new\n&gt; &gt;&gt; CopyStrategy interface.\n&gt; &gt;&gt;\n&gt; &gt;&gt; Her=\r\ne is an example:\n&gt; &gt;&gt;\n&gt; &gt;&gt; @RunWith(Theories.class)\n&gt; &gt;&gt; public class TestM=\r\nutable {\n&gt; &gt;&gt;\n&gt; &gt;&gt; @DataPoint(copyStrategy =3D MutableWithCopyStrategy.clas=\r\ns)\n&gt; &gt;&gt; public static Mutable mutable =3D new Mutable();\n&gt; &gt;&gt;\n&gt; &gt;&gt; @Theory\n=\r\n&gt; &gt;&gt; public static testMutate(Mutable a) {\n&gt; &gt;&gt; a.mutate();\n&gt; &gt;&gt; }\n&gt; &gt;&gt;\n&gt; &gt;=\r\n&gt; @Theory\n&gt; &gt;&gt; public static testNotMutated(Mutable a) {\n&gt; &gt;&gt; assertFalse(a=\r\n.isMutated());\n&gt; &gt;&gt; }\n&gt; &gt;&gt; }\n&gt; &gt;&gt;\n&gt; &gt;&gt; In the current implementation of JUn=\r\nit, the second theory may fail\n&gt; because\n&gt; &gt;&gt; the first theory mutates the =\r\ndatapoint. With a copy strategy enabled,\n&gt; both\n&gt; &gt;&gt; theories receive a new=\r\n value.\n&gt; &gt;&gt;\n&gt; &gt;&gt; Strategies can do almost anything: clone the data point, =\r\ncall a factory\n&gt; &gt;&gt; method, or--as in the following implementation--instant=\r\naiate a new\n&gt; object\n&gt; &gt;&gt; with a copy constructor.\n&gt; &gt;&gt;\n&gt; &gt;&gt; public class M=\r\nutableWithCopyStrategy implements CopyStrategy {\n&gt; &gt;&gt; public Object copyDat=\r\naPoint(Object toCopy) throws Exception {\n&gt; &gt;&gt; return new Mutable((Mutable)t=\r\noCopy);\n&gt; &gt;&gt; }\n&gt; &gt;&gt; }\n&gt; &gt;&gt;\n&gt; &gt;&gt; There are several benefits to this implemen=\r\ntation. First, the new\n&gt; parameter\n&gt; &gt;&gt; is completely optional; if it is om=\r\nitted, the theory runner behaves as\n&gt; it\n&gt; &gt;&gt; always has. Second, it doesn&#39;=\r\nt require modifying the data point&#39;s class\n&gt; &gt;&gt; (for\n&gt; &gt;&gt; example, to add a=\r\n copy constructor or clone method). Most importantly,\n&gt; it\n&gt; &gt;&gt; makes it cl=\r\near to the tester that without a copy strategy one theory\n&gt; &gt;&gt; execution ca=\r\nn impact another.\n&gt; &gt;&gt;\n&gt; &gt;&gt; I have CC&#39;d the two students in this email. Ple=\r\nase direct any questions\n&gt; to\n&gt; &gt;&gt; them.\n&gt; &gt;&gt;\n&gt; &gt;&gt; Brett\n&gt; &gt;&gt;\n&gt; &gt;&gt;\n&gt; &gt;&gt; On =\r\nThu, Feb 18, 2010 at 5:28 PM, Berin &lt;berin.loritsch@...&lt;berin.lorits=\r\nch%40gd-ais.com&gt;&lt;mailto:\n&gt; berin.loritsch%40gd-ais.com &lt;berin.loritsch%2540=\r\ngd-ais.com&gt;&gt;\n&gt; &lt;berin.loritsch%40gd-ais.com&gt;&gt;\n&gt; &gt;&gt; wrote:\n&gt; &gt;&gt;\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; =\r\n&gt;\n&gt; &gt;&gt; &gt; I agree with your prognosis, about fresh data points for testing t=\r\nhe\n&gt; &gt;&gt; &gt; theories. That is precisely why I proposed reading them once, and=\r\n\n&gt; cloning\n&gt; &gt;&gt; &gt; them (making a copy) as needed for each theory. With that=\r\n approach we\n&gt; &gt;&gt; even\n&gt; &gt;&gt; &gt; get the protection from mutated data points w=\r\nhen you use the\n&gt; @DataPoint\n&gt; &gt;&gt; to\n&gt; &gt;&gt; &gt; mark a static field.\n&gt; &gt;&gt; &gt;\n&gt; &gt;=\r\n&gt; &gt; Cloning is a much quicker operation, does not execute any\n&gt; constructor=\r\ns.\n&gt; &gt;&gt; It\n&gt; &gt;&gt; &gt; merely copies the contents of the object memory verbatim.=\r\n\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; With the current implementation, if you are not prepared for=\r\n the\n&gt; &gt;&gt; &gt; combinatorial affect of 60 data points combined with 60 data po=\r\nints\n&gt; for\n&gt; &gt;&gt; each\n&gt; &gt;&gt; &gt; theory there is a major disconnect. The majorit=\r\ny of the overhead in\n&gt; this\n&gt; &gt;&gt; &gt; particular scenario has to do with creat=\r\ning objects (with the\n&gt; additional\n&gt; &gt;&gt; &gt; overhead of doing it by reflectio=\r\nn).\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; When I created only one instance of each class instead of=\r\n two, the\n&gt; &gt;&gt; &gt; performance was twice as fast (i.e. 37 seconds down to abo=\r\nut 16\n&gt; seconds).\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; Essentially the number of times your @DataP=\r\noints method is called\n&gt; depends\n&gt; &gt;&gt; &gt; on the number of parameters in your=\r\n @Theory and how many theories you\n&gt; &gt;&gt; have.\n&gt; &gt;&gt; &gt; Essentially the formul=\r\na for my theory (ha, ha) of the execution is\n&gt; like\n&gt; &gt;&gt; &gt; this:\n&gt; &gt;&gt; &gt;\n&gt; &gt;=\r\n&gt; &gt; N^(p-1) + 1\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; where:\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; N is the number of data =\r\npoints returned by the method\n&gt; &gt;&gt; &gt; p is the number of parameters\n&gt; &gt;&gt; &gt; a=\r\nnd the + 1 represents the run where the data point is read the first\n&gt; &gt;&gt; t=\r\nime\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; So for 60 data points it is run 61 times for two paramete=\r\nrs. With\n&gt; three\n&gt; &gt;&gt; &gt; parameters it would be called 3601 times. I have to=\r\n verify with three\n&gt; &gt;&gt; &gt; parameters. The theory is called N^p times for su=\r\nre and that is\n&gt; expected.\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; With the above formula, the mappin=\r\ng of number of calls to parameters\n&gt; for\n&gt; &gt;&gt; 60\n&gt; &gt;&gt; &gt; data points would b=\r\ne:\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; 1 -&gt; 2 (I know this is wrong which gives me doubts on the =\r\nformula)\n&gt; &gt;&gt; &gt; 2 -&gt; 61\n&gt; &gt;&gt; &gt; 3 -&gt; 3601\n&gt; &gt;&gt; &gt; 3 -&gt; 216001\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; E=\r\nssentially when the Assignments class needs to make the combinations,\n&gt; it\n=\r\n&gt; &gt;&gt; &gt; will collect the data points initially for each theory. It then call=\r\ns\n&gt; the\n&gt; &gt;&gt; &gt; data points again for each existing data point it collected =\r\nfrom the\n&gt; &gt;&gt; first\n&gt; &gt;&gt; &gt; read. With a third parameter it would take all t=\r\nhose combinations\n&gt; again,\n&gt; &gt;&gt; to\n&gt; &gt;&gt; &gt; add all the permutations for the =\r\nnext round.\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; I might be wrong and the real formula would be li=\r\nke this:\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; N^0 + N^1 ... + N^(p-1)\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; If this is the=\r\n correct formula, then if you have 60 data points the\n&gt; &gt;&gt; number\n&gt; &gt;&gt; &gt; of=\r\n times the method is called would map to the number of parameters\n&gt; like\n&gt; =\r\n&gt;&gt; &gt; this:\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; 1 -&gt; 1\n&gt; &gt;&gt; &gt; 2 -&gt; 61\n&gt; &gt;&gt; &gt; 3 -&gt; 3661\n&gt; &gt;&gt; &gt; 4 -&gt;=\r\n 219661\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; --- In junit@yahoogroups.com &lt;junit%40yahoogro=\r\nups.com&gt; &lt;mailto:\n&gt; junit%40yahoogroups.com &lt;junit%2540yahoogroups.com&gt;&gt;  &lt;=\r\njunit%\n&gt; 40yahoogroups.com&gt; &lt;junit%\n&gt; &gt;&gt; 40yahoogroups.com&gt;, Brett Daniel\n&gt;=\r\n &gt;&gt;\n&gt; &gt;&gt; &gt; &lt;brettdaniel@...&gt; wrote:\n&gt; &gt;&gt; &gt; &gt;\n&gt; &gt;&gt; &gt; &gt; Berin,\n&gt; &gt;&gt; &gt; &gt;\n&gt; &gt;&gt; =\r\n&gt; &gt; When a theory mutates data points, it might be beneficial to\n&gt; recreate=\r\n\n&gt; &gt;&gt; &gt; &gt; the data point for every theory invocation. Doing so prevents one=\r\n\n&gt; &gt;&gt; &gt; &gt; theory execution from affecting others. I wrote about this issue =\r\nin\n&gt; &gt;&gt; &gt; &gt; the following weblog post:\n&gt; &gt;&gt; &gt; &gt;\n&gt; &gt;&gt; &gt; &gt; http://www.brettda=\r\nniel.com/archives/2009/09/24/200845/ &lt;\n&gt; http://www.brettdaniel.com/archive=\r\ns/2009/09/24/200845/&gt;\n&gt; &gt;&gt; &gt; &gt;\n&gt; &gt;&gt; &gt; &gt; You are correct, though, that copyi=\r\nng would avoid some of the\n&gt; overhead\n&gt; &gt;&gt; &gt; &gt; in calling datapoint methods=\r\n. It is interesting you mention this\n&gt; idea,\n&gt; &gt;&gt; &gt; &gt; because I am currentl=\r\ny overseeing two students who for their senior\n&gt; &gt;&gt; &gt; &gt; thesis project are =\r\nimplementing framework for copying datapoints. I\n&gt; &gt;&gt; &gt; &gt; will post more in=\r\nformation to the mailing list as the project\n&gt; &gt;&gt; &gt; &gt; continues.\n&gt; &gt;&gt; &gt; &gt;\n&gt;=\r\n &gt;&gt; &gt; &gt; Brett\n&gt; &gt;&gt; &gt; &gt;\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt;\n&gt; &gt;&gt; [Non-text portions of=\r\n this message have been removed]\n&gt; &gt;&gt;\n&gt; &gt;&gt;\n&gt; &gt;&gt;\n&gt; &gt;\n&gt; &gt; [Non-text portions =\r\nof this message have been removed]\n&gt; &gt;\n&gt; &gt;\n&gt; &gt;\n&gt; &gt;\n&gt; &gt;\n&gt; &gt;\n&gt; &gt; [Non-text po=\r\nrtions of this message have been removed]\n&gt; &gt;\n&gt; &gt;\n&gt; &gt;\n&gt; &gt; -----------------=\r\n-------------------\n&gt; &gt;\n&gt; &gt; Yahoo! Groups Links\n&gt; &gt;\n&gt; &gt;\n&gt; &gt;\n&gt; &gt;\n&gt;  \n&gt;\n\n\n[No=\r\nn-text portions of this message have been removed]\n\n\n", 
    "profile": "brettddaniel", 
    "topicId": 22425, 
    "spamInfo": {
        "reason": "4", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 416009989, 
    "prevInTime": 22547, 
    "contentTrasformed": false, 
    "postDate": "1268675773", 
    "canDelete": false, 
    "nextInTopic": 22549, 
    "prevInTopic": 22547, 
    "headers": {
        "inReplyToHeader": "PDRmN2RhNmI5MTAwMzE1MDY1MW0xMmYyNzk2a2Y5YWFiMTdmZjMxMmNkOTNAbWFpbC5nbWFpbC5jb20+", 
        "messageIdInHeader": "PDU4ZGJhMjI1MTAwMzE1MTA1Nms0YmYyNGZmMnhmMTYxZTY0MTVhYmY0YWJhQG1haWwuZ21haWwuY29tPg==", 
        "referencesHeader": "PDU4ZGJhMjI1MTAwMjE4MDk0M3EyMzhkZDhkdjExYWI0ODczNjMyMWUxNzhAbWFpbC5nbWFpbC5jb20+CSA8aGxraWYyKzNtdGVAZUdyb3Vwcy5jb20+CSA8NThkYmEyMjUxMDAzMTIxNTQ0cDNjZDdkZDI4aDFhODk5Y2U2NTdmNjZhZDNAbWFpbC5nbWFpbC5jb20+CSA8YTUyN2ZkZGYxMDAzMTQwOTE1bDczNzYxZWUxcjc4MWJhMjBmYzc2OGU0MmVAbWFpbC5nbWFpbC5jb20+CSA8NzVGNUVEOEE1QTU1MzY0NkE0NkUwMEU2RUM4NTRGQTMwMzc4QzdFNEB2YWZmMDEtbWFpbDAxLmFkLmdkLWFpcy5jb20+CSA8NGY3ZGE2YjkxMDAzMTUwNjUxbTEyZjI3OTZrZjlhYWIxN2ZmMzEyY2Q5M0BtYWlsLmdtYWlsLmNvbT4="
    }
}