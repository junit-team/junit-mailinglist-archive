{
    "numMessagesInTopic": 17, 
    "nextInTime": 17372, 
    "senderId": "M0ijTPMRreMlDwP5kTZMVI2_ulDwVXiML098xnPZk6kRhnUK5MMsDQ67NeMWOxABac_hniDTrNogakAXtH0KkRqhE74e0p2zOaVzZcv5JQ", 
    "systemMessage": true, 
    "subject": "Re: [junit] Re: Are you really using JUnit during your developmen t?", 
    "from": "&quot;J. B. Rainsberger&quot; &lt;jbrains@...&gt;", 
    "authorName": "J. B. Rainsberger", 
    "msgSnippet": "... I m not sure what you mean here, but I ll provide another perspective, based on my experience. There are two ways to write this kind of test: * Know the", 
    "msgId": 17371, 
    "rawEmail": "Return-Path: &lt;jbrains@...&gt;\r\nReceived: (qmail 34350 invoked from network); 11 Aug 2006 02:36:09 -0000\r\nReceived: from unknown (66.218.66.172)\n  by m25.grp.scd.yahoo.com with QMQP; 11 Aug 2006 02:36:09 -0000\r\nReceived: from unknown (HELO n16a.bullet.scd.yahoo.com) (66.94.237.45)\n  by mta4.grp.scd.yahoo.com with SMTP; 11 Aug 2006 02:36:09 -0000\r\nReceived: from [66.218.66.59] by n16.bullet.scd.yahoo.com with NNFMP; 11 Aug 2006 02:36:09 -0000\r\nReceived: from [66.218.66.81] by t8.bullet.scd.yahoo.com with NNFMP; 11 Aug 2006 02:36:09 -0000\r\nX-Sender: jbrains@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (qmail 59142 invoked from network); 8 Aug 2006 19:50:53 -0000\r\nReceived: from unknown (66.218.67.35)\n  by m37.grp.scd.yahoo.com with QMQP; 8 Aug 2006 19:50:53 -0000\r\nReceived: from unknown (HELO chilco.textdrive.com) (207.7.108.242)\n  by mta9.grp.scd.yahoo.com with SMTP; 8 Aug 2006 19:50:53 -0000\r\nReceived: from [192.168.1.113] (unknown [70.24.207.92])\n\tby chilco.textdrive.com (Postfix) with ESMTP id 9677FDB777\n\tfor &lt;junit@yahoogroups.com&gt;; Tue,  8 Aug 2006 19:50:35 +0000 (UTC)\r\nMessage-ID: &lt;44D8EB0F.9030001@...&gt;\r\nDate: Tue, 08 Aug 2006 15:50:39 -0400\r\nUser-Agent: Thunderbird 1.5.0.5 (Macintosh/20060719)\r\nMIME-Version: 1.0\r\nTo: junit@yahoogroups.com\r\nReferences: &lt;eb9kme+87ug@...&gt;\r\nIn-Reply-To: &lt;eb9kme+87ug@...&gt;\r\nContent-Type: text/plain; charset=ISO-8859-1; format=flowed\r\nContent-Transfer-Encoding: 7bit\r\nX-eGroups-Msg-Info: 2:4:8:0\r\nFrom: &quot;J. B. Rainsberger&quot; &lt;jbrains@...&gt;\r\nSubject: Re: [junit] Re: Are you really using JUnit during your developmen\n t?\r\nX-Yahoo-Group-Post: member; u=127224993; y=Ur4xsVAI_cPlm5U2ibpTp1b9Wu4lQZ_z7v8VcWQ21PBhmCI\r\nX-Yahoo-Profile: nails762\r\nX-Yahoo-Marked-Not-Spam: \r\nX-Yahoo-Newman-Property: groups-system\r\nX-eGroups-Approved-By: nails762 &lt;jbrains@...&gt; via web; 11 Aug 2006 02:36:06 -0000\r\n\r\nthehasko wrote:\n\n&gt;  &gt; 1. I need to know the correct result from the other way around and\n&gt; sometimes it&#39;s hard to find another way.\n&gt; \n&gt; I am not quite sure if I fully understand what you mean. Are you\n&gt; saying, to write good test, you need two different &quot;approaches&quot; to\n&gt; solve the problem under test? Like in the following, trivial\n&gt; example:\n&gt; \n&gt; public int multiply(int a, int b) {\n&gt; return a * b;\n&gt; }\n&gt; \n&gt; public void testMultiply() {\n&gt; // test the expected result, &quot;the other way round&quot;\n&gt; assertEquals(5 + 5, x.multiply(5, 2);\n&gt; }\n&gt; \n&gt; I can see that this can get quite hard for non-trivial problems.\n&gt; \n&gt; If this is what you meant, I think I have good news: In believe this\n&gt; rigorous approach to unit testing is not necessary. It&#39;s perferctly\n&gt; accaptable to just write the test as:\n&gt; \n&gt; assertEquals(5 * 2, x.multiply(5, 2);\n&gt; \n&gt; The point of automated unit testing is not to prove algorithmic\n&gt; correctness but just to check real behavior against expected\n&gt; behavior. In my opinion, the main benefit of _automated_ unit\n&gt; testing is to be able to re-run the tests after implementation\n&gt; changes. And, after implementation changes, you cannot be sure\n&gt; if &quot;the other way round&quot; is still another way or if it has actually\n&gt; become &quot;the way&quot;. So don&#39;t bother in the first place, and save a lot\n&gt; of time and pain.\n&gt; \n&gt; Again: For me, automated unit tests are primarily like an insurance\n&gt; against quality degradation when I change code. They are less\n&gt; important to prove correctness of the initial version of the code I\n&gt; write. I tend to spend more time changeing existing code than\n&gt; writing new code, so that&#39;s fine for me.\n&gt; \n&gt; Bottom line is, forget about the &quot;other way round&quot; issue. ;-)\n\nI&#39;m not sure what you mean here, but I&#39;ll provide another perspective, \nbased on my experience.\n\nThere are two ways to write this kind of test:\n\n  * Know the correct answer in advance and expect it\n  * Do not know the correct answer in advance, discover it, then expect \nit the next time\n\nTo use Hasko&#39;s example, I would simply write the test this way, since I \nknow the correct answer in advance:\n\nassertEquals(10, multiply(5, 2));\n\nSuppose I didn&#39;t know the correct answer in advance. This could be \nbecause someone has already written multiply() and now I am adding tests \nto it. In this case, I would use the Gold Master approach. (Google: \nkeith stobie test patterns) First, I write this:\n\nassertEquals(0, multiply(5, 2));\n\nWhen I run the test, it fails, expecting 0, but was 10. Now I look at \nthe 10 and confirm with someone that it is the correct answer. (In this \ncase, I know it&#39;s correct, but if multiply() were more complex, I might \nhave to ask someone. It&#39;s better to ask a /business user/ than the \nprogrammer, because you want to know if the answer is correct, and not \nmerely what the programmer thought was correct.) Now in the test, I \npaste the actual result (10) into the test.\n\nassertEquals(10, multiply(5, 2));\n\nThis test passes and I move on to the next case.\n\nAs Hasko points out, do /not/ use the algorithm to test itself, so don&#39;t \ndo this:\n\nassertEquals(5 * 2, multiply(5, 2));\n\nTo see why that test is silly, inline the call to multiply, and you get \nthis:\n\nassertEquals(5 * 2, 5 * 2);\n\nClearly that test does nothing useful.\n\nAlso, don&#39;t use algorithm 1 to test algorithm 2, so don&#39;t do this:\n\nassertEquals(5 + 5, multiply(5, 2));\n\nIt&#39;s possible to get the &quot;5 + 5&quot; wrong, especially when it comes time to \ntest mutiply(12, 26) or in case you want to do &quot;2 + 2 + 2 + 2 + 2&quot;. (Are \nyou sure there are 5 2s there?)\n\nIf the expected result is easily determined outside the program, compute \nit by hand and put the answer in the test.\n\nIf the expected result is not easily determined outside the program, use \nthe Gold Master approach. Be careful that that does not become &quot;Guru \nChecks Output&quot;.\n\nI hope that helps.\n-- \nJ. B. (Joe) Rainsberger :: http://www.jbrains.info\nYour guide to software craftsmanship\nJUnit Recipes: Practical Methods for Programmer Testing\n2005 Gordon Pask Award for contribution Agile Software Practice\n\n\n\n", 
    "profile": "nails762", 
    "topicId": 17279, 
    "spamInfo": {
        "reason": "4", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 127224993, 
    "prevInTime": 17370, 
    "contentTrasformed": false, 
    "postDate": "1155066639", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 17339, 
    "headers": {
        "inReplyToHeader": "PGViOWttZSs4N3VnQGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PDQ0RDhFQjBGLjkwMzAwMDFAcm9nZXJzLmNvbT4=", 
        "referencesHeader": "PGViOWttZSs4N3VnQGVHcm91cHMuY29tPg=="
    }
}