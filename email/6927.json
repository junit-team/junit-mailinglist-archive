{
    "numMessagesInTopic": 4, 
    "nextInTime": 6928, 
    "senderId": "aVeQyeuBAD9uyLvv9-EEF2ZmqslXaESRrBKJYBBvH-4zszy5WCEev78INL6pcqkMAWciI4cBqENzzyd_0aUSMn7lZ372QudaQoCv0aiNig", 
    "systemMessage": false, 
    "subject": "RE: [junit] Testable Interface / &quot;unit&quot; (?) testing", 
    "from": "&quot;Scott Stirling&quot; &lt;scottstirling@...&gt;", 
    "authorName": "Scott Stirling", 
    "msgSnippet": "... Yes, both of these would be cool, especially if a reporting mechanism and driver was built-into the JVM.  Not likely, but it s not impossible. ... That is", 
    "msgId": 6927, 
    "profile": "jrun5", 
    "topicId": 6922, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 112036634, 
    "messageBody": "<div id=\"ygrps-yiv-1786983417\"><blockquote><span title=\"ireply\">&gt; -----Original Message-----<br/>\n&gt; From: Eric Armstrong [mailto:<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:eric.armstrong@...\">eric.armstrong@...</a>]<br/>\n&gt; Scott Stirling wrote:<br/>\n&gt; &gt; What would it be like<br/>\n&gt; &gt; to idiomaticize Testability as a marker interface in Java?<br/>\n&gt; &gt;<br/>\n&gt; &gt; One idea is that &quot;implements Testable&quot; could mean that a runtime flag<br/>\n&gt; &gt; could be used to enable/disable a set of test methods (a la JUnit&#39;s<br/>\n&gt; &gt; test**** method naming pattern) in classes.  Just a thought.<br/>\n&gt;<br/>\n&gt; Heck of a thought.<br/>\n&gt;<br/>\n&gt; I would expect:<br/>\n&gt;    a) The class structure would contain the test methods, but they<br/>\n&gt;        wouldn&#39;t be loaded in the absence of a -test flag, or some such.<br/>\n&gt;<br/>\n&gt;    b) With the -test option present, a framework would exist to help you<br/>\n&gt;<br/>\n&gt;         experiment with the APIs, uncovering gaps in the documentation.<br/>\n&gt;         (If I give an empty string as an argument, do I get a null<br/>\n&gt; String, an empty string, or an exception?)<br/>\n<br/>\n </span></blockquote>Yes, both of these would be cool, especially if a reporting mechanism and<br/>\ndriver was built-into the JVM.  Not likely, but it&#39;s not impossible.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;    c) API documentation would have a link to a page containing test<br/>\n&gt;        methods that would exist only if the class was testable.<br/>\n&gt;<br/>\n&gt; Such a thing could be really cool, self-documenting addition to<br/>\n&gt; libraries.<br/>\n<br/>\n </span></blockquote>That is a pretty cool idea.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; What the heck *is* unit testing, anyway? If it is &quot;class methods&quot;, then<br/>\n&gt; JUnitDoclet made sense. But if it is &quot;basic operations&quot;, isn&#39;t that more<br/>\n&gt; like integration testing? Or is there a middle ground, say, as package-<br/>\n&gt; level operations?<br/>\n&gt;<br/>\n&gt; Right now, I&#39;m seeing &quot;unit&quot; as one or more of:<br/>\n&gt;   * method<br/>\n&gt;   * class<br/>\n&gt;   * package<br/>\n&gt;   * use case<br/>\n&gt;<br/>\n&gt; Are there any other candidates? Are any of these automatically<br/>\n&gt; ruled out? What exactly does the word &quot;unit&quot; mean, in this<br/>\n&gt; context?<br/>\n<br/>\n </span></blockquote>I go by the Robert Binder definition, which is couched in a comprehensive<br/>\nthesis about the importance of identifying appropriate testing techniques<br/>\nand bug predictions for components at different scopes.  But the scopes used<br/>\nare traditional categories (in QA engineering, Boris Beizer and Gelnford<br/>\nMeyers pretty well represent the founders of tradition).<br/>\n<br/>\nFrom Binder&#39;s &quot;Testing Object-Oriented Systems,&quot; p. 45:<br/>\n<br/>\n&quot;The scope of a test is the collection of software components to be<br/>\nverified. [...] Scope is traditionally designated as unit, integration or<br/>\nsystem.&quot;<br/>\n<br/>\n&quot;The scope of a unit test typically comprises a relatively small executable.<br/>\nIn object-oriented programming, an object of a class is the smallest<br/>\nexecutable unit, but test messages must be sent to a method, so we can speak<br/>\nof method scope testing.  A test unit may consist of a class, several<br/>\nrelated classes (a cluster), or an executable binary file.  Typically it is<br/>\na cluster of interdependent classes.&quot;<br/>\n<br/>\nAnd, some gems from the chapter on &quot;Classes&quot; (chapter 10), p. 351:<br/>\n<br/>\nQ: Why Test at Class Scope?<br/>\nA [edited for length]:<br/>\n- System-level testing cannot exercise components to the same degree as<br/>\nclass scope testing.<br/>\n- Trying to exercise a class through its clients is usually like trying to<br/>\npick up a dime with boxing gloves. [one of my favorite lines from Binder&#39;s<br/>\nbook]<br/>\n- The longer the time between creation of a bug and its debut as a failure,<br/>\nthe higher the cost of correction.<br/>\n- Effective class scope testing reduces schedule risk and improves<br/>\nproductivity.<br/>\n- It is poor practice, at best, to foist testing on to developers of client<br/>\nclasses.<br/>\n<br/>\nScott Stirling<br/>\nFramingham, MA</div>", 
    "prevInTime": 6926, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1044937429", 
    "canDelete": false, 
    "nextInTopic": 6933, 
    "prevInTopic": 6926, 
    "headers": {
        "inReplyToHeader": "PDNFNDZFNjg1LkQ4NzM0RUVFQHN1bi5jb20+", 
        "messageIdInHeader": "PEtJRUhJQklPQkFFTEpBSElQTkhES0VCRkNQQUEuc2NvdHRzdGlybGluZ0ByY24uY29tPg=="
    }
}