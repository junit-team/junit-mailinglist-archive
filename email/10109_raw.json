{
    "numMessagesInTopic": 5, 
    "nextInTime": 10110, 
    "senderId": "JsF1ONbIgXJvxYZXyHl8k9DPLm7-B4PXhZ4mWThZ6i93iEJmB0VaOtRVPUdD1lmBbqwhWFf8IEqjpQjnTNkp6WRNby2euVJ41K7DRXsf8A", 
    "systemMessage": false, 
    "subject": "Re: [junit] newbie - how to test clases persisting to DB, mock objects in .net", 
    "from": "&quot;J. B. Rainsberger&quot; &lt;jbrains@...&gt;", 
    "authorName": "J. B. Rainsberger", 
    "msgSnippet": "... I have had the greatest success with Interface Segregation. My business logic talks to Store objects using commands, and not a database. The Store objects", 
    "msgId": 10109, 
    "rawEmail": "Return-Path: &lt;jbrains@...&gt;\r\nX-Sender: jbrains@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (qmail 32669 invoked from network); 17 Dec 2003 20:03:19 -0000\r\nReceived: from unknown (66.218.66.216)\n  by m1.grp.scd.yahoo.com with QMQP; 17 Dec 2003 20:03:19 -0000\r\nReceived: from unknown (HELO fep04-mail.bloor.is.net.cable.rogers.com) (66.185.86.74)\n  by mta1.grp.scd.yahoo.com with SMTP; 17 Dec 2003 20:03:19 -0000\r\nReceived: from rogers.com ([24.156.43.226])\n          by fep04-mail.bloor.is.net.cable.rogers.com\n          (InterMail vM.5.01.05.12 201-253-122-126-112-20020820) with ESMTP\n          id &lt;20031217200109.NPSE317816.fep04-mail.bloor.is.net.cable.rogers.com@...&gt;\n          for &lt;junit@yahoogroups.com&gt;; Wed, 17 Dec 2003 15:01:09 -0500\r\nMessage-ID: &lt;3FE0B628.50108@...&gt;\r\nDate: Wed, 17 Dec 2003 15:01:44 -0500\r\nUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.0; en-US; rv:1.5b) Gecko/20030901 Thunderbird/0.2\r\nX-Accept-Language: en-us, en\r\nMIME-Version: 1.0\r\nTo: junit@yahoogroups.com\r\nReferences: &lt;20031217192916.9511.qmail@...&gt;\r\nIn-Reply-To: &lt;20031217192916.9511.qmail@...&gt;\r\nContent-Type: text/plain; charset=us-ascii; format=flowed\r\nContent-Transfer-Encoding: 7bit\r\nX-Authentication-Info: Submitted using SMTP AUTH PLAIN at fep04-mail.bloor.is.net.cable.rogers.com from [24.156.43.226] using ID &lt;jbrains@...&gt; at Wed, 17 Dec 2003 15:01:09 -0500\r\nX-eGroups-Remote-IP: 66.185.86.74\r\nFrom: &quot;J. B. Rainsberger&quot; &lt;jbrains@...&gt;\r\nSubject: Re: [junit] newbie - how to test clases persisting to DB, mock objects\n in .net\r\nX-Yahoo-Group-Post: member; u=127224993\r\nX-Yahoo-Profile: nails762\r\n\r\nKevin Klinemeier wrote:\n\n&gt; I&#39;ve been using the mock object approach to testing with a good amount\n&gt; of success.  I&#39;ve used both the SQL mock objects from\n&gt; http://www.mockobjecst.com, and a mock implementation of our own\n&gt; persistence level. \n\nI have had the greatest success with Interface Segregation. My business \nlogic talks to Store objects using commands, and not a database. The \nStore objects could be hooked up to anything: files, RDBMS, OODBMS, it \ndoesn&#39;t matter. The command executer and Store objects go together: the \nJDBC version manages connections to the database as well as transaction \nboundaries. I suppose I could put an Abstract Factory around the whole \nthing, but I haven&#39;t bothered yet.\n\n&gt; The main criticism of this approach is that you&#39;re not really testing\n&gt; writing to the database.\n\nMy response to those critics: it&#39;s not my job to test someone else&#39;s \nJDBC driver. I&#39;d rather test /my/ code.\n\n&gt; Performance, configuration, db behavior, and\n&gt; select statement correctness is not tested.  \n\nMy response to those critics: that&#39;s ridiculous. We test it by using the \napplication. Every day.\n\n&gt; I don&#39;t think that\n&gt; configuration and performance are things that are appropriate for\n&gt; testing in unit tests, so I ignore those points.  \n\n/Everything/ is appropriate for testing as an object test, but some \ntests provide more ROI than others. If you have persistent ongoing \nconfiguration problems, then build a Deployment Test Suite to verify \nyour configuration before you deploy. If you don&#39;t, then don&#39;t build it \nuntil you do.\n\n &gt; To the database\n&gt; behavior question (aka &quot;actually writing to the database&quot;), I respond\n&gt; with, &quot;I didn&#39;t write the database layer, I don&#39;t need to test it.&quot;  \n\nBeautiful. Not my yob, mang.\n\n&gt; It\n&gt; is true that you can have unresolved bugs with problems in your SQL\n&gt; statement (or QBE examples, in my case).  That&#39;s an admitted weakness,\n&gt; and not a small one.  If there are suggestions on that front, they&#39;re\n&gt; welcome (see below).\n\nTest &#39;em manually. Type an SQL statement into a command line interactive \nSQL interface. Did it work? Great. Paste it into your code and make it \nthe Gold Master. If anyone changes that SQL statement (example: they \ngenerate it differently than they used to), then the tests tell you that \nthat happened and you can use your judgment: either the gold master \nneeds to be updated or the change to the SQL statement was wrong.\n\n&gt; Just to clarify, (almost) all my tests run without actually accessing\n&gt; the database.  I think this approach has these key advantages:\n&gt; \n&gt; 1:  Test independence - I don&#39;t have to worry about stepping on other\n&gt; developers.  (If my non-mock test creates a value, then deletes it,\n&gt; what happens if someone else&#39;s test it re-creates it after I&#39;ve deleted\n&gt; it, but before I&#39;ve checked for it being missing?  Trouble and\n&gt; confusion).\n&gt; \n\n&gt; 2:  Test speed - This sounds minor, but its a bigger deal than you\n&gt; might think.  No database startup or connection times makes for much\n&gt; faster execution of unit tests.  This makes me much more likely to add\n&gt; a unit test, or to run old ones.\n\nIn memory, these tests take 0.25 seconds less time each.\n\n1000 database tests times 0.25 seconds per test = 250 seconds &gt; 4 minutes.\n\nNow I can run my tests an extra 15-20 times per hour, if I want. That&#39;s \n120-160 times per day. How many more defects will that help you find? \nMany. Not to mention avoiding extra context switches by checking e-mail, \nbrowsing the web, grabbing a coffee.\n\nWhen the computer starts telling /you/ when to take a break, something \nis wrong.\n\n&gt; 3:  Test failure cases - This is a big one.  The mock object approach\n&gt; can test the way your code behaves when the database fails.  I can have\n&gt; my mock object accept the Person query, but when it asks for Salary, it\n&gt; throws an exception.  This can&#39;t be done with the database-connected\n&gt; approach.\n\nTell me more about this. I don&#39;t understand it.\n\nI think you mean that the tests detect problems before your JDBC driver \ntries to execute an obviously erroneous query. Is that right?\n\n&gt; 4:  Test completeness - This is more true of the SQL tools, but only\n&gt; because they&#39;ve taken the time to write all the things I needed.  I can\n&gt; tell the SQL tools to look for the following select statements, and if\n&gt; there is deviation, complain.  The not-so-obvious case that this caught\n&gt; for me was multiple queries.  I had a logic problem that was causing my\n&gt; code to ask ten times for a particular case that I only intended for it\n&gt; to ask once.\n\nEasyMock objects are great for this.\n\n&gt; 4:  Test completeness - I want to say this again with another example.\n&gt; If you have code that deletes things, you can be sure that it only\n&gt; deletes the things you expect.  With the database-connected approach,\n&gt; you&#39;re typically only testing that it deletes the things you expect to\n&gt; be gone, not whether there were things that existed before that are now\n&gt; also deleted by some side effect (like in another table you weren&#39;t\n&gt; expecting, for example).\n\nHow often does it happen that data magically disappears from another \ntable? I suppose it happens when someone silently adds a new foreign key \nconstraint with &quot;cascade delete&quot;. Perhaps this shouldn&#39;t happen. Perhaps \nthat&#39;s a different problem.\n\n&gt; 5:  Test size unchanged - When I set out to use the mock objects, I\n&gt; expected this to increase the size of my test code vs the\n&gt; database-connected approach.  I was suprised to find that this wasn&#39;t\n&gt; the case.  Consider the following pseudocode:\n&gt; \n&gt; setupInitialState();\n&gt; executeMethodUnderTest();\n&gt; assertTrue(&quot;State not right&quot;,checkState());\n&gt; cleanupState();\n&gt; \n&gt; This is the same type of code whether your initial state is inserting\n&gt; records in the database, or if it is setting up mock objects.  The only\n&gt; place I had more code than before was in cases #3 and #4, where I was\n&gt; testing things I was previously unable to test.\n\nDisagree. More mock objects means more complex object construction (more \nparameters to constructors). This means your setUp() code is more \ncomplex. (I use EasyMock, so two lines of code per interface to mock.) \nWhat&#39;s neat, though, is that you spend more lines of code setting up \nobjects, but verifying them is a snap. The less cohesive your objects \n(common with a direct-to-database design), the more hoops to jump \nthrough to verify a particular condition.\n\nComplex object construction is much less brittle, in general, than \ncomplex assertions.\n\nThanks for your thoughts. I&#39;m glad I&#39;m not alone in this. :)\n-- \nJ. B. Rainsberger,\nDiaspar Software Services\nhttp://www.diasparsoftware.com :: +1 416 791-8603\nLet&#39;s write software that people understand\n\n\n", 
    "profile": "nails762", 
    "topicId": 10094, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 127224993, 
    "prevInTime": 10108, 
    "contentTrasformed": false, 
    "postDate": "1071691304", 
    "canDelete": false, 
    "nextInTopic": 10112, 
    "prevInTopic": 10107, 
    "headers": {
        "inReplyToHeader": "PDIwMDMxMjE3MTkyOTE2Ljk1MTEucW1haWxAd2ViNjAzMDYubWFpbC55YWhvby5jb20+", 
        "messageIdInHeader": "PDNGRTBCNjI4LjUwMTA4QHJvZ2Vycy5jb20+", 
        "referencesHeader": "PDIwMDMxMjE3MTkyOTE2Ljk1MTEucW1haWxAd2ViNjAzMDYubWFpbC55YWhvby5jb20+"
    }
}