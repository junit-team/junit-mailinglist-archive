{
    "numMessagesInTopic": 1, 
    "nextInTime": 7081, 
    "senderId": "2ocn163qVyDIAfYx3yOerMzxAY6uB-al67RFTFfyZ4tR2ml5CJ4tNKanrMZUUPFEQpL_v0LfIGj1wq22J3rL6LjcNhMA97X9KA9SJUO3", 
    "systemMessage": false, 
    "subject": "Testing Philosophy", 
    "from": "Eric Armstrong &lt;eric.armstrong@...&gt;", 
    "authorName": "Eric Armstrong", 
    "msgSnippet": "I often heard the unit-testing advice that you should test the things you need confidence in, rather than anally testing everything in sight. That advice has", 
    "msgId": 7080, 
    "profile": "ericsilverlight", 
    "topicId": 7080, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 78994084, 
    "messageBody": "<div id=\"ygrps-yiv-419388796\">I often heard the unit-testing advice that you should test the things<br/>\nyou need confidence in, rather than anally testing everything in sight.<br/>\nThat advice has been expressed in a variety of ways, including &quot;test<br/>\nuntil you&#39;re bored&quot;, and it seems like sound advice to me. I&#39;m curious,<br/>\nhowever, as to how that advice squares with the notion of TDD.<br/>\n<br/>\nAmong other things, testing only the important bits means being<br/>\nable to skip tests for setters and for getters. It also means not having<br/>\n<br/>\nto write a test for the main loop that merely says &quot;process every item<br/>\nin the input collection&quot;, and get down to the nitty gritty of ensuring<br/>\nthat<br/>\nthe processing steps actually work.<br/>\n<br/>\nIn TDD, on the other hand, I understand that one is not supposed to<br/>\nwrite a scrap of code until one has first written the failing test for<br/>\nit.<br/>\nThis philosophy has two intriguing features:<br/>\n   * 100% code coverage<br/>\n       Because nothing gets written that doesn&#39;t have a test in the<br/>\nfirst place.<br/>\n<br/>\n   * Un-prejudiced design<br/>\n      So you wind up creating the abstractions you really need, instead<br/>\n      of the ones you first conceive of. The example of the multi-room<br/>\n      game was illuminating in that respect. Instead of having a Room<br/>\n      class, as one might expect, simple integers were all that was<br/>\n      actually needed to represent a room. (Where did I read that?)<br/>\n<br/>\nBut writing tests first seems fundamentally incompatible with the notion<br/>\n<br/>\nof testing only what you need to test. Or am I being anal about the<br/>\nTDD idea, and in fact, &quot;simple&quot; code is written without first writing<br/>\ntests?<br/>\n(Or is there some other unifying idea I&#39;m missing.)<br/>\n<br/>\nAs an aside, I&#39;m curious to know if in TDD it is &quot;kosher&quot; to write<br/>\na failing test, examine the results and, if they look good, plug them<br/>\ninto the test. My thoughts so far are:<br/>\n   1) It feels like cheating, because the test will then succeed even<br/>\n        if my examination failed.<br/>\n<br/>\n   2) I&#39;m especially inclined to do it when the results are big, because<br/>\n<br/>\n       it&#39;s so hard to manually generate the results I expect. But that<br/>\n       means:<br/>\n          a) It&#39;s even more likely that the visual examination will<br/>\noverlook<br/>\n              something.<br/>\n          b) Taking advantage of the ability to cut and paste results<br/>\nmay<br/>\n              incline me to make larger tests than I really should be<br/>\nmaking.</div>", 
    "prevInTime": 7079, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1046291603", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PDNFNUQyNDkzLjRGRkI5QjJBQHN1bi5jb20+"
    }
}