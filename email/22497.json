{
    "numMessagesInTopic": 9, 
    "nextInTime": 22498, 
    "senderId": "1CNA24hfEuOJySJBkUhm1Juv1QJjyy6ekxeCVm_z9cpPaSfoUPHwjVT10NamuN1jMK-OZF6mc9aO34Vn4T-F78UvmQiZTNZVLjkNJ5CrIUKTwlGA3iva", 
    "systemMessage": false, 
    "subject": "RE: [junit] [RT] JUnit Core, Parallelism, Documentation", 
    "from": "&quot;Loritsch, Berin C.&quot; &lt;berin.loritsch@...&gt;", 
    "authorName": "Loritsch, Berin C.", 
    "msgSnippet": "Well, getting to the core, it is not very clear what is the _internal_ API and what is the _external_ API.  For something like JUnit there are actually two", 
    "msgId": 22497, 
    "profile": "bloritsch", 
    "topicId": 22487, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 428096731, 
    "messageBody": "<div id=\"ygrps-yiv-1338293048\">Well, getting to the core, it is not very clear what is the _internal_<br/>\nAPI and what is the _external_ API.  For something like JUnit there are<br/>\nactually two external APIs to worry about:<br/>\n<br/>\n <br/>\n<br/>\n*         The API for Test Writers<br/>\n<br/>\n*         The API for IDE/tool writers<br/>\n<br/>\n <br/>\n<br/>\nThe JavaDocs do have to be very clear on what is likely to change, and<br/>\nwhat is meant to be stable.  This approach allows you to clean up cruft<br/>\nover time.<br/>\n<br/>\n <br/>\n<br/>\nThe first misstep I saw was the move from using the Description object<br/>\nto build the tree of tests to using a Plan to build the tree of tests.<br/>\nThe addChild() and getChildren() methods of the Description object are<br/>\ndeprecated, yet JUnit creates the Plan from the description object.  I<br/>\nbelieve that the new direction of using a Plan instead of a hierarchy of<br/>\ndescriptions is the correct one from a conceptual standpoint.<br/>\n<br/>\n <br/>\n<br/>\nThe API for testers is pretty well understood, and I would be very<br/>\nresistant to arbitrarily changing that.  I think most people would be as<br/>\nwell.<br/>\n<br/>\n <br/>\n<br/>\nWhat is less understood is where JUnit is designed to integrate with<br/>\nIDEs and tool vendors.  How much of the Computer/Plan/Filtering/Ordering<br/>\ndo we want to expose?  What are we confident with?  The rest, as they<br/>\nsay, making sure our internals work with that spec.  None of the<br/>\ninternals should rely on deprecated features.  Anything in the<br/>\n&quot;internal&quot; package should be considered, by definition, internal.  That<br/>\nmeans anything in there that is deprecated should be free to be removed.<br/>\n<br/>\n <br/>\n<br/>\nAt least, this is how I&#39;ve evolved libraries before (I&#39;ve worked on a<br/>\nfew Apache projects in the past). <br/>\n<br/>\n <br/>\n<br/>\n <br/>\n<br/>\nFrom: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a> [mailto:<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>] On Behalf Of<br/>\nDavid Saff<br/>\nSent: Tuesday, March 02, 2010 9:32 AM<br/>\nTo: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a><br/>\nSubject: Re: [junit] [RT] JUnit Core, Parallelism, Documentation<br/>\n<br/>\n <br/>\n<br/>\n  <br/>\n<br/>\nBerin,<br/>\n<br/>\nThanks for this! I can&#39;t touch here on all of your ideas, so feel<br/>\nfree to repeat any points you&#39;d like to prioritize in the discussion.<br/>\n<br/>\nWith regard to deprecation, we&#39;ve definitely begun to feel the weight<br/>\nof the old code, but have indeed felt that it&#39;s not clear whether<br/>\nbeing very aggressive would be in the best interests of users: thanks<br/>\nto the fact that many users of tools like Eclipse and Maven have their<br/>\nJUnit version automatically updated without explicit intervention,<br/>\nit&#39;s easy to be the cause of breaking something that&#39;s been working<br/>\nfor years. That said, I think it is time for a little housecleaning.<br/>\nI&#39;ve mentioned to Kent that we should do a codesearch.google.com<br/>\nsmackdown, and start kicking the least-used public method or class<br/>\n&quot;off the island&quot; with each release.<br/>\n<br/>\nAs you mention, I think that the biggest obstacle to real parallelism<br/>\nis an replacement or enhancement of the BeforeClass/AfterClass idiom<br/>\nthat is well-defined outside of a single-threaded execution. As two<br/>\nexamples, (1) it&#39;s not well-defined whether a BeforeClass method<br/>\nshould be able to be run more than once per test suite execution, (2)<br/>\nit&#39;s not well-defined whether one class can correctly start before<br/>\nanother class&#39;s AfterClass method has been called.<br/>\n<br/>\nDavid<br/>\n<br/>\nOn Mon, Mar 1, 2010 at 5:17 PM, Loritsch, Berin C.<br/>\n&lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:berin.loritsch@...\">berin.loritsch@...</a> &lt;mailto:berin.loritsch%40gd-ais.com&gt; &gt; wrote:<br/>\n<blockquote><span title=\"ireply\"> &gt; RT = Random Thought.  It&#39;s a habit I picked up from Stefano Mazzocchi<br/>\n&gt; when I used to work with him on the Cocoon project.  Essentially, it&#39;s<br/>\n </span></blockquote>a<br/>\n<blockquote><span title=\"ireply\"> &gt; structured brain dump based on observations of the internals of a<br/>\n&gt; project (as such it is longer than most posts).  My apologies if this<br/>\n </span></blockquote>is<br/>\n<blockquote><span title=\"ireply\"> &gt; not the forum for this.<br/>\n&gt;<br/>\n&gt; == Code Maintenance Thoughts ==<br/>\n&gt;<br/>\n&gt; I&#39;ve been going through some of the JUnit Core to add some JavaDocs<br/>\n&gt; (it&#39;s in my forked copy if you want me to do a Push request), and made<br/>\n </span></blockquote>a<br/>\n<blockquote><span title=\"ireply\"> &gt; few observations.  I can definitely see how JUnit has begun to evolve<br/>\n&gt; over the years, and as is natural with a couple missteps along the<br/>\n </span></blockquote>way.<br/>\n<blockquote><span title=\"ireply\"> &gt; It&#39;s hard to get rid of those missteps because some people may have<br/>\n&gt; extended them.  Some of the classes have been deprecated with the<br/>\n&gt; promise that they would be removed in the next revision (as of 4.4)<br/>\n </span></blockquote>and<br/>\n<blockquote><span title=\"ireply\"> &gt; they are still there.  I&#39;m not saying that the current solution is a<br/>\n&gt; misstep, just that it is hard to separate the past ones from the<br/>\n </span></blockquote>current<br/>\n<blockquote><span title=\"ireply\"> &gt; preferred solution.<br/>\n&gt;<br/>\n&gt; Part of managing a codebase like this includes separating the public<br/>\n </span></blockquote>and<br/>\n<blockquote><span title=\"ireply\"> &gt; private API.  Some of that has been done with the &quot;internal&quot; package.<br/>\n&gt; There is no reason to worry about deprecating classes and methods in<br/>\n </span></blockquote>the<br/>\n<blockquote><span title=\"ireply\"> &gt; internal package because they are not part of the public API.  But I<br/>\n </span></blockquote>did<br/>\n<blockquote><span title=\"ireply\"> &gt; notice that when some classes got moved, the old class in full was<br/>\n </span></blockquote>kept<br/>\n<blockquote><span title=\"ireply\"> &gt; in the original location.  A low maintenance way of performing a move<br/>\n&gt; like that makes use of inheritance.  Essentially the newer class is<br/>\n&gt; moved so there is one maintenance location, and the deprecated class<br/>\n&gt; extends the newer class.  Kind of like how the JUnit4 runner provides<br/>\n </span></blockquote>a<br/>\n<blockquote><span title=\"ireply\"> &gt; preferred alias to the BlockJUnit4Runner class.<br/>\n&gt;<br/>\n&gt; Part of the core includes a nice little callback interface (the<br/>\n&gt; RunListener).  I imagine that a number of integrations make good use<br/>\n </span></blockquote>of<br/>\n<blockquote><span title=\"ireply\"> &gt; this little class.  However, with the implementation as it is<br/>\n </span></blockquote>currently<br/>\n<blockquote><span title=\"ireply\"> &gt; written, the RunListener can affect the run performance and<br/>\n </span></blockquote>parallelism<br/>\n<blockquote><span title=\"ireply\"> &gt; available.  Essentially, the act of calling a method is a synchronous<br/>\n&gt; function.  That means a poorly written runner can detrimentally affect<br/>\n&gt; the performance of JUnit.  The one that is included with JUnit is<br/>\n </span></blockquote>pretty<br/>\n<blockquote><span title=\"ireply\"> &gt; tame, doing the absolute minimum it has to do to track the test<br/>\n&gt; progress.  However, if your tests execute slower in an IDE than with<br/>\n&gt; JUnit alone, it&#39;s probably the RunListener slowing things down.<br/>\n&gt;<br/>\n&gt; == Parallelism Thoughts ==<br/>\n&gt;<br/>\n&gt; Some of the architectural decisions in JUnit&#39;s core definitely reflect<br/>\n&gt; the synchronous nature that the tests were designed to be written.  I<br/>\n&gt; don&#39;t think there is going to be an easy solution to that problem,<br/>\n&gt; unless you stick to a test class per thread model.  More on that a bit<br/>\n&gt; latter.<br/>\n&gt;<br/>\n&gt; When designing for parallel execution of tests (the ParallelComputer<br/>\n&gt; hints at this), you usually don&#39;t want an unbounded number of threads<br/>\n </span></blockquote>to<br/>\n<blockquote><span title=\"ireply\"> &gt; be executed in the system.  A fairly common approach to taming the<br/>\n&gt; thread/work apportioning beast is to use queues and worker threads.<br/>\n&gt; Essentially, each test (including the set up and tear down parts) gets<br/>\n&gt; pushed on to the queue, while the executor pops it off on the other<br/>\n </span></blockquote>side<br/>\n<blockquote><span title=\"ireply\"> &gt; in another process.  Essentially the relationship to executors to work<br/>\n&gt; queues depends on whatever rules you&#39;ve set up.  For JUnit a simple<br/>\n&gt; mapping of executors to the number of processors (cores) or some<br/>\n&gt; multiple of that would be sufficient.  This model is closer to how JMS<br/>\n&gt; works without all the quality of service overhead.  As the executor<br/>\n </span></blockquote>runs<br/>\n<blockquote><span title=\"ireply\"> &gt; the test, it sends notification objects to the notification queue.<br/>\n&gt; Using one line of ASCII art, the process looks like this:<br/>\n&gt;<br/>\n&gt; Classes/Suite ==&gt; Executor ==&gt; Notifier<br/>\n&gt;<br/>\n&gt; Each &quot;==&gt;&quot; represents a queue.  The notification mechanism then<br/>\n </span></blockquote>becomes<br/>\n<blockquote><span title=\"ireply\"> &gt; more like Swing events.  We could even cheat and use an Java 5 enum<br/>\n </span></blockquote>for<br/>\n<blockquote><span title=\"ireply\"> &gt; the types of events.  This provides the same interface for all the<br/>\n&gt; events, and the convenience of an enum for determining the type of<br/>\n&gt; event.  If we take this approach a step further, if we substitute a<br/>\n&gt; PriorityQueue for the first queue, we get a way to prefer some tests<br/>\n&gt; over others (e.g. using categories as a priority mechanism).<br/>\n </span></blockquote>Collecting<br/>\n<blockquote><span title=\"ireply\"> &gt; the results in a separate thread than they are being executed protects<br/>\n&gt; the execution of tests from poorly written listeners.<br/>\n&gt;<br/>\n&gt; We could go to a very fine level of detail (i.e. each individual test)<br/>\n&gt; if it weren&#39;t for the class setup/tear down methods.  Those kind of<br/>\n&gt; tests would force some sort of ordering.  It&#39;s not entirely<br/>\n </span></blockquote>impossible,<br/>\n<blockquote><span title=\"ireply\"> &gt; but does require more care.<br/>\n&gt;<br/>\n&gt; Such an approach may be over-engineering things a bit, and for short<br/>\n&gt; runs of a couple hundred tests that takes less than a second to run<br/>\n&gt; definitely overkill.  However for larger projects with much larger<br/>\n&gt; execution times, it may be a way to short circuit the execution a bit.<br/>\n&gt; Essentially the win here would be the ability to execute tests while<br/>\n&gt; they are still being parsed and prepared.  That can help with things<br/>\n&gt; like Theories where collecting a large number of DataPoints can have a<br/>\n&gt; profound impact on the time it takes to run.<br/>\n&gt;<br/>\n&gt; It would be pretty easy to ensure that no more than n+2 threads are<br/>\n </span></blockquote>used<br/>\n<blockquote><span title=\"ireply\"> &gt; in a system, where n = Runtime.availableProcessors().<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; [Non-text portions of this message have been removed]<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; ------------------------------------<br/>\n&gt;<br/>\n&gt; Yahoo! Groups Links<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n </span></blockquote>[Non-text portions of this message have been removed]</div>", 
    "prevInTime": 22496, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1267552042", 
    "canDelete": false, 
    "nextInTopic": 22498, 
    "prevInTopic": 22494, 
    "headers": {
        "inReplyToHeader": "PDRmN2RhNmI5MTAwMzAyMDYzMW82ZjgyMGQyN2tiMTU5NzcwYzlkN2NhMWNhQG1haWwuZ21haWwuY29tPg==", 
        "messageIdInHeader": "PDc1RjVFRDhBNUE1NTM2NDZBNDZFMDBFNkVDODU0RkEzMDQ0Qjk5RTRAdmFmZjAxLW1haWwwMS5hZC5nZC1haXMuY29tPg==", 
        "referencesHeader": "PDc1RjVFRDhBNUE1NTM2NDZBNDZFMDBFNkVDODU0RkEzMDQ0Qjk3RjJAdmFmZjAxLW1haWwwMS5hZC5nZC1haXMuY29tPiA8NGY3ZGE2YjkxMDAzMDIwNjMxbzZmODIwZDI3a2IxNTk3NzBjOWQ3Y2ExY2FAbWFpbC5nbWFpbC5jb20+"
    }
}