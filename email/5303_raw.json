{
    "topicId": 5186, 
    "postDate": "1025697270", 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "from": "Mark Meyers &lt;markm@...&gt;", 
    "canDelete": false, 
    "replyTo": "LIST", 
    "senderId": "KFv-Zs5ecH0xioHVL3eh9BpIsFi3c9CsYcuAB4pNvz7hrAEYw4wWm5Zk0q0gx3Qb_moF7bMHSgRWE_tcOxDOv__Cvm88lSeY9cTxPCCW", 
    "nextInTime": 5304, 
    "userId": 61568997, 
    "prevInTime": 5302, 
    "prevInTopic": 5300, 
    "headers": {
        "messageIdInHeader": "PEM0NTBEOTY2NjRDQkQzMTE4MkI2MDBBMEM5NzY2OEIxNjQ4MENBQENBU0UwNTI+"
    }, 
    "authorName": "Mark Meyers", 
    "numMessagesInTopic": 67, 
    "msgSnippet": "... should be assertTrue( ... , true), sorry. ... That is correct, I think if you are concerned about illegal input generating exceptions, you should handle", 
    "contentTrasformed": false, 
    "msgId": 5303, 
    "nextInTopic": 5304, 
    "systemMessage": false, 
    "rawEmail": "Return-Path: &lt;markm@...&gt;\r\nX-Sender: markm@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (EGP: mail-8_0_7_4); 3 Jul 2002 11:58:36 -0000\r\nReceived: (qmail 28093 invoked from network); 3 Jul 2002 11:58:36 -0000\r\nReceived: from unknown (66.218.66.218)\n  by m5.grp.scd.yahoo.com with QMQP; 3 Jul 2002 11:58:36 -0000\r\nReceived: from unknown (HELO smtp1.pandora.be) (195.130.132.33)\n  by mta3.grp.scd.yahoo.com with SMTP; 3 Jul 2002 11:58:36 -0000\r\nReceived: (qmail 20385 invoked from network); 3 Jul 2002 11:58:35 -0000\r\nReceived: from unknown (HELO tartarus.telenet-ops.be) ([195.130.132.34]) (envelope-sender &lt;markm@...&gt;)\n          by hercules.telenet-ops.be (qmail-ldap-1.03) with SMTP\n          for &lt;junit@yahoogroups.com&gt;; 3 Jul 2002 11:58:35 -0000\r\nReceived: from localhost (localhost.localdomain [127.0.0.1])\n\tby tartarus.telenet-ops.be (Postfix) with SMTP id 84AD5DC460\n\tfor &lt;junit@yahoogroups.com&gt;; Wed,  3 Jul 2002 13:58:35 +0200 (CEST)\r\nReceived: from case052.minervasoftcare.com (D5767812.kabel.telenet.be [213.118.120.18])\n\tby tartarus.telenet-ops.be (Postfix) with ESMTP id 5DFB5DC33B\n\tfor &lt;junit@yahoogroups.com&gt;; Wed,  3 Jul 2002 13:58:35 +0200 (CEST)\r\nReceived: by CASE052 with Internet Mail Service (5.5.2653.19)\n\tid &lt;31J4QDBY&gt;; Wed, 3 Jul 2002 13:54:31 +0200\r\nMessage-ID: &lt;C450D96664CBD31182B600A0C97668B16480CA@CASE052&gt;\r\nTo: &quot;&#39;junit@yahoogroups.com&#39;&quot; &lt;junit@yahoogroups.com&gt;\r\nSubject: RE: [junit] Re: distinguishing between failures and errors\r\nDate: Wed, 3 Jul 2002 13:54:30 +0200 \r\nMIME-Version: 1.0\r\nX-Mailer: Internet Mail Service (5.5.2653.19)\r\nContent-Type: text/plain;\n\tcharset=&quot;iso-8859-1&quot;\r\nFrom: Mark Meyers &lt;markm@...&gt;\r\nX-Yahoo-Group-Post: member; u=61568997\r\n\r\n\n\n&gt; -----Original Message-----\n&gt; From: Daniel Barclay \n&gt; \n&gt; &gt; From: Mark Meyers \n&gt; &gt; \n&gt; &gt; \n&gt; &gt; &gt; From: Daniel Barclay  \n&gt; &gt; ...\n&gt; &gt; &gt; (How can a test show that the caller is responsible for not \n&gt; &gt; &gt; passing in a null pointer?\n&gt; &gt; &gt; \n&gt; &gt; \n&gt; &gt; I disagree, how about:\n&gt; &gt; \ttry{\n&gt; &gt; \t    instance.someMethod(null);\n&gt; &gt; \t    fail(&quot;someMethod should not accept null&quot;);\n&gt; &gt; \t}catch(IllegalArgumentException e){\n&gt; &gt; \t    assertTrue(&quot;Client code should check for null arguments&quot;);\n&gt; &gt; \t}\n&gt; \n&gt; (Is that code correct?  Is there an assertTrue(String) method?)\n&gt; \n\nshould be assertTrue(&quot;...&quot;, true), sorry.\n\n&gt; Your call to fail(...) says that the method must throw an \n&gt; IllegalArgumentException when passed a null pointer.  \n&gt; \n&gt; That is _not_ the same as saying that the caller must not pass in\n&gt; null.\n&gt; \n\nThat is correct, I think if you are concerned about illegal input generating\nexceptions,\nyou should handle them. The problem is that the argument is illegal, not\nthat the current implementation \ncan&#39;t cope with it. What I was trying to say is that the concern you try to\nput in a test, is really a \nconcern you want to put in the implementation.\n\n&gt; \n&gt; In your case, a caller is allowed to use the method to detect null \n&gt; pointers.  \n&gt; \n\nNo. In either case, the behavior is not documented, except in the Tests.\nNullPointerException and IllegalArgumentException are both unchecked. I just\nthink IllegalArgumentException is a better \ndescription of what goes wrong.\n\n&gt; In my case, a caller cannot expect any particular behavior.  \n&gt; (Maybe the \n&gt; method throws IllegalArgumentException.  Maybe it returns a \n&gt; bogus result.\n&gt; Maybe it gets stuck in an endless loop.  Maybe it makes something else\n&gt; fail 10000 calls later in another method.  Maybe it crashes \n&gt; the VM (via \n&gt; JNI).)\n&gt; \n&gt; \n\nSo, check the input parameter before The Apocalypse...\n\n&gt; \n&gt; &gt; &gt; You can&#39;t test for any particular behavior from the callee\n&gt; &gt; &gt; if the callee&#39;s behavior in the face of a null pointer is \n&gt; &gt; &gt; intentially left undefined (e.g., for flexibility in \n&gt; &gt; &gt; implementing an interface).)\n&gt; &gt; &gt; \n&gt; &gt; \n&gt; &gt; The callee is the class being tested, the specifics for different\n&gt; &gt; implementations could be implemented\n&gt; &gt; in specific TestCases, \n&gt; \n&gt; Why test for behavior that is (intentionally) undefined?\n&gt; \n&gt; Consider a method that is defined to return &quot;an instance of some \n&gt; class implementing interface I.&quot;  In that specification, the\n&gt; particular class is undefined.\n&gt; \n&gt; If your implementation currently uses a class C, why test that \n&gt; the returned instance is of class C?  Why constrain yourself from\n&gt; returning an instance of class D, as long as you still return\n&gt; &quot;an instance of some class implementing interface I&quot;?\n&gt; \n\nWell, you would have tests for class C and D ? (Concrete implementations for\nI).\nThen you probably would have an abstract super class TestI for TestC and\nTestD.\nWhat I meant is if you want to make sure an implementation of I never calls\ncallee&#39;s someMethod(...) with a null argument, this is really a condition\nfor\nthe caller, and must be tested in TestC or TestD. Which is somewhat awkward.\nSo, throwing an IllegalArgumentException is more elegant and much simpler.\n(You don&#39;t need to know about callers being implemented)\n\n&gt; If you test for class C and treat tests as documentation, then \n&gt; that implies that a caller is allowed to depend on the fact that \n&gt; you return class C.  That is usually _not_ at all what you want.\n&gt; \n&gt; \n&gt; \n&gt; &gt; &gt; (How can a test show that a caller is responsible for not\n&gt; &gt; &gt; depending on certain current behavior of an implementation\n&gt; &gt; &gt; that is not part of the interface contract?)\n&gt; &gt; &gt; \n&gt; &gt; \n&gt; &gt; It can&#39;t, the caller&#39;s TestCase should do that. And possibly \n&gt; \n&gt; What caller?  That is, no caller necessarily even exists yet. \n&gt; So no, the caller&#39;s test case cannot do that.  \n&gt; \n\nThat is the point. It is the responsibility of the caller(s) not to depend\non internal implementation.\nAnd if you have a concern about the possibility, and think it&#39;s dangerous to\nallow such dependencies, your problem as an implementor of the callee, is to\nmake your code sufficiently robust to prevent that happening.\n\n&gt; (And how could a test case for a caller detect whether that \n&gt; caller passes a null pointer to the called method?)\n&gt; \n&gt; \n&gt; &gt; the callee&#39;s\n&gt; &gt; documentation.\n&gt; \n&gt; EXACTLY--documentation, not just tests!!!\n&gt; \n\nI agree you need documentation (javadoc, How-To, specs, whatever) when\n&quot;publishing&quot; code as an API or framework.\nBut dependencies on paper copies of programmer intent _inside_ a project is\ndangerous. Tests are safer.\n\n&gt; \n&gt; \n&gt; &gt; &gt; Because tests, being code, can&#39;t relate code to external \n&gt; concepts.  \n&gt; &gt; &gt; \n&gt; &gt; &gt; (A specification can say that a function f returns the \n&gt; mathematical\n&gt; &gt; &gt; sum of two given integers subject to the limitations of 32-bit\n&gt; &gt; &gt; signed binary arithmetic.  How can a test say something \n&gt; like that?)\n&gt; &gt; &gt; \n&gt; &gt; \n&gt; &gt; \ttry{\n&gt; &gt; \t    int result = instance.f(Integer.MAX_VALUE, \n&gt; &gt; Integer.MAX_VALUE);\n&gt; &gt; \t    fail(&quot;f should throw Exception when integer limits \n&gt; &gt; are met&quot;);\n&gt; &gt; \t}catch(IllegalStateException e){\n&gt; &gt; \t    assertTrue(&quot;function f returns the mathematical sum \n&gt; &gt; of two given\n&gt; &gt; integers subject to the limitations of 32-bit&quot;);\n\n(sorry again, assertTrue(&quot;...&quot;, true)...)\n\n&gt; \n&gt; Hmm.  I thought you were talking about having the test logic/behavior\n&gt; define the method behavior.\n&gt; \n&gt; You can stick documentation text in the test case code, but I don&#39;t\n&gt; think that changes the fact that it&#39;s human-parsed documentation.\n&gt; \n&gt; \n&gt; I do grant that your example shows that documentation doesn&#39;t have to \n&gt; be in some place separate from the tests. \n&gt; \n&gt; Hey--I have an idea.  You know how Javadoc 1.4 can provide links to \n&gt; the source?  Maybe (ideally, fantasy-land, etc.) it could \n&gt; provide links \n&gt; to the test case source too.\n&gt; \n&gt; \n\nNo, I didn&#39;t know that. Would be nice in a project.\nNext we can google search through our code ;-)\nWell, I like this discussion a lot. Makes me think about\ncode/test in another way, Thanks;\n\n&gt; \n&gt; Daniel\n&gt; \n\n", 
    "subject": "RE: [junit] Re: distinguishing between failures and errors"
}