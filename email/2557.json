{
    "numMessagesInTopic": 10, 
    "nextInTime": 2558, 
    "senderId": "rwOaFCQ8xIsKq6JoE5X3eBlZwf2MX2Xm9MWmBl5FAj5AOncu3HzAy1AlHTzX5lUi6AVS6waIvzo2pJHnB9K9TZPxhPm7", 
    "systemMessage": false, 
    "subject": "Re: [junit] Failing multiple times in one test", 
    "from": "Eric Vought &lt;evought@...&gt;", 
    "authorName": "Eric Vought", 
    "msgSnippet": "I have a test routine called EnumerationEquals(..) which I ve written various variants on for different projects. It takes two Enumerations and compares them", 
    "msgId": 2557, 
    "topicId": 2534, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 0, 
    "messageBody": "<div id=\"ygrps-yiv-784225429\">I have a test routine called EnumerationEquals(..) which I&#39;ve written<br/>\nvarious variants on for different projects. It takes two Enumerations and<br/>\ncompares them for equality, irrespective of order. It returns a hash of<br/>\nthe differences between the enumerations. The fact that it takes<br/>\nEnumerations allows you to test more than just hash keys and it can be<br/>\ntrivially modified to work with Iterators as well.<br/>\n<br/>\nBasically, you just take each element from the first enum and add it to a<br/>\nlocal hash with a dummy key. Then you walk through the second enum and<br/>\nsubtract keys that match ones already in the hash (or change the value).<br/>\nIf you find an element in the second enum not in the hash, you set it with<br/>\nanother distinctive value. If you have keys left in the hash when you are<br/>\ndone, you know there are elements in the first enum that are not in the<br/>\nsecond. If it fails, you can print the table to get quite clear and useful<br/>\ndiagnostics.<br/>\n<br/>\nThis gives you one testcase with one pass-or-fail, but gives you the<br/>\ndebugging ease you are looking for. Better, you can stick this routine in<br/>\nyour toolbox and reuse it all over the place. Once I had something like<br/>\nthis available, I found myself writing trivial tests for things that I had<br/>\nbeen avoiding before.<br/>\n<br/>\n<blockquote><span title=\"qreply\"> On Mon, 3 Sep 2001, Laurent Duperval wrote:<br/>\n<br/>\n&gt; On  1 Sep, J. B. Rainsberger wrote:<br/>\n&gt; &gt;&gt;I&#39;m writing a test whose purpose is to make sure that a Hashtable contains<br/>\n&gt; &gt; a<br/>\n&gt; &gt;&gt;certain set of keys. Basically, the test will make sure that someone<br/>\n&gt; &gt; filling<br/>\n&gt; &gt;&gt;out a form on the web provides all the mandatory info<br/>\n&gt; &gt;<br/>\n&gt; &gt; Hashtable? Tsk, tsk... why aren&#39;t you using Map instead? :)<br/>\n&gt; &gt;<br/>\n&gt;<br/>\n&gt; Uhm... What&#39;s the diff?<br/>\n&gt;<br/>\n&gt; &gt;&gt;I&#39;d like a way to make<br/>\n&gt; &gt;&gt;the test fail for every parameter that is missing and consider each of the<br/>\n&gt; &gt;&gt;iterations as one test.<br/>\n&gt; &gt;<br/>\n&gt; &gt; Silly question: why? Does it matter whether one, two or ten parameters are<br/>\n&gt; &gt; not handled correctly? I think it matters more whether they are all<br/>\n&gt; &gt; handled correctly, or not.<br/>\n&gt; &gt;<br/>\n&gt;<br/>\n&gt; It does but the fact that one parameter fails may have nothing to do with<br/>\n&gt; the fact that another fails since validation may be occuring in different<br/>\n&gt; parts of the code. By failing once per invalid parameter, you are<br/>\n&gt; immediately pointed to the proper place to debug. And if the test lists all<br/>\n&gt; the parameters that failed, a developer could possibly see a pattern, which<br/>\n&gt; also helps in debugging.<br/>\n&gt;<br/>\n&gt; &gt; Also, who cares how many tests there are? Do you? Your manager? I don&#39;t<br/>\n&gt; &gt; want to get into the discussion again about counting tests, but I have<br/>\n&gt; &gt; never really cared how many tests I have, as long as I&#39;m happy with the<br/>\n&gt; &gt; quality of the tests.<br/>\n&gt; &gt;<br/>\n&gt;<br/>\n&gt; No, counting tests wasn&#39;t the motive behind my question.<br/>\n&gt;<br/>\n&gt; &gt; Since JUnit counts test methods by default, you&#39;d need one method per<br/>\n&gt; &gt; parameter. Do you really think that&#39;s a useful thing to do? I don&#39;t.<br/>\n&gt; &gt;<br/>\n&gt;<br/>\n&gt; No, that&#39;s why I asked if there was a better method than what I&#39;m doing now:<br/>\n&gt; I have a StringBuffer to which I add all the parameters that failed and then<br/>\n&gt; use the StringBuffer in fail().<br/>\n&gt;<br/>\n&gt; L<br/>\n&gt;<br/>\n&gt;<br/>\n<br/>\n-- <br/>\nEric Vought<br/>\nChief Technical Officer - QLUE Consulting, Inc.<br/>\n<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:evought@...\">evought@...</a> toll-free: 888-771-3538  RTP area: 919-816-9901 </span></blockquote></div>", 
    "prevInTime": 2556, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "999570241", 
    "canDelete": false, 
    "nextInTopic": 2564, 
    "prevInTopic": 2555, 
    "headers": {
        "inReplyToHeader": "PDIwMDEwOTAzMTkxNjQ4LjJGRDJBNDY4OTFAbGVuYXJkLm1pY3JvY2VsbGk1LmNvbT4=", 
        "messageIdInHeader": "PFBpbmUuTE5YLjQuMzAuMDEwOTAzMjIxNDI4MC4xNDU1LTEwMDAwMEBicmFpbi5xbHVlLWxhbj4="
    }
}