{
    "numMessagesInTopic": 27, 
    "nextInTime": 7267, 
    "senderId": "EWjrOYQh4FFz0vtJunUdaNYQoOGN2fYalzE0ENWllvy_mj-ls-d_nUB4bCLWF5WCpnpNV6GljBKJSoxX4GPYKJIyVUjVv2HHyvYOaPVY", 
    "systemMessage": false, 
    "subject": "JUnit Design?", 
    "from": "Eric Armstrong &lt;eric.armstrong@...&gt;", 
    "authorName": "Eric Armstrong", 
    "msgSnippet": "(lengthy, philosophical, article-length) (grab a cup of coffee) Summary ... At the same time that SuiteRunner provides some useful extensions to JUnit (api", 
    "msgId": 7266, 
    "profile": "ericsilverlight", 
    "topicId": 7266, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 78994084, 
    "messageBody": "<div id=\"ygrps-yiv-385555461\">(lengthy, philosophical, article-length)<br/>\n(grab a cup of coffee)<br/>\n<br/>\nSummary<br/>\n-------<br/>\nAt the same time that SuiteRunner provides some <br/>\nuseful extensions to JUnit (api signature testing,<br/>\nnetwork testing), it also provides some interesting <br/>\nsimplifications. Determining whether those simplifications <br/>\nare dual-edged swords requires both a better understanding  <br/>\nof the motivations behind the JUnit design, and a better<br/>\nunderstanding of the motivations for SuiteRunner&#39;s<br/>\nrefactoring.<br/>\n<br/>\nIntroduction<br/>\n------------<br/>\nI spent a little time looking at Artima SuiteRunner<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.artima.com/suiterunner/\">http://www.artima.com/suiterunner/</a><br/>\n<br/>\nAfter looking at the API documentation and the tutorial<br/>\nat <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.artima.com/suiterunner/tutorial.html,\">http://www.artima.com/suiterunner/tutorial.html,</a> I<br/>\nfound that I had some questions about some of the<br/>\nmotivations behind JUnit&#39;s current design, and I suspect<br/>\nthat a comparison of the the two systems will help <br/>\nbring out the rationale behind JUnit, to make a better<br/>\nbasis for comparison.<br/>\n<br/>\nThis post compares SuiteRunner and JUnit in several areas:<br/>\n  * Conceptual Underpinnings<br/>\n  * Test Sequencing<br/>\n  * Class Structure<br/>\n  * Assertion Syntax<br/>\n<br/>\nConceptual Underpinnings<br/>\n------------------------<br/>\nThe most appealing feature of SuiteRunner that I see<br/>\nat the moment is it&#39;s conceptual simplicity:<br/>\n  * Suites contain tests<br/>\n  * Suites are classes, tests are methods<br/>\n  * Suites can also contain other suites<br/>\n  * You run a suite, and send the results to a reporter<br/>\n  * There&#39;s a graphic reporter, an HTML reporter, and<br/>\n    a text reporter, as well as examples of custom<br/>\n    XML reporters.<br/>\n<br/>\nThere are also some additional facilities:<br/>\n  * SuiteRunner can run existing JUnit tests (since it&#39;s<br/>\n    intended as an &quot;upgrade&quot;).<br/>\n<br/>\n  * You can create &quot;recipes&quot; (property files) for additional<br/>\n    control when executing tests. (For example, you can<br/>\n    change the directory path settings to select a different<br/>\n    version of the libraries used by the tests.)<br/>\n<br/>\nProbably the nicest thing in all this was that there is no<br/>\nconfusion at all as to what is a &quot;test&quot;. In SuiteRunner,<br/>\ntests are methods, and suites are collections of tests <br/>\n(or other suites). End of Story.<br/>\n<br/>\nIn JUnit, on the other hand, a &quot;test&quot; is a class. But a<br/>\n&quot;test&quot; is also a method. That terminology can lead to <br/>\nconfusion, on occasion.<br/>\n<br/>\nSo if SuiteRunner seems to be more intuitive in this<br/>\nrespect, it makes me wonder what it is that motivated<br/>\nJUnit&#39;s current architecture?<br/>\n<br/>\nIt may be that the difference in &quot;test sequencing&quot;<br/>\n(discussed next) can help to explain the difference.<br/>\n<br/>\nTest Sequencing<br/>\n---------------<br/>\nIn SuiteRunner, a suite (class) object is constructed,<br/>\nand all of the tests in it are run. The advantages are:<br/>\n  * performance <br/>\n    The class isn&#39;t recreated for each method.<br/>\n<br/>\n  * sequencing <br/>\n    It&#39;s easy to create a testA, testB sequence, where the<br/>\n    operation of testB uses results generated by testA<br/>\n<br/>\nIn JUnit, on the other hand, the class is reconstructed <br/>\nfor each test method, so each method operates independently.<br/>\n<br/>\nBut it&#39;s clear that a lot of thought went into JUnit&#39;s design.<br/>\nSo what is it that makes &quot;sequential tests&quot; undesirable?<br/>\n<br/>\nAbout once a week, someone shows up on the JUnit mailing list<br/>\nasking a question that is similar to this: &quot;How do I get test2<br/>\nto use the results of test1?&quot;, or its equivalent (often<br/>\nphrased in the form, &quot;How do I specify the sequence in which<br/>\ntests are run?&quot;, where the real goal is the construction of<br/>\ndependent tests. So the question would appear to need a good <br/>\nanswer.<br/>\n<br/>\nOn the other hand, suppose there is an indisputable rationale<br/>\nfor the independence of test methods. Returning to the <br/>\nquestion raised in the &quot;Conceptual Underpinnings&quot; section, <br/>\nit&#39;s now clear that at runtime, a test is *both* a class and a <br/>\nmethod, because a JUnit test class will only ever run one <br/>\ntest method, and it will do so in a pristine object created<br/>\nfrom that class.<br/>\n<br/>\nOn the other hand, the *syntax* of a JUnit test class clearly <br/>\ndepicts the class as a collection of test methods. <br/>\n<br/>\nThe question then becomes, is there a way to eliminate the<br/>\nsemantic confusion? At runtime, a test is a class, and a <br/>\ntest is a method. They are one and the same. But when we&#39;re<br/>\ntalking about Junit &quot;tests&quot;, it&#39;s often not clear whether <br/>\nwe are talking about a collection of methods or a<br/>\ncollection of classes. (A confusion that led to at least one<br/>\nmajor misunderstanding by the author, reflected in an earlier<br/>\npost.)<br/>\n<br/>\nClass Structure<br/>\n---------------<br/>\nThen there is the matter of class structure. The SuiteRunner<br/>\ntutorial says:<br/>\n  &quot;you can think of class Suite as the JUnit types<br/>\n   TestCase, TestSuite, Assert, and Test all collapsed<br/>\n   into one type&quot;<br/>\n<br/>\nAgain, the major value appears to be conceptual simplicity. <br/>\nIn particular, you don&#39;t have the difficult-to-follow<br/>\nstructure where TestCase extends Assert and implements Test.<br/>\n<br/>\nSo that raises the question: What was it that made those 4 class<br/>\ntypes appear to be valuable? What motivated that design?<br/>\n<br/>\n  Sidebar/Note:<br/>\n  The SuiteRunner article, &quot;Why We Refactored JUnit&quot;, at<br/>\n  <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.artima.com/suiterunner/why.html\">http://www.artima.com/suiterunner/why.html</a><br/>\n<br/>\n  doesn&#39;t really describe the motivations for refactoring. (A<br/>\n  better title would be &quot;Why We Extended JUnit&quot;. That article<br/>\n  clearly describes the motivations that led to the SuiteRunner<br/>\n  project:<br/>\n    * Signature testing, to test API-compliance<br/>\n    * Better testing of network components <br/>\n<br/>\n  But it doesn&#39;t go into the reasons for collapsing the class<br/>\n  structure. <br/>\n<br/>\n  The article does promise a series of refactoring notes to <br/>\n  discuss such issues. It&#39;s a series I&#39;m greatly forward to. <br/>\n  Between them, and responses to the questions raised here,<br/>\n  I figure to become smarter any day now.<br/>\n<br/>\nAssertion Syntax<br/>\n----------------<br/>\nFinally, there is the fairly minor matter of how you make the<br/>\nclaims that will be validated by the tests. JUnit originally<br/>\nchose:<br/>\n   assert(x)<br/>\n<br/>\nThat was a nice, strong word that said what it meant in no-<br/>\nnonsense terms. Unfortunately, Java 1.4 usurped it, so <br/>\nJUnit had to find an alternative. So it became:<br/>\n   assertTrue(x)<br/>\n<br/>\nThat&#39;s still pretty authoritative, although lenghier.<br/>\n<br/>\nSuiteRunner, on the other hand, chose<br/>\n   verify(x)<br/>\n<br/>\nI&#39;m not very fond of that, actually, because it&#39;s not as<br/>\n&quot;strong&quot; as assert. But then it&#39;s not as long as assertTrue,<br/>\neither.<br/>\n<br/>\n   Note:<br/>\n   My personal preference is &quot;expect&quot;. It seems to be <br/>\n   strong and assertive, yet short and succinct. So that&#39;s<br/>\n   what I chose to implement in my abstract LabExperiment<br/>\n   class, where an expectation-failure leads to sudden death,<br/>\n   rather than a failure-report. (Labs are like interactive<br/>\n   debugging, where test suites are like logging. Both are<br/>\n   important.)<br/>\n<br/>\nBut where JUnit provides a bevy of assertion statements:<br/>\n  * assertTrue<br/>\n  * assertFalse<br/>\n  * assertEquals(String, String)<br/>\n  * assertEquals(float, float)<br/>\n  * assertEquals(long, long)<br/>\n  * assertEquals(boolean, boolean)<br/>\n  * assertEquals(char, char)<br/>\n  * assertEquals(short, short)<br/>\n  * assertEquals(int, int)<br/>\n  * assertNotNull<br/>\n  * assertNull<br/>\n  * assertSame(Object, Object)<br/>\n  * assertNotSame(Object, Object)<br/>\n  * fail<br/>\n  * failSame(Object, Object)<br/>\n  * failNotSame(Object, Object)<br/>\n  * failNotEquals(Object, Object)<br/>\n<br/>\nSuiteRunner chose to implement only a few:<br/>\n    verify(x)<br/>\n    fail<br/>\n<br/>\nIn general, I&#39;m in favor of that simplification. I don&#39;t<br/>\nsee any compelling need to specify:<br/>\n    assertEquals(x,y)<br/>\n<br/>\nrather than<br/>\n    verify(x == y)<br/>\n<br/>\nBut if you want to compare strings in SuiteRunner,<br/>\nyou&#39;ll need to say:<br/>\n    verify(x.equals(y))<br/>\n<br/>\nand if there is a problem, its up to you to figure out what<br/>\nthe difference is and display it.<br/>\n<br/>\n   Note:<br/>\n   The need to do a good job of displaying string differences<br/>\n   motivated LabExperiment to include this method:<br/>\n     expect(String expected, String observed)<br/>\n<br/>\n   (It took quite a while with my nose buried in a <br/>\n    thesaurus to come up with a good pair of terms like<br/>\n    &quot;expected&quot; and &quot;observed&quot;, that are grammatically<br/>\n    parallel and the same length, so that the differences<br/>\n    could be displayed in useful fashion, like this:<br/>\n       expected: |...what you got...|&quot;<br/>\n       observed: |...what you expected...|<br/>\n<br/>\nJUnit also displays what seems to me to be a defect in <br/>\ntheir API construction. The principle I&#39;m used to is that<br/>\noptional parameters go at the end of the parameter list. <br/>\nSo if you have a version of method x that takes parameter a,<br/>\nand one that takes a and b, you define the methods like this:<br/>\n   x(a)<br/>\n   x(a,b)<br/>\n<br/>\nJUnit places their optional &quot;message&quot; parameters at the <br/>\nbeginning of their assert methods, which produces this:<br/>\n   assert(condition)<br/>\n   assert(message, condition)<br/>\n<br/>\nBut SuiteRunner follows the more standard convention:<br/>\n   verify(condition)<br/>\n   verify(condition, message)<br/>\n<br/>\nTo my mind, that makes it somewhat easier to see the <br/>\ncommonalities when reading the APIs, and a tad easier to<br/>\n&quot;tack on&quot; a message at some later date, when using them.<br/>\n<br/>\nThat convention also contributes to readability when a <br/>\npotentially long string is the optional parameter. For<br/>\nexample, compare these two:<br/>\n   assert(&quot;This is a rather long string that describes &quot;<br/>\n         +&quot;the conditions under which the error occurs&quot;,<br/>\n          file.exists()<br/>\n          );<br/>\nand this:<br/>\n   assert(file.exists(),<br/>\n          &quot;This is a rather long string that describes &quot;<br/>\n         +&quot;the conditions under which the error occurs&quot;<br/>\n         );<br/>\n<br/>\nIn the second form, you can see what&#39;s being tested <br/>\nimmediately, and skip right over the text. But in the<br/>\nfirst form, you have to scan through the text to get<br/>\nto the semantics.<br/>\n<br/>\nSo I&#39;m curious if there was any particular motivation<br/>\nfor inverting the expected sequence in JUnit. (It may<br/>\nhave been a simple oversight, or it may have been one<br/>\nof those ideas that &quot;seemed better at the time&quot;, or it<br/>\nmay be that the original authors tended towards very<br/>\nshort messages and very long conditional expressions.<br/>\nThis is a fairly minor point, so its mostly a matter of<br/>\ncuriosity.)<br/>\n<br/>\nConclusions<br/>\n------------<br/>\nAt the same time that SuiteRunner provides some <br/>\nuseful extensions to JUnit, it also provides some<br/>\ninteresting simplifications. Two things are needed<br/>\nto understand the value and potential pitfalls of<br/>\nthe differences:<br/>\n  * A better understanding of the motivations behind<br/>\n    JUnit&#39;s original design<br/>\n  * A better understanding of the motivations for<br/>\n    SuiteRunner&#39;s refactoring.</div>", 
    "prevInTime": 7265, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1048119274", 
    "canDelete": false, 
    "nextInTopic": 7271, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PDNFNzkwN0VBLkJEMzhFQzRCQHN1bi5jb20+"
    }
}