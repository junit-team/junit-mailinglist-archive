{
    "numMessagesInTopic": 13, 
    "nextInTime": 23641, 
    "senderId": "K2LZx63UCTWGkFiMykmhJFAkVLf9k2n76AN37kpwd1YkgxmMxO77ub7CcwJj-MVAU45y7wnuZMc-VeX-HF4ZfT3K", 
    "systemMessage": false, 
    "subject": "Re: [junit] Feature request: @Assumes", 
    "from": "David Saff &lt;david@...&gt;", 
    "authorName": "David Saff", 
    "msgSnippet": "Stephen, I can see how this could be useful.  It shouldn t be too hard to try it out as a custom runner: - subclass BlockJUnit4ClassRunner - override", 
    "msgId": 23640, 
    "rawEmail": "Return-Path: &lt;david.saff@...&gt;\r\nX-Sender: david.saff@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nX-Received: (qmail 74923 invoked from network); 14 Sep 2011 17:30:44 -0000\r\nX-Received: from unknown (98.137.35.160)\n  by m6.grp.sp2.yahoo.com with QMQP; 14 Sep 2011 17:30:44 -0000\r\nX-Received: from unknown (HELO mail-pz0-f48.google.com) (209.85.210.48)\n  by mta4.grp.sp2.yahoo.com with SMTP; 14 Sep 2011 17:30:44 -0000\r\nX-Received: by pzk34 with SMTP id 34so3651551pzk.7\n        for &lt;junit@yahoogroups.com&gt;; Wed, 14 Sep 2011 10:30:43 -0700 (PDT)\r\nMIME-Version: 1.0\r\nX-Received: by 10.68.60.164 with SMTP id i4mr312633pbr.401.1316021443624; Wed,\n 14 Sep 2011 10:30:43 -0700 (PDT)\r\nX-Received: by 10.68.60.201 with HTTP; Wed, 14 Sep 2011 10:30:43 -0700 (PDT)\r\nIn-Reply-To: &lt;CA+nPnMyQPw_hmB5PZjY5tO7LdhSvXJkb7Nn9JFZreB1Vy5P8ow@...&gt;\r\nReferences: &lt;CA+nPnMwbfNvxbhqjWVyXW7UDt2VM5TzwWzwAiRJaHkKrnHzmxQ@...&gt;\n\t&lt;CA+nPnMyQPw_hmB5PZjY5tO7LdhSvXJkb7Nn9JFZreB1Vy5P8ow@...&gt;\r\nDate: Wed, 14 Sep 2011 13:30:43 -0400\r\nX-Google-Sender-Auth: l1bpjhNY3ZdDQf6dIjvgow_y9Ks\r\nMessage-ID: &lt;CACj8BuOn5eFmNfSxP-RzV3rM331VeD0EHS_fOzwEmPbnjTuU6A@...&gt;\r\nTo: junit@yahoogroups.com\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Transfer-Encoding: quoted-printable\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: David Saff &lt;david@...&gt;\r\nSubject: Re: [junit] Feature request: @Assumes\r\nX-Yahoo-Group-Post: member; u=341876227; y=2_oTKAww0xQexq44HQ7yfMztm_i7pbH76jcBgCLA8PQ\r\nX-Yahoo-Profile: dsaff\r\n\r\nStephen,\n\nI can see how this could be useful.  It shouldn&#39;t be too hard to =\r\ntry\nit out as a custom runner:\n- subclass BlockJUnit4ClassRunner\n- override=\r\n computeTestMethods to order the methods based on assumptions\n- override me=\r\nthodBlock to notice when tests fail, and use that to mark\nassumption failur=\r\nes on later tests.\n\nWould you be interested in contributing something like =\r\nthis to junit.contrib?\n\n   David Saff\n\nOn Wed, Sep 14, 2011 at 6:02 AM, Ste=\r\nphen Connolly\n&lt;stephen.alan.connolly@...&gt; wrote:\n&gt; Note: I have also =\r\nposted this to junit-devel@... but\n&gt; I think that wider i=\r\nnput could be beneficial\n&gt;\n&gt; Consider the case where you are testing a List=\r\n class...\n&gt;\n&gt; we have\n&gt;\n&gt; public class ListTest {\n&gt;\n&gt; =A0@Test\n&gt; =A0public =\r\nvoid newListIsEmpty() {\n&gt; =A0 =A0assertThat(new List().isEmpty(), is(true);=\r\n\n&gt; =A0}\n&gt;\n&gt; =A0@Test\n&gt; =A0public void newListHasSizeZero() {\n&gt; =A0 =A0asser=\r\ntThat(new List().size(), is(0));\n&gt; =A0}\n&gt;\n&gt; =A0@Test\n&gt; =A0public void addPu=\r\ntsAnElementIntoAnEmptyList() {\n&gt; =A0 =A0List l =3D new List();\n&gt; =A0 =A0l.a=\r\ndd(new Object());\n&gt; =A0 =A0assertThat(l.isEmpty(), is(false));\n&gt; =A0}\n&gt;\n&gt; =\r\n=A0@Test\n&gt; =A0public void addIncreasesSizeOfPopulatedListByOne() {\n&gt; =A0 =\r\n=A0List l =3D new List();\n&gt; =A0 =A0l.add(new Object());\n&gt; =A0 =A0int s =3D =\r\nl.size();\n&gt; =A0 =A0l.add(new Object());\n&gt; =A0 =A0assertThat(l.size(), is(s =\r\n+ 1));\n&gt; =A0}\n&gt;\n&gt; }\n&gt;\n&gt; We now want to add some tests of the delete functio=\r\nnality... but the\n&gt; reality is that until/unless some of the preceding test=\r\ns are passing,\n&gt; the tests for delete are meaningless. We could have a perf=\r\nectly\n&gt; functional List.delete() method but until such time as the above te=\r\nsts\n&gt; are passing, there is no way to tell that the method does not work.\n&gt;=\r\n\n&gt; Now I could code my tests like such\n&gt;\n&gt; =A0@Test\n&gt; =A0public void delete=\r\nIsANoOpOnEmptyList() {\n&gt; =A0 =A0List l =3D new List();\n&gt; =A0 =A0assumeThat(=\r\nl.isEmpty(), is(true));\n&gt; =A0 =A0l.delete(new Object());\n&gt; =A0}\n&gt;\n&gt; But all=\r\n that I am doing is repeating code from the preceding tests,\n&gt; having chang=\r\ned all those tests&#39; assertThat(...)s into assumeThat(...)s\n&gt;\n&gt; That does no=\r\nt seem agile to me, copy & paste & search & replace... ban\n&gt; code smell the=\r\nre\n&gt;\n&gt; I would much rather be able to annotate the tests with an @Assumes\n&gt;=\r\n annotation that indicates that the test assumes that the specified\n&gt; tests=\r\n are passing, e.g.\n&gt;\n&gt; =A0@Test\n&gt; =A0@Assumes(&quot;newListIsEmpty&quot;)\n&gt; =A0public=\r\n void deleteIsANoOpOnEmptyList() {\n&gt; =A0 =A0List l =3D new List();\n&gt; =A0 =\r\n=A0l.delete(new Object());\n&gt; =A0}\n&gt;\n&gt; =A0@Test\n&gt; =A0@Assumes({&quot;newListIsEmp=\r\nty&quot;,&quot;addPutsAnElementIntoAnEmptyList&quot;)\n&gt; =A0public void deleteRemovesAnElem=\r\nent() {\n&gt; =A0 =A0List l =3D new List();\n&gt; =A0 =A0Object o =3D new Object();=\r\n\n&gt; =A0 =A0l.add(o);\n&gt; =A0 =A0l.delete(o);\n&gt; =A0 =A0assertThat(l.isEmpty(), =\r\nis(true));\n&gt; =A0}\n&gt;\n&gt; In fact in my initial example of tests, there are som=\r\ne additional\n&gt; assumptions that I didn&#39;t make explicit\n&gt;\n&gt;\n&gt; =A0@Test\n&gt; =A0=\r\n@Assumes(&quot;newListIsEmpty&quot;)\n&gt; =A0public void addPutsAnElementIntoAnEmptyList=\r\n() {\n&gt; =A0 =A0...\n&gt; =A0}\n&gt;\n&gt; and\n&gt;\n&gt; =A0@Test\n&gt; =A0@Assumes({&quot;newListIsEmpt=\r\ny&quot;,&quot;addPutsAnElementIntoAnEmptyList&quot;)\n&gt; =A0public void addIncreasesSizeOfPo=\r\npulatedListByOne() {\n&gt; =A0 =A0...\n&gt; =A0}\n&gt;\n&gt; Now you could get some of this=\r\n functionality via a TestRule...\n&gt;\n&gt; You could watch tests to see if they p=\r\nass, and skip tests annotated\n&gt; with the annotation if assumed functionalit=\r\ny is failing, but that\n&gt; would result in sporadic failures of, e.g. deleteR=\r\nemovesAnElement\n&gt; because of the failing newListIsEmpty being executed _aft=\r\ner_\n&gt; deleteRemovesAnElement rather than before.\n&gt;\n&gt; The simple point is th=\r\nat the test result of deleteRemovesAnElement is\n&gt; meaningless until its ass=\r\numptions are true, and while I could code the\n&gt; assumptions with assumeThat=\r\n(..)s C&P&S&R is even worse than C&P.\n&gt;\n&gt; Another alternative to @Assumes w=\r\nould be to invoke the assumed\n&gt; method(s) at the start of the test, e.g.\n&gt;\n=\r\n&gt; =A0@Test\n&gt; =A0public void deleteRemovesAnElement() {\n&gt; =A0 =A0newListIsEm=\r\npty(); // verify assumed functionality\n&gt; =A0 =A0addPutsAnElementIntoAnEmpty=\r\nList(); =A0// verify assumed functionality\n&gt; =A0 =A0...\n&gt; =A0}\n&gt;\n&gt; That get=\r\ns rid of the C&P&S&R, but there are two issues with that:\n&gt;\n&gt; =A01. We have=\r\n to manually invoke any setup/tearDown methods, including\n&gt; all those of th=\r\ne rules that the test class has... very messy\n&gt;\n&gt; =A02. The test fails when=\r\n the assumed test fails. In actuality we can\n&gt; say nothing at all about whe=\r\nther deleteRemovesAnElement if a\n&gt; newListIsEmpty is not passing... yes we =\r\ncould code the test\n&gt; differently, but that is just moving our assumptions =\r\nsomewhere else.\n&gt;\n&gt; I am sure that there are others out there who feel ther=\r\ne is a point 3...\n&gt;\n&gt; =A03. We already ran those tests why waste time runni=\r\nng them again?\n&gt;\n&gt; Well the answer to 3 is that these are UNIT tests which =\r\nshould be very\n&gt; fast, so what is the harm...\n&gt;\n&gt; So, in my view, best prac=\r\ntice unit testing needs the ability to mark\n&gt; tests as assuming that other =\r\ntests are passing, so that those tests\n&gt; can be skipped when the assumption=\r\ns are known to be failing or\n&gt; skipped. [This is a deliberately loaded crit=\r\neria... if the\n&gt; org.junit.runner.Request does not include the assumed test=\r\n, then that\n&gt; test is neither known failing or known skipped, so we can run=\r\n the test\n&gt; and output a warning that the failure may be because of assumed=\r\n\n&gt; functionality... the use case of executing one and only one test\n&gt; repea=\r\ntedly until you get that test passing]\n&gt;\n&gt; The annotation would have implic=\r\nations on test sorting, as any assumed\n&gt; tests would have to always happen =\r\nbefore the assuming tests (as long\n&gt; as the assumed tests are in the org.ju=\r\nnit.runner.Request)\n&gt;\n&gt; Also might have to be two annotations, e.g.\n&gt;\n&gt; @As=\r\nsumes(methodNames)\n&gt; @AssumesClasses(classes)\n&gt;\n&gt; though in my view the @As=\r\nsumesClasses is less critical, as these are\n&gt; UNIT tests and each test clas=\r\ns should be independent to a large\n&gt; extent. However I am willing to consid=\r\ner that some people may have\n&gt; many test classes for one class under test, =\r\none test class containing\n&gt; all the tests of the constructors, another test=\r\ning the Add methods,\n&gt; etc. in which case an @AssumesClasses annotation mak=\r\nes sense.\n&gt;\n&gt; Where tests contain a circular dependency, fail/error both te=\r\nsts\n&gt;\n&gt; Ok, let the critique begin!\n&gt;\n&gt; -Stephen\n&gt;\n&gt; P.S.\n&gt;\n&gt; I pinged Kent=\r\n with an earlier version of this idea... but I think that\n&gt; he missed the p=\r\noint about eliminating C&P&S&R that this feature would\n&gt; provide because I =\r\ndidn&#39;t frame the idea correctly...\n&gt;\n&gt; ---------- Forwarded message -------=\r\n---\n&gt; From: &quot;Kent Beck&quot;\n&gt; Date: 13 Sep 2011 17:11\n&gt; Subject: Re: JUnit and =\r\ntest dependencies\n&gt; To: &quot;Stephen Connolly&quot;\n&gt;\n&gt; Stephen,\n&gt;\n&gt; Thank you for a=\r\nrticulating your idea so clearly. The short answer is that\n&gt; no, we don&#39;t p=\r\nlan to support dependencies. If I have tests that are slow\n&gt; enough that I =\r\ncare about dependencies, my most productive option is\n&gt; generally to work o=\r\nn the design of the software until the tests are fast\n&gt; enough that I no lo=\r\nnger care. That said, my voice is only one of many. The\n&gt; longer answer is =\r\nthat I encourage you to post your idea on the JUnit mailing\n&gt; list for comm=\r\nunity discussion.\n&gt;\n&gt; Regards,\n&gt;\n&gt; Kent\n&gt;\n&gt; On Sep 13, 2011, at 8:32 AM, St=\r\nephen Connolly wrote:\n&gt;\n&gt;&gt; Kent,\n&gt;&gt;\n&gt;&gt; Are there any plans for JUnit to sup=\r\nport some test dependencies, such as:\n&gt;&gt;\n&gt;&gt; public class OnlyRunTestsThatMa=\r\nkeSenseTest {\n&gt;&gt;\n&gt;&gt; =A0@Test\n&gt;&gt; =A0public void basicFunctionalityWorks() {\n=\r\n&gt;&gt; =A0 =A0...\n&gt;&gt; =A0}\n&gt;&gt;\n&gt;&gt; =A0@Test\n&gt;&gt; =A0@AssumesPasses(&quot;basicFunctionali=\r\ntyWorks&quot;)\n&gt;&gt; =A0public void advancedFunctionalityWorks() {\n&gt;&gt; =A0 =A0...\n&gt;&gt;=\r\n =A0}\n&gt;&gt;\n&gt;&gt; =A0@Test\n&gt;&gt; =A0@AssumesPasses(&quot;basicFunctionalityWorks&quot;)\n&gt;&gt; =A0=\r\npublic void basicFunctionalityWorksWithBevel() {\n&gt;&gt; =A0 =A0...\n&gt;&gt; =A0}\n&gt;&gt;\n&gt;=\r\n&gt; =A0@Test\n&gt;&gt;\n&gt; =A0@AssumesPasses({&quot;basicFunctionalityWorksWithBevel&quot;,&quot;adva=\r\nncedFunctionalityWorks&quot;})\n&gt;&gt; =A0public void advancedFunctionalityWorksWithB=\r\nevel() {\n&gt;&gt; =A0 =A0...\n&gt;&gt; =A0}\n&gt;&gt;\n&gt;&gt; }\n&gt;&gt;\n&gt;&gt; In the above example, no matte=\r\nr what sorting is applied,\n&gt;&gt; basicFunctionalityWorks will always be run fi=\r\nrst, and the other three\n&gt;&gt; tests will only be run if basicFunctionalityWor=\r\nks passed.\n&gt;&gt;\n&gt;&gt; I see the above being completely in the spirit of unit tes=\r\nting, the\n&gt;&gt; point with the above is that the @Before and @After&#39;s will be =\r\nrun\n&gt;&gt; around each method, you are just saying that there is no point even\n=\r\n&gt;&gt; trying to test the advanced functionality when the basic functionality\n&gt;=\r\n&gt; is broken, skip those tests which we know cannot pass. That allows the\n&gt;&gt;=\r\n person writing advancedFunctionalityWorks to power through the setup\n&gt;&gt; th=\r\nat depends on the basic functionality and not have to litter their\n&gt;&gt; advan=\r\nced test with asserts that are redundant because of the basic\n&gt;&gt; functional=\r\nity. Those people who are relying on side-effects should\n&gt;&gt; really, for uni=\r\nt tests at least, be invoking the method who&#39;s\n&gt;&gt; side-effects they depend =\r\non directly within their test method, rather\n&gt;&gt; than relying on accidental =\r\nordering.\n&gt;&gt;\n&gt;&gt; Having said that, a second feature that I think would be go=\r\nod is\n&gt;&gt; something like a @RunAfter and/or @RunBefore which would ensure th=\r\nat\n&gt;&gt; the test method is run in sequence even if the before or after tests\n=\r\n&gt;&gt; fail/are skipped. with @RunAfter and @RunBefore I still think the\n&gt;&gt; @Be=\r\nfore and @After methods should be invoked in-between, this would be\n&gt;&gt; movi=\r\nng towards more of a general purpose testing framework as opposed\n&gt;&gt; to bei=\r\nng unit-testing focused, but JUnit is just too good ;-)\n&gt;&gt;\n&gt;&gt; Thoughts?\n&gt;&gt;\n=\r\n&gt;&gt; -Stephen\n&gt;\n&gt;\n&gt; ------------------------------------\n&gt;\n&gt; Yahoo! Groups Li=\r\nnks\n&gt;\n&gt;\n&gt;\n&gt;\n\n", 
    "profile": "dsaff", 
    "topicId": 23636, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 341876227, 
    "prevInTime": 23639, 
    "contentTrasformed": false, 
    "postDate": "1316021443", 
    "canDelete": false, 
    "nextInTopic": 23642, 
    "prevInTopic": 23639, 
    "headers": {
        "inReplyToHeader": "PENBK25Qbk15UVB3X2htQjVQWmpZNXRPN0xkaFN2WEprYjdObjlKRlpyZUIxVnk1UDhvd0BtYWlsLmdtYWlsLmNvbT4=", 
        "messageIdInHeader": "PENBQ2o4QnVPbjVlRm1OZlN4UC1SelYzck0zMzFWZUQwRUhTX2ZPendFbVBibmpUdVU2QUBtYWlsLmdtYWlsLmNvbT4=", 
        "referencesHeader": "PENBK25Qbk13YmZOdnhiaHFqV1Z5WFc3VUR0MlZNNVR6d1d6d0FpUkphSGtLcm5Iem14UUBtYWlsLmdtYWlsLmNvbT4JPENBK25Qbk15UVB3X2htQjVQWmpZNXRPN0xkaFN2WEprYjdObjlKRlpyZUIxVnk1UDhvd0BtYWlsLmdtYWlsLmNvbT4="
    }
}