{
    "numMessagesInTopic": 17, 
    "nextInTime": 24054, 
    "senderId": "48wQqIZNotcW_FzmoMeTEtFuoPdHU9X5LMmt4gXiPYH3tIkbbXbONL0aTJJOZJ1EgRjCyqGLOF8nufOYxS2_0DdOiu7nSdfE", 
    "systemMessage": false, 
    "subject": "Re: JUnit 4.11-beta-1 is released", 
    "from": "&quot;Paul Holser&quot; &lt;pholser@...&gt;", 
    "authorName": "Paul Holser", 
    "msgSnippet": "Many thanks to Marc for getting 4.11 prepped for takeoff. From looking at the downloads on GitHub, it seems as though there are still junit.jar and", 
    "msgId": 24053, 
    "profile": "pholser", 
    "topicId": 24052, 
    "spamInfo": {
        "reason": "6", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 66805313, 
    "messageBody": "<div id=\"ygrps-yiv-29488373\">Many thanks to Marc for getting 4.11 prepped for takeoff.<br/>\n<br/>\nFrom looking at the downloads on GitHub, it seems as though there are still junit.jar and junit-dep.jar for 4.11 beta 1. Is this intentional? I was thinking that there would ultimately be only junit.jar, without the Hamcrest classes baked in?<br/>\n<br/>\nCheers,<br/>\np<br/>\n<br/>\n<blockquote><span title=\"qreply\"> --- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>, Marc Philipp &lt;mphilipp82@...&gt; wrote:<br/>\n&gt;<br/>\n&gt; All,<br/>\n&gt; <br/>\n&gt; I am happy to announce the release of JUnit 4.11-beta-1. There have been a lot of contributions by a full cast of contributors. Thanks to everyone who took part by reporting an issue, offering his/her opinion, or even submitting a pull request!<br/>\n&gt; <br/>\n&gt; Today, we are releasing a first beta version of 4.11. The reason is simple: We want to make sure the upgrade from Hamcrest 1.1 to 1.3 goes smoothly. Therefore, we are kindly asking you to give it a try. If you find anything we should consider, please let us know, either via this mailing list or directly on GitHub: <a rel=\"nofollow\" target=\"_blank\" href=\"https://github.com/KentBeck/junit/issues/512\">https://github.com/KentBeck/junit/issues/512</a><br/>\n&gt; <br/>\n&gt; As usual, you can download the JARs or the complete ZIP file directly from <a rel=\"nofollow\" target=\"_blank\" href=\"https://github.com/KentBeck/junit/downloads.\">https://github.com/KentBeck/junit/downloads.</a> In addition, the jars<br/>\n&gt; have been submitted to Maven Central and should appear there within one or two hours.<br/>\n&gt; <br/>\n&gt; You can find the preliminary release notes on GitHub and copied below:<br/>\n&gt; <a rel=\"nofollow\" target=\"_blank\" href=\"https://github.com/KentBeck/junit/blob/master/doc/ReleaseNotes4.11.txt\">https://github.com/KentBeck/junit/blob/master/doc/ReleaseNotes4.11.txt</a><br/>\n&gt; <br/>\n&gt; Cheers,<br/>\n&gt; <br/>\n&gt; Marc Philipp<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; Summary of changes in version 4.11 [unreleased!]<br/>\n&gt; <br/>\n&gt; Matchers: Upgrade to Hamcrest 1.3<br/>\n&gt; <br/>\n&gt; JUnit now uses the latest version of Hamcrest. Thus, you can use all the available matchers and benefit from an improved assertThat which will now print the mismatch description from the matcher when an assertion fails.<br/>\n&gt; <br/>\n&gt; Example<br/>\n&gt; <br/>\n&gt; assertThat(Long.valueOf(1), instanceOf(Integer.class));<br/>\n&gt; Old error message:<br/>\n&gt; <br/>\n&gt; Expected: an instance of java.lang.Integer<br/>\n&gt;      got: &lt;1L&gt;<br/>\n&gt; New error message:<br/>\n&gt; <br/>\n&gt; Expected: an instance of java.lang.Integer<br/>\n&gt;      but: &lt;1L&gt; is a java.lang.Long<br/>\n&gt; Hamcrest&#39;s new FeatureMatcher makes writing custom matchers that make use of custom mismatch descriptions quite easy:<br/>\n&gt; <br/>\n&gt; @Test<br/>\n&gt; public void featureMatcher() throws Exception {<br/>\n&gt;     assertThat(&quot;Hello World!&quot;, length(is(0)));<br/>\n&gt; }<br/>\n&gt; <br/>\n&gt; private Matcher&lt;String&gt; length(Matcher&lt;? super Integer&gt; matcher) {<br/>\n&gt;     return new FeatureMatcher&lt;String, Integer&gt;(matcher, &quot;a String of length that&quot;, &quot;length&quot;) {<br/>\n&gt;         @Override<br/>\n&gt;         protected Integer featureValueOf(String actual) {<br/>\n&gt;             return actual.length();<br/>\n&gt;         }<br/>\n&gt;     };<br/>\n&gt; }<br/>\n&gt; Running this test will return the following failure message:<br/>\n&gt; <br/>\n&gt; Expected: a String of length that is &lt;0&gt;<br/>\n&gt;      but: length was &lt;12&gt;<br/>\n&gt; Most of the matchers in JUnitMatchers have been deprecated. Please use org.hamcrest.CoreMatchers directly.<br/>\n&gt; <br/>\n&gt; Parameterized Tests<br/>\n&gt; <br/>\n&gt; In order to easily identify the individual test cases in a Parameterized test, you may provide a name using the @Parameters annotation. This name is allowed to contain placeholders that are replaced at runtime:<br/>\n&gt; <br/>\n&gt; {index}: the current parameter index<br/>\n&gt; {0}, {1}, Â…: the first, second, and so on, parameter value<br/>\n&gt; Example<br/>\n&gt; <br/>\n&gt; @RunWith(Parameterized.class)<br/>\n&gt; public class FibonacciTest {<br/>\n&gt; <br/>\n&gt;     @Parameters(name = &quot;{index}: fib({0})={1}&quot;)<br/>\n&gt;     public static Iterable&lt;Object[]&gt; data() {<br/>\n&gt;         return Arrays.asList(new Object[][] { { 0, 0 }, { 1, 1 }, { 2, 1 },<br/>\n&gt;                 { 3, 2 }, { 4, 3 }, { 5, 5 }, { 6, 8 } });<br/>\n&gt;     }<br/>\n&gt; <br/>\n&gt;     private int input;<br/>\n&gt;     private int expected;<br/>\n&gt; <br/>\n&gt;     public FibonacciTest(int input, int expected) {<br/>\n&gt;         this.input = input;<br/>\n&gt;         this.expected = expected;<br/>\n&gt;     }<br/>\n&gt; <br/>\n&gt;     @Test<br/>\n&gt;     public void test() {<br/>\n&gt;         assertEquals(expected, Fibonacci.compute(input));<br/>\n&gt;     }<br/>\n&gt; }<br/>\n&gt; In the example given above, the Parameterized runner creates names like [1: fib(3)=2]. If you don&#39;t specify a name, the current parameter index will be used by default.<br/>\n&gt; <br/>\n&gt; Test execution order<br/>\n&gt; <br/>\n&gt; By design, JUnit does not specify the execution order of test method invocations. Until now, the methods were simply invoked in the order returned by the reflection API. However, using the JVM order is unwise since the Java platform does not specify any particular order, and in fact JDK 7 returns a more or less random order. Of course, well-written test code would not assume any order, but some does, and a predictable failure is better than a random failure on certain platforms.<br/>\n&gt; <br/>\n&gt; From now on, JUnit will by default use a deterministic, but not predictable, order (MethodSorters.DEFAULT). To change the test execution order simply annotate your test class using @FixMethodOrder and specify one of the available MethodSorters:<br/>\n&gt; <br/>\n&gt; @FixMethodOrder(MethodSorters.JVM): Leaves the test methods in the order returned by the JVM. This order may vary from run to run.<br/>\n&gt; <br/>\n&gt; @FixMethodOrder(MethodSorters.NAME_ASCENDING): Sorts the test methods by method name, in lexicographic order.<br/>\n&gt; <br/>\n&gt; Maven artifacts<br/>\n&gt; <br/>\n&gt; Up until now there were two Maven artifacts for JUnit: junit:junit-dep and junit:junit. From a Maven point-of-view only the former made sense because it did not contain the Hamcrest classes but declared a dependency to the Hamcrest Maven artifact. The latter included the Hamcrest classes which was very un-Maven-like.<br/>\n&gt; <br/>\n&gt; From this release on, you should use junit:junit which will be what junit:junit-dep used to. If you still reference junit:junit-dep, Maven will automatically relocate you to the new junit:junit and issue a warning for you to fix.<br/>\n&gt; <br/>\n&gt; Rules<br/>\n&gt; <br/>\n&gt; A number of improvements have been made to Rules:<br/>\n&gt; <br/>\n&gt; Both @Rule and @ClassRule can now be used on methods that return a TestRule.<br/>\n&gt; ExpectedException now always prints the stacktrace of the actual exception in case of failure.<br/>\n&gt; A parent folder can be specified for TemporaryFolder. In addition, the newFile/newFolder methods will now fail when the file or folder could not be created.<br/>\n&gt; TestWatcher has a new template method called skipped that is invoked when a test is skipped due to a failed assumption.<br/>\n&gt; Improvements to Assert and Assume<br/>\n&gt; <br/>\n&gt; assertNotEquals has been added to Assert.<br/>\n&gt; assertEquals has been overloaded in order to check whether two floats are equal given a certain float delta.<br/>\n&gt; Most methods in Assume now allow to pass a custom message.<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; <br/>\n&gt; [Non-text portions of this message have been removed]<br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 24052, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1350422765", 
    "canDelete": false, 
    "nextInTopic": 24054, 
    "prevInTopic": 24052, 
    "headers": {
        "inReplyToHeader": "PEUzQjBGMzYxLUMzMEEtNDgxNC04MjdCLTJCNzE2OTkyRThBMUBtYXJjcGhpbGlwcC5kZT4=", 
        "messageIdInHeader": "PGs1a2pkZCtubmRlQGVHcm91cHMuY29tPg=="
    }
}