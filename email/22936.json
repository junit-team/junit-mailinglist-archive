{
    "numMessagesInTopic": 8, 
    "nextInTime": 22937, 
    "senderId": "hCk9Z42gAzTM0MdpkK_CaPUFQjPAfifRKJl-EHlBXUZtWUNVKUXsswxA14y_eewnRI3-mm_-8LBF1sZPwz7R_nItOB_Rl7QzDq-9Zo55", 
    "systemMessage": false, 
    "subject": "Re: [junit] Common Test Runner for JVM", 
    "from": "Esko Luontola &lt;esko.luontola@...&gt;", 
    "authorName": "Esko Luontola", 
    "msgSnippet": "... Yes. In addition to programming I do also interaction design, and usability is very important to me. My development process is to first design the UI and", 
    "msgId": 22936, 
    "profile": "egeluontola", 
    "topicId": 22933, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 395435659, 
    "messageBody": "<div id=\"ygrps-yiv-1980589594\"><blockquote><span title=\"ireply\">&gt;  &gt; I notice that a<br/>\n&gt;  &gt; number of the issues you&#39;re tackling are mostly about IDE<br/>\n&gt;  &gt; integration<br/>\n<br/>\n </span></blockquote>Yes. In addition to programming I do also interaction design, and <br/>\nusability is very important to me. My development process is to first <br/>\ndesign the UI and after that think about what is needed to implement it. <br/>\nQuite many times a good user interface affects all levels of the <br/>\nimplementation.<br/>\n<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;  &gt; I wonder if thinking about the interface you wish IDEs<br/>\n&gt;  &gt; would talk to, and then getting at least one IDE to agree to it, would<br/>\n&gt;  &gt; be a good approach.<br/>\n<br/>\n </span></blockquote>Yes, that&#39;s what I&#39;m planning. As Linus Torvalds says, &quot;Talk is cheap. <br/>\nShow me the code.&quot;<br/>\n<br/>\nMy current plan is to implement a minimal set of features, create a UI <br/>\nand integrate it with IntelliJ IDEA. Then people can better see what <br/>\nthis is all about, and can better decide whether it&#39;s something that <br/>\nthey like. I will setup a dedicated mailing list and contact the major <br/>\ntool vendors after I have something working to show (right now I&#39;m only <br/>\ngauging some interest on JUnit, scala-tools and simple-build-tool <br/>\nmailing lists).<br/>\n<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; I think the main advantage to being able to count the tests before<br/>\n&gt; you run<br/>\n&gt; them is that is that you can make a progress bar that gives feedback to the<br/>\n&gt; user as the tests run. That&#39;s a really nice feature in GUI test runners that<br/>\n&gt; is lost if you can&#39;t count tests in advance. It would be possible to make<br/>\n&gt; the advance test count an optional feature, but then when tests can&#39;t be<br/>\n&gt; counted, you couldn&#39;t show a progress bar. And I think that would be a<br/>\n&gt; pretty big loss.<br/>\n<br/>\n </span></blockquote>I&#39;ve thought about that. It&#39;s possible to measure progress at least on <br/>\nthe class level. And within a class, the completion of a class can be <br/>\napproximated as more tests are discovered.<br/>\n<br/>\nI&#39;m also planning on making the tool remember statistics from previous <br/>\ntest runs (and do some classloader caching of external libraries, to <br/>\nspeed up the test runs), so after the first test run the tool will know <br/>\nquite accurately that how many tests there are and how long each of them <br/>\ntakes to execute.<br/>\n<br/>\nI&#39;ve also thought about some ways to detect which classes are covered by <br/>\na test, which information can be used to run first the tests for the <br/>\nrecently modified classes. So there might be some features similar to <br/>\nJUnit Max (I haven&#39;t used Max because it&#39;s not available on IntelliJ IDEA).<br/>\n<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;  &gt; In terms of IDE integration, JUnit just reports a tree of<br/>\n&gt;  &gt; Descriptions, and results against them. Runners are free to structure<br/>\n&gt;  &gt; these trees however they wish. Have you run into IDE limitations for<br/>\n&gt;  &gt; displaying/interacting with these trees?<br/>\n&gt;  &gt;<br/>\n&gt; I would question the need for nesting tests. I can easily see the benefit<br/>\n&gt; of nesting closures in test code. Several traits in ScalaTest do that, but<br/>\n&gt; the model I use in ScalaTest is that each leaf node is one test. The<br/>\n&gt; closures surrounding the leaf nodes are descriptions, not tests themselves.<br/>\n&gt; I would think you and Eric could adopt that approach in Specs and Specsy<br/>\n&gt; without much trouble.<br/>\n<br/>\n </span></blockquote>It would be possible for me to detect the leaf nodes after the tests <br/>\nhave been run, but I prefer the UI to show the correct mental model of <br/>\nwhat is happening during test runs.<br/>\n<br/>\nTo illustrate, here is a partial version of one of Specsy&#39;s example <br/>\nspecs with some println() debug statements.<br/>\n<br/>\n@RunWith(classOf[Specsy])<br/>\nclass StackSpec extends Spec {<br/>\n   val stack = new scala.collection.mutable.Stack[String]<br/>\n   println(stack)<br/>\n<br/>\n   &quot;When objects have been pushed onto a stack&quot; &gt;&gt; {<br/>\n     stack.push(&quot;pushed first&quot;)<br/>\n     stack.push(&quot;pushed last&quot;)<br/>\n     println(stack)<br/>\n<br/>\n     &quot;the object pushed last is popped first&quot; &gt;&gt; {<br/>\n       val poppedFirst = stack.pop()<br/>\n       assertThat(poppedFirst, is(&quot;pushed last&quot;))<br/>\n       println(stack)<br/>\n     }<br/>\n     &quot;the object pushed first is popped last&quot; &gt;&gt; {<br/>\n       stack.pop()<br/>\n       val poppedLast = stack.pop()<br/>\n       assertThat(poppedLast, is(&quot;pushed first&quot;))<br/>\n       println(stack)<br/>\n     }<br/>\n   }<br/>\n}<br/>\n<br/>\nTo execute that, Specsy needs to instantiate and run the class two <br/>\ntimes. The first test run will print:<br/>\n<br/>\nStack()<br/>\nStack(pushed last, pushed first)<br/>\nStack(pushed first)<br/>\n<br/>\nThe second test run will print:<br/>\n<br/>\nStack()<br/>\nStack(pushed last, pushed first)<br/>\nStack()<br/>\n<br/>\nMy vision is that the UI would visualize where one test ends and another <br/>\nbegins. It would provide the same information as the following examples <br/>\n(but better visualized ;).<br/>\n<br/>\nTest run 1:<br/>\n<br/>\n-- &lt;net.orfjackal.specsy.examples.StackSpec&gt;<br/>\nStack()<br/>\n--     &lt;When objects have been pushed onto a stack&gt;<br/>\nStack(pushed last, pushed first)<br/>\n--         &lt;the object pushed last is popped first&gt;<br/>\nStack(pushed first)<br/>\n--         &lt;/the object pushed last is popped first&gt;<br/>\n--     &lt;/When objects have been pushed onto a stack&gt;<br/>\n-- &lt;/net.orfjackal.specsy.examples.StackSpec&gt;<br/>\n<br/>\nTest run 2:<br/>\n<br/>\n-- &lt;net.orfjackal.specsy.examples.StackSpec&gt;<br/>\nStack()<br/>\n--     &lt;When objects have been pushed onto a stack&gt;<br/>\nStack(pushed last, pushed first)<br/>\n--         &lt;the object pushed first is popped last&gt;<br/>\nStack()<br/>\n--         &lt;/the object pushed first is popped last&gt;<br/>\n--     &lt;/When objects have been pushed onto a stack&gt;<br/>\n-- &lt;/net.orfjackal.specsy.examples.StackSpec&gt;<br/>\n<br/>\nThen when I select &quot;StackSpec&quot; or &quot;When objects have been pushed onto a <br/>\nstack&quot; in the tree of tests shown by the UI, it would show both of those <br/>\ntest runs, because those tests were included in both of them. But if I <br/>\nselect &quot;the object pushed last is popped first&quot; then it will show only <br/>\ntest run 1, and if I select &quot;the object pushed first is popped last&quot; it <br/>\nwill show only test run 2.<br/>\n<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;  &gt; That assumption is in the IDE&#39;s. It&#39;s a useful one, but it&#39;s neither<br/>\n&gt;  &gt; required nor assumed by JUnit itself.<br/>\n<br/>\n </span></blockquote>True. I would like to make that concept explicit, so that the testing <br/>\nframework could help the IDE with code navigation.<br/>\n<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;  &gt; We&#39;ve taken several stabs at this. The biggest hurdle is how to<br/>\n&gt;  &gt; extend the test-definition language: while many tests can be<br/>\n&gt;  &gt; parallelized without cost, and test writers should not depend on<br/>\n&gt;  &gt; order, they currently might depend on only test being written at the<br/>\n&gt;  &gt; time.<br/>\n<br/>\n </span></blockquote>I&#39;ve been thinking whether to make parallelization enabled by default. <br/>\n From a usability point of view, I would prefer to &quot;design for one user&quot; <br/>\n(as advocated for example by Alan Cooper) and as such I&#39;m tempted to <br/>\nwrite the test runner for programmers who write tests which don&#39;t depend <br/>\non any global state (i.e. I would design it for myself :).<br/>\n<br/>\nFor tests which cannot be executed safely in parallel, my plan is to <br/>\nmake it possible to annotate the class with @LocallySequential or <br/>\n@GloballySequential. The first annotation would still allow running <br/>\ntests from other classes in parallel, but the second annotation would <br/>\nexecute this one test class all alone.<br/>\n<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;  &gt; Test discovery seems to be yet another feature of a common IDE interface.<br/>\n<br/>\n </span></blockquote>And build tools.<br/>\n<br/>\nOne thing that I&#39;m also trying to solve, is minor differences between <br/>\nrunning tests in the IDE vs. running them through a build tool. For <br/>\nexample IntelliJ IDEA executes all tests in the project using the same <br/>\nclasspath, but Maven uses the classpath of the module which contains the <br/>\ntests. If two modules use different versions of a library (I have one <br/>\nsuch project), then this difference might be important.<br/>\n<br/>\nAlso I want to get rid of bugs such as <br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://youtrack.jetbrains.net/issue/IDEA-57696\">http://youtrack.jetbrains.net/issue/IDEA-57696</a> &quot;IDEA&#39;s JUnit test runner <br/>\ndoes not run Scala classes which are annotated with <br/>\norg.junit.runner.RunWith&quot;. Running tests is such an important feature, <br/>\nthat I don&#39;t want it to have any bugs.<br/>\n<br/>\n-- <br/>\nEsko Luontola<br/>\nwww.orfjackal.net</div>", 
    "prevInTime": 22935, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1284405533", 
    "canDelete": false, 
    "nextInTopic": 22937, 
    "prevInTopic": 22935, 
    "headers": {
        "inReplyToHeader": "PEFBTkxrVGltMTFPUk82OGlyRmhIclZDQnZxSDh2SzlCUUcyNndpVXhXZDlaZEBtYWlsLmdtYWlsLmNvbT4=", 
        "messageIdInHeader": "PDRDOEU3OTFELjUwNDA3MDRAZ21haWwuY29tPg==", 
        "referencesHeader": "PDRDOEJGREU3LjMwMTA2MDNAZ21haWwuY29tPgk8QUFOTGtUaW40QVhrOEJHY2JYR2ZtNjhLUUZ6THFiVnprK20yMkNyY1VnUnQxQG1haWwuZ21haWwuY29tPiA8QUFOTGtUaW0xMU9STzY4aXJGaEhyVkNCdnFIOHZLOUJRRzI2d2lVeFdkOVpkQG1haWwuZ21haWwuY29tPg=="
    }
}