{
    "numMessagesInTopic": 13, 
    "nextInTime": 23651, 
    "senderId": "wpWlRs_hzX_JXvop7LZU7nyoJ2tjbfxG8OdpiIqakQT_mmSwzyQdDqXNEa7QSgvDLC_pzzNCNmE4TzO5EAy60BFfzzmL3gREJ_MHYDJH33947HLnVEpA69Y", 
    "systemMessage": false, 
    "subject": "Re: [junit] Feature request: @Assumes", 
    "from": "Stephen Connolly &lt;stephen.alan.connolly@...&gt;", 
    "authorName": "Stephen Connolly", 
    "msgSnippet": "On 14 September 2011 18:25, Tomek Kaczanowski ... Ahem... *caugh* http://junit.sourceforge.net/javadoc/org/junit/runner/manipulation/Sortable.html *caugh* ", 
    "msgId": 23650, 
    "rawEmail": "Return-Path: &lt;stephen.alan.connolly@...&gt;\r\nReceived: (qmail 86623 invoked by uid 7800); 16 Sep 2011 13:44:43 -0000\r\nX-Sender: stephen.alan.connolly@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nX-Received: (qmail 5165 invoked from network); 16 Sep 2011 08:22:23 -0000\r\nX-Received: from unknown (98.137.34.44)\n  by m12.grp.sp2.yahoo.com with QMQP; 16 Sep 2011 08:22:23 -0000\r\nX-Received: from unknown (HELO mail-ww0-f50.google.com) (74.125.82.50)\n  by mta1.grp.sp2.yahoo.com with SMTP; 16 Sep 2011 08:22:22 -0000\r\nX-Received: by wwe3 with SMTP id 3so4487110wwe.31\n        for &lt;junit@yahoogroups.com&gt;; Fri, 16 Sep 2011 01:22:21 -0700 (PDT)\r\nMIME-Version: 1.0\r\nX-Received: by 10.227.202.201 with SMTP id ff9mr1254259wbb.80.1316161340729;\n Fri, 16 Sep 2011 01:22:20 -0700 (PDT)\r\nX-Received: by 10.227.129.18 with HTTP; Fri, 16 Sep 2011 01:22:20 -0700 (PDT)\r\nIn-Reply-To: &lt;CA+BycFraJ5n2ogdebr2bNt8h93jCMxPwsgtH3wxOT0JPiSsLBA@...&gt;\r\nReferences: &lt;CA+nPnMwbfNvxbhqjWVyXW7UDt2VM5TzwWzwAiRJaHkKrnHzmxQ@...&gt;\n\t&lt;CA+nPnMyQPw_hmB5PZjY5tO7LdhSvXJkb7Nn9JFZreB1Vy5P8ow@...&gt;\n\t&lt;CACfbOveM6NMPJDFn5B9uyo5bccFJy1+rWvs8373cGHhv71wVWg@...&gt;\n\t&lt;CA+nPnMzynw4Fw-3FBHF8=d+emhD3g7SOvXJ6x3uN5uj++AP-Vw@...&gt;\n\t&lt;CA+BycFraJ5n2ogdebr2bNt8h93jCMxPwsgtH3wxOT0JPiSsLBA@...&gt;\r\nDate: Fri, 16 Sep 2011 09:22:20 +0100\r\nMessage-ID: &lt;CA+nPnMxczUxoaM+o3JvPqTDRS=-LS_HtAswGVyy5Q7YewoOQXw@...&gt;\r\nTo: junit@yahoogroups.com\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Transfer-Encoding: quoted-printable\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: Stephen Connolly &lt;stephen.alan.connolly@...&gt;\r\nSubject: Re: [junit] Feature request: @Assumes\r\nX-Yahoo-Group-Post: member; u=458231986; y=zERuqHn88RzTlzQnqBhwauKnryW_pVWv4Zu5DFVTMoGFZJW6V8-8LrXUtnzQZw\r\nX-Yahoo-Profile: stephenalanconnolly\r\nX-eGroups-Approved-By: dsaff &lt;david@...&gt; via email; 16 Sep 2011 13:44:43 -0000\r\n\r\nOn 14 September 2011 18:25, Tomek Kaczanowski\n&lt;kaczanowski.tomek@...&gt;=\r\n wrote:\n&gt; Sound like TestNG dependsOn feature. But from what I know, JUnit =\r\nis against\n&gt; any kind of test dependencies (there was a recent discussion o=\r\nn this mailing\n&gt; list, see http://tech.groups.yahoo.com/group/junit/message=\r\n/23568). A short\n&gt; quote from this discussion: &quot;It has always been a delibe=\r\nrate design decision\n&gt; in JUnit that we would *not* guarantee the order of =\r\ntest execution.&quot;\n\nAhem...\n\n*caugh* http://junit.sourceforge.net/javadoc/org=\r\n/junit/runner/manipulation/Sortable.html\n*caugh*\n\nHowever as that relies on=\r\n Collections.sort you are not guaranteed to\nhave all the N*N/2 comparisons =\r\nmade that would be required for a true\nsort... hence https://github.com/Ken=\r\ntBeck/junit/pull/316\n\n&gt;\n&gt; --\n&gt; Regards / Pozdrawiam\n&gt; Tomek Kaczanowski\n&gt; h=\r\nttp://kaczanowscy.pl/tomek\n&gt;\n&gt; 2011/9/14 Stephen Connolly &lt;stephen.alan.con=\r\nnolly@...&gt;\n&gt;\n&gt;&gt;\n&gt;&gt;\n&gt;&gt; Nope not a mock at all.\n&gt;&gt;\n&gt;&gt; Say you have a cl=\r\nass List (which is not java.util.List but looks a lot\n&gt;&gt; like it in terms o=\r\nf interface)\n&gt;&gt;\n&gt;&gt; This list class is something you are developing via TDD.=\r\n\n&gt;&gt;\n&gt;&gt; You write a whole lot of unit tests for it.\n&gt;&gt;\n&gt;&gt; Now suppose it hap=\r\npens to be a linked list, and you decide to change\n&gt;&gt; from a null for end o=\r\nf list marker to a sentinel instead. All your\n&gt;&gt; methods are working now, e=\r\nxcept for the isEmpty() method, but yet 200+\n&gt;&gt; test cases are failing beca=\r\nuse they all rely on isEmpty working. Which\n&gt;&gt; unit test do I try to fix fi=\r\nrst?\n&gt;&gt;\n&gt;&gt; with @Assumes, you would have 1 failing test and 199 skipped tes=\r\nts...\n&gt;&gt;\n&gt;&gt; No mocks involved at all\n&gt;&gt;\n&gt;&gt;\n&gt;&gt; On 14 September 2011 16:34, C=\r\narfield Yim &lt;carfield@...&gt; wrote:\n&gt;&gt; &gt; It sound like a mock, isn&#39;t it=\r\n?\n&gt;&gt; &gt;\n&gt;&gt; &gt; On Wed, Sep 14, 2011 at 6:02 PM, Stephen Connolly &lt;\n&gt;&gt; &gt; stephe=\r\nn.alan.connolly@...&gt; wrote:\n&gt;&gt; &gt;\n&gt;&gt; &gt;&gt; Note: I have also posted this =\r\nto junit-devel@... but\n&gt;&gt; &gt;&gt; I think that wider input cou=\r\nld be beneficial\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; Consider the case where you are testing a List=\r\n class...\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; we have\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; public class ListTest {\n&gt;&gt; &gt;&gt;\n&gt;&gt; =\r\n&gt;&gt; =A0@Test\n&gt;&gt; &gt;&gt; =A0public void newListIsEmpty() {\n&gt;&gt; &gt;&gt; =A0 =A0assertThat=\r\n(new List().isEmpty(), is(true);\n&gt;&gt; &gt;&gt; =A0}\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; =A0@Test\n&gt;&gt; &gt;&gt; =A0p=\r\nublic void newListHasSizeZero() {\n&gt;&gt; &gt;&gt; =A0 =A0assertThat(new List().size()=\r\n, is(0));\n&gt;&gt; &gt;&gt; =A0}\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; =A0@Test\n&gt;&gt; &gt;&gt; =A0public void addPutsAnEle=\r\nmentIntoAnEmptyList() {\n&gt;&gt; &gt;&gt; =A0 =A0List l =3D new List();\n&gt;&gt; &gt;&gt; =A0 =A0l.=\r\nadd(new Object());\n&gt;&gt; &gt;&gt; =A0 =A0assertThat(l.isEmpty(), is(false));\n&gt;&gt; &gt;&gt; =\r\n=A0}\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; =A0@Test\n&gt;&gt; &gt;&gt; =A0public void addIncreasesSizeOfPopulatedL=\r\nistByOne() {\n&gt;&gt; &gt;&gt; =A0 =A0List l =3D new List();\n&gt;&gt; &gt;&gt; =A0 =A0l.add(new Obj=\r\nect());\n&gt;&gt; &gt;&gt; =A0 =A0int s =3D l.size();\n&gt;&gt; &gt;&gt; =A0 =A0l.add(new Object());\n=\r\n&gt;&gt; &gt;&gt; =A0 =A0assertThat(l.size(), is(s + 1));\n&gt;&gt; &gt;&gt; =A0}\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; }\n&gt;&gt; &gt;=\r\n&gt;\n&gt;&gt; &gt;&gt; We now want to add some tests of the delete functionality... but th=\r\ne\n&gt;&gt; &gt;&gt; reality is that until/unless some of the preceding tests are passin=\r\ng,\n&gt;&gt; &gt;&gt; the tests for delete are meaningless. We could have a perfectly\n&gt;&gt;=\r\n &gt;&gt; functional List.delete() method but until such time as the above tests\n=\r\n&gt;&gt; &gt;&gt; are passing, there is no way to tell that the method does not work.\n&gt;=\r\n&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; Now I could code my tests like such\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; =A0@Test\n&gt;&gt; &gt;&gt; =\r\n=A0public void deleteIsANoOpOnEmptyList() {\n&gt;&gt; &gt;&gt; =A0 =A0List l =3D new Lis=\r\nt();\n&gt;&gt; &gt;&gt; =A0 =A0assumeThat(l.isEmpty(), is(true));\n&gt;&gt; &gt;&gt; =A0 =A0l.delete(=\r\nnew Object());\n&gt;&gt; &gt;&gt; =A0}\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; But all that I am doing is repeating =\r\ncode from the preceding tests,\n&gt;&gt; &gt;&gt; having changed all those tests&#39; assert=\r\nThat(...)s into assumeThat(...)s\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; That does not seem agile to me=\r\n, copy & paste & search & replace... ban\n&gt;&gt; &gt;&gt; code smell there\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt;=\r\n I would much rather be able to annotate the tests with an @Assumes\n&gt;&gt; &gt;&gt; a=\r\nnnotation that indicates that the test assumes that the specified\n&gt;&gt; &gt;&gt; tes=\r\nts are passing, e.g.\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; =A0@Test\n&gt;&gt; &gt;&gt; =A0@Assumes(&quot;newListIsEmpty=\r\n&quot;)\n&gt;&gt; &gt;&gt; =A0public void deleteIsANoOpOnEmptyList() {\n&gt;&gt; &gt;&gt; =A0 =A0List l =\r\n=3D new List();\n&gt;&gt; &gt;&gt; =A0 =A0l.delete(new Object());\n&gt;&gt; &gt;&gt; =A0}\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt;=\r\n =A0@Test\n&gt;&gt; &gt;&gt; =A0@Assumes({&quot;newListIsEmpty&quot;,&quot;addPutsAnElementIntoAnEmptyL=\r\nist&quot;)\n&gt;&gt; &gt;&gt; =A0public void deleteRemovesAnElement() {\n&gt;&gt; &gt;&gt; =A0 =A0List l =\r\n=3D new List();\n&gt;&gt; &gt;&gt; =A0 =A0Object o =3D new Object();\n&gt;&gt; &gt;&gt; =A0 =A0l.add(=\r\no);\n&gt;&gt; &gt;&gt; =A0 =A0l.delete(o);\n&gt;&gt; &gt;&gt; =A0 =A0assertThat(l.isEmpty(), is(true)=\r\n);\n&gt;&gt; &gt;&gt; =A0}\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; In fact in my initial example of tests, there are=\r\n some additional\n&gt;&gt; &gt;&gt; assumptions that I didn&#39;t make explicit\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt;\n=\r\n&gt;&gt; &gt;&gt; =A0@Test\n&gt;&gt; &gt;&gt; =A0@Assumes(&quot;newListIsEmpty&quot;)\n&gt;&gt; &gt;&gt; =A0public void add=\r\nPutsAnElementIntoAnEmptyList() {\n&gt;&gt; &gt;&gt; =A0 =A0...\n&gt;&gt; &gt;&gt; =A0}\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; an=\r\nd\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; =A0@Test\n&gt;&gt; &gt;&gt; =A0@Assumes({&quot;newListIsEmpty&quot;,&quot;addPutsAnElemen=\r\ntIntoAnEmptyList&quot;)\n&gt;&gt; &gt;&gt; =A0public void addIncreasesSizeOfPopulatedListByOn=\r\ne() {\n&gt;&gt; &gt;&gt; =A0 =A0...\n&gt;&gt; &gt;&gt; =A0}\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; Now you could get some of thi=\r\ns functionality via a TestRule...\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; You could watch tests to see =\r\nif they pass, and skip tests annotated\n&gt;&gt; &gt;&gt; with the annotation if assumed=\r\n functionality is failing, but that\n&gt;&gt; &gt;&gt; would result in sporadic failures=\r\n of, e.g. deleteRemovesAnElement\n&gt;&gt; &gt;&gt; because of the failing newListIsEmpt=\r\ny being executed _after_\n&gt;&gt; &gt;&gt; deleteRemovesAnElement rather than before.\n&gt;=\r\n&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; The simple point is that the test result of deleteRemovesAnEleme=\r\nnt is\n&gt;&gt; &gt;&gt; meaningless until its assumptions are true, and while I could c=\r\node the\n&gt;&gt; &gt;&gt; assumptions with assumeThat(..)s C&P&S&R is even worse than C=\r\n&P.\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; Another alternative to @Assumes would be to invoke the assu=\r\nmed\n&gt;&gt; &gt;&gt; method(s) at the start of the test, e.g.\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; =A0@Test\n&gt;&gt; =\r\n&gt;&gt; =A0public void deleteRemovesAnElement() {\n&gt;&gt; &gt;&gt; =A0 =A0newListIsEmpty();=\r\n // verify assumed functionality\n&gt;&gt; &gt;&gt; =A0 =A0addPutsAnElementIntoAnEmptyLi=\r\nst(); =A0// verify assumed functionality\n&gt;&gt; &gt;&gt; =A0 =A0...\n&gt;&gt; &gt;&gt; =A0}\n&gt;&gt; &gt;&gt;\n=\r\n&gt;&gt; &gt;&gt; That gets rid of the C&P&S&R, but there are two issues with that:\n&gt;&gt; =\r\n&gt;&gt;\n&gt;&gt; &gt;&gt; =A01. We have to manually invoke any setup/tearDown methods, inclu=\r\nding\n&gt;&gt; &gt;&gt; all those of the rules that the test class has... very messy\n&gt;&gt; =\r\n&gt;&gt;\n&gt;&gt; &gt;&gt; =A02. The test fails when the assumed test fails. In actuality we =\r\ncan\n&gt;&gt; &gt;&gt; say nothing at all about whether deleteRemovesAnElement if a\n&gt;&gt; &gt;=\r\n&gt; newListIsEmpty is not passing... yes we could code the test\n&gt;&gt; &gt;&gt; differe=\r\nntly, but that is just moving our assumptions somewhere else.\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; I=\r\n am sure that there are others out there who feel there is a point 3...\n&gt;&gt; =\r\n&gt;&gt;\n&gt;&gt; &gt;&gt; =A03. We already ran those tests why waste time running them again=\r\n?\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; Well the answer to 3 is that these are UNIT tests which shoul=\r\nd be very\n&gt;&gt; &gt;&gt; fast, so what is the harm...\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; So, in my view, be=\r\nst practice unit testing needs the ability to mark\n&gt;&gt; &gt;&gt; tests as assuming =\r\nthat other tests are passing, so that those tests\n&gt;&gt; &gt;&gt; can be skipped when=\r\n the assumptions are known to be failing or\n&gt;&gt; &gt;&gt; skipped. [This is a delib=\r\nerately loaded criteria... if the\n&gt;&gt; &gt;&gt; org.junit.runner.Request does not i=\r\nnclude the assumed test, then that\n&gt;&gt; &gt;&gt; test is neither known failing or k=\r\nnown skipped, so we can run the test\n&gt;&gt; &gt;&gt; and output a warning that the fa=\r\nilure may be because of assumed\n&gt;&gt; &gt;&gt; functionality... the use case of exec=\r\nuting one and only one test\n&gt;&gt; &gt;&gt; repeatedly until you get that test passin=\r\ng]\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; The annotation would have implications on test sorting, as a=\r\nny assumed\n&gt;&gt; &gt;&gt; tests would have to always happen before the assuming test=\r\ns (as long\n&gt;&gt; &gt;&gt; as the assumed tests are in the org.junit.runner.Request)\n=\r\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; Also might have to be two annotations, e.g.\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; @Assume=\r\ns(methodNames)\n&gt;&gt; &gt;&gt; @AssumesClasses(classes)\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; though in my view=\r\n the @AssumesClasses is less critical, as these are\n&gt;&gt; &gt;&gt; UNIT tests and ea=\r\nch test class should be independent to a large\n&gt;&gt; &gt;&gt; extent. However I am w=\r\nilling to consider that some people may have\n&gt;&gt; &gt;&gt; many test classes for on=\r\ne class under test, one test class containing\n&gt;&gt; &gt;&gt; all the tests of the co=\r\nnstructors, another testing the Add methods,\n&gt;&gt; &gt;&gt; etc. in which case an @A=\r\nssumesClasses annotation makes sense.\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; Where tests contain a cir=\r\ncular dependency, fail/error both tests\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; Ok, let the critique be=\r\ngin!\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; -Stephen\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; P.S.\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; I pinged Kent with a=\r\nn earlier version of this idea... but I think that\n&gt;&gt; &gt;&gt; he missed the poin=\r\nt about eliminating C&P&S&R that this feature would\n&gt;&gt; &gt;&gt; provide because I=\r\n didn&#39;t frame the idea correctly...\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; ---------- Forwarded messag=\r\ne ----------\n&gt;&gt; &gt;&gt; From: &quot;Kent Beck&quot;\n&gt;&gt; &gt;&gt; Date: 13 Sep 2011 17:11\n&gt;&gt; &gt;&gt; Su=\r\nbject: Re: JUnit and test dependencies\n&gt;&gt; &gt;&gt; To: &quot;Stephen Connolly&quot;\n&gt;&gt; &gt;&gt;\n&gt;=\r\n&gt; &gt;&gt; Stephen,\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; Thank you for articulating your idea so clearly. =\r\nThe short answer is\n&gt;&gt; that\n&gt;&gt; &gt;&gt; no, we don&#39;t plan to support dependencies=\r\n. If I have tests that are slow\n&gt;&gt; &gt;&gt; enough that I care about dependencies=\r\n, my most productive option is\n&gt;&gt; &gt;&gt; generally to work on the design of the=\r\n software until the tests are fast\n&gt;&gt; &gt;&gt; enough that I no longer care. That=\r\n said, my voice is only one of many.\n&gt;&gt; The\n&gt;&gt; &gt;&gt; longer answer is that I e=\r\nncourage you to post your idea on the JUnit\n&gt;&gt; &gt;&gt; mailing\n&gt;&gt; &gt;&gt; list for co=\r\nmmunity discussion.\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; Regards,\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; Kent\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; On Se=\r\np 13, 2011, at 8:32 AM, Stephen Connolly wrote:\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; &gt; Kent,\n&gt;&gt; &gt;&gt; &gt;=\r\n\n&gt;&gt; &gt;&gt; &gt; Are there any plans for JUnit to support some test dependencies, s=\r\nuch\n&gt;&gt; as:\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; public class OnlyRunTestsThatMakeSenseTest {\n&gt;&gt; =\r\n&gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; =A0@Test\n&gt;&gt; &gt;&gt; &gt; =A0public void basicFunctionalityWorks() {\n&gt;&gt;=\r\n &gt;&gt; &gt; =A0 =A0...\n&gt;&gt; &gt;&gt; &gt; =A0}\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; =A0@Test\n&gt;&gt; &gt;&gt; &gt; =A0@AssumesP=\r\nasses(&quot;basicFunctionalityWorks&quot;)\n&gt;&gt; &gt;&gt; &gt; =A0public void advancedFunctionali=\r\ntyWorks() {\n&gt;&gt; &gt;&gt; &gt; =A0 =A0...\n&gt;&gt; &gt;&gt; &gt; =A0}\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; =A0@Test\n&gt;&gt; &gt;&gt; =\r\n&gt; =A0@AssumesPasses(&quot;basicFunctionalityWorks&quot;)\n&gt;&gt; &gt;&gt; &gt; =A0public void basic=\r\nFunctionalityWorksWithBevel() {\n&gt;&gt; &gt;&gt; &gt; =A0 =A0...\n&gt;&gt; &gt;&gt; &gt; =A0}\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; =\r\n&gt;&gt; &gt; =A0@Test\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt;\n&gt;&gt; =A0@AssumesPasses({&quot;basicFunctionality=\r\nWorksWithBevel&quot;,&quot;advancedFunctionalityWorks&quot;})\n&gt;&gt; &gt;&gt; &gt; =A0public void advan=\r\ncedFunctionalityWorksWithBevel() {\n&gt;&gt; &gt;&gt; &gt; =A0 =A0...\n&gt;&gt; &gt;&gt; &gt; =A0}\n&gt;&gt; &gt;&gt; &gt;\n=\r\n&gt;&gt; &gt;&gt; &gt; }\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; In the above example, no matter what sorting is a=\r\npplied,\n&gt;&gt; &gt;&gt; &gt; basicFunctionalityWorks will always be run first, and the o=\r\nther three\n&gt;&gt; &gt;&gt; &gt; tests will only be run if basicFunctionalityWorks passed=\r\n.\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; I see the above being completely in the spirit of unit te=\r\nsting, the\n&gt;&gt; &gt;&gt; &gt; point with the above is that the @Before and @After&#39;s wi=\r\nll be run\n&gt;&gt; &gt;&gt; &gt; around each method, you are just saying that there is no =\r\npoint even\n&gt;&gt; &gt;&gt; &gt; trying to test the advanced functionality when the basic=\r\n functionality\n&gt;&gt; &gt;&gt; &gt; is broken, skip those tests which we know cannot pas=\r\ns. That allows the\n&gt;&gt; &gt;&gt; &gt; person writing advancedFunctionalityWorks to pow=\r\ner through the setup\n&gt;&gt; &gt;&gt; &gt; that depends on the basic functionality and no=\r\nt have to litter their\n&gt;&gt; &gt;&gt; &gt; advanced test with asserts that are redundan=\r\nt because of the basic\n&gt;&gt; &gt;&gt; &gt; functionality. Those people who are relying =\r\non side-effects should\n&gt;&gt; &gt;&gt; &gt; really, for unit tests at least, be invoking=\r\n the method who&#39;s\n&gt;&gt; &gt;&gt; &gt; side-effects they depend on directly within their=\r\n test method, rather\n&gt;&gt; &gt;&gt; &gt; than relying on accidental ordering.\n&gt;&gt; &gt;&gt; &gt;\n&gt;=\r\n&gt; &gt;&gt; &gt; Having said that, a second feature that I think would be good is\n&gt;&gt; =\r\n&gt;&gt; &gt; something like a @RunAfter and/or @RunBefore which would ensure that\n&gt;=\r\n&gt; &gt;&gt; &gt; the test method is run in sequence even if the before or after tests=\r\n\n&gt;&gt; &gt;&gt; &gt; fail/are skipped. with @RunAfter and @RunBefore I still think the\n=\r\n&gt;&gt; &gt;&gt; &gt; @Before and @After methods should be invoked in-between, this would=\r\n be\n&gt;&gt; &gt;&gt; &gt; moving towards more of a general purpose testing framework as o=\r\npposed\n&gt;&gt; &gt;&gt; &gt; to being unit-testing focused, but JUnit is just too good ;-=\r\n)\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; Thoughts?\n&gt;&gt; &gt;&gt; &gt;\n&gt;&gt; &gt;&gt; &gt; -Stephen\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; ----=\r\n--------------------------------\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt; Yahoo! Groups Links\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;=\r\n&gt;\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;&gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt; [Non-text portions of this message have been r=\r\nemoved]\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt; ------------------------------------\n&gt;&gt; &gt;\n&gt;&gt; &gt; =\r\nYahoo! Groups Links\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt;\n&gt;&gt;\n&gt;\n&gt;\n&gt; [Non-text portions of t=\r\nhis message have been removed]\n&gt;\n&gt;\n&gt;\n&gt; ------------------------------------=\r\n\n&gt;\n&gt; Yahoo! Groups Links\n&gt;\n&gt;\n&gt;\n&gt;\n\n", 
    "profile": "stephenalanconnolly", 
    "topicId": 23636, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 458231986, 
    "prevInTime": 23649, 
    "contentTrasformed": false, 
    "postDate": "1316161340", 
    "canDelete": false, 
    "nextInTopic": 23651, 
    "prevInTopic": 23649, 
    "headers": {
        "inReplyToHeader": "PENBK0J5Y0ZyYUo1bjJvZ2RlYnIyYk50OGg5M2pDTXhQd3NndEgzd3hPVDBKUGlTc0xCQUBtYWlsLmdtYWlsLmNvbT4=", 
        "messageIdInHeader": "PENBK25Qbk14Y3pVeG9hTStvM0p2UHFURFJTPS1MU19IdEFzd0dWeXk1UTdZZXdvT1FYd0BtYWlsLmdtYWlsLmNvbT4=", 
        "referencesHeader": "PENBK25Qbk13YmZOdnhiaHFqV1Z5WFc3VUR0MlZNNVR6d1d6d0FpUkphSGtLcm5Iem14UUBtYWlsLmdtYWlsLmNvbT4JPENBK25Qbk15UVB3X2htQjVQWmpZNXRPN0xkaFN2WEprYjdObjlKRlpyZUIxVnk1UDhvd0BtYWlsLmdtYWlsLmNvbT4JPENBQ2ZiT3ZlTTZOTVBKREZuNUI5dXlvNWJjY0ZKeTErcld2czgzNzNjR0hodjcxd1ZXZ0BtYWlsLmdtYWlsLmNvbT4JPENBK25Qbk16eW53NEZ3LTNGQkhGOD1kK2VtaEQzZzdTT3ZYSjZ4M3VONXVqKytBUC1Wd0BtYWlsLmdtYWlsLmNvbT4JPENBK0J5Y0ZyYUo1bjJvZ2RlYnIyYk50OGg5M2pDTXhQd3NndEgzd3hPVDBKUGlTc0xCQUBtYWlsLmdtYWlsLmNvbT4="
    }
}