{
    "numMessagesInTopic": 10, 
    "nextInTime": 24629, 
    "senderId": "Pp-6GJPkm_90GQVI8fjC-e8Vk9Z9cEqXNTPPbc2UH1xFftPNNUQYaBxqrGsk5OYmOPpHZEPyiUMmEeC3h1d_4txmZr_Jfyut5YAsq2Maow", 
    "systemMessage": false, 
    "subject": "Re: [junit] Decoupling JUnit and Hamcrest", 
    "from": "Stefan Bechtold &lt;stefan.bechtold@...&gt;", 
    "authorName": "Stefan Bechtold", 
    "msgSnippet": "Hi, this seems to be a discussion from Stefan to Stefan, so I cant hesitate to post an answer. ;-) I really think that separation is a good thing and should be", 
    "msgId": 24628, 
    "topicId": 24625, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 558173103, 
    "messageBody": "<div id=\"ygrps-yiv-1520351719\">Hi,<br/>\n<br/>\nthis seems to be a discussion from Stefan to Stefan, so I cant hesitate to post an answer. ;-)<br/>\n<br/>\nI really think that separation is a good thing and should be enforced by the JUnit team. Hamcrest is a great framework for assertions, but in some cases it is not needed or not the best fit. So the test writers should have to possibility to choose the assertion framework of their choice and the testing framework should smoothly work with it.<br/>\n<br/>\nWhat&#39;s behind my opinion? Some months ago I was playing around with different unit testing frameworks. While I was doing so I asked myself the question: How do you develop a unit testing framework using TDD practices? I sat down and started to create the first bits of code that would represent a &quot;unit test&quot;. With this very simple test in place I wrote some production code to execute the test case. Fun it was! I tried some more tests and continued to play around like this for some hours and when I finished I realized that I had developed a very rudimental unit testing framework. While being very rudimental, the framework still supports things like:<br/>\n<br/>\n- @Test, @Before, @After, @Ignore, @Context (like the hierarchical context runner for JUnit)<br/>\n- Test Groups and Test Suites,<br/>\n- Reporters (still no support for Listeners, but soon to come ;-))<br/>\n- Extendable Tests Creators (you can register a Factory to support your own Test Cases, like cucumber files, etc.)<br/>\n<br/>\nThe core idea of the framework was not to create a new standard, but to play around with TDD for building a Unit Testing Framework. I came up with two guidelines, which I think are very important for a next generation of JUnit (5.x for example):<br/>\n<br/>\n1. Provide a flexible and extendable framework that only cares about the execution and reporting of test cases and results<br/>\n2. Don&#39;t struggle with things third party libraries can offer, i.e. don&#39;t try to be the one-and-only tool for TDD<br/>\n<br/>\nIn order to be flexible and extendable, I think there should be some kind of application context that third party libraries may register themselves for certain activities, e.g. finding test cases (no longer limited to annotated Java Classes, input can be anything like cucumber tests), providing assertions (I simply used Hamcrest in my tests, but the user of the framework should be free to choose anything that throws an AssertionError), or to run tests multiple times or expect exceptions (I used Java 8 lambdas to create a very well readable syntax for it). I finally felt like this is the way to go: Separate the core framework from things that can be easily provided separately.<br/>\n<br/>\nTo give a very short impression of what a test will look like using my framework, look at this test case:<br/>\n<br/>\n// ...<br/>\n<br/>\npublic class TestContextTest {<br/>\n  @Test<br/>\n  public void givenInvalidTestContext_createInstanceFails() throws Exception {<br/>\n    expectThrowable(AssertionError.class).withMessage(&quot;Class not instantiable&quot;).in(() -&gt; {<br/>\n      TestClass testClass = new TestClass(TestContextWithPrivateConstructor.class);<br/>\n      TestContext testContext = new TestContext(testClass, TestContextWithPrivateConstructor.InvalidContext.class);<br/>\n      testContext.createTestInstance();<br/>\n    });<br/>\n  }<br/>\n<br/>\n  @Context<br/>\n  public class GivenTestContextWithSingleTest {<br/>\n    // ...<br/>\n<br/>\n    @Before<br/>\n    public void setupTestContext() throws Exception {<br/>\n      parentInstance = new TestContextWithSingleTest();<br/>\n      testClass = new TestClassMock(parentInstance);<br/>\n      testContext = new TestContext(testClass, TestContextWithSingleTest.TestContext.class);<br/>\n    }<br/>\n<br/>\n    @Test<br/>\n    public void createsAValidTestInstanceOfClassUnderTest() throws Exception {<br/>\n      TestContextWithSingleTest.TestContext instance = testContext.createTestInstance();<br/>\n      assertThat(instance, is(instanceOf(TestContextWithSingleTest.TestContext.class)));<br/>\n    }<br/>\n    <br/>\n    // ...<br/>\n  }<br/>\n<br/>\n  // ...<br/>\n}<br/>\n<br/>\nCode taken from: <a rel=\"nofollow\" target=\"_blank\" href=\"https://github.com/bechte/JUT/blob/master/src/test/java/de/bechte/jut/testables/TestContextTest.java\">https://github.com/bechte/JUT/blob/master/src/test/java/de/bechte/jut/testables/TestContextTest.java</a> (I crunched some lines for readability reasons).<br/>\n<br/>\nFor those who are interested in more details, I uploaded JUT at github: <a rel=\"nofollow\" target=\"_blank\" href=\"https://github.com/bechte/JUT\">https://github.com/bechte/JUT</a> - I really think it is worth a look at and we might use some ideas from it for a future JUnit release (especially the lambda style expressions for exception handling, which I think is much more readable). :-)<br/>\n<br/>\nAll the best,<br/>\n<br/>\nStefan<br/>\n<br/>\nAm 08.01.2015 um 23:15 schrieb Stefan Birkner <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:mail@...\">mail@...</a> [junit] &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>&gt;:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; <br/>\n&gt; Hi Stefan,<br/>\n&gt; <br/>\n&gt; thank you for your feedback.<br/>\n&gt; <br/>\n&gt; The JUnit team itself wants to get rid of the Hamcrest dependency. Basically Hamcrest is an assertion library (like AssertJ, Truth, ...) and it can be independent from JUnit. Therefore it must only use JUnit&#39;s interfaces (AssertionError and AssumptionViolatedException) and JUnit must not use Hamcrest. Both is possible, but it needs a new JUnit major release.<br/>\n&gt; <br/>\n&gt; ciao,<br/>\n&gt; stefan<br/>\n&gt; <br/>\n&gt; 2015-01-08 21:46 GMT+01:00 Stefan <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:stefan@...\">stefan@...</a> [junit] &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>&gt;:<br/>\n&gt;  <br/>\n&gt; Hi,<br/>\n&gt; <br/>\n&gt; I&#39;m not a developer of junit nor hamcrest and I don&#39;t feel the pain of the tight integration of junit and hamcrest that &quot;prevents both from moving on&quot; but I&#39;m a heavy user of both.<br/>\n&gt; I don&#39;t think it&#39;s a good idea to separate the hamcrest integration from junit into it&#39;s own library.<br/>\n&gt; <br/>\n&gt; At the moment JUnit dictates the hamcrest version to be used but also guarantees compatibility with this version.<br/>\n&gt; With the new library hamcrest developers will dictate the junit version that is compatible with a specific hamcrest release. This is only a change in responsibility but has no benefits.<br/>\n&gt; <br/>\n&gt; Of course there is also the opportunity to provide a broader range of compatible versions. But this opportunity also means more work for the maintainers and slower adoption by users. JUnit 4.12 uses hamcrest 1.3. What if JUnit moves on to 4.13, 4.14 and hamcrest releases 2.0 and 2.1 respectively. Will there be a version which is compatible with hamcrest 2.1 and JUnit 4.13? Will there be a version which is compatible with JUnit 4.14 and hamcrest 1.3?<br/>\n&gt; <br/>\n&gt; As a developer who want&#39;s to use JUnit 4.14 - how do I know which hamcrest-junit-integration version to use? What will stop me from using a wrong version? For example I might be tempted to update JUnit to 4.14 but forget to update hamcrest-junit-integration. There might be changes of the behaviour of JUnit that might cause some of my tests to pass always although they should fail. On the other hand: JUnit 4.14 might be binary incompatible to JUnit 4.12 - where to look for the right version of hamcrest-junit-integration?<br/>\n&gt; <br/>\n&gt; If hamcrest moves on to 2.0 - which could be binary incompatible to 1.3 due to the major version change (haven&#39;t checked) - how long will hamcrest 1.3 be supported with latest JUnit versions by hamcrest-junit-integration? I&#39;m asking because we also use JMock which depends on hamcrest as well. If I update to an incompatible 2.0 I need also an update of JMock....<br/>\n&gt; (( Actually I cannot update JMock without big effort because there was an incompatible change from 2.5.1 to 2.6 .... ))<br/>\n&gt; <br/>\n&gt; On the other hand this will slow down speed for adoption of new JUnit versions because we have to wait until a new hamcrest-junit-integration version is out or at least someone has built the appropriate version with latest JUnit release and verified unit tests are still passing. It will also increase the effort necessary to try JUnit release candidates or snapshots in real projects (because I also have to checkout and build the integration library myself to be sure there is no problem with that... and if there is a problem I need to fix it myself or stop using latest JUnit release candidate).<br/>\n&gt; <br/>\n&gt; ----<br/>\n&gt; IMHO decoupling JUnit and hamcrest has more drawbacks than benefits. Although I see it can be a chance for hamcrest to move on. I don&#39;t think JUnit as a project will profit that much. JUnit users might have a broader choice of compatible hamcrest versions but this requires some effort (of the maintainers of hamcrest-junit-integration). I think this might only work well for JUnit users if the JUnit team commits to that integration project and is able to push out new releases of the hamcrest-junit-integration together with new JUnit releases.<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; Regards,<br/>\n&gt; Stefan<br/>\n&gt; <br/>\n&gt; <br/>\n&gt; <br/>\n&gt; Am 07.01.2015 um 08:31 schrieb Stefan Birkner <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:mail@...\">mail@...</a> [junit]:<br/>\n&gt;&gt;  <br/>\n&gt;&gt; FYI: Nat Pryce took a first step for decoupling JUnit and Hamcrest:<br/>\n&gt;&gt; <a rel=\"nofollow\" target=\"_blank\" href=\"http://natpryce.com/articles/000806.html\">http://natpryce.com/articles/000806.html</a><br/>\n&gt;&gt; <br/>\n&gt; <br/>\n&gt; <br/>\n&gt; <br/>\n&gt; <br/>\n&gt; <br/>\n<br/>\n<br/>\n<br/>\n </span></blockquote>[Non-text portions of this message have been removed]</div>", 
    "prevInTime": 24627, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1420995884", 
    "canDelete": false, 
    "nextInTopic": 24629, 
    "prevInTopic": 24627, 
    "headers": {
        "inReplyToHeader": "PENBSGhZVko0cW5feHZiK2NaaXF6cm01RTRXRjMtcXZUX3hFenNKUFMwcng9aE5lY1UzUUBtYWlsLmdtYWlsLmNvbT4=", 
        "messageIdInHeader": "PDA4MjU2NjNBLTZGOEItNDA4My04OTUzLTY4MTA2RUVBQTA2RUBtZS5jb20+", 
        "referencesHeader": "PENBSGhZVko1OGN1NU1DS3FkYVZmR3E2OVI2MDI2Z2tOVUZBNVBDNFJrRms0TmFlU2lSQUBtYWlsLmdtYWlsLmNvbT4gPDU0QUVFQ0EwLjgwMTA5MDVAY3lwaG9yaWEubmV0PiA8Q0FIaFlWSjRxbl94dmIrY1ppcXpybTVFNFdGMy1xdlRfeEV6c0pQUzByeD1oTmVjVTNRQG1haWwuZ21haWwuY29tPg=="
    }
}