{
    "numMessagesInTopic": 7, 
    "nextInTime": 20717, 
    "senderId": "nGlyo-DSBKBDMv3VYCjVu3efHOZtffG7OTbnc1VjdnzwwgeNiiOM3OR7noZ3xZS4SrWW0mPvuRCCi6krH2qLiHgrWmPByGxPYaI_aV-zPapQn1Yl90hLtIvFJqy0xNMYTc8qdGfC7rof", 
    "systemMessage": false, 
    "subject": "RE: [junit] Newbie wants to take some JUnit group. Some basic questions.", 
    "from": "=?iso-8859-1?Q?B=F6hm=2C_Martin?= &lt;martin.boehm@...&gt;", 
    "authorName": "BÃ¶hm, Martin", 
    "msgSnippet": "Hi, sorry, for the late answer. ... Mock frameworks will help you in cases, when you want to manipulate the indirect outputs and inputs of a unit. Assuming", 
    "msgId": 20716, 
    "profile": "martinboehmsonneberg", 
    "topicId": 20700, 
    "spamInfo": {
        "reason": "3", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 334026059, 
    "messageBody": "<div id=\"ygrps-yiv-711859111\">Hi,<br/>\n<br/>\nsorry, for the late answer.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; -----Original Message-----<br/>\n&gt; From: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a> [mailto:<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>] On <br/>\n&gt; Behalf Of Serethos<br/>\n&gt; Sent: Dienstag, 22. Juli 2008 23:43<br/>\n&gt; To: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a><br/>\n&gt; Subject: Re: [junit] Newbie wants to take some JUnit group. <br/>\n&gt; Some basic questions.<br/>\n&gt; <br/>\n&gt; [...]<br/>\n&gt; <br/>\n&gt; No, but I hope to have soon some time investigating in <br/>\n&gt; EasyMock. Up to now I am not sure what to expect of it. With <br/>\n&gt; my little experience I only see the problem of provoking all <br/>\n&gt; possible error cases, e.g.:<br/>\n&gt; <br/>\n&gt; client.login(user, pass) // illegal arguments, authentication <br/>\n&gt; error, timeout ..?<br/>\n&gt; <br/>\n&gt; But as I said, I do not know, which help EasyMock offers me <br/>\n&gt; in these cases.<br/>\n<br/>\n </span></blockquote>Mock frameworks will help you in cases, when you want to manipulate<br/>\nthe indirect outputs and inputs of a unit. Assuming your login example<br/>\nuses a connection object, this connection object will provide outputs<br/>\nfor the client (exceptions, login...) as well as expecting<br/>\ninputs (connection parameters, network...). But these outputs and<br/>\ninputs are all indirect, so the client can&#39;t directly control.<br/>\n<br/>\nTo control these inputs anyway - maybe to test how the client reacts<br/>\non connection errors - you may use an object that substitutes the<br/>\nreal connection object. Usally you know the main exception cases,<br/>\nyou are able to handle in your objects method. All other exceptions<br/>\nare thrown through or you have to catch them at a deeper level.<br/>\n<br/>\nMock frameworks offer different substitutes for the real object.<br/>\nJB already mentioned it, if you hide the real implementation<br/>\ndetails behind interfaces, its easy to substitute, manipulate,<br/>\ncontrol etc. a dependend component.<br/>\n<br/>\nAnd thats it what you realy want: Isolate your unit and control<br/>\nit in a well definied environment to test all assumption as well<br/>\nas unsufficiencies, for example different exceptions, you except<br/>\nin your method and you can handle at this point.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; &gt; &quot;Whole&quot; sounds like a megajob, thats not a good practice in unit <br/>\n&gt; &gt; testing. Maybe the lifecycle is a separate object that controls <br/>\n&gt; &gt; different tasks; the connections and fetchers are <br/>\n&gt; serviceobjects that <br/>\n&gt; &gt; do something with your data objects.<br/>\n&gt; &gt; <br/>\n&gt; It sounds more than it is in my case. Such kinds of importers <br/>\n&gt; often are only some glue between data formats (xml/ db), <br/>\n&gt; connection handling (getting the data from a to<br/>\n&gt; b) and much reboust<br/>\n&gt; exception handling and logging.<br/>\n&gt; Sometimes - when I really think about which class should do <br/>\n&gt; what in contrast to others - I tend to code over-ambitioned. <br/>\n&gt; This leads to many classes which really do their<br/>\n&gt; job: connection handlers,<br/>\n&gt; value or transfer objects, data mappers, controllers <br/>\n&gt; whatever. And there lies a certain beauty, every class does <br/>\n&gt; only what it is ment for and even better: it only knows what <br/>\n&gt; i really needs. But for a simple task like &quot;get data from a, <br/>\n&gt; parse data into structure, put it into place b&quot; this produces <br/>\n&gt; lots of classes with perhaps two methods, and some more only <br/>\n&gt; for building an abstraction layer - which can be useless if <br/>\n&gt; it is not part of another bigger architecture.<br/>\n&gt; The endprduct can be a less beautyful code, but in best KISS manner.<br/>\n<br/>\n </span></blockquote>If an overall class is a sufficient solution, a simple and stupid<br/>\ntestcase may ensure your expectation as well. But...<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; &gt; All objects/units are easilier to test if they have one <br/>\n&gt; objectiv, that <br/>\n&gt; &gt; you can test separatly.<br/>\n&gt; &gt;<br/>\n&gt; &gt; <br/>\n&gt; Thats the point. I see a difference between a good practice <br/>\n&gt; in Unit Testing and the intention of how the class should be <br/>\n&gt; used. My FTP Example (very simplified):<br/>\n&gt; <br/>\n&gt; +FtpImporter(host, port, user, pass)<br/>\n&gt; +ImporterObjects[] import() // calls connect()/<br/>\n&gt; disconnect()<br/>\n&gt; -connect()<br/>\n&gt; -disconnect()<br/>\n&gt; (+ some setters getters for the attributes)<br/>\n&gt; <br/>\n&gt; It is clear that this is bad for two reasons:<br/>\n&gt; - no flexibility in controlling the data-/workflow <br/>\n&gt; (especially open, close)<br/>\n&gt; - therefore a problem in testing<br/>\n&gt; <br/>\n&gt; But there comes the advantage I mentioned as usage intention:<br/>\n&gt; - it is clear how to use the importer<br/>\n&gt; - it is very hard to bring the class in an invalid state<br/>\n&gt; <br/>\n&gt; Opening the open/close methods and offering the standard <br/>\n&gt; constructor for later code (configured) injection would offer <br/>\n&gt; a way to handle the class wrong:<br/>\n<br/>\n </span></blockquote>I&#39;m not really sure if its the intended usecase for the Importer<br/>\nto assume it has connected/disconnected states.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; new FtpImporter().import() // missing connect<br/>\n&gt; <br/>\n&gt; It would also need to put extra state validation into the <br/>\n&gt; connect/ disconnect methods<br/>\n<br/>\n </span></blockquote>Thats an assumption or expectation you want to test as well.<br/>\nSo I see no real chance to test this aspect as well in another<br/>\nway discribed by JBR.<br/>\n<br/>\nTo underline it, its easier to look onto interfaces at the<br/>\nfirst step and don&#39;t worry about the implementation details.<br/>\nFrom my first experience it also saves a little time, because<br/>\nyou don&#39;t waste your time on the uncertainity of quickly changing<br/>\nimplememantions - e.g. today SQL-Database-Persistence, tomorrow<br/>\nsome other Persistence.<br/>\n<br/>\n<blockquote><span title=\"qreply\"> &gt;  <br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 20715, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1217315210", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 20711, 
    "headers": {
        "inReplyToHeader": "PDQ4ODY1NDQ2LjgwNDA2MDJAd2ViLmRlPg==", 
        "messageIdInHeader": "PDE0OUM4RDRDN0NENkQ0NEZCOUUyNkNERUY0NDY5RDJFMDFGRjRDODlAc2RyZXhjMS5zYWx0LXNvbHV0aW9ucy5kZT4=", 
        "referencesHeader": "PGc2Mm5lYis1NWl0QGVHcm91cHMuY29tPiA8MTQ5QzhENEM3Q0Q2RDQ0RkI5RTI2Q0RFRjQ0NjlEMkUwMUZGNEM4MEBzZHJleGMxLnNhbHQtc29sdXRpb25zLmRlPiA8NDg4NjU0NDYuODA0MDYwMkB3ZWIuZGU+"
    }
}