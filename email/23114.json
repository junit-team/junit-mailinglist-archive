{
    "numMessagesInTopic": 22, 
    "nextInTime": 23115, 
    "senderId": "ja7x_vFlVkJen4-8Y2mIyvQh-gn6vwmEJtf1vCS1EDT3Az4TOBMh9ek6n3j_CjIgzDpwiyj1fv4cZl7m8as-DdivUxwX9Zb2kaphdFfo", 
    "systemMessage": false, 
    "subject": "Re: [junit] Re: Unit testing a private method??", 
    "from": "Esko Luontola &lt;esko.luontola@...&gt;", 
    "authorName": "Esko Luontola", 
    "msgSnippet": "... SPEED For me too, the speed of running the tests is important. If it takes over 5-10 seconds to run all the tests, then I will hesitate to run them after", 
    "msgId": 23114, 
    "profile": "egeluontola", 
    "topicId": 23073, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 395435659, 
    "messageBody": "<div id=\"ygrps-yiv-1098687586\">Mike Forsberg wrote on 5.12.2010 2:17:<br/>\n<blockquote><span title=\"ireply\"> &gt; In regards to... why do unit testing at all if everything is tested through<br/>\n&gt; functional testing.<br/>\n&gt;<br/>\n&gt; Personally, if I could get every scenario to run at the<br/>\n&gt; integration/functional level within the time I can run my unit tests, I&#39;d<br/>\n&gt; only write unit tests to track down why the higher level tests are failing.<br/>\n&gt; In this amazing world, a unit test would only be needed to track down a bug<br/>\n&gt; since my brain is not big enough to hold the whole system in it&#39;s mind.<br/>\n&gt; However, once the bug is fixed, the unit test can grow stale. As I&#39;d be<br/>\n&gt; assured that every possible scenario is tested.<br/>\n<br/>\n<br/>\n </span></blockquote>   SPEED<br/>\n<br/>\nFor me too, the speed of running the tests is important. If it takes <br/>\nover 5-10 seconds to run all the tests, then I will hesitate to run them <br/>\nafter every change, which in turn will lead to slower feedback and <br/>\nlonger times in finding the reason for a failure: If I run the tests <br/>\nless often, I will make more changes between running tests, and the <br/>\nmistake could be in any of those changed lines. But if I run tests after <br/>\nevery one-liner change and the tests break, there is a high probability <br/>\nthat the mistake was on that one line and I will find it quickly.<br/>\n<br/>\nSo I will have near-100% test coverage using unit tests, which I will <br/>\nrun many times per minute; these tests must run at a speed of hundreds <br/>\nor thousands of tests per second. Then I also have a small set of <br/>\nend-to-end tests, which I use the verify the existence of features and <br/>\nthat all the components have been plugged together correctly.<br/>\n<br/>\nP.S. When using Guice, I might have a unit test which creates the Guice <br/>\nInjector to check that the DI configuration doesn&#39;t contain such obvious <br/>\nerrors which Guice&#39;s built-in checks will find. But I would not <br/>\ninstantiate the SUT of my unit tests using Guice, because that&#39;s slow <br/>\n(on my C2Q6600 CPU about 5 ms to create the Injector), and because it <br/>\nwould not put as much design pressure on my code (more on that later).<br/>\n<br/>\n<br/>\n   FOCUS<br/>\n<br/>\nAnother reason is that by writing focused unit tests you can focus <br/>\nbetter on making that unit behave correctly in all corner cases (pun <br/>\nintended).<br/>\n<br/>\nFor example, I was writing a small transactional in-memory database and <br/>\nhad to introduce locking of multiple keys as an atomic group (my <br/>\nintegration tests were sometimes failing due to a concurrency bug - so <br/>\nat integration level the bug was reproducable, but very <br/>\nnon-deterministic), so I wrote a GroupLock [1] class which I could then <br/>\nuse in the database. What do you think, could all the corner cases <br/>\nmentioned in [2] be covered reliably with integration tests for a <br/>\nmulti-threaded system?<br/>\n<br/>\nIn the same in-memory database there were also other low-level <br/>\ncomponents which I test-drove using unit tests, because test-driving <br/>\nthem using higher level tests would not have been possible with small <br/>\nsteps. When I was test-driving the database class, at first I had all <br/>\nthe values in a HashMap, but then when I started to implement <br/>\ntransactions and multiversion concurrency control [3], I basically <br/>\nneeded a versioned Map which remembers some of the previous values, <br/>\nuntil there are no active transactions which can read those old <br/>\nversions. This produced the five Revision* classes at [4], in total over <br/>\n400 LOC, and I don&#39;t see how I could have test-driven those using only <br/>\nintegration tests. So I grew those classes using the four Revision*Spec <br/>\ntests at [5].<br/>\n<br/>\n[1] <br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"https://github.com/orfjackal/dimdwarf/blob/master/dimdwarf-core/src/main/java/net/orfjackal/dimdwarf/db/inmemory/GroupLock.java\">https://github.com/orfjackal/dimdwarf/blob/master/dimdwarf-core/src/main/java/net/orfjackal/dimdwarf/db/inmemory/GroupLock.java</a><br/>\n[2] <br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"https://github.com/orfjackal/dimdwarf/blob/master/dimdwarf-core/src/test/java/net/orfjackal/dimdwarf/db/inmemory/GroupLockSpec.java\">https://github.com/orfjackal/dimdwarf/blob/master/dimdwarf-core/src/test/java/net/orfjackal/dimdwarf/db/inmemory/GroupLockSpec.java</a><br/>\n[3] <a rel=\"nofollow\" target=\"_blank\" href=\"http://en.wikipedia.org/wiki/Multiversion_concurrency_control\">http://en.wikipedia.org/wiki/Multiversion_concurrency_control</a><br/>\n[4] <br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"https://github.com/orfjackal/dimdwarf/tree/master/dimdwarf-core/src/main/java/net/orfjackal/dimdwarf/db/inmemory\">https://github.com/orfjackal/dimdwarf/tree/master/dimdwarf-core/src/main/java/net/orfjackal/dimdwarf/db/inmemory</a><br/>\n[5] <br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"https://github.com/orfjackal/dimdwarf/tree/master/dimdwarf-core/src/test/java/net/orfjackal/dimdwarf/db/inmemory\">https://github.com/orfjackal/dimdwarf/tree/master/dimdwarf-core/src/test/java/net/orfjackal/dimdwarf/db/inmemory</a><br/>\n<br/>\n<br/>\n   PRESSURE<br/>\n<br/>\nStill one more reason why I write unit tests (in addition to end-to-end <br/>\ntests), is that writing unit tests is more painful [6]. To be able to <br/>\ntest something in isolation, the code needs to be decoupled and <br/>\ncohesive, and it needs to avoid global state and many other traits of <br/>\ngenerally bad design [7]. When dealing with bad code, writing unit tests <br/>\ncauses *more pain* than writing integration tests, which is a *good <br/>\nthing*, because it leads me to improve the design so that writing the <br/>\ntests will be easier. This in turn leads into better code and a more <br/>\nmaintainable design. If I would write only integration tests, or even no <br/>\ntests, then I would be shutting my eyes to the problem points in the <br/>\ndesign and there would be no pressure to improve the design.<br/>\n<br/>\nP.S. In the Growing Object-Oriented Software book the authors say that <br/>\nalso writing end-to-end tests puts design pressure on the system as a <br/>\nwhole, which leads to for example introducing monitoring hooks into the <br/>\nsystem. These hooks in turn also happen to be useful for monitoring the <br/>\nsystem in production.<br/>\n<br/>\n[6] <br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://blog.orfjackal.net/2010/04/direct-and-indirect-effects-of-tdd.html\">http://blog.orfjackal.net/2010/04/direct-and-indirect-effects-of-tdd.html</a><br/>\n[7] <br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://googletesting.blogspot.com/2008/08/by-miko-hevery-so-you-decided-to.html\">http://googletesting.blogspot.com/2008/08/by-miko-hevery-so-you-decided-to.html</a><br/>\n<br/>\n-- <br/>\nEsko Luontola<br/>\nwww.orfjackal.net</div>", 
    "prevInTime": 23113, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1291634957", 
    "canDelete": false, 
    "nextInTopic": 23295, 
    "prevInTopic": 23112, 
    "headers": {
        "inReplyToHeader": "PEFBTkxrVGltZ2RpT09BWkZicG1vUXlHSkhSeUYwcG9IdUZMaWlNRzh2Z3VEaEBtYWlsLmdtYWlsLmNvbT4=", 
        "messageIdInHeader": "PDRDRkNDOTBELjgwOTA4MDdAZ21haWwuY29tPg==", 
        "referencesHeader": "PEFBTkxrVGluQTlQaDlFWEsreWI1QTllb1hnaG5DMDFnTHl3Z05VUkFReUhxM0BtYWlsLmdtYWlsLmNvbT4JPGlkZGt2ZCs2aWNlQGVHcm91cHMuY29tPgk8QUFOTGtUaW1rRWNVZVBBRXlRLTM9TnYwbm5WeXVzTnhNT3JVPWItZmJ0PTRFQG1haWwuZ21haWwuY29tPiA8QUFOTGtUaW1nZGlPT0FaRmJwbW9ReUdKSFJ5RjBwb0h1RkxpaU1HOHZndURoQG1haWwuZ21haWwuY29tPg=="
    }
}