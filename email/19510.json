{
    "numMessagesInTopic": 5, 
    "nextInTime": 19511, 
    "senderId": "QGfsRl1wA6TP-Z4km8GNCeYaOmZhiR-soinGB3iwElVOZgQG5SHUh3OPJHgaZVVyAH-FEF5yktboP-XkAE9NRawwoFGgfb7Bh0Y", 
    "systemMessage": true, 
    "subject": "Re: should new Integer(1) equal new Long(1)", 
    "from": "&quot;vaughnbutt&quot; &lt;vaughnbutt@...&gt;", 
    "authorName": "vaughnbutt", 
    "msgSnippet": "I m glad B will fail as it should. To me, the principle least surprise means that when o1 and o2 are not null (regardless of their type) then assertEquals(o1,", 
    "msgId": 19510, 
    "profile": "vaughnbutt", 
    "topicId": 19509, 
    "spamInfo": {
        "reason": "6", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 204224862, 
    "messageBody": "<div id=\"ygrps-yiv-1816022716\">I&#39;m glad B will fail as it should.<br/>\n<br/>\nTo me, the principle least surprise means that when o1 and o2 are not<br/>\nnull (regardless of their type) then<br/>\n<br/>\nassertEquals(o1, o2)<br/>\n<br/>\nshould have the same result as<br/>\n<br/>\nassertTrue(o1.equals(o2))<br/>\n<br/>\nIf that means that A fails then so be it.<br/>\n<br/>\nHaving said that, I am a bit surprised that Integer.equals only<br/>\n&quot;likes&quot; other Integers (and not Longs for example).  But we shouldn&#39;t<br/>\nbe fixing java.lang in junit.<br/>\n<br/>\n<blockquote><span title=\"qreply\"> --- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>, &quot;David Saff&quot; &lt;saff@...&gt; wrote:<br/>\n&gt;<br/>\n&gt; All,<br/>\n&gt; <br/>\n&gt; Kent and I continue to try to fine-tune equality to produce the least<br/>\n&gt; surprise, and continue to wonder if well enough should have been left<br/>\n&gt; alone.  In 4.3, we introduced some run-time math magic to make up for<br/>\n&gt; the lack of type-expansion once we had removed most of the primitive<br/>\n&gt; type assertEquals methods.  Thus, it became the case, somewhat<br/>\n&gt; accidentally, that this would pass:<br/>\n&gt; <br/>\n&gt; assertEquals(new Integer(1), new Long(1));  // A<br/>\n&gt; <br/>\n&gt; However, it simultaneously became the case that this would also pass:<br/>\n&gt; <br/>\n&gt; assertEquals(new BigDecimal(&quot;1.0&quot;), new BigDecimal(&quot;1.1&quot;));  // B<br/>\n&gt; <br/>\n&gt; Line B should certainly fail.  The simplest thing to do is to remove<br/>\n&gt; our math magic, introduce assertEquals(long, long), etc, and let<br/>\n&gt; numerical classes define their own equality.  This means that line A<br/>\n&gt; will now fail, since that&#39;s how Integer.equals() is defined.  This is<br/>\n&gt; a small behavior change, but a &quot;regression&quot; of sorts.<br/>\n&gt; <br/>\n&gt; If anyone believes this is a damaging decision, please let me know.<br/>\n&gt; <br/>\n&gt;    David Saff<br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 19509, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1183090204", 
    "canDelete": false, 
    "nextInTopic": 19512, 
    "prevInTopic": 19509, 
    "headers": {
        "inReplyToHeader": "PDRmN2RhNmI5MDcwNjI4MTM1OHI1YWI0YWY1cjRmMDg3MWU4MjZhZDI5ZjFAbWFpbC5nbWFpbC5jb20+", 
        "messageIdInHeader": "PGY2MjBtcyttZjg3QGVHcm91cHMuY29tPg=="
    }
}