{
    "numMessagesInTopic": 287, 
    "nextInTime": 17750, 
    "senderId": "fguB6hFlRLAg2_6BhJXta3L5iVJN1hTAxf422DGZEAdZ5RFmAmmZy2zrcAUFENmDMmgI_5jvGJnrUDalqnvOipbMlseyIH3UGhbtZfjV7y4", 
    "systemMessage": false, 
    "subject": "Re: Test-friendly, but not caller-friendly?", 
    "from": "Robert Martin &lt;UncleBob@...&gt;", 
    "authorName": "Robert Martin", 
    "msgSnippet": "... It s not.  Overuse of factories is an abomination.  So *IF* I thought an interface would help, I would simply prefer: Document doc =", 
    "msgId": 17749, 
    "rawEmail": "Return-Path: &lt;unclebob@...&gt;\r\nX-Sender: unclebob@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (qmail 65975 invoked from network); 3 Sep 2006 03:20:46 -0000\r\nReceived: from unknown (66.218.66.216)\n  by m29.grp.scd.yahoo.com with QMQP; 3 Sep 2006 03:20:46 -0000\r\nReceived: from unknown (HELO cliff.objectmentor.com) (67.153.232.124)\n  by mta1.grp.scd.yahoo.com with SMTP; 3 Sep 2006 03:20:45 -0000\r\nReceived: from [192.168.1.6] ([::ffff:76.16.89.49])\n  (AUTH: LOGIN robertcmartin, SSL: TLSv1/SSLv3,128bits,RC4-SHA)\n  by cliff.objectmentor.com with esmtp; Sat, 02 Sep 2006 22:20:40 -0500\r\nMime-Version: 1.0 (Apple Message framework v752.2)\r\nTo: junit@yahoogroups.com\r\nMessage-Id: &lt;5A785051-1549-439D-8671-EE5F4FAD88DA@...&gt;\r\nDate: Sat, 2 Sep 2006 22:20:40 -0500\r\nX-Mailer: Apple Mail (2.752.2)\r\nX-eGroups-Msg-Info: 1:0:0:0\r\nFrom: Robert Martin &lt;UncleBob@...&gt;\r\nSubject: Re: Test-friendly, but not caller-friendly?\r\nX-Yahoo-Group-Post: member; u=85922638; y=wPF6BzCpbaDD9eABTSmjUMR2frRkXLjHYieRBP4AYzqIfo1Rhw\r\nX-Yahoo-Profile: rmartinoma\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\n\r\n&gt; Robert Martin wrote:\n&gt;\n&gt; &gt; [interfaces] make receiving a message more complex, it&#39;s true.  \n&gt; They make\n&gt; &gt; sending a message much simpler. Or rather, they add more lines of\n&gt; &gt; code on the receiving side; but they eliminate dependencies on the\n&gt; &gt; sending side. The benefit of those eliminated dependencies is very\n&gt; &gt; powerful.\n&gt; &gt;\n&gt;\n&gt; I&#39;m not sure I believe the second part. In practice, replacing a\n&gt; concrete-class based solution with an interface-based solution expands\n&gt; the complexity for the caller. What used to require a single class now\n&gt; typically requires three: a factory to create the factory, the factory\n&gt; itself, and the interface you&#39;re actually trying to create. I&#39;m not  \n&gt; sure\n&gt; you really need all that, but you need at least two pieces where you\n&gt; previously needed one, and in practice three is what we usually  \n&gt; seem to\n&gt; end up with. (Think of DocumentBuilderFactory, DocumentBuilder, and\n&gt; Document in JAXP/DOM for example). And of course there are still\n&gt; concrete classes for each of these. We&#39;ve turned what could have been\n&gt; one concrete class (Document) into six separate pieces! What could  \n&gt; have\n&gt; been this:\n&gt;\n&gt; Document doc = new Document();\n&gt;\n&gt; is now this:\n&gt;\n&gt; DocumentBuilderFactory factory = DocumentBuilderFactory.getInstance();\n&gt; DocumentBuilder builder = factory.newDocumentBuilder();\n&gt; Document doc = builder.newDocument();\n&gt;\n&gt; I fail to see how that&#39;s simpler.\n\nIt&#39;s not.  Overuse of factories is an abomination.  So *IF* I thought  \nan interface would help, I would simply prefer:\n\nDocument doc = Document.newDocument();\n\nThe simplicity of interfaces vs concrete classes comes from  \ndependencies.  Let&#39;s say we have some concrete class named  \nMyDocument, and it has lots and lots of methods.  Users of this class  \ndepend on all these methods even if they don&#39;t call them.  If I make  \na change to MyDocument it can affect all the callers to the extent  \nthat they all have to be recompiled and redeployed.  (Yes, you can  \nplay the game and try to figure out whether or not the class really  \nand truly needs to be recompiled, but that way lay madness.)\n\nIf I interpose one or more interfaces then suddenly the callers  \ndepend ONLY on the methods in the interfaces that they use; and those  \ninterfaces can be *very* sparse.  Even if there is only one  \ninterface, and that interface has all the methods of MyDocument I can  \nstill swap out MyDocument for some other implementation or some Mock  \nimplementation.  I can also add new methods to MyDocument without  \nforcing recompilation and redeployment of the callers.\n\n From the point of view of a caller, it is much simpler to depend on  \nan interface than a concrete class.\n\n\n----\nRobert C. Martin (Uncle Bob)  | email: unclebob@...\nObject Mentor Inc.            | blog:  www.butunclebob.com\nThe Agile Transition Experts  | web:   www.objectmentor.com\n800-338-6716                  |\n\n\n\n\n\n\n[Non-text portions of this message have been removed]\n\n\n", 
    "profile": "rmartinoma", 
    "topicId": 17266, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 85922638, 
    "prevInTime": 17748, 
    "contentTrasformed": false, 
    "postDate": "1157253640", 
    "canDelete": false, 
    "nextInTopic": 17750, 
    "prevInTopic": 17748, 
    "headers": {
        "messageIdInHeader": "PDVBNzg1MDUxLTE1NDktNDM5RC04NjcxLUVFNUY0RkFEODhEQUBvYmplY3RtZW50b3IuY29tPg=="
    }
}