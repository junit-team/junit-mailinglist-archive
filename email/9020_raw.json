{
    "numMessagesInTopic": 24, 
    "nextInTime": 9021, 
    "senderId": "a6mD0sX81Kw0xfD8NO3dwjYB4hp8HiGg7PvfnSpAnkPqS2AJ3jcBpCKtO-TJIyt1AqpQHeeE-8Cw4Fhwp1HY2XS9L0WZ4MbA", 
    "systemMessage": false, 
    "subject": "Re: How to test a main(String[] args) method?", 
    "from": "&quot;jxingtang&quot; &lt;jxingtang@...&gt;", 
    "authorName": "jxingtang", 
    "msgSnippet": "... method. ... founds ... test ... test ... production ... (see ... value;}      // ... on ... (used ... case! ... instead ... field ... false ... method, ...", 
    "msgId": 9020, 
    "rawEmail": "Return-Path: &lt;jxingtang@...&gt;\r\nReceived: (qmail 85251 invoked by uid 7800); 4 Aug 2003 20:31:03 -0000\r\nX-Sender: jxingtang@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (qmail 36073 invoked from network); 4 Aug 2003 20:24:51 -0000\r\nReceived: from unknown (66.218.66.217)\n  by m3.grp.scd.yahoo.com with QMQP; 4 Aug 2003 20:24:51 -0000\r\nReceived: from unknown (HELO n30.grp.scd.yahoo.com) (66.218.66.87)\n  by mta2.grp.scd.yahoo.com with SMTP; 4 Aug 2003 20:24:50 -0000\r\nReceived: from [66.218.67.186] by n30.grp.scd.yahoo.com with NNFMP; 04 Aug 2003 20:24:50 -0000\r\nDate: Mon, 04 Aug 2003 20:24:48 -0000\r\nTo: junit@yahoogroups.com\r\nSubject: Re: How to test a main(String[] args) method?\r\nMessage-ID: &lt;bgmfeg+ht12@...&gt;\r\nIn-Reply-To: &lt;NFBBLFDNMJLNLJAJJKNAIENGFHAA.achepati67@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Length: 8122\r\nX-Mailer: Yahoo Groups Message Poster\r\nFrom: &quot;jxingtang&quot; &lt;jxingtang@...&gt;\r\nX-Yahoo-Group-Post: member; u=126373237\r\nX-Yahoo-Profile: jxingtang\r\nX-eGroups-Approved-By: nails762 &lt;jbrains@...&gt; via email; 4 Aug 2003 20:31:03 -0000\r\n\r\n--- In junit@yahoogroups.com, &quot;David&quot; &lt;achepati67@y...&gt; wrote:\n&gt; See below...\n&gt;   -----Mensaje original-----\n&gt;   De: jxingtang [mailto:jxingtang@y...]\n&gt;   Enviado el: viernes, 01 de agosto de 2003 0:33\n&gt;   Para: junit@yahoogroups.com\n&gt;   Asunto: [junit] Re: How to test a main(String[] args) method?\n&gt; \n&gt; \n&gt;   --- In junit@yahoogroups.com, &quot;David&quot; &lt;achepati67@y...&gt; wrote:\n&gt;   &gt; &gt;Dear Members,\n&gt;   &gt; &gt;\n&gt;   &gt; &gt;I whould like to test a class with a main(String[] args) \nmethod.\n&gt;   Depending\n&gt;   &gt; &gt;on the input argument it executes one thing or the other. The\n&gt;   problem is\n&gt;   &gt; &gt;that on my main(String[] args) method at the end or when it \nfounds\n&gt;   an\n&gt;   &gt; error,\n&gt;   &gt; &gt;the method System.exit() is invoked. So when I define jUnit \ntest\n&gt;   cases\n&gt;   &gt; &gt;(methods with prefix test), jUnits only runs the first test,\n&gt;   because\n&gt;   &gt; some&gt;System.exit() was invoked.\n&gt;   &gt; &gt;Is there any way to test such kind of situations?\n&gt;   &gt; &gt;Thanks in advance,\n&gt;   &gt;\n&gt;   &gt; The solution propoused by Bern was:\n&gt;   &gt;\n&gt;   &gt; java.lang.System is final and does not implement interfaces,so\n&gt;   there is no\n&gt;   &gt; chance to replace ist behaviour.You may want to replace calls to\n&gt;   &gt; System.exit() with calls againstan interface you define. Under \ntest\n&gt;   use an\n&gt;   &gt; implementation which allowsyourtest code to chech if the exit\n&gt;   method has\n&gt;   &gt; been called by main() but whichdoes not exit the VM. In \nproduction\n&gt;   use an\n&gt;   &gt; implememtation which delegatesto System.exit().\n&gt;   &gt;\n&gt;   &gt; As far as I know what you mean could be implemented like this: \n(see\n&gt;   comments\n&gt;   &gt; below)\n&gt;   &gt;\n&gt;   &gt; package com.my.example\n&gt;   &gt;\n&gt;   &gt; public class Example {\n&gt;   &gt;       static Finish _finish = new Example.ProductionFinish();//\n&gt;   private package\n&gt;   &gt; (static because it is\n&gt;   &gt;\n&gt;               // going to be used on main.)\n&gt;   &gt;       static void setFinish(Finish value){_finish = \nvalue;}      //\n&gt;   private package\n&gt;   &gt;\n&gt;   &gt;       static main (String[] args)\n&gt;   &gt;\n&gt;   &gt;             boolean goOn = true;       // because we don&#39;t exit \non\n&gt;   testing mode,\n&gt;   &gt;                                     // we need a way for\n&gt;   controling the execution flow.\n&gt;   &gt;             if (someCondition) {// first checking (exceptional\n&gt;   flow)\n&gt;   &gt;                   goOn = finish.do(-1);\n&gt;   &gt;             }\n&gt;   &gt;             // ... put other checking here\n&gt;   &gt;             if (goOn && otherCondition) {// main flow\n&gt;   &gt;                   finish.do(0);\n&gt;   &gt;             }\n&gt;   &gt;       }\n&gt;   &gt;\n&gt;   &gt;       /* Now we define the interface Finish and its default\n&gt;   implementation (as\n&gt;   &gt; inner classes\n&gt;   &gt;       with private-package visibility, because we have to define\n&gt;   ONLY for testing\n&gt;   &gt; purpose this\n&gt;   &gt;       interface!)*/\n&gt;   &gt;\n&gt;   &gt;       interface Finish {\n&gt;   &gt;             boolean do(int i);\n&gt;   &gt;       }\n&gt;   &gt;\n&gt;   &gt;       class ProductionFinish {// its default implementation \n(used\n&gt;   on production\n&gt;   &gt; mode)\n&gt;   &gt;             ProductionFinish(){} // default constructor with\n&gt;   private-package\n&gt;   &gt; visibility\n&gt;   &gt;             boolean do(int i) {\n&gt;   &gt;                   System.exit(i);\n&gt;   &gt;             }\n&gt;   &gt;       }\n&gt;   &gt; }\n&gt;   &gt;\n&gt;   &gt; Now on the testing class defined on the same package:\n&gt;   &gt;\n&gt;   &gt; package com.my.example\n&gt;   &gt;\n&gt;   &gt; public class ExampleTest extends TestCase{\n&gt;   &gt;       // ...\n&gt;   &gt;           protected void setUp (){Example.setFinish(new\n&gt;   &gt; ExampleTest.TestingFinish());}\n&gt;   &gt;       }\n&gt;   &gt;       class TestingFinish implements Example.Finish{\n&gt;   &gt;             TestingFinish (){} // default constructor with\n&gt;   private-package visibility\n&gt;   &gt;             boolean do(int i) { // We have to stop on every \ncase!\n&gt;   &gt;                   return false;\n&gt;   &gt;             }\n&gt;   &gt;       }\n&gt;   &gt; }\n&gt;   &gt;\n&gt;   &gt; COMMENTS:\n&gt;   &gt;\n&gt;   &gt; - About this suggestion and the corresponding implementation,\n&gt;   because we\n&gt;   &gt; need a default implementation ALWAYS (for production), then \ninstead\n&gt;   of using\n&gt;   &gt; an INTERFACE, it is BETTER to just define the class Finish as\n&gt;   ABSTRACT (the\n&gt;   &gt; do(int i) method should be abstract)\n&gt;   &gt;\n&gt;   &gt; - You have to write A LOT for makeing a very simple task. I have\n&gt;   implemented\n&gt;   &gt; a simpler solution, just do the following steps:\n&gt;   &gt;\n&gt;   &gt; a) Define on the class to test (Example), the static boolean \nfield\n&gt;   _TEST as\n&gt;   &gt; private-package. This field is initialized with default value: \nfalse\n&gt;   &gt; (production)\n&gt;   &gt;\n&gt;   &gt; b) Define a STATIC PRIVATE method finish, like this:\n&gt;   &gt;             private static boolean finish(int i) {\n&gt;   &gt;                   if(!_TEST) {\n&gt;   &gt;                         System.exit(i);\n&gt;   &gt;                   }\n&gt;   &gt;                   return false;\n&gt;   &gt;             }\n&gt;   &gt; c) On the testing class (ExampleTest), set on the setup() \nmethod,\n&gt;   the field\n&gt;   &gt; _TEST to true.\n&gt;   &gt;\n&gt;   &gt;\n&gt;   &gt; Now we have:\n&gt;   &gt;\n&gt;   &gt; package com.my.example\n&gt;   &gt;\n&gt;   &gt; public class Example {\n&gt;   &gt;       static boolean _TEST = false;\n&gt;   &gt;\n&gt;   &gt;       static main (String[] args)\n&gt;   &gt;\n&gt;   &gt;             boolean goOn = true;\n&gt;   &gt;             if (someCondition) {// fist checking\n&gt;   &gt;                   goOn = finish(-1);\n&gt;   &gt;             }\n&gt;   &gt;             // ... put other checking here\n&gt;   &gt;             if (goOn && otherCondition) {// the last condition\n&gt;   (end of the program)\n&gt;   &gt;                   finish(-1);\n&gt;   &gt;             }\n&gt;   &gt;       }\n&gt;   &gt;\n&gt;   &gt;       private static boolean finish (int i) {\n&gt;   &gt;             if (!_TEST) {\n&gt;   &gt;                   System.exit(i);\n&gt;   &gt;             }\n&gt;   &gt;             return false;\n&gt;   &gt;       }\n&gt;   &gt; }\n&gt;   &gt;\n&gt;   &gt; package com.my.example\n&gt;   &gt;\n&gt;   &gt; public class ExampleTest extends TestCase{\n&gt;   &gt;       // ...\n&gt;   &gt;           protected void setUp (){Example._TEST = true;}\n&gt;   &gt;       }\n&gt;   &gt; }\n&gt;   &gt;\n&gt;   &gt; I think this solution is enough. Any suggestion?\n&gt;   &gt;\n&gt;   &gt; Thanks in advance,\n&gt;   &gt;\n&gt;   &gt; David\n&gt; \n&gt; \n&gt;   Just wondering how the testMain() looks like? How do you cover for\n&gt;   all different arguments combination? Do you have to separate \ntestMain\n&gt;   () for each scenario? Thanks!\n&gt;   [David Leal] In general I have the following test methods:\n&gt;   testMain_help for testing when the user invokes the &quot;-h&quot;. &quot;-help&quot; \non my\n&gt; case.\n&gt;   testMain_exceptionalFlow for testing situation that produces \nerrors and\n&gt; the process is abruptly stoped.\n&gt;   testMain_mainFlow it is the main flow execution.\n&gt; \n&gt;   I coollects all possible outputs: error and standard output on \nfiles\n&gt; (using the methods: System.setOut(), System.setErr()) and then \ncompare the\n&gt; files with the expected ones. That is may test.\n&gt; \n&gt;   That is my aproach, because on test mode the main() method \ndoesn&#39;t finish\n&gt; (Example._TEST= true), we can test more than one invocation to the \nmethod.\n&gt; \n&gt;   Hope this help,\n&gt; \n&gt;   David\n\nBy reading your answers to my question, I suddenly had a second \nthought to the approach to test main(...) method. Personally, I think \nthat the approach we have been discussed so far is little bit over \nengineering for Junit test. We are compelled to change the design to \nfaciliate unit testing. It may not be a good idea. So far, we just \nachieved test the exit code invoked by main. To test whether other \nmethods should be called, I am afraid that we may need introduce more \nmock object/interface. For instance, if main(...) calls fooA(), fooB\n()...fooX(), fooY() and fooZ(), then we may have to introduce \nfooA_4test(),fooB_4test()...fooZ_4test() to verify that \nfooA,fooB,,,fooZ are called by main(). Here we just want to test that \nthese foo methods are called but how they are exeucted is out of the \nscope of just testing main(...). This is what the task for \ntestMain_mainFlow should be. \n\nFor testMain_exceptionalFlow, could we try something to avoid \nchanging the code?\n\nString[] cmdStrArr = { &quot;myCmd exceptArg1,exceptArg2...&quot;,\n                       ....\n                      };\n\nfor( int i=0; i&lt;cmdStrArr.length; i++ )\n{\n    Process mainProcess = Runtime.getRuntime.exec( cmdStrArr[ i ] );\n\n    int exitVal = mainProcess.exitValue();\n \n    assertEqual( exitValue, ... );\n}\n\nThanks a lot for your input and correction!\n\n\n \n\n\n", 
    "profile": "jxingtang", 
    "topicId": 8737, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 126373237, 
    "prevInTime": 9019, 
    "contentTrasformed": false, 
    "postDate": "1060028688", 
    "canDelete": false, 
    "nextInTopic": 9021, 
    "prevInTopic": 9016, 
    "headers": {
        "inReplyToHeader": "PE5GQkJMRkROTUpMTkxKQUpKS05BSUVOR0ZIQUEuYWNoZXBhdGk2N0B5YWhvby5lcz4=", 
        "messageIdInHeader": "PGJnbWZlZytodDEyQGVHcm91cHMuY29tPg=="
    }
}