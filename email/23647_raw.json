{
    "topicId": 23636, 
    "postDate": "1316021119", 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "from": "Tomek Kaczanowski &lt;kaczanowski.tomek@...&gt;", 
    "canDelete": false, 
    "replyTo": "LIST", 
    "senderId": "0j1M2e2313U9uwOFrWFv6gID4clKfPi6JLu9DFCX2zKTB7o0BoaoV9wA-zaeb7zD4UHeRClPLD-wTGP4AvNxW-cfV3WV0Cs5k2N8F8SAL6Yx_HQOtzM", 
    "nextInTime": 23648, 
    "userId": 475099113, 
    "prevInTime": 23646, 
    "prevInTopic": 23646, 
    "headers": {
        "inReplyToHeader": "PENBK25Qbk16eW53NEZ3LTNGQkhGOD1kK2VtaEQzZzdTT3ZYSjZ4M3VONXVqKytBUC1Wd0BtYWlsLmdtYWlsLmNvbT4=", 
        "messageIdInHeader": "PENBK0J5Y0ZyYUo1bjJvZ2RlYnIyYk50OGg5M2pDTXhQd3NndEgzd3hPVDBKUGlTc0xCQUBtYWlsLmdtYWlsLmNvbT4=", 
        "referencesHeader": "PENBK25Qbk13YmZOdnhiaHFqV1Z5WFc3VUR0MlZNNVR6d1d6d0FpUkphSGtLcm5Iem14UUBtYWlsLmdtYWlsLmNvbT4JPENBK25Qbk15UVB3X2htQjVQWmpZNXRPN0xkaFN2WEprYjdObjlKRlpyZUIxVnk1UDhvd0BtYWlsLmdtYWlsLmNvbT4JPENBQ2ZiT3ZlTTZOTVBKREZuNUI5dXlvNWJjY0ZKeTErcld2czgzNzNjR0hodjcxd1ZXZ0BtYWlsLmdtYWlsLmNvbT4JPENBK25Qbk16eW53NEZ3LTNGQkhGOD1kK2VtaEQzZzdTT3ZYSjZ4M3VONXVqKytBUC1Wd0BtYWlsLmdtYWlsLmNvbT4="
    }, 
    "authorName": "Tomek Kaczanowski", 
    "numMessagesInTopic": 13, 
    "msgSnippet": "Sound like TestNG dependsOn feature. But from what I know, JUnit is against any kind of test dependencies (there was a recent discussion on this mailing list,", 
    "contentTrasformed": false, 
    "msgId": 23647, 
    "nextInTopic": 23648, 
    "systemMessage": true, 
    "rawEmail": "Return-Path: &lt;kaczanowski.tomek@...&gt;\r\nReceived: (qmail 47169 invoked from network); 16 Sep 2011 00:36:39 -0000\r\nReceived: from unknown (98.137.35.161)\n  by m7.grp.sp2.yahoo.com with QMQP; 16 Sep 2011 00:36:39 -0000\r\nReceived: from unknown (HELO n37b.bullet.mail.sp1.yahoo.com) (66.163.168.151)\n  by mta5.grp.sp2.yahoo.com with SMTP; 16 Sep 2011 00:36:39 -0000\r\nDKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoogroups.com; s=lima; t=1316133399; bh=RYuMhppMQUGgux+t/MTVI52G9t165pKsaPHvMcZzWZ8=; h=Received:Received:X-Sender:X-Apparently-To:X-Received:X-Received:X-Received:X-Received:MIME-Version:X-Received:X-Received:In-Reply-To:References:Date:Message-ID:To:X-Originating-IP:X-eGroups-Msg-Info:From:Subject:X-Yahoo-Group-Post:Content-Type:Content-Transfer-Encoding:X-YGroups-SubInfo:Sender:X-Yahoo-Newman-Property:X-eGroups-Approved-By:X-eGroups-Auth; b=uLjVusb+Z2EVqNh4FmCiTNmlK+HT+vk4ht5AaC4DL8aXGv/53br4uG4TML2cJmPTHEuAD9PLWZUhWQrBe8JTyNLvH9BvxDzYJerWP6aWtTY+xGMNgFhgUgp3YkGU9oxz\r\nReceived: from [69.147.65.151] by n37.bullet.mail.sp1.yahoo.com with NNFMP; 16 Sep 2011 00:36:39 -0000\r\nReceived: from [98.137.34.184] by t5.bullet.mail.sp1.yahoo.com with NNFMP; 16 Sep 2011 00:36:39 -0000\r\nX-Sender: kaczanowski.tomek@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nX-Received: (qmail 17808 invoked from network); 14 Sep 2011 17:25:20 -0000\r\nX-Received: from unknown (98.137.35.160)\n  by m3.grp.sp2.yahoo.com with QMQP; 14 Sep 2011 17:25:20 -0000\r\nX-Received: from unknown (HELO mail-gy0-f175.google.com) (209.85.160.175)\n  by mta4.grp.sp2.yahoo.com with SMTP; 14 Sep 2011 17:25:20 -0000\r\nX-Received: by gyg8 with SMTP id 8so1542221gyg.6\n        for &lt;junit@yahoogroups.com&gt;; Wed, 14 Sep 2011 10:25:20 -0700 (PDT)\r\nMIME-Version: 1.0\r\nX-Received: by 10.236.181.101 with SMTP id k65mr545690yhm.65.1316021119871; Wed,\n 14 Sep 2011 10:25:19 -0700 (PDT)\r\nX-Received: by 10.236.208.131 with HTTP; Wed, 14 Sep 2011 10:25:19 -0700 (PDT)\r\nIn-Reply-To: &lt;CA+nPnMzynw4Fw-3FBHF8=d+emhD3g7SOvXJ6x3uN5uj++AP-Vw@...&gt;\r\nReferences: &lt;CA+nPnMwbfNvxbhqjWVyXW7UDt2VM5TzwWzwAiRJaHkKrnHzmxQ@...&gt;\n\t&lt;CA+nPnMyQPw_hmB5PZjY5tO7LdhSvXJkb7Nn9JFZreB1Vy5P8ow@...&gt;\n\t&lt;CACfbOveM6NMPJDFn5B9uyo5bccFJy1+rWvs8373cGHhv71wVWg@...&gt;\n\t&lt;CA+nPnMzynw4Fw-3FBHF8=d+emhD3g7SOvXJ6x3uN5uj++AP-Vw@...&gt;\r\nDate: Wed, 14 Sep 2011 19:25:19 +0200\r\nMessage-ID: &lt;CA+BycFraJ5n2ogdebr2bNt8h93jCMxPwsgtH3wxOT0JPiSsLBA@...&gt;\r\nTo: junit@yahoogroups.com\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: Tomek Kaczanowski &lt;kaczanowski.tomek@...&gt;\r\nSubject: Re: [junit] Feature request: @Assumes\r\nX-Yahoo-Group-Post: member; u=475099113; y=51hABLOiDahuoszAq63n1Z0dPsjorojms3xJXweTj6UzQSd_xJkELnMicfmwAoZuwtIfH5ke9wrxpdQ\r\nContent-Type: text/plain\r\nContent-Transfer-Encoding: quoted-printable\r\nX-Yahoo-Newman-Property: groups-system\r\nX-eGroups-Approved-By: spchappell &lt;simonpeterchappell@...&gt; via web; 16 Sep 2011 00:36:38 -0000\r\n\r\nSound like TestNG dependsOn feature. But from what I know, JUnit is against=\r\n\nany kind of test dependencies (there was a recent discussion on this maili=\r\nng\nlist, see http://tech.groups.yahoo.com/group/junit/message/23568). A sho=\r\nrt\nquote from this discussion: &quot;It has always been a deliberate design deci=\r\nsion\nin JUnit that we would *not* guarantee the order of test execution.&quot;\n\n=\r\n-- \nRegards / Pozdrawiam\nTomek Kaczanowski\nhttp://kaczanowscy.pl/tomek\n\n201=\r\n1/9/14 Stephen Connolly &lt;stephen.alan.connolly@...&gt;\n\n&gt;\n&gt;\n&gt; Nope not a=\r\n mock at all.\n&gt;\n&gt; Say you have a class List (which is not java.util.List bu=\r\nt looks a lot\n&gt; like it in terms of interface)\n&gt;\n&gt; This list class is somet=\r\nhing you are developing via TDD.\n&gt;\n&gt; You write a whole lot of unit tests fo=\r\nr it.\n&gt;\n&gt; Now suppose it happens to be a linked list, and you decide to cha=\r\nnge\n&gt; from a null for end of list marker to a sentinel instead. All your\n&gt; =\r\nmethods are working now, except for the isEmpty() method, but yet 200+\n&gt; te=\r\nst cases are failing because they all rely on isEmpty working. Which\n&gt; unit=\r\n test do I try to fix first?\n&gt;\n&gt; with @Assumes, you would have 1 failing te=\r\nst and 199 skipped tests...\n&gt;\n&gt; No mocks involved at all\n&gt;\n&gt;\n&gt; On 14 Septem=\r\nber 2011 16:34, Carfield Yim &lt;carfield@...&gt; wrote:\n&gt; &gt; It sound like =\r\na mock, isn&#39;t it?\n&gt; &gt;\n&gt; &gt; On Wed, Sep 14, 2011 at 6:02 PM, Stephen Connolly=\r\n &lt;\n&gt; &gt; stephen.alan.connolly@...&gt; wrote:\n&gt; &gt;\n&gt; &gt;&gt; Note: I have also p=\r\nosted this to junit-devel@... but\n&gt; &gt;&gt; I think that wider=\r\n input could be beneficial\n&gt; &gt;&gt;\n&gt; &gt;&gt; Consider the case where you are testin=\r\ng a List class...\n&gt; &gt;&gt;\n&gt; &gt;&gt; we have\n&gt; &gt;&gt;\n&gt; &gt;&gt; public class ListTest {\n&gt; &gt;&gt;\n=\r\n&gt; &gt;&gt;  @Test\n&gt; &gt;&gt;  public void newListIsEmpty() {\n&gt; &gt;&gt;    assertThat(new Lis=\r\nt().isEmpty(), is(true);\n&gt; &gt;&gt;  }\n&gt; &gt;&gt;\n&gt; &gt;&gt;  @Test\n&gt; &gt;&gt;  public void newList=\r\nHasSizeZero() {\n&gt; &gt;&gt;    assertThat(new List().size(), is(0));\n&gt; &gt;&gt;  }\n&gt; &gt;&gt;\n=\r\n&gt; &gt;&gt;  @Test\n&gt; &gt;&gt;  public void addPutsAnElementIntoAnEmptyList() {\n&gt; &gt;&gt;    L=\r\nist l =3D new List();\n&gt; &gt;&gt;    l.add(new Object());\n&gt; &gt;&gt;    assertThat(l.isE=\r\nmpty(), is(false));\n&gt; &gt;&gt;  }\n&gt; &gt;&gt;\n&gt; &gt;&gt;  @Test\n&gt; &gt;&gt;  public void addIncreases=\r\nSizeOfPopulatedListByOne() {\n&gt; &gt;&gt;    List l =3D new List();\n&gt; &gt;&gt;    l.add(n=\r\new Object());\n&gt; &gt;&gt;    int s =3D l.size();\n&gt; &gt;&gt;    l.add(new Object());\n&gt; &gt;&gt;=\r\n    assertThat(l.size(), is(s + 1));\n&gt; &gt;&gt;  }\n&gt; &gt;&gt;\n&gt; &gt;&gt; }\n&gt; &gt;&gt;\n&gt; &gt;&gt; We now w=\r\nant to add some tests of the delete functionality... but the\n&gt; &gt;&gt; reality i=\r\ns that until/unless some of the preceding tests are passing,\n&gt; &gt;&gt; the tests=\r\n for delete are meaningless. We could have a perfectly\n&gt; &gt;&gt; functional List=\r\n.delete() method but until such time as the above tests\n&gt; &gt;&gt; are passing, t=\r\nhere is no way to tell that the method does not work.\n&gt; &gt;&gt;\n&gt; &gt;&gt; Now I could=\r\n code my tests like such\n&gt; &gt;&gt;\n&gt; &gt;&gt;  @Test\n&gt; &gt;&gt;  public void deleteIsANoOpOn=\r\nEmptyList() {\n&gt; &gt;&gt;    List l =3D new List();\n&gt; &gt;&gt;    assumeThat(l.isEmpty()=\r\n, is(true));\n&gt; &gt;&gt;    l.delete(new Object());\n&gt; &gt;&gt;  }\n&gt; &gt;&gt;\n&gt; &gt;&gt; But all that=\r\n I am doing is repeating code from the preceding tests,\n&gt; &gt;&gt; having changed=\r\n all those tests&#39; assertThat(...)s into assumeThat(...)s\n&gt; &gt;&gt;\n&gt; &gt;&gt; That doe=\r\ns not seem agile to me, copy & paste & search & replace... ban\n&gt; &gt;&gt; code sm=\r\nell there\n&gt; &gt;&gt;\n&gt; &gt;&gt; I would much rather be able to annotate the tests with =\r\nan @Assumes\n&gt; &gt;&gt; annotation that indicates that the test assumes that the s=\r\npecified\n&gt; &gt;&gt; tests are passing, e.g.\n&gt; &gt;&gt;\n&gt; &gt;&gt;  @Test\n&gt; &gt;&gt;  @Assumes(&quot;newL=\r\nistIsEmpty&quot;)\n&gt; &gt;&gt;  public void deleteIsANoOpOnEmptyList() {\n&gt; &gt;&gt;    List l =\r\n=3D new List();\n&gt; &gt;&gt;    l.delete(new Object());\n&gt; &gt;&gt;  }\n&gt; &gt;&gt;\n&gt; &gt;&gt;  @Test\n&gt; =\r\n&gt;&gt;  @Assumes({&quot;newListIsEmpty&quot;,&quot;addPutsAnElementIntoAnEmptyList&quot;)\n&gt; &gt;&gt;  pub=\r\nlic void deleteRemovesAnElement() {\n&gt; &gt;&gt;    List l =3D new List();\n&gt; &gt;&gt;    =\r\nObject o =3D new Object();\n&gt; &gt;&gt;    l.add(o);\n&gt; &gt;&gt;    l.delete(o);\n&gt; &gt;&gt;    a=\r\nssertThat(l.isEmpty(), is(true));\n&gt; &gt;&gt;  }\n&gt; &gt;&gt;\n&gt; &gt;&gt; In fact in my initial e=\r\nxample of tests, there are some additional\n&gt; &gt;&gt; assumptions that I didn&#39;t m=\r\nake explicit\n&gt; &gt;&gt;\n&gt; &gt;&gt;\n&gt; &gt;&gt;  @Test\n&gt; &gt;&gt;  @Assumes(&quot;newListIsEmpty&quot;)\n&gt; &gt;&gt;  p=\r\nublic void addPutsAnElementIntoAnEmptyList() {\n&gt; &gt;&gt;    ...\n&gt; &gt;&gt;  }\n&gt; &gt;&gt;\n&gt; &gt;=\r\n&gt; and\n&gt; &gt;&gt;\n&gt; &gt;&gt;  @Test\n&gt; &gt;&gt;  @Assumes({&quot;newListIsEmpty&quot;,&quot;addPutsAnElementIn=\r\ntoAnEmptyList&quot;)\n&gt; &gt;&gt;  public void addIncreasesSizeOfPopulatedListByOne() {\n=\r\n&gt; &gt;&gt;    ...\n&gt; &gt;&gt;  }\n&gt; &gt;&gt;\n&gt; &gt;&gt; Now you could get some of this functionality =\r\nvia a TestRule...\n&gt; &gt;&gt;\n&gt; &gt;&gt; You could watch tests to see if they pass, and =\r\nskip tests annotated\n&gt; &gt;&gt; with the annotation if assumed functionality is f=\r\nailing, but that\n&gt; &gt;&gt; would result in sporadic failures of, e.g. deleteRemo=\r\nvesAnElement\n&gt; &gt;&gt; because of the failing newListIsEmpty being executed _aft=\r\ner_\n&gt; &gt;&gt; deleteRemovesAnElement rather than before.\n&gt; &gt;&gt;\n&gt; &gt;&gt; The simple po=\r\nint is that the test result of deleteRemovesAnElement is\n&gt; &gt;&gt; meaningless u=\r\nntil its assumptions are true, and while I could code the\n&gt; &gt;&gt; assumptions =\r\nwith assumeThat(..)s C&P&S&R is even worse than C&P.\n&gt; &gt;&gt;\n&gt; &gt;&gt; Another alte=\r\nrnative to @Assumes would be to invoke the assumed\n&gt; &gt;&gt; method(s) at the st=\r\nart of the test, e.g.\n&gt; &gt;&gt;\n&gt; &gt;&gt;  @Test\n&gt; &gt;&gt;  public void deleteRemovesAnEle=\r\nment() {\n&gt; &gt;&gt;    newListIsEmpty(); // verify assumed functionality\n&gt; &gt;&gt;    =\r\naddPutsAnElementIntoAnEmptyList();  // verify assumed functionality\n&gt; &gt;&gt;   =\r\n ...\n&gt; &gt;&gt;  }\n&gt; &gt;&gt;\n&gt; &gt;&gt; That gets rid of the C&P&S&R, but there are two issu=\r\nes with that:\n&gt; &gt;&gt;\n&gt; &gt;&gt;  1. We have to manually invoke any setup/tearDown m=\r\nethods, including\n&gt; &gt;&gt; all those of the rules that the test class has... ve=\r\nry messy\n&gt; &gt;&gt;\n&gt; &gt;&gt;  2. The test fails when the assumed test fails. In actua=\r\nlity we can\n&gt; &gt;&gt; say nothing at all about whether deleteRemovesAnElement if=\r\n a\n&gt; &gt;&gt; newListIsEmpty is not passing... yes we could code the test\n&gt; &gt;&gt; di=\r\nfferently, but that is just moving our assumptions somewhere else.\n&gt; &gt;&gt;\n&gt; &gt;=\r\n&gt; I am sure that there are others out there who feel there is a point 3...\n=\r\n&gt; &gt;&gt;\n&gt; &gt;&gt;  3. We already ran those tests why waste time running them again?=\r\n\n&gt; &gt;&gt;\n&gt; &gt;&gt; Well the answer to 3 is that these are UNIT tests which should b=\r\ne very\n&gt; &gt;&gt; fast, so what is the harm...\n&gt; &gt;&gt;\n&gt; &gt;&gt; So, in my view, best pra=\r\nctice unit testing needs the ability to mark\n&gt; &gt;&gt; tests as assuming that ot=\r\nher tests are passing, so that those tests\n&gt; &gt;&gt; can be skipped when the ass=\r\numptions are known to be failing or\n&gt; &gt;&gt; skipped. [This is a deliberately l=\r\noaded criteria... if the\n&gt; &gt;&gt; org.junit.runner.Request does not include the=\r\n assumed test, then that\n&gt; &gt;&gt; test is neither known failing or known skippe=\r\nd, so we can run the test\n&gt; &gt;&gt; and output a warning that the failure may be=\r\n because of assumed\n&gt; &gt;&gt; functionality... the use case of executing one and=\r\n only one test\n&gt; &gt;&gt; repeatedly until you get that test passing]\n&gt; &gt;&gt;\n&gt; &gt;&gt; T=\r\nhe annotation would have implications on test sorting, as any assumed\n&gt; &gt;&gt; =\r\ntests would have to always happen before the assuming tests (as long\n&gt; &gt;&gt; a=\r\ns the assumed tests are in the org.junit.runner.Request)\n&gt; &gt;&gt;\n&gt; &gt;&gt; Also mig=\r\nht have to be two annotations, e.g.\n&gt; &gt;&gt;\n&gt; &gt;&gt; @Assumes(methodNames)\n&gt; &gt;&gt; @A=\r\nssumesClasses(classes)\n&gt; &gt;&gt;\n&gt; &gt;&gt; though in my view the @AssumesClasses is l=\r\ness critical, as these are\n&gt; &gt;&gt; UNIT tests and each test class should be in=\r\ndependent to a large\n&gt; &gt;&gt; extent. However I am willing to consider that som=\r\ne people may have\n&gt; &gt;&gt; many test classes for one class under test, one test=\r\n class containing\n&gt; &gt;&gt; all the tests of the constructors, another testing t=\r\nhe Add methods,\n&gt; &gt;&gt; etc. in which case an @AssumesClasses annotation makes=\r\n sense.\n&gt; &gt;&gt;\n&gt; &gt;&gt; Where tests contain a circular dependency, fail/error bot=\r\nh tests\n&gt; &gt;&gt;\n&gt; &gt;&gt; Ok, let the critique begin!\n&gt; &gt;&gt;\n&gt; &gt;&gt; -Stephen\n&gt; &gt;&gt;\n&gt; &gt;&gt; =\r\nP.S.\n&gt; &gt;&gt;\n&gt; &gt;&gt; I pinged Kent with an earlier version of this idea... but I =\r\nthink that\n&gt; &gt;&gt; he missed the point about eliminating C&P&S&R that this fea=\r\nture would\n&gt; &gt;&gt; provide because I didn&#39;t frame the idea correctly...\n&gt; &gt;&gt;\n&gt;=\r\n &gt;&gt; ---------- Forwarded message ----------\n&gt; &gt;&gt; From: &quot;Kent Beck&quot;\n&gt; &gt;&gt; Dat=\r\ne: 13 Sep 2011 17:11\n&gt; &gt;&gt; Subject: Re: JUnit and test dependencies\n&gt; &gt;&gt; To:=\r\n &quot;Stephen Connolly&quot;\n&gt; &gt;&gt;\n&gt; &gt;&gt; Stephen,\n&gt; &gt;&gt;\n&gt; &gt;&gt; Thank you for articulating=\r\n your idea so clearly. The short answer is\n&gt; that\n&gt; &gt;&gt; no, we don&#39;t plan to=\r\n support dependencies. If I have tests that are slow\n&gt; &gt;&gt; enough that I car=\r\ne about dependencies, my most productive option is\n&gt; &gt;&gt; generally to work o=\r\nn the design of the software until the tests are fast\n&gt; &gt;&gt; enough that I no=\r\n longer care. That said, my voice is only one of many.\n&gt; The\n&gt; &gt;&gt; longer an=\r\nswer is that I encourage you to post your idea on the JUnit\n&gt; &gt;&gt; mailing\n&gt; =\r\n&gt;&gt; list for community discussion.\n&gt; &gt;&gt;\n&gt; &gt;&gt; Regards,\n&gt; &gt;&gt;\n&gt; &gt;&gt; Kent\n&gt; &gt;&gt;\n&gt; =\r\n&gt;&gt; On Sep 13, 2011, at 8:32 AM, Stephen Connolly wrote:\n&gt; &gt;&gt;\n&gt; &gt;&gt; &gt; Kent,\n&gt;=\r\n &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; Are there any plans for JUnit to support some test dependencie=\r\ns, such\n&gt; as:\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; public class OnlyRunTestsThatMakeSenseTest {\n&gt; =\r\n&gt;&gt; &gt;\n&gt; &gt;&gt; &gt;  @Test\n&gt; &gt;&gt; &gt;  public void basicFunctionalityWorks() {\n&gt; &gt;&gt; &gt;  =\r\n  ...\n&gt; &gt;&gt; &gt;  }\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt;  @Test\n&gt; &gt;&gt; &gt;  @AssumesPasses(&quot;basicFunctiona=\r\nlityWorks&quot;)\n&gt; &gt;&gt; &gt;  public void advancedFunctionalityWorks() {\n&gt; &gt;&gt; &gt;    ..=\r\n.\n&gt; &gt;&gt; &gt;  }\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt;  @Test\n&gt; &gt;&gt; &gt;  @AssumesPasses(&quot;basicFunctionality=\r\nWorks&quot;)\n&gt; &gt;&gt; &gt;  public void basicFunctionalityWorksWithBevel() {\n&gt; &gt;&gt; &gt;    =\r\n...\n&gt; &gt;&gt; &gt;  }\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt;  @Test\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt;\n&gt; &gt;&gt;\n&gt;  @AssumesPasses({&quot;bas=\r\nicFunctionalityWorksWithBevel&quot;,&quot;advancedFunctionalityWorks&quot;})\n&gt; &gt;&gt; &gt;  publi=\r\nc void advancedFunctionalityWorksWithBevel() {\n&gt; &gt;&gt; &gt;    ...\n&gt; &gt;&gt; &gt;  }\n&gt; &gt;&gt;=\r\n &gt;\n&gt; &gt;&gt; &gt; }\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; In the above example, no matter what sorting is a=\r\npplied,\n&gt; &gt;&gt; &gt; basicFunctionalityWorks will always be run first, and the ot=\r\nher three\n&gt; &gt;&gt; &gt; tests will only be run if basicFunctionalityWorks passed.\n=\r\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; I see the above being completely in the spirit of unit testin=\r\ng, the\n&gt; &gt;&gt; &gt; point with the above is that the @Before and @After&#39;s will be=\r\n run\n&gt; &gt;&gt; &gt; around each method, you are just saying that there is no point =\r\neven\n&gt; &gt;&gt; &gt; trying to test the advanced functionality when the basic functi=\r\nonality\n&gt; &gt;&gt; &gt; is broken, skip those tests which we know cannot pass. That =\r\nallows the\n&gt; &gt;&gt; &gt; person writing advancedFunctionalityWorks to power throug=\r\nh the setup\n&gt; &gt;&gt; &gt; that depends on the basic functionality and not have to =\r\nlitter their\n&gt; &gt;&gt; &gt; advanced test with asserts that are redundant because o=\r\nf the basic\n&gt; &gt;&gt; &gt; functionality. Those people who are relying on side-effe=\r\ncts should\n&gt; &gt;&gt; &gt; really, for unit tests at least, be invoking the method w=\r\nho&#39;s\n&gt; &gt;&gt; &gt; side-effects they depend on directly within their test method, =\r\nrather\n&gt; &gt;&gt; &gt; than relying on accidental ordering.\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; Having sai=\r\nd that, a second feature that I think would be good is\n&gt; &gt;&gt; &gt; something lik=\r\ne a @RunAfter and/or @RunBefore which would ensure that\n&gt; &gt;&gt; &gt; the test met=\r\nhod is run in sequence even if the before or after tests\n&gt; &gt;&gt; &gt; fail/are sk=\r\nipped. with @RunAfter and @RunBefore I still think the\n&gt; &gt;&gt; &gt; @Before and @=\r\nAfter methods should be invoked in-between, this would be\n&gt; &gt;&gt; &gt; moving tow=\r\nards more of a general purpose testing framework as opposed\n&gt; &gt;&gt; &gt; to being=\r\n unit-testing focused, but JUnit is just too good ;-)\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; Thought=\r\ns?\n&gt; &gt;&gt; &gt;\n&gt; &gt;&gt; &gt; -Stephen\n&gt; &gt;&gt;\n&gt; &gt;&gt;\n&gt; &gt;&gt; ----------------------------------=\r\n--\n&gt; &gt;&gt;\n&gt; &gt;&gt; Yahoo! Groups Links\n&gt; &gt;&gt;\n&gt; &gt;&gt;\n&gt; &gt;&gt;\n&gt; &gt;&gt;\n&gt; &gt;\n&gt; &gt;\n&gt; &gt; [Non-text =\r\nportions of this message have been removed]\n&gt; &gt;\n&gt; &gt;\n&gt; &gt;\n&gt; &gt; ---------------=\r\n---------------------\n&gt; &gt;\n&gt; &gt; Yahoo! Groups Links\n&gt; &gt;\n&gt; &gt;\n&gt; &gt;\n&gt; &gt;\n&gt;  \n&gt;\n\n\n[=\r\nNon-text portions of this message have been removed]\n\n\n", 
    "subject": "Re: [junit] Feature request: @Assumes"
}