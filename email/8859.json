{
    "numMessagesInTopic": 24, 
    "nextInTime": 8860, 
    "senderId": "vk55vrmTl8HWt6tyLy6FX14icXoVf1PgJSazQsCtZTGhGtPSma4F9DKpamkMO9TekLWkNoyVIPhpKtk7u9dOkhafmpE", 
    "systemMessage": false, 
    "subject": "RE: [junit] How to test a main(String[] args) method?", 
    "from": "&quot;David&quot; &lt;achepati67@...&gt;", 
    "authorName": "David", 
    "msgSnippet": "... error, ... some System.exit() was invoked. ... The solution propoused by Bern was: java.lang.System is final and does not implement interfaces,so there is", 
    "msgId": 8859, 
    "profile": "achepati67", 
    "topicId": 8737, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 152694144, 
    "messageBody": "<div id=\"ygrps-yiv-495331189\"><blockquote><span title=\"ireply\">&gt;Dear Members,<br/>\n&gt;<br/>\n&gt;I whould like to test a class with a main(String[] args) method. Depending<br/>\n&gt;on the input argument it executes one thing or the other. The problem is<br/>\n&gt;that on my main(String[] args) method at the end or when it founds an<br/>\n </span></blockquote>error,<br/>\n<blockquote><span title=\"ireply\"> &gt;the method System.exit() is invoked. So when I define jUnit test cases<br/>\n&gt;(methods with prefix test), jUnits only runs the first test, because<br/>\n </span></blockquote>some&gt;System.exit() was invoked.<br/>\n<blockquote><span title=\"ireply\"> &gt;Is there any way to test such kind of situations?<br/>\n&gt;Thanks in advance,<br/>\n<br/>\n </span></blockquote>The solution propoused by Bern was:<br/>\n<br/>\njava.lang.System is final and does not implement interfaces,so there is no<br/>\nchance to replace ist behaviour.You may want to replace calls to<br/>\nSystem.exit() with calls againstan interface you define. Under test use an<br/>\nimplementation which allowsyourtest code to chech if the exit method has<br/>\nbeen called by main() but whichdoes not exit the VM. In production use an<br/>\nimplememtation which delegatesto System.exit().<br/>\n<br/>\nAs far as I know what you mean could be implemented like this: (see comments<br/>\nbelow)<br/>\n<br/>\npackage com.my.example<br/>\n<br/>\npublic class Example {<br/>\n\tstatic Finish _finish = new Example.ProductionFinish();// private package<br/>\n(static because it is<br/>\n\t\t\t\t\t\t\t\t\t\t// going to be used on main.)<br/>\n\tstatic void setFinish(Finish value){_finish = value;}\t// private package<br/>\n<br/>\n\tstatic main (String[] args)<br/>\n<br/>\n\t\tboolean goOn = true; \t// because we don&#39;t exit on testing mode,<br/>\n\t\t\t\t\t\t// we need a way for controling the execution flow.<br/>\n\t\tif (someCondition) {// first checking (exceptional flow)<br/>\n\t\t\tgoOn = finish.do(-1);<br/>\n\t\t}<br/>\n\t\t// ... put other checking here<br/>\n\t\tif (goOn && otherCondition) {// main flow<br/>\n\t\t\tfinish.do(0);<br/>\n\t\t}<br/>\n\t}<br/>\n<br/>\n\t/* Now we define the interface Finish and its default implementation (as<br/>\ninner classes<br/>\n\twith private-package visibility, because we have to define ONLY for testing<br/>\npurpose this<br/>\n\tinterface!)*/<br/>\n<br/>\n\tinterface Finish {<br/>\n\t\tboolean do(int i);<br/>\n\t}<br/>\n<br/>\n\tclass ProductionFinish {// its default implementation (used on production<br/>\nmode)<br/>\n\t\tProductionFinish(){} // default constructor with private-package<br/>\nvisibility<br/>\n\t\tboolean do(int i) {<br/>\n\t\t\tSystem.exit(i);<br/>\n\t\t}<br/>\n\t}<br/>\n}<br/>\n<br/>\nNow on the testing class defined on the same package:<br/>\n<br/>\npackage com.my.example<br/>\n<br/>\npublic class ExampleTest extends TestCase{<br/>\n\t// ...<br/>\n    \tprotected void setUp (){Example.setFinish(new<br/>\nExampleTest.TestingFinish());}<br/>\n\t}<br/>\n\tclass TestingFinish implements Example.Finish{<br/>\n\t\tTestingFinish (){} // default constructor with private-package visibility<br/>\n\t\tboolean do(int i) { // We have to stop on every case!<br/>\n\t\t\treturn false;<br/>\n\t\t}<br/>\n\t}<br/>\n}<br/>\n<br/>\nCOMMENTS:<br/>\n<br/>\n- About this suggestion and the corresponding implementation, because we<br/>\nneed a default implementation ALWAYS (for production), then instead of using<br/>\nan INTERFACE, it is BETTER to just define the class Finish as ABSTRACT (the<br/>\ndo(int i) method should be abstract)<br/>\n<br/>\n- You have to write A LOT for makeing a very simple task. I have implemented<br/>\na simpler solution, just do the following steps:<br/>\n<br/>\na) Define on the class to test (Example), the static boolean field _TEST as<br/>\nprivate-package. This field is initialized with default value: false<br/>\n(production)<br/>\n<br/>\nb) Define a STATIC PRIVATE method finish, like this:<br/>\n\t\tprivate static boolean finish(int i) {<br/>\n\t\t\tif(!_TEST) {<br/>\n\t\t\t\tSystem.exit(i);<br/>\n\t\t\t}<br/>\n\t\t\treturn false;<br/>\n\t\t}<br/>\nc) On the testing class (ExampleTest), set on the setup() method, the field<br/>\n_TEST to true.<br/>\n<br/>\n<br/>\nNow we have:<br/>\n<br/>\npackage com.my.example<br/>\n<br/>\npublic class Example {<br/>\n\tstatic boolean _TEST = false;<br/>\n<br/>\n\tstatic main (String[] args)<br/>\n<br/>\n\t\tboolean goOn = true;<br/>\n\t\tif (someCondition) {// fist checking<br/>\n\t\t\tgoOn = finish(-1);<br/>\n\t\t}<br/>\n\t\t// ... put other checking here<br/>\n\t\tif (goOn && otherCondition) {// the last condition (end of the program)<br/>\n\t\t\tfinish(-1);<br/>\n\t\t}<br/>\n\t}<br/>\n<br/>\n\tprivate static boolean finish (int i) {<br/>\n\t\tif (!_TEST) {<br/>\n\t\t\tSystem.exit(i);<br/>\n\t\t}<br/>\n\t\treturn false;<br/>\n\t}<br/>\n}<br/>\n<br/>\npackage com.my.example<br/>\n<br/>\npublic class ExampleTest extends TestCase{<br/>\n\t// ...<br/>\n    \tprotected void setUp (){Example._TEST = true;}<br/>\n\t}<br/>\n}<br/>\n<br/>\nI think this solution is enough. Any suggestion?<br/>\n<br/>\nThanks in advance,<br/>\n<br/>\nDavid</div>", 
    "prevInTime": 8858, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1059555398", 
    "canDelete": false, 
    "nextInTopic": 8891, 
    "prevInTopic": 8840, 
    "headers": {
        "messageIdInHeader": "PE5GQkJMRkROTUpMTkxKQUpKS05BS0VLSEZIQUEuYWNoZXBhdGk2N0B5YWhvby5lcz4="
    }
}