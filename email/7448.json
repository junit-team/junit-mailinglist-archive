{
    "numMessagesInTopic": 45, 
    "nextInTime": 7449, 
    "senderId": "Uo4xEh4qkdm58r5kia9T0VwRsORWWYYzLA7lebnB15yd_UHhF6fURESoqzXd6bS4T0s8FmcCLBkeFsONagLsyaqgNoVNuUGRiicySsguwGuWyAVj2fKPqx7pmhL5nBot9g", 
    "systemMessage": false, 
    "subject": "Re: [junit] Re: JUnit considered problematic", 
    "from": "Herr Christian Wolfgang Hujer &lt;Christian.Hujer@...&gt;", 
    "authorName": "Herr Christian Wolfgang Hujer", 
    "msgSnippet": "... Hash: SHA1 [Note for duplicate mail: http://www.heise.de/newsticker/data/uma-01.04.03-000 Zahlreiche Mails müssen nun ein zweites Mal gesendet werden.", 
    "msgId": 7448, 
    "topicId": 7355, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 108505539, 
    "messageBody": "<div id=\"ygrps-yiv-1079133709\">-----BEGIN PGP SIGNED MESSAGE-----<br/>\nHash: SHA1<br/>\n<br/>\n[Note for duplicate mail:<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.heise.de/newsticker/data/uma-01.04.03-000\">http://www.heise.de/newsticker/data/uma-01.04.03-000</a><br/>\nZahlreiche Mails müssen nun ein zweites Mal gesendet werden. Sorry für <br/>\nDuplikate.<br/>\nMany mails must be sent a second time. Sorry for duplicates.]<br/>\n<br/>\n<br/>\nHi,<br/>\n<br/>\n<br/>\nAm Mittwoch, 2. April 2003 09:46 schrieb javainsel:<br/>\n<blockquote><span title=\"ireply\"> &gt; I wish I would be a expert to convince you of a better approach than<br/>\n&gt; JUnit provides (and TDD).<br/>\n </span></blockquote>You can&#39;t, because Exceptions, Assertions, JUnit and Design by Contract are<br/>\nnot competing but complementary approaches on the same aspect: Increase the<br/>\nstability and robustness of code and decrease the number of bugs.<br/>\n&quot;DBC is better than JUnit&quot; is like saying &quot;Bolts are better than glue&quot;.<br/>\n<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; But I try.<br/>\n </span></blockquote>Of course you may.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; I consider Design by Contract to be suitable to replace JUnit and TDD<br/>\n&gt; completely. It can provide many benefits and by the same time not<br/>\n&gt; having all the side effects that JUnit and TDD have. Examples are<br/>\n&gt; Eiffel and Java Modelling Language (JML).<br/>\n&gt;<br/>\n&gt; Why? How? I&#39;ll explain.<br/>\n&gt;<br/>\n&gt; Testing of the code (methods) can be done with precondition,<br/>\n&gt; invartiants and postconditions (the contracts). Thats how I<br/>\n&gt; understand Design by Contract. You write your method definition and<br/>\n&gt; then you write the contract for it. Then you implement your method.<br/>\n </span></blockquote>No.<br/>\n<br/>\nYou must differ between:<br/>\na) External preconditions and postconditions.<br/>\nTextField tf = (TextField) e.getSource();<br/>\nMyDate df = new MyDate();<br/>\ndf.setDayOfMonth(Integer.parseInt(tf.getText()));<br/>\nDesign by Contract won&#39;t solve the problem, it could only help.<br/>\nSuch Preconditions currently must be solved using Exceptions.<br/>\nYou even don&#39;t use Assertions for that, Exceptions are used there.<br/>\nDesignByContract can only help by replacing<br/>\nif (day &lt; 1 || day &gt; 31) { throw new IllegalArgumentException(); }<br/>\nwith a contract. A more declarative way for restricting argument ranges is<br/>\nalways increasing robustness and therefore welcome.<br/>\nOr take a look at the next() method of the interface Iterator. Design by<br/>\nContract won&#39;t help you to avoid the problem of calling next() once too<br/>\noften.<br/>\n<br/>\n<br/>\nb) Internal preconditions, postconditions and invariants.<br/>\nHere you may use Java assertions, e.g.:<br/>\nint w = dice.roll();<br/>\nswitch (w) {<br/>\n    case 1: case 2: case 3: case 4:<br/>\n        // do something<br/>\n        break;<br/>\n    default: // This must be a four-sided dice<br/>\n        assert false;<br/>\n}<br/>\n<br/>\nc) Complex processes.<br/>\nImagine you want to test a shopping cart system.<br/>\nTests might be:<br/>\n- - place no order with a logged-in customer but an empty shopping cart.<br/>\n- - place an order with a logged-in customer and non-empty shopping cart<br/>\n- - place no order with no logged-in customer<br/>\nOr how do you use DBC to verify that your classes correctly use the database?<br/>\n<br/>\nd) Contracts<br/>\nAnd there, differ between contracts on interfaces and contracts on<br/>\nimplementations. Contracts on interfaces sometimes simply *can&#39;t* be checked<br/>\nby the compiler. And contracts on user input also can&#39;t be checked by the<br/>\ncompiler. So these Contracts are just a more convenient way for<br/>\nIllegalArgumentExceptions and IllegalStateExceptions.<br/>\n<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Now the great thing: When you compile your code the implementation<br/>\n&gt; can be checked whether it obeys the contract. If not, a compile error<br/>\n&gt; is thrown. That it!<br/>\n </span></blockquote>This is a great feature, and DBC is welcome.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; No JUnit test needed! Not TDD needed!<br/>\n </span></blockquote>Wrong.<br/>\nThere are enough things that DBC can&#39;t ensure to work correctly.<br/>\nJust because some parts of the system work accordingly to their contract and<br/>\nthey use each other in a correct way doesn&#39;t mean the system is bug-free.<br/>\n<br/>\nDon&#39;t understand me wrong, I am not against DBC, I like DBC and I welcome DBC,<br/>\nDBC is very helpful. And DBC can even replace *some* Unit Tests and<br/>\nAssertions. But DBC cannot replace *all* Unit Tests.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Besides this, a contract serves as a documentation.<br/>\n </span></blockquote>So do Unit Tests and Javadoc. But I welcome DBC as an enrichment of that<br/>\ndocumentation.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; And it can use invariants which JUnit will always lack of.<br/>\n </span></blockquote>How does JUnit lack of invariants? Or do you talk of *internal* invariants?<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Now come on and don&#39;t tell me: &quot;We always used JUnit, most people do,<br/>\n&gt; why do you little inexperienced programer think you have a better<br/>\n&gt; idea than people like Gamma or Fowler?&quot;<br/>\n </span></blockquote>But we do.<br/>\nIt&#39;s because we must use something exists. Until SUN has made it part of the<br/>\nJava 2 SDK SE or at least published a JSR for the JCP, DBC for Java will<br/>\nremain a castle in the air, a pipe dream, a mirage. Public add-ons for DBC<br/>\nwill not work because it&#39;s a feature the compiler must support and the<br/>\ncompiler is not yet pluggable - look at AspectJ and their problems, and I<br/>\ncouldn&#39;t use DBC together with AOP for that, and then, I&#39;d prefer AOP over<br/>\nDBC, not because AOP could replace DBC in anyway, but AOP adds much more<br/>\nfeature value to Java than DBC.<br/>\n<br/>\nI think if a DBC feature would exist, many would use it. But currently it<br/>\ndoesn&#39;t. It&#39;s just optional for those seeking it, far away from being mature.<br/>\n<br/>\nI tell you, true DBC will never be there in Java, similar to the fact that we<br/>\nwill never see true aspect oriented programming in Java (the latter because<br/>\nonce a class is loaded in Java, its methods can&#39;t be changed, and AspectJ is<br/>\nnot really aspect oriented because it can&#39;t provide aspects for classes not<br/>\ncompiled with AspectJ).<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; I am not satisfied with the JUnit and TDD &quot;paradigma&quot;. They are<br/>\n&gt; originated because of a *poverty* in Java programing language.<br/>\n </span></blockquote>No, that definitely is not true.<br/>\nThere are several kinds of tests:<br/>\n- - Unit-Tests for a method<br/>\n- - Unit-Tests for classes<br/>\n- - Unit-Tests for sequences of methods<br/>\n- - Integration tests that test how some classes / methods work together<br/>\n- - Framework-Tests<br/>\n<br/>\nVery many of these can&#39;t be replaced by DBC.<br/>\nAnd not having a certain feature is not neccessarily a poverty.<br/>\nIn Java, not having (manipulable) pointers is a missing feature but definitely<br/>\nthe opposite of poverty.<br/>\n<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; If Java would support proper Design by Contract and a compiler for that<br/>\n&gt; than no one would bother with JUnit and TDD.<br/>\n </span></blockquote>Wrong.<br/>\nIf Design By Contract Proposed would already be part of Java, even more people<br/>\nwould use JUnit and TDD because even more people would be aware of the need<br/>\nof ways to increase stability and robustness of code and search for such<br/>\nways, and DBC lacks many facilities Unit-Testing provides. That doesn&#39;t mean<br/>\nthat DBC is bad and they wouldn&#39;t use it, they would use it. It&#39;s like with<br/>\nsweets. If you don&#39;t know sweets, you don&#39;t search for them. If you know<br/>\nchocolate, you&#39;re curious wether there are other sweets, too.<br/>\n<br/>\nBut some things can&#39;t be done with DBC. For instance, imagine you have a class<br/>\nthat accesses a database. You want to know if the class makes correct use of<br/>\nthe interface and *also* correctly deals with problems (exceptions etc.)<br/>\n*and* also uses the correct data.<br/>\nWith JUnit, just use some Dummies, Stubs and Mocks instead of the real<br/>\ndatabase connection and you know wether your code works correctly.<br/>\nThis is something you simply *can&#39;t* completely cover with DBC.<br/>\nDBC can make some of these tests superflous, but others will persist still<br/>\nbeing required.<br/>\n<br/>\n<br/>\n<br/>\nI appreciate your engagement for DBC. I&#39;m a fan of DBC myself and I&#39;ve already<br/>\nexperimented with DBC a bit.<br/>\n<br/>\nBut &quot;DBC is better than JUnit&quot; is like saying &quot;Bolts are better than glue&quot;.<br/>\nIn the best case scenario, you could use both.<br/>\nJava has no DBC. So instead of telling JUnit users Bolts are better than glue<br/>\nyou should tell SUN to provide bolts in the first place.<br/>\n<br/>\nGo ahead, go to the Java website and vote for DBC, as I have already done,<br/>\nthat&#39;s much more helpful.<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://developer.java.sun.com/developer/bugParade/bugs/4449383.html\">http://developer.java.sun.com/developer/bugParade/bugs/4449383.html</a><br/>\n<br/>\nLast but not least, just because a feature is good it needn&#39;t neccessarily be<br/>\nimplemented in the language. Otherwise, we&#39;d create a darn heavy mixture of<br/>\nC, Java, Perl, SmallTalk, Eiffel, Lisp, Prolog and XSLT:<br/>\n<br/>\n/** Print all those elements of an array that have string representations<br/>\nstarting with white space.<br/>\n * @... some list<br/>\n * @... some list containing elements with strings starting with<br/>\nwhitespace<br/>\n*/<br/>\npublic static void somemethod(@[/^&#92;s/]) {<br/>\n    print for (@ARGV);<br/>\n}<br/>\n<br/>\n/** Print all elements of a list.<br/>\n * @... some list<br/>\n * @... $_ list head<br/>\n * @... @list tail of list, if empty $_ is printed and method<br/>\nreturns immediatly<br/>\n*/<br/>\npublic static printList($_, @list[.length&gt;0 :|| print && return]) {<br/>\n    return print && printList @list; // print $_ and recurse<br/>\n}<br/>\nor alternatively<br/>\npublic static printList($_, @_) {<br/>\n    return print && printList @_;<br/>\n}<br/>\npublic static printList($_) {<br/>\n    return print;<br/>\n}<br/>\n<br/>\n<br/>\n/** Calculate the sqrt of a number. num must be &gt;0 otherwise an<br/>\nIllegalArgumentException is thrown.<br/>\n*/<br/>\npublic static void sqrt(double num[&gt;0]) {<br/>\n# ...<br/>\n}<br/>\n<br/>\n/** Handle all IllegalArgumentExceptions occuring on gui input */<br/>\naspect GUIExceptions {<br/>\n    pointcut userInput(gui.** o[instanceof ActionListener]) : target(o) &&<br/>\ncall(void ActionListener.actionPerformed(ActionEvent[.getSource() instanceof<br/>\nTextField] ev));<br/>\n    after () throwing (IllegalArgumentException e) :userInput(gui.** o) {<br/>\n        use dynamicTyping;<br/>\n\twith this, JOptionPane showMessageDialog(ev.getSource(), e, localize(&quot;Error<br/>\nin input&quot;), ERROR_MESSAGE);<br/>\n        return;<br/>\n    }<br/>\n}<br/>\n<br/>\nType where you want, don&#39;t type where you don&#39;t want, use DBC together with<br/>\nlist processing, etc., make the language full of features. I know Perl is<br/>\ninfamous for its featurism (I really like, no, I love Perl).<br/>\nI&#39;d really like such a melting pot of languages (if I&#39;d not need to do some<br/>\nnormal work to earn money, I&#39;d design such a language). Complete freedom.<br/>\nComplete list of features that have ever been into a language. Look at the<br/>\ncode above. It uses dynamic typing, declarative lists, list processing,<br/>\ndynamic argument lists and, for design by contract, predicates, and it also<br/>\nfeatures automatic variables ($_) and regular expressions. The last one<br/>\ncreates an aspect which handles all IllegalArgumentExceptions thrown in<br/>\nActionListeners that are in subpackages of gui and invoked from TextFields by<br/>\ndisplaying a message dialog and setting the stack back to normal state<br/>\n(return). The with keyword changes the scope by adding JOptionPane to the<br/>\nlocal scope. The use dynamicTyping prevents the compiler from complaining<br/>\nabout incompatible types, during runtime ClassCastExceptions may occur if the<br/>\ndesired type is not castable and not String. (These examples perhaps still<br/>\nhave some ambiguity regarding the use and meaning of predicates). But would<br/>\nothers like such a language?<br/>\n<br/>\n<br/>\nI don&#39;t want to say DBC alone makes Java code less readable. I just want to<br/>\nsay that a rich set of features can make a language a rich language as well<br/>\nas a *reduced* set of features can make a language a rich language. And up to<br/>\nnow, the latter was the case with Java. Some want to introduce DBC, some want<br/>\nto introduce AOP, some want to introduce regular expressions, some want to<br/>\nintroduce dynamic typing, some want to introduce dynamic scoping, some want<br/>\nto introduce global variables, some want to introduce dynamic variables, some<br/>\nwant to introduce configurable scoping, some want to introduce list<br/>\nprocessing, some want to introduce predicates. But hey, just because Java<br/>\ndoesn&#39;t have all these features, it isn&#39;t a bad language.<br/>\n<br/>\nOf course, now, 8 years after Java was born, it&#39;s easy to say &quot;Java lacks<br/>\nthis&quot; and &quot;Java lacks that&quot;. But Java is dominant, we have to deal with Java<br/>\nand the way how it is now, we can only use the JCP and external APIs like<br/>\nJUnit to improve Java. And Java isn&#39;t too bad at all.<br/>\n<br/>\nIf I had to decide wether to add DBC *or* AOP to Java, my vote was for AOP,<br/>\ndefinitely. DBC is not so important at all, it saves much less money than AOP<br/>\ncould.<br/>\n<br/>\n<br/>\nBye<br/>\n<br/>\nP.S.:<br/>\nPlease, don&#39;t tell us to purchase iContract ;-)<br/>\n- --<br/>\nITCQIS GmbH<br/>\nChristian Wolfgang Hujer<br/>\nGeschäftsführender Gesellschafter<br/>\nTelefon: +49  (0)89  27 37 04 37<br/>\nTelefax: +49  (0)89  27 37 04 39<br/>\nE-Mail: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:Christian.Hujer@...\">Christian.Hujer@...</a><br/>\nWWW: <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.itcqis.com/\">http://www.itcqis.com/</a><br/>\n-----BEGIN PGP SIGNATURE-----<br/>\nVersion: GnuPG v1.0.7 (GNU/Linux)<br/>\n<br/>\niD8DBQE+i0M0zu6h7O/MKZkRAqeSAJ4lP0jYpE3qwEB+5EFklIaxlmV0KQCfSt/2<br/>\nET6PgzEqlcht4JkaXGlYGJE=<br/>\n=mvgc<br/>\n-----END PGP SIGNATURE-----</div>", 
    "prevInTime": 7447, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1049314100", 
    "canDelete": false, 
    "nextInTopic": 7449, 
    "prevInTopic": 7447, 
    "headers": {
        "inReplyToHeader": "PGI2ZTRnNisyazEwQGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PDIwMDMwNDAyMjIwOC4yMTQ1OC5DaHJpc3RpYW4uSHVqZXJAaXRjcWlzLmNvbT4=", 
        "referencesHeader": "PGI2ZTRnNisyazEwQGVHcm91cHMuY29tPg=="
    }
}