{
    "numMessagesInTopic": 55, 
    "nextInTime": 13619, 
    "senderId": "MUZMFCph5nNgA3sG7yBLyopChKzeiWTdKy71Cr7150DT2mAiSF3ptknW0hVzngg7dkEd3PgbXiXc6RqV7TF-n6rBj5cd-P8VvMCQOILYVw", 
    "systemMessage": false, 
    "subject": "Re: [junit] RE: Isolation or Collaboration", 
    "from": "&quot;J. B. Rainsberger&quot; &lt;jbrains@...&gt;", 
    "authorName": "J. B. Rainsberger", 
    "msgSnippet": "... These examples seem to fall into one category: an object representing a resource we have released. This is far different from initializing an object in an", 
    "msgId": 13618, 
    "rawEmail": "Return-Path: &lt;jbrains@...&gt;\r\nX-Sender: jbrains@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (qmail 51849 invoked from network); 25 May 2005 01:58:05 -0000\r\nReceived: from unknown (66.218.66.218)\n  by m29.grp.scd.yahoo.com with QMQP; 25 May 2005 01:58:05 -0000\r\nReceived: from unknown (HELO smtp102.rog.mail.re2.yahoo.com) (206.190.36.80)\n  by mta3.grp.scd.yahoo.com with SMTP; 25 May 2005 01:58:05 -0000\r\nReceived: from unknown (HELO ?172.20.101.181?) (srainsberger5790@67.78.67.130 with plain)\n  by smtp102.rog.mail.re2.yahoo.com with SMTP; 25 May 2005 01:57:56 -0000\r\nMessage-ID: &lt;4293DBB8.6000205@...&gt;\r\nDate: Tue, 24 May 2005 21:58:16 -0400\r\nUser-Agent: Mozilla Thunderbird 0.9 (Macintosh/20041103)\r\nX-Accept-Language: en-us, en\r\nMIME-Version: 1.0\r\nTo: junit@yahoogroups.com\r\nReferences: &lt;000201c55e2d$0c717ab0$bb00a8c0@HARRY&gt;\r\nIn-Reply-To: &lt;000201c55e2d$0c717ab0$bb00a8c0@HARRY&gt;\r\nContent-Type: text/plain; charset=ISO-8859-1; format=flowed\r\nContent-Transfer-Encoding: 7bit\r\nX-eGroups-Msg-Info: 1:12:0\r\nFrom: &quot;J. B. Rainsberger&quot; &lt;jbrains@...&gt;\r\nSubject: Re: [junit] RE: Isolation or Collaboration\r\nX-Yahoo-Group-Post: member; u=127224993; y=oourUrAr5d8uYnERr3d1JuvPriAS_C7FM0Jq2JB0DKm6aT4\r\nX-Yahoo-Profile: nails762\r\n\r\nHarald M. Muller wrote:\n&gt; Just 2 small points:\n&gt; \n&gt; J. B. Rainsberger wrote:\n&gt;  &gt; Cedric Beust wrote:\n&gt;  &gt;\n&gt;  &gt; &gt; Real code relies on dependencies all the time:\n&gt;  &gt; &gt;\n&gt; [...]\n&gt;  &gt;\n&gt;  &gt; &gt; - This method can only be invoked if such field has been\n&gt;  &gt; initialized.\n&gt;  &gt;\n&gt;  &gt; All objects should be in a &quot;sane&quot; state all the time. If not,\n&gt;  &gt; then the\n&gt;  &gt; design could be improved to avoid this problem. The Pragmatic\n&gt;  &gt; Programmers call what you describe as &quot;Programming by Coincidence&quot;.\n&gt;  &gt;\n&gt; \n&gt; &quot;Sane state&quot; does NOT mean that everything can be done to the object at\n&gt; every time. Cedric&#39;s &quot;initialized&quot; example is probably actually a design\n&gt; flaw, but for other states, it makes of course much sense to disallow\n&gt; certain operations: If a database connection is not open, you cannot\n&gt; execute a select; if a file has been deleted, it cannot be deleted a\n&gt; second time; a bill that has been cancelled cannot be invoiced; etc.etc.\n&gt; In many cases I saw and see, programmers/designers/architects seem to\n&gt; believe that the String class (where you can indeed execute every method\n&gt; sensibly at every time) is the paradigmatic example of a class. Nothing\n&gt; can be further from the truth: Many classes have an &quot;interesting state\n&gt; diagram&quot;, where certain operations can only be invoked if certain\n&gt; conditions hold.\n\nThese examples seem to fall into one category: an object representing a \nresource we have released. This is far different from initializing an \nobject in an insane state, so my argument certainly doesn&#39;t apply, nor \ndid I try to make it apply. :)\n\nJava&#39;s File class is an example of questionable design: it represents \nboth a file path and a file. I shouldn&#39;t be able to create a File object \nthat doesn&#39;t represent an underlying file, just like I shouldn&#39;t be able \nto create a DatabaseConnection object that doesn&#39;t represent an \nunderlying connection to Postgresql. An object like this is insane:\n\nnew File(&quot;wi8ybv3ql4i587b43;95876bvq3495786bgq347895&quot;)\n\nI would much prefer this:\n\npath = new FileSystemPath(&quot;/Users/jbrains/Documents&quot;);\ndirectory = path.locate();   // or &quot;open&quot; or &quot;validate&quot; -- not sure \nabout the method name\nassertTrue(directory.isDirectory());\n\nOr, since it&#39;s simpler:\n\ndirectory = FileSystem.locate(&quot;/Users/jbrains/Documents&quot;);\nassertTrue(directory.isDirectory());\n...\n\nI have been experimenting with using different classes aggressively to \ndeal with objects in different states. I&#39;m very happy with the result. \nIt&#39;s nothing new; I&#39;m just taking the technique further than I used to.\n\n&gt; [...]\n&gt;  &gt; &gt; - A certain object can only be created if a previous object\n&gt;  &gt; has been created\n&gt;  &gt; &gt; before.\n&gt;  &gt;\n&gt;  &gt; If so, then the previous object should be the only thing that\n&gt;  &gt; can create\n&gt;  &gt; the new object!\n&gt; \n&gt; This is often contrary to design concepts with somewhat centralized\n&gt; responsibilities. For example, if you look at the UML metamodel, an\n&gt; association is a thing &quot;between two (or more) classes&quot; - so an\n&gt; association (e.g. in an UML tool) can only be created when the classes\n&gt; (e.g. class &quot;icons&quot;) are there. Obviously, the order of the class\n&gt; (&quot;icon&quot;) creation is not important - but both must be there. Usually,\n&gt; one does not design this by giving the &quot;icons&quot; the responsibility of\n&gt; creating the association (even in this case, the creating &quot;icon&quot; must\n&gt; check whether the other one exists), but has a central &quot;association\n&gt; creation tool&quot; which checks for the existence of the necessary icons.\n\nLet me say it differently then: if we cannot create B without having \ncreated A, then the method creating B should require the instance of A, \neither by:\n\n1. a.createB(), or\n2. C.createB(a)\n\nEither way, there&#39;s no way to create B without A.\n\nGoing back to your example, if an Association cannot exist without a \npair of objects to associate, then I would prefer this:\n\nAssociation.fromTo(class1, class2);\n\nto this:\n\nassociation = new Assocation();\nassociation.setFrom(class1);\nassociation.setTo(class2);\n\nor any of its variants.\n\n&gt; Still, on a more general level - e.g. when one talks about closely tied\n&gt; groups of classes (yes: they are there; not even one of the tutorials\n&gt; that explain JUnit pretends that litterally everything makes sense to be\n&gt; mocked) - the guidelines hinted at by JBR do make sense.\n\nI appreciate that.\n-- \nJ. B. (Joe) Rainsberger\nDiaspar Software Services\nhttp://www.diasparsoftware.com\nAuthor, JUnit Recipes: Practical Methods for Programmer Testing\n\n", 
    "profile": "nails762", 
    "topicId": 13451, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 127224993, 
    "prevInTime": 13617, 
    "contentTrasformed": false, 
    "postDate": "1116986296", 
    "canDelete": false, 
    "nextInTopic": 13621, 
    "prevInTopic": 13598, 
    "headers": {
        "inReplyToHeader": "PDAwMDIwMWM1NWUyZCQwYzcxN2FiMCRiYjAwYThjMEBIQVJSWT4=", 
        "messageIdInHeader": "PDQyOTNEQkI4LjYwMDAyMDVAcm9nZXJzLmNvbT4=", 
        "referencesHeader": "PDAwMDIwMWM1NWUyZCQwYzcxN2FiMCRiYjAwYThjMEBIQVJSWT4="
    }
}