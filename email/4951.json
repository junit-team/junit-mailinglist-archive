{
    "numMessagesInTopic": 2, 
    "nextInTime": 4952, 
    "senderId": "Q3ivcOBBFMqN9dKiY5zBHVPzW-bWHOXB2m8RhdD6AF65K2WcOeqtJtVNwgqv_x7kuNRnigMDZb8Df_Jbz34__Gs9TBVyjjEH", 
    "systemMessage": false, 
    "subject": "Re: [junit] Re: unit testing philosophy [LONG]", 
    "from": "&quot;Steve Freeman&quot; &lt;steve@...&gt;", 
    "authorName": "Steve Freeman", 
    "msgSnippet": "... That s why we started mocking up Dynamo components. In some ways, the Nucleus is very amenable to writing mock-based unit tests given that it s all about", 
    "msgId": 4951, 
    "profile": "smg_freeman", 
    "topicId": 4951, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 30618548, 
    "messageBody": "<div id=\"ygrps-yiv-611677759\"><blockquote><span title=\"ireply\">&gt; In the real world, I use ATG Dynamo.  If you&#39;ve heard of it or used<br/>\n&gt; it, it&#39;s an App Server / EJB Container.   Dynamo&#39;s entire framework is<br/>\n&gt; based off this component known as Nucleus, which does a lot of work in<br/>\n&gt; terms of instantiating classes, setting properties, etc..  It&#39;s also<br/>\n&gt; very slow and to test - build - test takes forever if I have to start<br/>\n&gt; and stop the app-server for every change in the code.<br/>\n<br/>\n </span></blockquote>That&#39;s why we started mocking up Dynamo components. In some ways, the<br/>\nNucleus is very amenable to writing mock-based unit tests given that<br/>\nit&#39;s all about glueing components together at runtime. If you define<br/>\nyour components in terms of interfaces rather than classes, then it&#39;s<br/>\neasier to substitute alternative implementations. Once you&#39;ve done<br/>\nthis, it turns out that your code is better structured for coping with<br/>\nnew requirements.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; That&#39;s where MockObjects come in.  Dynamo is a very Java Beans heavy<br/>\n&gt; framework, that relies a lot on setters and getters.  ( In fact, the<br/>\n&gt; MockObjects guys at SF have started putting together some Dynamo<br/>\n&gt; MockObjects. ) I was looking into MockObjects as a way to lessen my<br/>\n&gt; reliance on the Nucleus namespace so that I could code quickly and<br/>\n&gt; only integrate with the Nucleus namespace at the latest possible time.<br/>\n<br/>\n </span></blockquote>Sadly, our library is getting out of date, because I&#39;m not working<br/>\nwith Dynamo any more. One point is that we&#39;re trying to move away from<br/>\ngetters and setters. It&#39;s worth thinking about passing handler and<br/>\npolicy objects around, rather than extracting values via getters. The<br/>\nNucleus supports it just as well.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; However, I can&#39;t get my head around the fact that in certain cases my<br/>\n&gt; mock code will need to generate other mock code<br/>\n<br/>\n </span></blockquote>Sometimes that happens, for example with the JDBC library. Where it&#39;s<br/>\nunavoidable, at least it&#39;s usually repeated across multiple tests and<br/>\nso worth wrapping in some helper code, or in the TestCase setup. For<br/>\nsomething like the Dynamo repository, you&#39;re likely to be using the<br/>\ninfrastructure a lot, so there may be some point in investing in a<br/>\nlittle infrastrcuture. Don&#39;t forget that you only need enough<br/>\nimplementation to get through the test (in a modern IDE this is a<br/>\nmatter of a few points-and-clicks). For example, something like:<br/>\n<br/>\nclass MockRepository extends MockObject {<br/>\n  private RepositoryView view;<br/>\n  private ExpectationValue itemDescription =<br/>\n    new ExpectationValue(&quot;MockRepository.itemDescription&quot;);<br/>\n<br/>\n  public void setExpectedGetView(String description,<br/>\n                                 RepositoryView aView) {<br/>\n    view = aView;<br/>\n    itemDescription.setExpected(description);<br/>\n  }<br/>\n<br/>\n  public RepositoryView getView(String description) {<br/>\n    itemDescription.setActual(description);<br/>\n    return view;<br/>\n  }<br/>\n}<br/>\n<br/>\nAnother other route to consider is that you can use the Repository<br/>\noutside Dynamo. Set up a test instance of the database and manage test<br/>\nvalues with something like DBUnit.<br/>\n<br/>\nFinally, what makes this code hard to test is that there are too many<br/>\nobjects involved in the method, can we break them up? One observation<br/>\nis that the sequence from the Repository to the array of items is more<br/>\nor less independant of the application. Does it repeat often enough to<br/>\nwrite something like:<br/>\n<br/>\npublic Map generateEmptyPreferencesMap(Map map)<br/>\n{<br/>\n  RepositoryView contactMethodView =<br/>\n<br/>\n<br/>\n    getPreferencesRepository().getView(CONTACT_METHOD_REPOSITORY_ITEM );<br/>\n  PropertyFinder finder = finderFactory.make(contactMethodView);<br/>\n  finder.addPropertyValuesTo(map, CONTACT_METHOD_CODE_PROPERTY_NAME);<br/>\n  return map;<br/>\n}<br/>\n<br/>\nWhere the PropertyFinder encapsulates all that RepositoryView<br/>\nstuff. If you create PropertyFinder&#39;s via a factory, you can subsitute<br/>\na MockPropertyFinder when testing the Droplet. You can then test the<br/>\nPropertyFinder separately with a smaller chain of mock<br/>\n(or real) Repository objects. It would be too much work if this is the<br/>\nonly place you do this but, more likely, you can refactor in this<br/>\ndirection as you discover repetitions. An example of a test would be:<br/>\n<br/>\npublic void testGenerateEmptyPreferencesMap() throws RepositoryException<br/>\n{<br/>\n    MockPropertyFinder mockFinder = new MockPropertyFinder();<br/>\n    Map map = new Hashmap();<br/>\n<br/>\n    mockRepository.setupView(mockRepositoryView);<br/>\n    mockFinderFactory.setupFinder(mockFinder);<br/>\n<br/>\n    mockFinderFactory.setExpectedView(mockRepositoryView);<br/>\n    mockRepository.setExpectedGetView(CONTACT_METHOD_REPOSITORY_ITEM);<br/>\n    mockFinder.setExpectedAddPropertyValuesTo(map,<br/>\nCONTACT_METHOD_CODE_PROPERTY_NAME);<br/>\n<br/>\n    assertEquals(&quot;Should be same map&quot;, map,<br/>\ndroplet.generateEmptyPreferencesMap(map));<br/>\n    mockFinderFactory.verify();<br/>\n    mockRepository.verify();<br/>\n    mockFinder.verify();<br/>\n}<br/>\n<br/>\nHmmm, thinking about it, the next version might be:<br/>\n<br/>\npublic Map generateEmptyPreferencesMap(Map map)<br/>\n{<br/>\n    PropertyFinder finder =<br/>\n        finderFactory.simpleFinder(preferencesRepository,<br/>\nCONTACT_METHOD_REPOSITORY_ITEM );<br/>\n    finder.addPropertyValuesTo(map, CONTACT_METHOD_CODE_PROPERTY_NAME);<br/>\n    return map;<br/>\n}<br/>\n<br/>\nSteve<br/>\n<br/>\n<blockquote><span title=\"qreply\"> &gt; Here&#39;s a method from a piece of old code that I wrote before I decided<br/>\n&gt; to start using JUnit:<br/>\n&gt;<br/>\n&gt;     public  Map generateEmptyPreferencesMap( Map m ) throws<br/>\n&gt; RepositoryException {<br/>\n&gt;<br/>\n&gt; // get the list of possible preferences<br/>\n&gt; RepositoryView contactMethodView = getPreferencesRepository().getView(<br/>\n&gt; CONTACT_METHOD_REPOSITORY_ITEM );<br/>\n&gt; RepositoryItem[] contactMethods = contactMethodView.executeQuery(<br/>\n&gt; contactMethodView.getQueryBuilder().createUnconstrainedQuery() );<br/>\n&gt;<br/>\n&gt; if ( ( contactMethods != null ) && ( contactMethods.length &gt; 0 ) )  {<br/>\n&gt;     // add each one to the map<br/>\n&gt;     for ( int i = 0 ; i &lt; contactMethods.length ; i++ ) {<br/>\n&gt; m.put( contactMethods[i].getPropertyValue(<br/>\n&gt; CONTACT_METHOD_CODE_PROPERTY_NAME ), new BooleanPlaceHolder() );<br/>\n&gt;     }<br/>\n&gt; }<br/>\n&gt;      return m;<br/>\n&gt;     } </span></blockquote></div>", 
    "prevInTime": 4950, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1021200066", 
    "canDelete": false, 
    "nextInTopic": 8766, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PDAwMzUwMWMxZjlhMSRhNDc1ODJhMCQxMjNiMjdkOUBnYXRld2F5Pg==", 
        "referencesHeader": "PGFiZjN1cys1YzFsQGVHcm91cHMuY29tPg=="
    }
}