{
    "numMessagesInTopic": 55, 
    "nextInTime": 13531, 
    "senderId": "wmZ2MnDzO0kMR98n7wXHHErXnlv0lPC_D4LgcXPcp1ACU_QjKIMWGzfi7941dp0w4Dmztfm50KmMrvRNd4IwrQ_g2PCDmLJPdw", 
    "systemMessage": false, 
    "subject": "RE: [junit] Re: DbUnit & ORM", 
    "from": "John Smith &lt;haefeleuser@...&gt;", 
    "authorName": "John Smith", 
    "msgSnippet": "... J.B. Rainsberger wrote in his book that there are some developers who prefer to test the real thing (Integration Test) and other developers prefer to use", 
    "msgId": 13530, 
    "rawEmail": "Return-Path: &lt;haefeleuser@...&gt;\r\nX-Sender: haefeleuser@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (qmail 45333 invoked from network); 16 May 2005 06:56:52 -0000\r\nReceived: from unknown (66.218.66.216)\n  by m23.grp.scd.yahoo.com with QMQP; 16 May 2005 06:56:52 -0000\r\nReceived: from unknown (HELO web60019.mail.yahoo.com) (209.73.178.67)\n  by mta1.grp.scd.yahoo.com with SMTP; 16 May 2005 06:56:52 -0000\r\nReceived: (qmail 40440 invoked by uid 60001); 16 May 2005 06:56:35 -0000\r\nComment: DomainKeys? See http://antispam.yahoo.com/domainkeys\r\nMessage-ID: &lt;20050516065635.40438.qmail@...&gt;\r\nReceived: from [84.160.249.183] by web60019.mail.yahoo.com via HTTP; Sun, 15 May 2005 23:56:35 PDT\r\nDate: Sun, 15 May 2005 23:56:35 -0700 (PDT)\r\nTo: junit@yahoogroups.com\r\nIn-Reply-To: 6667\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=us-ascii\r\nX-eGroups-Msg-Info: 1:12:0\r\nFrom: John Smith &lt;haefeleuser@...&gt;\r\nSubject: RE: [junit] Re: DbUnit & ORM\r\nX-Yahoo-Group-Post: member; u=174752849\r\nX-Yahoo-Profile: haefeleuser\r\n\r\n--- Cedric Beust &lt;cbeust@...&gt; wrote:\n&gt; &gt; From: junit@yahoogroups.com\n&gt; [mailto:junit@yahoogroups.com] On \n&gt; Don&#39;t get me wrong, I&#39;m not opposed to the idea of\n&gt; mock objects, but it\n&gt; seems to me that if you want to do more than unit\n&gt; testing with JUnit (which\n&gt; is a mistake in my opinion), you are *forced* to use\n&gt; mock objects.  It&#39;s\n&gt; just the only way to solve this problem.\n&gt; \n&gt; Mock objects are a fine solution if you have other\n&gt; alternatives and after\n&gt; you considered them all, mock objects came out as\n&gt; the best solution, but\n&gt; they come at a price (well, two prices:  the one I\n&gt; just mentioned and the\n&gt; fact that you need to maintain two parallel\n&gt; hierarchies).\n\nJ.B. Rainsberger wrote in his book that there are some\ndevelopers who prefer to test the &quot;real thing&quot;\n(Integration Test) and other developers prefer to use\nMock Objects. I think he wrote in his book that he\nprefers what he calls &quot;Programmer Tests&quot; or &quot;Object\nTests&quot;.\n\nWe have to use mock objects. Our tests are very data\ndriven. It would take too much time to set up the test\ndata for each test. Besides this, it would be too much\nwork for a test. So we started to use mock objects. We\ndon&#39;t want to test the public methods which the method\nunder test uses indirectly, because they must have\ntheir own tests. We don&#39;t need to test these methods\nagain indirectly. The main reason for not doing it is\nbecause it takes too much time (programming and\nperformance).\n\nFor example, we have a service called\n&quot;SupplierArticleInformation.getReplacementTime(...)&quot;.\nThe real object needs a lot of data in the database to\noperate. If I use a mock object for\nSupplierArticleInformation I don&#39;t have to create all\nthat data. I simply manipulate the method to return a\nvalue without looking into the database.\n\nThis makes tests run much faster, which especially in\nbig projects like ours is very important. And the\ntests are easier to understand and maintain. Some\npeople think &quot;one dataset for all tests&quot; would solve\nthe problem, but it wouldn&#39;t in my opinion. This would\nresult in an error prone &quot;Spaghetti test data set&quot;. If\nall tests are based on this &quot;one dataset for all\ntests&quot;, then modifying these dataset for new tests can\nbreak existing tests. The dataset would become more\nand more unpredictable and thus unmaintainable.\n\nI only looked shortly at EasyMock. It doesn&#39;t require\nto create mock object classes because it uses the Java\nProxy. This is better than to write or code generate\nmock object classes.\n\nSo for applications which are heavily data driven,\nmock objects provide a lot of benefit in my eyes.\n\nIf the unit tests are good, then I think only few\nerrors can occur. A pragmatic test suite doesn&#39;t test\neverything. So maybe we could say that we don&#39;t\nautomate integration tests? I am just at the beginning\nof thinking about the importance of integration tests.\nThis is my first (radical) idea...\n\nCedric, I didn&#39;t examine TestNG yet. So you maybe have\nimplemented my suggestion already. I want to suggest\nto support ignoring tests. Like: 1 test failed, 10\ntests skipped, 2 tests ignored. Sometimes you want a\ntest to set to ignore because all tests need to pass.\nYou can comment it, but then you might forget about\nit. So I think a test framework should provide support\nfor ignoring tests.\n\n\n\t\t\nYahoo! Mail\nStay connected, organized, and protected. Take the tour:\nhttp://tour.mail.yahoo.com/mailtour.html\n\n\n", 
    "profile": "haefeleuser", 
    "topicId": 13451, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 174752849, 
    "prevInTime": 13529, 
    "contentTrasformed": false, 
    "postDate": "1116226595", 
    "canDelete": false, 
    "nextInTopic": 13532, 
    "prevInTopic": 13529, 
    "headers": {
        "inReplyToHeader": "NjY2Nw==", 
        "messageIdInHeader": "PDIwMDUwNTE2MDY1NjM1LjQwNDM4LnFtYWlsQHdlYjYwMDE5Lm1haWwueWFob28uY29tPg=="
    }
}