{
    "numMessagesInTopic": 11, 
    "nextInTime": 22748, 
    "senderId": "BO8ezMD9IgFSh49EKLSbyZhvxsfd9QRq1spLtDG7FoU4nMeNvyQShUw1WyTmO00LvI16yAYjobXsTA9hPe2fb_-W", 
    "systemMessage": false, 
    "subject": "Re: [junit] Large, hierarchical, randomized test suites: how to not \trun out of memory?", 
    "from": "David Saff &lt;david@...&gt;", 
    "authorName": "David Saff", 
    "msgSnippet": "... Yes, it would generate all 1,000 DataPoints at once right before they re needed, but it wouldn t create a bunch of test objects the way JUnit 3 does.  I", 
    "msgId": 22747, 
    "profile": "dsaff", 
    "topicId": 22741, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 341876227, 
    "messageBody": "<div id=\"ygrps-yiv-53326872\">On Thu, Jun 10, 2010 at 12:24 PM,  &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:allamistakeo18@...\">allamistakeo18@...</a>&gt; wrote:<br/>\n<blockquote><span title=\"ireply\"> &gt; Op 10-jun-2010, om 15:59 heeft David Saff het volgende geschreven:<br/>\n&gt;&gt; Have you looked at theory support in JUnit 4? You could have a<br/>\n&gt;&gt; @DataPoints method that returned 1000 random datapoints, and would<br/>\n&gt;&gt; only be called right before you needed it.<br/>\n&gt;&gt;<br/>\n&gt; Thank you for your input. I should definitely look into JUnit 4 Theories, a feature that I didn&#39;t know existed.<br/>\n&gt;<br/>\n&gt; However, even before I do so — and pardon me if I misunderstood your suggestion — it looks like your approach would generate all 1,000 random DataPoints at once. This would be even worse than my current approach, since the DataPoints we are talking about are large, expensive objects. Currently, each random input is nulled in tearDown() before the next one is instantiated in setUp(). Can I do that with JUnit 4 Theories?<br/>\n<br/>\n </span></blockquote>Yes, it would generate all 1,000 DataPoints at once right before<br/>\nthey&#39;re needed, but it wouldn&#39;t create a bunch of test objects the way<br/>\nJUnit 3 does.  I wasn&#39;t clear on your trade-offs: you&#39;d like to avoid<br/>\nboth blow-ups.<br/>\n<br/>\nIf it were possible to push the randomization into the method<br/>\nexecution itself, (or the before method), would it be sufficient to<br/>\njust repeat the method 1000 times?  I know a way to do that.<br/>\n<br/>\n   David Saff<br/>\n<br/>\n<blockquote><span title=\"qreply\"> &gt;<br/>\n&gt; for (int i = 0; i &lt; 1000; i++) {<br/>\n&gt;        // create one random DataPoint<br/>\n&gt;        // run the test on that DataPoint<br/>\n&gt;        // GC the DataPoint<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; Thanks again for your suggestions.<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; [Non-text portions of this message have been removed]<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; ------------------------------------<br/>\n&gt;<br/>\n&gt; Yahoo! Groups Links<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 22746, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1276190622", 
    "canDelete": false, 
    "nextInTopic": 22750, 
    "prevInTopic": 22746, 
    "headers": {
        "inReplyToHeader": "PDJCMjNCRTVFLUEyODktNDFEOC1BMjRCLTJDODJBREYwM0VBQkBtYWMuY29tPg==", 
        "messageIdInHeader": "PEFBTkxrVGlubm0wTGF6Y08wRTdlNWJZSElHamhMMmlBUzhTQVRVd0k2X2RGUEBtYWlsLmdtYWlsLmNvbT4=", 
        "referencesHeader": "PDBDMTk3RUM0LTM3QzgtNDM3NS05MjM1LTkzQzU0MjI5REM5OEBtYWMuY29tPgk8QUFOTGtUaWtHOERldUtrVGcxbjBpaHZJTXhscGRHa0pQVjM0QlFIVjAzWENNQG1haWwuZ21haWwuY29tPgk8MkIyM0JFNUUtQTI4OS00MUQ4LUEyNEItMkM4MkFERjAzRUFCQG1hYy5jb20+"
    }
}