{
    "numMessagesInTopic": 38, 
    "nextInTime": 22244, 
    "senderId": "YncSy4663nwSSeMmh4fkbzShMtFwwyeIsvlpD28jwmzRZuNzOQmU7AMgjBW5k0dAZWo1o17mSiQsZiNqOmXGyn835Xd_Q_XPxvzXdknGuRE2wUnIWySym4sdI3gIK9s", 
    "systemMessage": false, 
    "subject": "Re: [junit] Order of execution for tests", 
    "from": "=?UTF-8?B?Q8OpZHJpYyBCZXVzdCDimZQ=?= &lt;cbeust@...&gt;", 
    "authorName": "Cédric Beust ♔", 
    "msgSnippet": "Agree with Charlie:  I think it s impossible for a framework to automatically determine this kind of dependency.  Even assuming that the framework would go", 
    "msgId": 22243, 
    "profile": "cbeust", 
    "topicId": 22219, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 199443513, 
    "messageBody": "<div id=\"ygrps-yiv-1435114085\">Agree with Charlie:  I think it&#39;s impossible for a framework to<br/>\nautomatically determine this kind of dependency.  Even assuming that the<br/>\nframework would go inside the body of test methods and actually understand<br/>\nwhat&#39;s going on in there, it&#39;s just not possible to infer from that<br/>\ninformation which methods depend on which ones.<br/>\n<br/>\nExplicit (@Test(dependsOnGroups = &quot;init&quot;)) is good, and it opens the door<br/>\nfor additional tools to use this information in different ways, such as<br/>\nshowing a graph of dependencies or optimizing the thread pool allocation,<br/>\nlike I did in the article I posted earlier.<br/>\n<br/>\n-- <br/>\n***C�dric<br/>\n*<br/>\n<br/>\nOn Wed, Dec 30, 2009 at 12:11 PM, Charlie Poole &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:charlie@...\">charlie@...</a><br/>\n<blockquote><span title=\"ireply\"> &gt; wrote:<br/>\n<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; Hi Kent,<br/>\n&gt;<br/>\n&gt; &gt; It seems to me that a coverage tool like Clover could<br/>\n&gt; &gt; discover this information dynamically with[out] the user having to<br/>\n&gt; &gt; specify more meta-information about tests that could be wrong<br/>\n&gt; &gt; and would need maintenance. Isn&#39;t removing tedium why we have<br/>\n&gt; &gt; computers in the first place?<br/>\n&gt;<br/>\n&gt; As far as I know, coverage tools deal well with direct dependencies<br/>\n&gt; but not with logical (interpretive) dependency.<br/>\n&gt;<br/>\n&gt; For example, if we have<br/>\n&gt;<br/>\n&gt; Test A --&gt; SUT A --&gt; SUT B<br/>\n&gt; Test B --&gt; SUT B<br/>\n&gt;<br/>\n&gt; Even in this simple case, coverage analysis won&#39;t tell us anything<br/>\n&gt; about the relationship between A and B, although we could make some<br/>\n&gt; deductions by examining the results.<br/>\n&gt;<br/>\n&gt; If there were some way to tell the framework &quot;Test A depends<br/>\n&gt; on functionality, which is tested directly by B&quot; then I can<br/>\n&gt; imagine several good outcomes:<br/>\n&gt;<br/>\n&gt; 1) The test result output could be made much clearer - by<br/>\n&gt; emphasizing the B result when both tests had failed. Some<br/>\n&gt; approaches I can think include subordinating the A result<br/>\n&gt; to that of B, highlighting B, not showing A at all and<br/>\n&gt; marking A as inconclusive.<br/>\n&gt;<br/>\n&gt; 2) Users would be discouraged from seeking annotations that<br/>\n&gt; provide for direct ordering of tests or the actual &quot;hard&quot;<br/>\n&gt; dependencies.<br/>\n&gt;<br/>\n&gt; 3) Less important, but as an optimization, the framework<br/>\n&gt; could suppress running of A if B had already failed.<br/>\n&gt;<br/>\n&gt; Charlie<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; &gt; Kent<br/>\n&gt; &gt;<br/>\n&gt; &gt; On Dec 29, 2009, at 2:28 PM, Pigneri, Rocco wrote:<br/>\n&gt; &gt;<br/>\n&gt; &gt; &gt; Charlie,<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt;As a framework author, I can see that allowing the user to specify<br/>\n&gt; &gt; &gt; &gt;ordering is a simpler implementation. But I think it&#39;s more<br/>\n&gt; &gt; &gt; &gt;interesting to imagine the user specifying the nature of the<br/>\n&gt; &gt; &gt; &gt;dependencies and allowing the framework to figure out a strategy.<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; I am very much with you on this one. In my experience,<br/>\n&gt; &gt; there have been a lot of times when functions under test<br/>\n&gt; &gt; within the same class depend upon each other, and it would<br/>\n&gt; &gt; have been great to have the test harness know that<br/>\n&gt; &gt; information. When I was refactoring code for a new framework<br/>\n&gt; &gt; package, I would have loved to have the UI to display<br/>\n&gt; &gt; non-dependent tests first as it would have shown me very<br/>\n&gt; &gt; clearly the source of the problem.<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; Specifying only the relationships in code and leaving the<br/>\n&gt; &gt; display strategy to the test harness would allow more<br/>\n&gt; &gt; flexible display and execution of these tests based upon the<br/>\n&gt; &gt; user&#39;s goals rather than upon the dependencies themselves. I<br/>\n&gt; &gt; could imagine myself asking the UI only to display the least<br/>\n&gt; &gt; dependent functions&#39; errors and to hide all other errors for<br/>\n&gt; &gt; quick debugging on sweeping optimizations. I could also want<br/>\n&gt; &gt; to see the dependent tests in a tree in case I am changing a<br/>\n&gt; &gt; single class and want to understand the effects of what I am<br/>\n&gt; &gt; touching. I could also want to see all tests in a single list<br/>\n&gt; &gt; with the least dependent at the top and the most dependent on<br/>\n&gt; &gt; the bottom when running regression tests. As you can see, the<br/>\n&gt; &gt; chosen view depends more upon what I am doing than upon the<br/>\n&gt; &gt; test dependencies themselves.<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; Finally, being able to list dependencies between test<br/>\n&gt; &gt; classes in addition to test cases would also JUnit to report<br/>\n&gt; &gt; which components of the system depend upon each other. This<br/>\n&gt; &gt; simple extension would greatly increase the power of the<br/>\n&gt; &gt; dependency models for larger systems (particularly regression tests).<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; Thank you,<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; Rocco<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; From: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a> &lt;junit%40yahoogroups.com&gt; [mailto:<br/>\n&gt; <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a> &lt;junit%40yahoogroups.com&gt;]<br/>\n&gt; &gt; On Behalf<br/>\n&gt; &gt; &gt; Of Charlie Poole<br/>\n&gt; &gt; &gt; Sent: Thursday, December 24, 2009 12:09 AM<br/>\n&gt; &gt; &gt; To: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a> &lt;junit%40yahoogroups.com&gt;<br/>\n&gt; &gt; &gt; Subject: RE: [junit] Order of execution for tests<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; Hi C�dric,<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; &gt; On another list, I identified the same variations of dependency<br/>\n&gt; &gt; &gt; &gt; &gt; but with the variation that for case 1. We might run B<br/>\n&gt; &gt; anyway but<br/>\n&gt; &gt; &gt; &gt; &gt; could highlight the error in A in some way. That<br/>\n&gt; &gt; approach doesn&#39;t<br/>\n&gt; &gt; &gt; &gt; &gt; require ordering the tests in any particular way, which<br/>\n&gt; &gt; has some advantages.<br/>\n&gt; &gt; &gt; &gt; &gt; It still promotes developer efficiency while not worrying about<br/>\n&gt; &gt; &gt; &gt; &gt; execution efficiency.<br/>\n&gt; &gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; Yes, we call these &quot;soft dependencies&quot;.<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; If &quot;b&quot; has a hard dependency on &quot;a&quot; and &quot;a&quot; fails, &quot;a&quot; will be<br/>\n&gt; &gt; &gt; &gt; marked &quot;FAILED&quot; and b &quot;SKIPPED&quot;.<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; If &quot;b&quot; has a soft dependency on &quot;a&quot;, &quot;b&quot; will still run<br/>\n&gt; &gt; even if &quot;a&quot;<br/>\n&gt; &gt; &gt; &gt; fails but a warning could be displayed in the log.<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; This is an implementation-based view of the tests: i.e. they will<br/>\n&gt; &gt; &gt; either be run or not run.<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; The distinction I was trying to make - and I think David as<br/>\n&gt; &gt; well - is<br/>\n&gt; &gt; &gt; based on the cause and nature of the dependency.<br/>\n&gt; &gt; &gt; For the sake of argument, I&#39;ll try to redefine what you&#39;re calling<br/>\n&gt; &gt; &gt; Hard and Soft along those lines.<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; Hard: Test A does something (sets state) upon which B depends.<br/>\n&gt; &gt; &gt; For example, A may write to a data store and B might try to<br/>\n&gt; &gt; read the<br/>\n&gt; &gt; &gt; information back. Or A might create a complex object and B<br/>\n&gt; &gt; might try<br/>\n&gt; &gt; &gt; to call a method on that object. If we allow this sort of<br/>\n&gt; &gt; thing, then<br/>\n&gt; &gt; &gt; there is no choice but to run A first and it makes sense to<br/>\n&gt; &gt; not run B<br/>\n&gt; &gt; &gt; at all if A fails. However, I would not want a unit test<br/>\n&gt; &gt; framework to<br/>\n&gt; &gt; &gt; allow it.<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; Soft: Test A tests some functionality upon which some other<br/>\n&gt; &gt; &gt; functionality, tested by B, depends. Therefore, if test A<br/>\n&gt; &gt; fails, Test<br/>\n&gt; &gt; &gt; B will either fail as well or be inconclusive, so nothing<br/>\n&gt; &gt; further can<br/>\n&gt; &gt; &gt; be learned from test B. In this case, a testing framework could<br/>\n&gt; &gt; &gt; respond in a number of ways to the dependency:<br/>\n&gt; &gt; &gt; 1) Run the tests in order, skipping B if A fails.<br/>\n&gt; &gt; &gt; 2) Run the tests in an arbitrary order, but skip B if A already ran<br/>\n&gt; &gt; &gt; and failed.<br/>\n&gt; &gt; &gt; 3) Run the tests in an arbitrary order, not skipping any of<br/>\n&gt; &gt; them but<br/>\n&gt; &gt; &gt; organize reporting in such a way that a failure of A takes<br/>\n&gt; &gt; precedence<br/>\n&gt; &gt; &gt; over a failure of B.<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; As a framework author, I can see that allowing the user to specify<br/>\n&gt; &gt; &gt; ordering is a simpler implementation. But I think it&#39;s more<br/>\n&gt; &gt; &gt; interesting to imagine the user specifying the nature of the<br/>\n&gt; &gt; &gt; dependencies and allowing the framework to figure out a strategy.<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; Charlie<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; Every time we have discussed this potential feature for<br/>\n&gt; &gt; TestNG, the<br/>\n&gt; &gt; &gt; &gt; discussion ended up being non conclusive on the real interest and<br/>\n&gt; &gt; &gt; &gt; the existing ability to mark certain methods as<br/>\n&gt; &gt; &quot;alwaysRun&quot; already<br/>\n&gt; &gt; &gt; &gt; fills a big part of this scenario, so I always ended up<br/>\n&gt; &gt; punting on<br/>\n&gt; &gt; &gt; &gt; it, but I&#39;d be happy to hear if someone can come up with<br/>\n&gt; &gt; a good use<br/>\n&gt; &gt; &gt; &gt; case for soft dependencies...<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; --<br/>\n&gt; &gt; &gt; &gt; ***C�dric<br/>\n&gt; &gt; &gt; &gt; *<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; [Non-text portions of this message have been removed]<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; ------------------------------------<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt; Yahoo! Groups Links<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt; &gt;<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; [Non-text portions of this message have been removed]<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt; [Non-text portions of this message have been removed]<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt; ------------------------------------<br/>\n&gt; &gt;<br/>\n&gt; &gt; Yahoo! Groups Links<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt;<br/>\n&gt;  <br/>\n&gt;<br/>\n<br/>\n<br/>\n </span></blockquote>[Non-text portions of this message have been removed]</div>", 
    "prevInTime": 22242, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1262204135", 
    "canDelete": false, 
    "nextInTopic": 22244, 
    "prevInTopic": 22242, 
    "headers": {
        "inReplyToHeader": "PDAwM2QwMWNhODk4YyQzOTFkOWZmMCQ3MjAxYThjMEBmZXJyYXJpPg==", 
        "messageIdInHeader": "PGI4NmI2YTljMDkxMjMwMTIxNXE1MWE5ZTNmYmo0M2JlNDMxNzQ2YmE1ZWU2QG1haWwuZ21haWwuY29tPg==", 
        "referencesHeader": "PDM5MUVBNTJFLUFEODEtNDY3Ny04REY5LURBNDc4MTZENTQ3NEBlYXJ0aGxpbmsubmV0PiAJPDAwM2QwMWNhODk4YyQzOTFkOWZmMCQ3MjAxYThjMEBmZXJyYXJpPg=="
    }
}