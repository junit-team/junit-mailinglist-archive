{
    "numMessagesInTopic": 55, 
    "nextInTime": 13508, 
    "senderId": "zYI0UEl8azQSsqEkdNzEnbk0Opz8SUFc6LJgRowM1U-HKskIEczwJQsghWJ9bODxcNOlgNlcTnuEy_OC4O13ODWzGrJ69tzGI8vVuA", 
    "systemMessage": false, 
    "subject": "Re: DbUnit & ORM", 
    "from": "&quot;haefeleuser&quot; &lt;haefeleuser@...&gt;", 
    "authorName": "haefeleuser", 
    "msgSnippet": "... It does not need to know. What you do in your example, is to mock the data source. The ORM we use has so called Providers for every entity: ", 
    "msgId": 13507, 
    "profile": "haefeleuser", 
    "topicId": 13451, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 174752849, 
    "messageBody": "<div id=\"ygrps-yiv-1913552224\">--- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>, &quot;J. B. Rainsberger&quot; &lt;jbrains@r...&gt;<br/>\nwrote:<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt;Does your business logic need to know where it gets the data from?<br/>\n&gt;&gt;Usually not. Separate the data source from the business logic using <br/>\n&gt;&gt;the data...<br/>\n </span></blockquote>It does not need to know.<br/>\n<br/>\nWhat you do in your example, is to mock the data source.<br/>\n<br/>\nThe ORM we use has so called Providers for every entity:<br/>\nArticleProvider, SupplierProvider and so on. Besides that, the ORM has<br/>\nso called Managers, for example ArticleManager, SupplierManager and<br/>\nso on.<br/>\n<br/>\nMost of these ORM-related classes are generated by a code generation<br/>\ntool. We have methods like ArticleProvider.getArticleById(String id)<br/>\nand SupplierManager.createSupplier(Supplier supplier). Most of it is<br/>\ngenerated from meta data.<br/>\n<br/>\nIf we would use your strategy, we had to mock a lot of Providers and<br/>\nManagers. Lets assume the business logic method called<br/>\ncalculateReplacementTime(...) uses 2 Providers directly and another 2<br/>\nProviders indirectly (by calling other methods which use them). Then<br/>\nwe would have to mock 4 Providers for testing.<br/>\n<br/>\nThe business logic is often inside a stateless session bean. So we<br/>\nwould need to pass the Providers (either real or just mocks) into the<br/>\nmethod calculateReplacementTime(...), which would be 4 parameters.<br/>\n<br/>\nSome business logic methods (we call them &quot;Services&quot;) even use<br/>\nManagers which I mentioned above. So we would have to mock all these<br/>\nManagers too. In a way we would have to mock the whole ORM if we are<br/>\nconsequent. Would we walk on air then? I don&#39;t know.<br/>\n<br/>\nDon&#39;t be confused about Managers and Providers for each entity. They<br/>\nare an ugly consequence of that home grown crappy ORM I have to use.<br/>\n<br/>\nI don&#39;t know if this strategy can be applied in our case without<br/>\nintroducing too much noise and confusion in implementation and design.<br/>\nI&#39;ll think about it in more detail later. It could work. But I have to<br/>\nfind a good solution for our case.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt;DbUnit is good for any test that talks to a live database. I simply<br/>\n&gt;&gt;prefer to do that as little as possible.<br/>\n<br/>\n </span></blockquote>You wrote in your earlier answer that you wouldn&#39;t use DbUnit for<br/>\nbuilding test data and that you would use the ORM to do it. Or did I<br/>\nmisunderstood you?<br/>\n<br/>\nIts much easier for me to read this data building below than a data<br/>\nXML file for DbUnit:<br/>\nmeasurementUnit.setIsoId(&quot;KGM&quot;);<br/>\narticle.setId(&quot;123);<br/>\narticle.setMeasurementUnit(measurementUnit);<br/>\narticleMgr.persistArticle(article);<br/>\nentityGarbageCollector.addGarbage(article);<br/>\n...<br/>\nentityGarbageCollector.disposeGarbage(); // after the test is finished<br/>\n<br/>\nIf I refactor a entity name or a persistant attribute name (inside<br/>\nEclipse with the wizard), then my test still works. But with DbUnit I<br/>\nwould need to update the XML file manually, changing the field &quot;buyer&quot;<br/>\nto &quot;purchaser&quot; for example.<br/>\n<br/>\nUsing mocks is okay. But there are quite a lot of bugs which can only<br/>\nbe found with integration tests. Do you write pure unit tests? What<br/>\nabout integration testing? Is JUnit suitable for integration tests?</div>", 
    "prevInTime": 13506, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1116002217", 
    "canDelete": false, 
    "nextInTopic": 13516, 
    "prevInTopic": 13504, 
    "headers": {
        "inReplyToHeader": "PDQyODNFRjYxLjEwNzAwQHJvZ2Vycy5jb20+", 
        "messageIdInHeader": "PGQ2MmwzOStydXZqQGVHcm91cHMuY29tPg=="
    }
}