{
    "numMessagesInTopic": 47, 
    "nextInTime": 15062, 
    "senderId": "E33dIokT9UCQImDsVSJX60a5ux44WeUHy8bHTR_jwToFrmDnBLGvLWne_3ee_VaVJvQjTzaxxM-1hEQC2r5oaNU-92E", 
    "systemMessage": false, 
    "subject": "Re: [junit] Proposed parameterized test syntax for JUnit 4", 
    "from": "Eugene Kuleshov &lt;eu@...&gt;", 
    "authorName": "Eugene Kuleshov", 
    "msgSnippet": "David, Kent, I agree that one-class-instance-per-test is a good enforcement (as long as it does not cause performance issues). Usually it is also practical to", 
    "msgId": 15061, 
    "profile": "ekuleshov", 
    "topicId": 14820, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 150395705, 
    "messageBody": "<div id=\"ygrps-yiv-1725334506\">David, Kent,<br/>\n<br/>\n  I agree that one-class-instance-per-test is a good enforcement (as <br/>\nlong as it does not cause performance issues). Usually it is also <br/>\npractical to have single test class per class under test, it is just <br/>\neasier to see what tests you have.<br/>\n<br/>\n  Imagine that there is AThing class with N methods.<br/>\n  Test class AThingTest would have K test methods that can be groupped <br/>\nby use cases for AThing class implementing scenarious for each possible <br/>\nexecution flow (e.g. if all AThing methods are atomic and stateless you <br/>\nwould have at least N test methods).<br/>\n  Note that different use cases may have different input and <br/>\ninitialization data for AThing class under test. E.g. methods X and Y of <br/>\nAThing class have different parameters and as a result methods testX and <br/>\ntestY will require different parameters.<br/>\n  In current implementation of @Parameters in JUnit4 the above scenario <br/>\nwill require to implement two separate test classes and in my opinion it <br/>\nis a huge an annoying limitation because user will have to find and run <br/>\nall test classes that are testing AThing on AThing change.<br/>\n<br/>\n  Thanks<br/>\n<br/>\n  Eugene<br/>\n<br/>\n<br/>\nDavid Saff wrote:<br/>\n<br/>\n<blockquote><span title=\"qreply\"> &gt;Cedric,<br/>\n&gt;<br/>\n&gt;I think there&#39;s a lot of room for different ways of organizing tests. <br/>\n&gt;For me, it&#39;s good for JUnit 4 to keep the one-class-instance-per-test <br/>\n&gt;philosophy of JUnits 1 through 3. I find that if my code depends on too <br/>\n&gt;much global state, or too many collaborators, I begin to feel it, <br/>\n&gt;because it gets harder to test in JUnit. I find that if I ignore this <br/>\n&gt;pain in the tests, eventually it becomes a pain in the code, so I like <br/>\n&gt;JUnit&#39;s early warning.<br/>\n&gt;<br/>\n&gt;With that in mind, I find that having the parameters on the constructor <br/>\n&gt;reminds me of what&#39;s really going on.<br/>\n&gt;<br/>\n&gt;David Saff<br/>\n&gt;<br/>\n&gt;Cédric Beust ♔ wrote:<br/>\n&gt;<br/>\n&gt;  <br/>\n&gt;<br/>\n&gt;&gt;Hi Kent,<br/>\n&gt;&gt;<br/>\n&gt;&gt;On 10/4/05, Kent Beck &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:kentb@...\">kentb@...</a>&gt; wrote:<br/>\n&gt;&gt;    <br/>\n&gt;&gt;<br/>\n&gt;&gt;&gt;Cedric,<br/>\n&gt;&gt;&gt;<br/>\n&gt;&gt;&gt;If I need different sets of parameters for different tests, I put the<br/>\n&gt;&gt;&gt;tests<br/>\n&gt;&gt;&gt;in different classes. This way, tests don&#39;t see parameters they don&#39;t<br/>\n&gt;&gt;&gt;need.<br/>\n&gt;&gt;&gt;The same goes for fields set in a set-up method. Only tests that need<br/>\n&gt;&gt;&gt;exactly the same setup go in the same class.<br/>\n&gt;&gt;&gt;      <br/>\n&gt;&gt;&gt;<br/>\n&gt;&gt;Well, that&#39;s certainly the way it works in JUnit3, but I thought the whole<br/>\n&gt;&gt;point behind the parameterized proposal was to allow tests to receive<br/>\n&gt;&gt;parameters?<br/>\n&gt;&gt;<br/>\n&gt;&gt;A lot of TestNG users like this feature, so that instead of passing, say,<br/>\n&gt;&gt;the path of an XML file in the constructor and then referencing it in your<br/>\n&gt;&gt;test method:<br/>\n&gt;&gt;<br/>\n&gt;&gt;public VerifyXmlTest(String xmlPath) {<br/>\n&gt;&gt;this.xmlPath = xmlPath;<br/>\n&gt;&gt;}<br/>\n&gt;&gt;<br/>\n&gt;&gt;public void testXml() {<br/>\n&gt;&gt;// use this.xmlPath<br/>\n&gt;&gt;}<br/>\n&gt;&gt;<br/>\n&gt;&gt;You pass it directly to the test method:<br/>\n&gt;&gt;<br/>\n&gt;&gt;public void testXml(String xmlPath) {<br/>\n&gt;&gt;}<br/>\n&gt;&gt;<br/>\n&gt;&gt;Cleaner, and it also features better isolation since you are not exposing<br/>\n&gt;&gt;this parameter to test methods that don&#39;t need it.<br/>\n&gt;&gt;<br/>\n&gt;&gt;--<br/>\n&gt;&gt;Cédric<br/>\n&gt;&gt; </span></blockquote></div>", 
    "prevInTime": 15060, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1128522434", 
    "canDelete": false, 
    "nextInTopic": 15063, 
    "prevInTopic": 15060, 
    "headers": {
        "inReplyToHeader": "PDQzNDNERDQ4LjUwNzA0MDlAbWl0LmVkdT4=", 
        "messageIdInHeader": "PDQzNDNFMkMyLjUwNzA1QG1kLnBwLnJ1Pg==", 
        "referencesHeader": "PGI4NmI2YTljMDUxMDA0MDgzOXNiMmI0MjJla2IwNmVlMWI4MjY3NWQxZGFAbWFpbC5nb29nbGUuY29tPgkgPEUxRU12OHAtMDAwODc1LU9xQHNtdHBhdXRoMDgubWFpbC5hdGwuZWFydGhsaW5rLm5ldD4gPGI4NmI2YTljMDUxMDA0MTkzN28yYWMyM2ZjNG05Y2JmY2M0ZDk3NzVjMTRlQG1haWwuZ29vZ2xlLmNvbT4gPDQzNDNERDQ4LjUwNzA0MDlAbWl0LmVkdT4="
    }
}