{
    "numMessagesInTopic": 9, 
    "nextInTime": 16897, 
    "senderId": "8DvHsSwf-wunVkNGiuHsiBU_wNWhDwtWpN0kNc1xrbEcrC5QtH1Fdm_IPx0AtbjTmXpu6o8YMaIWVEC5EJgq4JJV7jpM5KAVlyDiw2C6EIdhmbke", 
    "systemMessage": false, 
    "subject": "Re: [junit] Deep Equals of two JavaBeans", 
    "from": "&quot;Joakim Ohlrogge&quot; &lt;joakim.ohlrogge@...&gt;", 
    "authorName": "Joakim Ohlrogge", 
    "msgSnippet": "Java collections implement the equals method so the way I see it you could use equals() on anything that is not an array or a primitive type. That would work", 
    "msgId": 16896, 
    "rawEmail": "Return-Path: &lt;joakim.ohlrogge@...&gt;\r\nX-Sender: joakim.ohlrogge@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (qmail 54512 invoked from network); 9 Jun 2006 12:15:33 -0000\r\nReceived: from unknown (66.218.66.217)\n  by m4.grp.scd.yahoo.com with QMQP; 9 Jun 2006 12:15:33 -0000\r\nReceived: from unknown (HELO nf-out-0910.google.com) (64.233.182.185)\n  by mta2.grp.scd.yahoo.com with SMTP; 9 Jun 2006 12:15:31 -0000\r\nReceived: by nf-out-0910.google.com with SMTP id c2so110576nfe\n        for &lt;junit@yahoogroups.com&gt;; Fri, 09 Jun 2006 05:11:20 -0700 (PDT)\r\nReceived: by 10.48.210.19 with SMTP id i19mr2329118nfg;\n        Fri, 09 Jun 2006 05:11:20 -0700 (PDT)\r\nReceived: by 10.48.42.1 with HTTP; Fri, 9 Jun 2006 05:11:20 -0700 (PDT)\r\nMessage-ID: &lt;b9ee5e410606090511v30f9792ek2e9deeb5bdb69217@...&gt;\r\nDate: Fri, 9 Jun 2006 14:11:20 +0200\r\nTo: junit@yahoogroups.com\r\nIn-Reply-To: &lt;e6a1ho+r9fo@...&gt;\r\nMIME-Version: 1.0\r\nReferences: &lt;e6a1ho+r9fo@...&gt;\r\nX-Google-Sender-Auth: add7f5207cfb4303\r\nX-eGroups-Msg-Info: 1:0:0:0\r\nX-eGroups-From: &quot;Joakim Ohlrogge&quot; &lt;joakim.ohlrogge@...&gt;\r\nFrom: &quot;Joakim Ohlrogge&quot; &lt;joakim.ohlrogge@...&gt;\r\nReply-To: joakim.ohlrogge@...\r\nSubject: Re: [junit] Deep Equals of two JavaBeans\r\nX-Yahoo-Group-Post: member; u=261856052; y=1LhS8vZhsOuwPaIBHJeqrs91Wu9knXzpMxbjtU-8RQijOz2g\r\nX-Yahoo-Profile: j0hlrogge\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\n\r\nJava collections implement the equals method so the way I see it you could\nuse equals() on anything that is not an array or a primitive type. That\nwould\nwork for collections and would attempt an equals on any other object.\n\nHere is the Javadoc for AbstractMap.equals(Object other):\n\nCompares the specified object with this map for equality. Returns true if\nthe given object is also a map and the two maps represent the same mappings.\nMore formally, two maps t1 and t2 represent the same mappings if t1.keySet\n().equals(t2.keySet()) and for every key k in t1.keySet(), (t1.get(k)==null\n? t2.get(k)==null : t1.get(k).equals(t2.get(k))) . This ensures that the\nequals method works properly across different implementations of the map\ninterface.\n\nThis implementation first checks if the specified object is this map; if so\nit returns true. Then, it checks if the specified object is a map whose size\nis identical to the size of this set; if not, it it returns false. If so, it\niterates over this map&#39;s entrySet collection, and checks that the specified\nmap contains each mapping that this map contains. If the specified map fails\nto contain such a mapping, false is returned. If the iteration completes,\ntrue is returned.\nLists, Sets etc als to deep compares with &quot;eager false&quot; or how ever you\nwould call it when it tries to determine as quickly and efficently when\nsomething is not equal.\n\nCheers!\n/Joakim Ohlrogge\n\n\n\n\nOn 6/8/06, wheelerpoker &lt;wheelerpoker@...&gt; wrote:\n&gt;\n&gt;   I am trying to implement an assertion that does a deep equals of two\n&gt; POJOs vs. using the POJOs&#39; equals methods like assertEquals(Object,\n&gt; Object). The code is below. It&#39;s kind of shakey and only works on\n&gt; properties that are maps, collections, arrays, primitives, and beans\n&gt; (complex types). It attempts to thwart infinite recursion from cycles\n&gt; by caching objects in a List and performing reference equality tests.\n&gt; I&#39;ve tried to make the code thread-safe, but it&#39;s probably not. Can\n&gt; you look and comment?\n&gt;\n&gt; import java.util.ArrayList;\n&gt; import java.util.Collection;\n&gt; import java.util.Date;\n&gt; import java.util.Iterator;\n&gt; import java.util.List;\n&gt; import java.util.Map;\n&gt; import java.util.Set;\n&gt;\n&gt; import junit.framework.Assert;\n&gt;\n&gt; import org.apache.commons.beanutils.PropertyUtils;\n&gt; import org.apache.commons.logging.Log;\n&gt; import org.apache.commons.logging.LogFactory;\n&gt;\n&gt; public final class AssertUtil extends Assert {\n&gt;\n&gt; private static final Log logger = LogFactory.getLog(AssertUtil.class);\n&gt; /** for detecting cycles and preventing infinite recursive loop */\n&gt; private static final List referenceCache = new ArrayList();\n&gt;\n&gt; private AssertUtil() {\n&gt; throw new UnsupportedOperationException(&quot;do not use&quot;);\n&gt; }\n&gt;\n&gt; public static synchronized void assertDeepEquals(Object expected,\n&gt; Object actual) {\n&gt; logger.debug(&quot;assertDeepEquals called&quot;);\n&gt; doAssertDeepEquals(null, expected, actual);\n&gt; logger.debug(&quot;clearing &quot; + referenceCache.size() + &quot; objects\n&gt; from reference cache&quot;);\n&gt; referenceCache.clear();\n&gt; }\n&gt;\n&gt; private static void doAssertDeepEquals(String name, Object\n&gt; expected, Object actual) {\n&gt; if (referenceAlreadyCached(expected)) {\n&gt; logger.debug(&quot;cycle detected on &quot; + expected);\n&gt; return;\n&gt; }\n&gt;\n&gt; if (expected == null) {\n&gt; assertNull(&quot;expected &quot; + name + &quot; was null, but actual was\n&gt; not&quot;, actual);\n&gt; } else if (expected != null) {\n&gt; assertNotNull(&quot;expected &quot; + name + &quot; was not null, but\n&gt; actual was&quot;, actual);\n&gt;\n&gt; // both objects guaranteed not null from now on\n&gt; if (isSimpleProperty(expected)) {\n&gt; evaluateSimpleProperty(name, expected, actual);\n&gt; } else {\n&gt; referenceCache.add(expected);\n&gt; if (isArrayProperty(expected)) {\n&gt; evaluateArrayProperty(name, (Object[])expected,\n&gt; (Object[])actual);\n&gt; } else if (isCollectionProperty(expected)) {\n&gt; evaluateCollectionProperty(name,\n&gt; (Collection)expected, (Collection)actual);\n&gt; } else if (isMapProperty(expected)) {\n&gt; evaluateMapProperty((Map)expected, (Map)actual);\n&gt;\n&gt; } else {\n&gt; evaluateComplexProperty(expected, actual);\n&gt; }\n&gt; }\n&gt; }\n&gt; }\n&gt;\n&gt; private static void evaluateSimpleProperty(String name, Object\n&gt; expected, Object actual) {\n&gt; logger.debug(name + &quot; [expected = &quot; + expected + &quot;, actual = &quot;\n&gt; + actual + &quot;]&quot;);\n&gt; assertEquals(name + &quot; not equal&quot;, expected, actual);\n&gt; }\n&gt;\n&gt; private static void evaluateArrayProperty(String name, Object[]\n&gt; expected, Object[] actual) {\n&gt; if (expected.length != actual.length)\n&gt; fail(&quot;not the same length&quot;);\n&gt; for (int i=0; i&lt;expected.length; i++)\n&gt; doAssertDeepEquals(name + &quot;[&quot; + i + &quot;]&quot;, expected[i],\n&gt; actual[i]);\n&gt; }\n&gt;\n&gt; private static void evaluateCollectionProperty(String name,\n&gt; Collection expected, Collection actual) {\n&gt; evaluateArrayProperty(name, expected.toArray(), actual.toArray());\n&gt; }\n&gt;\n&gt; /** TODO perform a deep comparison of each maps&#39; keys */\n&gt; private static void evaluateMapProperty(Map expected, Map actual) {\n&gt; Set keys = expected.keySet();\n&gt; if (!keys.equals(actual.keySet()))\n&gt; fail(&quot;dissimilar keys&quot;);\n&gt;\n&gt; for (Iterator i=keys.iterator(); i.hasNext();) {\n&gt; Object key = i.next();\n&gt; doAssertDeepEquals(key.toString(), expected.get(key),\n&gt; actual.get(key));\n&gt; }\n&gt; }\n&gt;\n&gt; private static void evaluateComplexProperty(Object expected,\n&gt; Object actual) {\n&gt; Map expectedProps = null, actualProps = null;\n&gt; try {\n&gt; expectedProps = PropertyUtils.describe(expected);\n&gt; actualProps = PropertyUtils.describe(actual);\n&gt; // not to thrilled about this, better way??\n&gt; expectedProps.remove(&quot;class&quot;);\n&gt; actualProps.remove(&quot;class&quot;);\n&gt; } catch (Exception ex) {\n&gt; ex.printStackTrace();\n&gt; logger.error(ex);\n&gt; }\n&gt;\n&gt; evaluateMapProperty(expectedProps, actualProps);\n&gt; }\n&gt;\n&gt; private static boolean isSimpleProperty(Object o) {\n&gt; return (\n&gt; o instanceof CharSequence ||\n&gt; o instanceof Number ||\n&gt; o instanceof Boolean ||\n&gt; o instanceof Date ||\n&gt; o instanceof Character);\n&gt; }\n&gt;\n&gt; private static boolean isArrayProperty(Object o) {\n&gt; return o.getClass().isArray();\n&gt; }\n&gt;\n&gt; private static boolean isCollectionProperty(Object o) {\n&gt; return (o instanceof Collection);\n&gt; }\n&gt;\n&gt; private static boolean isMapProperty(Object o) {\n&gt; return (o instanceof Map);\n&gt; }\n&gt;\n&gt; private static boolean referenceAlreadyCached(Object o) {\n&gt; for (int i=0, n=referenceCache.size(); i&lt;n; i++) {\n&gt; if (o == referenceCache.get(i)) {\n&gt; return true;\n&gt; }\n&gt; }\n&gt; return false;\n&gt; }\n&gt; }\n&gt;\n&gt;  \n&gt;\n\n\n[Non-text portions of this message have been removed]\n\n\n", 
    "profile": "j0hlrogge", 
    "topicId": 16890, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 261856052, 
    "prevInTime": 16895, 
    "contentTrasformed": false, 
    "postDate": "1149855080", 
    "canDelete": false, 
    "nextInTopic": 16899, 
    "prevInTopic": 16890, 
    "headers": {
        "inReplyToHeader": "PGU2YTFobytyOWZvQGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PGI5ZWU1ZTQxMDYwNjA5MDUxMXYzMGY5NzkyZWsyZTlkZWViNWJkYjY5MjE3QG1haWwuZ21haWwuY29tPg==", 
        "referencesHeader": "PGU2YTFobytyOWZvQGVHcm91cHMuY29tPg=="
    }
}