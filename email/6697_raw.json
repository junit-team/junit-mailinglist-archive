{
    "numMessagesInTopic": 11, 
    "nextInTime": 6698, 
    "senderId": "ygSisSm9G04HCexlEJmzTPQv5qMmz_J6AownMz_TS11QulmqOhlPldmgzx1AC3kdLUa3Y9-H1n-LxSMfzz4dW1Ac", 
    "systemMessage": false, 
    "subject": "Re: Test first? or Stub first?", 
    "from": "steffen.gemkow@...", 
    "authorName": "steffen.gemkow@objectfab.de", 
    "msgSnippet": "JBR, ... All this is about tests documenting the intentions behind the code . What I ment by documenting aspect does not depend on which comes first, but if", 
    "msgId": 6697, 
    "rawEmail": "Return-Path: &lt;steffen.gemkow@...&gt;\r\nReceived: (qmail 48861 invoked from network); 23 Jan 2003 16:03:55 -0000\r\nReceived: from unknown (66.218.66.218)\n  by m6.grp.scd.yahoo.com with QMQP; 23 Jan 2003 16:03:55 -0000\r\nReceived: from unknown (HELO n6.grp.scd.yahoo.com) (66.218.66.90)\n  by mta3.grp.scd.yahoo.com with SMTP; 23 Jan 2003 16:03:54 -0000\r\nX-eGroups-Return: steffen.gemkow@...\r\nReceived: from [66.218.67.191] by n6.grp.scd.yahoo.com with NNFMP; 23 Jan 2003 16:03:48 -0000\r\nX-Sender: steffen.gemkow@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (EGP: mail-8_2_3_0); 22 Jan 2003 09:30:17 -0000\r\nReceived: (qmail 92571 invoked from network); 22 Jan 2003 09:30:17 -0000\r\nReceived: from unknown (66.218.66.217)\n  by m14.grp.scd.yahoo.com with QMQP; 22 Jan 2003 09:30:17 -0000\r\nReceived: from unknown (HELO moutng.kundenserver.de) (212.227.126.188)\n  by mta2.grp.scd.yahoo.com with SMTP; 22 Jan 2003 09:30:17 -0000\r\nReceived: from [212.227.126.161] (helo=mrelayng.kundenserver.de)\n\tby moutng.kundenserver.de with esmtp (Exim 3.35 #1)\n\tid 18bHD6-0003fF-00\n\tfor junit@yahoogroups.com; Wed, 22 Jan 2003 10:30:16 +0100\r\nReceived: from [217.232.72.218] (helo=HOUSTON)\n\tby mrelayng.kundenserver.de with asmtp (Exim 3.35 #1)\n\tid 18bHD6-0002AS-00\n\tfor junit@yahoogroups.com; Wed, 22 Jan 2003 10:30:16 +0100\r\nTo: junit@yahoogroups.com\r\nDate: Wed, 22 Jan 2003 10:33:08 +0100\r\nMIME-Version: 1.0\r\nSubject: Re: Test first? or Stub first? \r\nMessage-ID: &lt;3E2E7364.26964.350ADC@localhost&gt;\r\nPriority: normal\r\nIn-reply-to: &lt;1043141177.517.52964.m12@yahoogroups.com&gt;\r\nX-mailer: Pegasus Mail for Windows (v4.01)\r\nContent-type: text/plain; charset=US-ASCII\r\nContent-transfer-encoding: 7BIT\r\nContent-description: Mail message body\r\nFrom: steffen.gemkow@...\r\nReply-To: steffen.gemkow@...\r\nX-Yahoo-Group-Post: member; u=127226929\r\nX-Yahoo-Profile: s_gemkow\r\nX-eGroups-Approved-By: clarkware &lt;mike@...&gt; via web; 23 Jan 2003 16:03:48 -0000\r\n\r\nJBR,\n\n&gt;    From: &quot;J. B. Rainsberger&quot; &lt;jbr@...&gt;\n\n&gt; I&#39;m not sure why writing the test before the stub provides more\n&gt; documentation than writing the stub before the test.\n\nAll this is about &quot;tests documenting the intentions behind the code&quot;.\nWhat I ment by &quot;documenting aspect&quot; does not depend on which \ncomes first, but if tests and app are in sync. To keep them in sync\nis much more easy, if one is the base for generating the other.\n\nThe difference (whether or not there is a strong and visible\nrealation) is, how easy one can understand the intention \nbehind certain app code. If one organizes tests similar to \nthe behavioral requirements (instead of following the app \nstructure), one sure makes a lot of progress during initial\ndevelopment. Because we are writing object oriented software,\nbehavior and methods are not very far away from each other.\n\nOver time, the application gets refactored. Changes of \nmethod names or signatures are likely to be the most \nfrequent ones. But often tests stay as they are as long \nas the bar is green. The structural differences between \ntests and application are growing.\n\nImagine you want to add some new feature to an application \nwith this kind of tests in three years from now. You need to \nmodify some code and maybe you need to use some \nexisting code too. Then you want to understand, what the \nintention behind those portions of code was. You want to \nunderstand the methods you are about to modify/use.\nYes, you can search the tests for uses of those method.\n\nWhen I want to get an idea, what the method &quot;xyz&quot; is \nsupposed to do, I prefer to look at &quot;testXyz&quot;. That is what\nI ment with the &quot;documenting aspect&quot; of tests that follow\nthe structure of the application.\n\nJUnitDoclet allows re-generating, so it&#39;s not much work \nto keep tests and app in sync.\n\n&gt; Also, if you haven&#39;t written the test, then how can you be sure that\n&gt; the stub:\n&gt; \n&gt; 1. ...has the proper signature?\n&gt; 2. ...is named well?\n&gt; 3. ...should be class- or instance-level?\n&gt; 4. ...is written on the appropriate object?\n\nAt that point I&#39;m not sure either. But with the skeleton of \nthe application method in place, one can use the full power \nof the IDE. I&#39;m using JUnitDoclet together with IDEA.\n\n1. (changing signature): IDEA does it. The structure of the \ntests is not effected, no need to re-run JUnitDoclet.\n\n2. (renaming a method): IDEA does much of it, including: \nreplacing the method name in the comments for JUnitDoclet. \nRegenerate the tests, and your code is in sync. Nothing else \nto do. (As far as I know Eclipse does not replace in comments, \nwhen doing the renaming. But there is help too, see 4.)\n\n3. (class- or instance level): The IDE is helping you.\n\n4.(appropriate object): Change the application by moving \nthe method. Again, the IDE is very supportive. You can \nmodify the test now manually. Or, if you run JUnitDoclet \nat this point, there would be a new empty test method \nand some &quot;not related&quot; test content. JUnitDoclet collects \nthose &quot;not related&quot; lines in a special method and prints \na warning if this special method is not empty. You can \nmove the test content now to the new method.\n\n&gt; Generally speaking, you don&#39;t really know these things until you write\n&gt; test code, which is really just sample client code, look at it,\n&gt; evaluate it and move on. In general, it is when one sees it &quot;in print&quot;\n&gt; than one really looks at it carefully. Writing the test first\n&gt; guarantees this, while writing the stub first does not.\n\nI consider the stub to be flexible when implementing the test. \nThere is not much of a difference, except we are using \ndifferent supporting features of the IDE.\n\n&gt; I don&#39;t use JUnitDoclet, so I can&#39;t comment on how using it changes the\n&gt; rules of the game. If it&#39;s easy to set up (less than 1 hour), then I\n&gt; may start using it, just for the experience.\n\nI&#39;d be glad to help, if there would be a problem. \nIf you want to look at JUnitDoclet before you install it:\n\n  http://www.junitdoclet.org/demo.html\n\n&gt; I would like you to expand on this: what &quot;documenting aspect&quot; do you\n&gt; mean? and why does writing the stub first enable this feature and\n&gt; writing the test first not enable this feature?\n\nI hope, my lines in the beginning of this email clarified, \nwhat I ment. Sorry, if I wasn&#39;t more precise in former emails.\n\nThanks for your time.\n\nKind Regards,\n\nSteffen Gemkow\n\nPS: Some people force _all_ assertions in tests related to \nspecifc units of code. There are good reasons, to manually \nwrite _some_ additional TestCases (for example at use case \nlevel) too.\n\n\n\n", 
    "profile": "s_gemkow", 
    "topicId": 6697, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 127226929, 
    "prevInTime": 6696, 
    "contentTrasformed": false, 
    "postDate": "1043227988", 
    "canDelete": false, 
    "nextInTopic": 6702, 
    "prevInTopic": 0, 
    "headers": {
        "inReplyToHeader": "PDEwNDMxNDExNzcuNTE3LjUyOTY0Lm0xMkB5YWhvb2dyb3Vwcy5jb20+", 
        "messageIdInHeader": "PDNFMkU3MzY0LjI2OTY0LjM1MEFEQ0Bsb2NhbGhvc3Q+"
    }
}