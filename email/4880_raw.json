{
    "numMessagesInTopic": 46, 
    "nextInTime": 4881, 
    "senderId": "WKJxt6iSuK-oPD6wd3sEMjn2t3OW9wuDkWswZoPhT8Y2BLlcgPWxFerce3evoOOXmnLblQuChbsWMdBzfKBvnfj9reFk3BB9e_MrYxhJ", 
    "systemMessage": false, 
    "subject": "RE: [junit] black box or white box?", 
    "from": "&quot;Berin Loritsch&quot; &lt;bloritsch@...&gt;", 
    "authorName": "Berin Loritsch", 
    "msgSnippet": "... Ok.  I am not guessing.  What I posted are my observations on the way I develop.  With sufficiently componentized software, your only contract that you can", 
    "msgId": 4880, 
    "rawEmail": "Return-Path: &lt;bloritsch@...&gt;\r\nX-Sender: bloritsch@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (EGP: mail-8_0_3_2); 6 May 2002 14:03:56 -0000\r\nReceived: (qmail 21607 invoked from network); 6 May 2002 14:03:56 -0000\r\nReceived: from unknown (66.218.66.216)\n  by m14.grp.scd.yahoo.com with QMQP; 6 May 2002 14:03:56 -0000\r\nReceived: from unknown (HELO failover.kc.aoindustries.com) (209.15.201.72)\n  by mta1.grp.scd.yahoo.com with SMTP; 6 May 2002 14:03:56 -0000\r\nReceived: from Gabriel ([65.105.132.131])\n\tby failover.kc.aoindustries.com (8.11.6/8.11.0) with ESMTP id g46E3m626364\n\tfor &lt;junit@yahoogroups.com&gt;; Mon, 6 May 2002 09:03:48 -0500\r\nTo: &lt;junit@yahoogroups.com&gt;\r\nSubject: RE: [junit] black box or white box?\r\nDate: Mon, 6 May 2002 10:03:45 -0400\r\nMessage-ID: &lt;000601c1f506$d904e4b0$ac00a8c0@Gabriel&gt;\r\nMIME-Version: 1.0\r\nContent-Type: text/plain;\n\tcharset=&quot;us-ascii&quot;\r\nContent-Transfer-Encoding: 7bit\r\nX-Priority: 3 (Normal)\r\nX-MSMail-Priority: Normal\r\nX-Mailer: Microsoft Outlook, Build 10.0.2627\r\nX-Mimeole: Produced By Microsoft MimeOLE V6.00.2600.0000\r\nImportance: Normal\r\nIn-Reply-To: &lt;000d01c1f3fd$24459560$46ec903e@haibach&gt;\r\nX-eGroups-From: &quot;Berin Loritsch&quot; &lt;bloritsch@...&gt;\r\nFrom: &quot;Berin Loritsch&quot; &lt;bloritsch@...&gt;\r\nReply-To: &lt;bloritsch@...&gt;\r\nX-Yahoo-Group-Post: member; u=64910131\r\nX-Yahoo-Profile: bloritsch\r\n\r\n&gt; From: Johannes Link [mailto:john.link@...] \n&gt; \n&gt; &gt;\n&gt; &gt; In reality, you *can* have the best of both worlds.  The \n&gt; issue at hand \n&gt; &gt; is that a general test case excercises all the contracts that the \n&gt; &gt; public interface has.  A contract is a guarantee that the \n&gt; class must \n&gt; &gt; satisfy.\n&gt; &gt;\n&gt; &gt; [...]\n&gt; &gt; If what you are talking about is different than what I just \n&gt; described, \n&gt; &gt; perhaps it is because we&#39;re not speaking the same language?\n&gt; \n&gt; Maybe, let me summarize in my language:\n&gt; What you say is that one can have sufficiently stable \n&gt; software and sufficient coverage with test cases that \n&gt; consider the external contracts only. What I say is that one \n&gt; cannot go beyond a certain level of quality, i.e. below a \n&gt; certain MTBF, without implementation-aware test cases. As \n&gt; long as your &quot;sufficiently stable&quot; is below that level, \n&gt; everything&#39;s fine. My guess is that this can be achieved for \n&gt; most application fields. However, I&#39;m also guessing that one \n&gt; can be testing more efficiently (less testing effort for same \n&gt; quality) with looking at the implementation than without \n&gt; looking at it.\n\nOk.  I am not guessing.  What I posted are my observations on\nthe way I develop.  With sufficiently componentized software,\nyour only contract that you can *trust* is the external contracts.\nIf you ever code the the internal contracts, using assumptions\nthat may not hold up in future versions, then you will *always*\nintroduce bugs into your system.  Those bugs will manifest themselves\nin the MTBF scenario above.\n\nThe difference between what you are describing and what I do\ncan be overcome by the quality of the contracts used to describe\nthe interface.  For example, if the interface to the object requires\nthat methods are called in a certain order, you have to test that\nthey are.  I have created Mock Objects that masquerade as one of\nthese types of objects and then test that an exception is thrown\nwhen the order is violated.  That is an external contract--not\nan internal one.\n\nThe contracts which are internal, and therefore fragile are tests\nfor external artifacts or internal state that does not affect the\nexternal contract.  For example, if we had an object storage component\nthat stored an object to the filesystem we might write a test to\nmake sure the file was written with the correct name.  However\nif we changed the implementation to store many objects in one\nfile, the test becomes invalid even though the component lives\nup to its external contracts.  Even more radical would be if we\nchanged the storage medium completely.  As to internal state,\nif we know that this implementation has seven states (with a\nprotected accessor so that there is a hook for the test to get\nthe state), and we determine that one of those states is not\nnecessary--we invalidate the test when we remove the state.\n\nMy point is this: the external contracts have to be strong enough\nto provide standard guarantees to all clients of the code.  Those\nguarantees are well documented (usually in the javadocs).  This frees\nyou to change the implementation details without worrying about\nbreaking the rest of the system.  If, by using the external contracts\nof the system, we can break a piece of code, then we add the testcase\nthat reenacts that scenario so that we catch it as a regression test.\n\nThe test writing process becomes iterative because it is practically\nimpossible to know every testcase ahead of time.  The initial testcases\nwill excersize the known contracts and is a simple sanity check.  The\nmore detailed ones come later.\n\nI have two examples of this approach--which works.\n\n1) Buffer\n\nAvalon Excalibur Collections sub-sub-project has a new class of\ncollection called a Buffer.  There are several reasons to use a\nList as a Buffer, but we found we could optimize the List even\nmore if we did not provide indexed access to the objects in the\nbuffer (which is not the point of a buffer).  We wrote the\ntestcases to ensure what we put in is what we got out.  However,\nsomeone uncovered that under a specific scenario that the buffer\nwould lose an object.  I asked that person to give me a testcase\ndemonstrating the phenomenon.  The testcase did not make any\nassumptions to the internals of the Buffer!  It was by the normal\nuse case that the problem showed up.  It turned out to be a bug\nin the resizing algorithm for the buffer.  We incorporated the\ntestcase into the normal testing.  That bug will not reappear.\n\n2) CLI\n\nAvalon Excalibur CLI sub-sub-project has a set of classes that\nparse the command line arguments in an easy manner.  The utility\nallows you to iterate through the commands with a switch to set\nthe parameters.  However, someone found that with a certain\ncombination of command line parameters the CLI package went into\nan infinite loop.  We added the testcase, and found the bug in\nshort order.\n\nThat is why I maintain that you can have sufficient testing\nwithout excercizing the internals of a piece of code.  There are\ntwo axioms that you have to use in order to make the approach\nsuccessful:\n\n* NEVER assume anything about the internals.  Any code that uses\n  assumptions _*will*_ break.\n\n* USE sufficiently strong external contracts to ensure the proper\n  usage of a type of object.  The contracts should be loose enough\n  to encourage different implementation details, but strong enough\n  to be quantifiably tested.\n\n\n", 
    "profile": "bloritsch", 
    "topicId": 4836, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 64910131, 
    "prevInTime": 4879, 
    "contentTrasformed": false, 
    "postDate": "1020693825", 
    "canDelete": false, 
    "nextInTopic": 4881, 
    "prevInTopic": 4878, 
    "headers": {
        "inReplyToHeader": "PDAwMGQwMWMxZjNmZCQyNDQ1OTU2MCQ0NmVjOTAzZUBoYWliYWNoPg==", 
        "messageIdInHeader": "PDAwMDYwMWMxZjUwNiRkOTA0ZTRiMCRhYzAwYThjMEBHYWJyaWVsPg=="
    }
}