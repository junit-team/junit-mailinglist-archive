{
    "numMessagesInTopic": 9, 
    "nextInTime": 5848, 
    "senderId": "BzEW3LU6A1AvWqMwD0MgKU5kbLY0HsXJm6Qmyi868Rcbu-VKZ5tuAUoHwLDnWxwZaFfNKoeTocSXkKYi7cz_Qbc7CtMlJDhmy2jfbsTg242MDgEF", 
    "systemMessage": false, 
    "subject": "Re: [junit] writing testcase for data read from a file", 
    "from": "&quot;J. B. Rainsberger&quot; &lt;jbr@...&gt;", 
    "authorName": "J. B. Rainsberger", 
    "msgSnippet": "So said  Singh Manpreet  on  2002-09-24 ... I assume you mean that the method answers the contents of a file as a String. String readContents(final File file);", 
    "msgId": 5847, 
    "rawEmail": "Return-Path: &lt;jbr@...&gt;\r\nX-Sender: jbr@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (EGP: mail-8_1_1_3); 24 Sep 2002 20:33:36 -0000\r\nReceived: (qmail 40072 invoked from network); 24 Sep 2002 20:33:34 -0000\r\nReceived: from unknown (66.218.66.217)\n  by m11.grp.scd.yahoo.com with QMQP; 24 Sep 2002 20:33:34 -0000\r\nReceived: from unknown (HELO fep04-mail.bloor.is.net.cable.rogers.com) (66.185.86.74)\n  by mta2.grp.scd.yahoo.com with SMTP; 24 Sep 2002 20:33:34 -0000\r\nReceived: from siferra ([24.42.96.247])\n          by fep04-mail.bloor.is.net.cable.rogers.com\n          (InterMail vM.5.01.05.06 201-253-122-126-106-20020509) with ESMTP\n          id &lt;20020924203312.WRFU89682.fep04-mail.bloor.is.net.cable.rogers.com@siferra&gt;\n          for &lt;junit@yahoogroups.com&gt;; Tue, 24 Sep 2002 16:33:12 -0400\r\nMessage-ID: &lt;200209241632310731.0089C328@smtp&gt;\r\nIn-Reply-To: &lt;20020924094000.43310.qmail@...&gt;\r\nReferences: &lt;20020924094000.43310.qmail@...&gt;\r\nX-Mailer: Calypso Version 3.30.00.00 (4)\r\nDate: Tue, 24 Sep 2002 16:32:31 -0400\r\nTo: junit@yahoogroups.com\r\nSubject: Re: [junit] writing testcase for data read from a file\r\nContent-Type: text/plain; charset=&quot;us-ascii&quot;\r\nX-Authentication-Info: Submitted using SMTP AUTH LOGIN at fep04-mail.bloor.is.net.cable.rogers.com from [24.42.96.247] using ID &lt;srainsberger5790@...&gt; at Tue, 24 Sep 2002 16:33:12 -0400\r\nFrom: &quot;J. B. Rainsberger&quot; &lt;jbr@...&gt;\r\nReply-To: jbr@...\r\nX-Yahoo-Group-Post: member; u=89240252\r\nX-Yahoo-Profile: nails762\r\n\r\n\nSo said  Singh Manpreet  on  2002-09-24 \n\n&gt;Hi Rainsberger,\n&gt;\n&gt;&gt; How do you know whether your method works? What\n&gt;&gt; would you do to verify\n&gt;&gt; for yourself that the method reads the data\n&gt;&gt; correctly? Explain that in\n&gt;&gt; words and we can convert it to code.\n&gt;\n&gt;The method which i want to test returns the file as a\n&gt;String object.\n\nI assume you mean that the method answers the contents of a file as a\nString.\n\n     String readContents(final File file);\n\n&gt; Now, i was thinking if i have to test\n&gt;what is read from the file, in the testcase i would\n&gt;again be reading from the file. The contents read from\n&gt;the file would be converted to String which would be\n&gt;compared to the value returned by the method for which\n&gt;the testcase is being written (sorry no TFD). But i\n&gt;found it to be weird idea, so i asked the question :-)\n\nIn this case, you could do this:\n\npublic void testReadContents() {\n    final File newFile = new File(&quot;newfile.txt&quot;);\n    assertFalse(newFile.exists());\n    final FileOutputStream newFileOutputStream = new\nFileOutputStream(newFile);\n    final PrintWriter out = new PrintWriter(newFileOutputStream);\n    final String contents = &quot;blah&quot;;\n    out.print(blah);\n    newFileOutputStream.flush();\n    newFileOutputStream.close();\n\n    assertEquals(contents, readContents(newFile));\n\n    // delete newFile in tearDown()\n}\n\nWrite the file with known contents, then compare those known contents\nwith the answer from &#39;readContents&#39;.\n\nNow ask yourself, what are you really testing? In this test, we test\nthe following:\n\n* File.exists() correctly identifies whether a file exists, so that I\ndon&#39;t accidentally overwrite an existing file.\n* FileOutputStream and PrintWriter correctly write my String out to the\nfile.\n* readContents reads the file contents correctly.\n\nThat&#39;s too much to test at once. It relies too much on the file system,\nand you should probably assume that the file system works.\n\nWhat do you really want to test? It&#39;s simple: the JDK doesn&#39;t include a\nlibrary call to return the contents of a text file as a String. The\nclosest thing it does it return the contents of a text file,\nline-by-line. Your job is to construct the lines into a String with the\nproper line separator. Perhaps you should just test that!\n\nOK, your job may also include handling the exceptions thrown by\nBufferedFileReader, which are all IOExceptions, as I recall. Test that,\ntoo!\n\nYou can do both without involving the file system. That makes your\ntests faster and more focussed on testing the code *you* write and not\nthe code already written by others in the JDK. Much better!\n\n    testHandleFileNotFound\n    testHandleIoExceptionWhileReading\n    testJoinLines_EmptyLineSet\n    testJoinLines\n\nThose four tests ought to do it. Now readContents does this:\n\nString readContents(final File file) throws IOException {\n    final BufferedReader reader = new BufferedReader(new\nFileInputStream(file));\n    final List lines = new ArrayList();\n    while (true) {\n        final String line = reader.readLine();\n        if (line == null) { break; }\n        lines.add(line);        \n    }\n    return joinLines(lines, System.getProperty(&quot;line.separator&quot;,\n&quot;&#92;n&quot;));\n}\n\nYou write joinLines and test it, or find it from a library. If\nnecessary, you test how to handle the exceptions.\n\nYou may consider the act of reading all the lines in a file and storing\nthem in a list something worth testing. I don&#39;t. If you do want to test\nit, instead do something like this:\n\ninterface LineProvider {\n    String readLine() throws IOException;\n}\n\nclass FileLineProvider implements LineProvider {\n    File file;\n\n    FileLineProvider(File file) {\n        this.file = file;\n    }\n\n    String readLine() throws IOException {\n        return getBufferedReader().readLine();\n    }\n\n    BufferedReader getBufferedReader() throws IOException {\n        // lazily instantiate BufferedReader\n    }\n}\n\nclass StringLineProvider implements LineProvider {\n    List strings;\n    Iterator iterator;\n\n    FileLineProvider(List strings) {\n        this.strings = new ArrayList(strings);\n        iterator = this.strings.iterator();\n    }\n\n    String readLine() {\n        if (iterator.hasNext()) {\n            return (String) iterator.next();\n        }\n        else {\n            return null;\n        }\n    }\n}\n\nUse StringLineProvider in the test and FileLineProvider in production.\nNow you have\n\nString readContents(LineProvider lineProvider) {\n    final List lines = new ArrayList();\n    while (true) {\n        final String line = lineProvider.readLine();\n        if (line == null) { break; }\n        lines.add(line);        \n    }\n    return joinLines(lines, System.getProperty(&quot;line.separator&quot;,\n&quot;&#92;n&quot;));\n}\n\nEven better would be to have LineProvider provide the collection of\nlines. The loop, after all, only talks to lineProvider.\n\nabstract class LineProvider {\n    LineProvider() {}\n\n    abstract String readLine() throws IOException;\n    \n    List readContents() {\n        final List lines = new ArrayList();\n        while (true) {\n            final String line = lineProvider.readLine();\n            if (line == null) { break; }\n            lines.add(line);        \n        }\n        return lines;\n    }\n}\n\n// Change implementors to be subclasses, now.\n\nString readContents(LineProvider lineProvider) {\n    return joinLines(lineProvider.readContents(),\nSystem.getProperty(&quot;line.separator&quot;, &quot;&#92;n&quot;));\n}\n\nNow readContents(LineProvider) can&#39;t possibly break -- all it does is\ndelegate! If joinLines and lineProvider.readContents() work, you&#39;re\nfree.\n\nI know you can get joinLines from a library, so don&#39;t test that.\n\nTesting readContents is easy, because it just puts stuff in a list. Two\nor three tests should cover it.\n\nIn fact, I&#39;d love to just have an Iterator-style interface for this and\nbe done with it. LineProvider is really just an Iterator. I should\nwrite that, stick in a library on SourceForge and then you have nothing\nleft to do!\n\nTake care.\n\nJ. B. Rainsberger,\nPresident, Diaspar Software Services\nLet&#39;s write software that people understand.\nhttp://www.diasparsoftware.com/\ntelephone: +1 416 791-8603\nAll correspondence (c) 2002 Diaspar Software Services.\nIf you want to use it, just ask; don&#39;t steal.\n\n\n", 
    "profile": "nails762", 
    "topicId": 5818, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 89240252, 
    "prevInTime": 5846, 
    "contentTrasformed": false, 
    "postDate": "1032899551", 
    "canDelete": false, 
    "nextInTopic": 5866, 
    "prevInTopic": 5839, 
    "headers": {
        "inReplyToHeader": "PDIwMDIwOTI0MDk0MDAwLjQzMzEwLnFtYWlsQHdlYjEzOTAyLm1haWwueWFob28uY29tPg==", 
        "messageIdInHeader": "PDIwMDIwOTI0MTYzMjMxMDczMS4wMDg5QzMyOEBzbXRwPg==", 
        "referencesHeader": "PDIwMDIwOTI0MDk0MDAwLjQzMzEwLnFtYWlsQHdlYjEzOTAyLm1haWwueWFob28uY29tPg=="
    }
}