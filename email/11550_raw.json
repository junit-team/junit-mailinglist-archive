{
    "numMessagesInTopic": 18, 
    "nextInTime": 11551, 
    "senderId": "XriEipYy7EchvNDf45vQGcWk32AH5LNWOIN1ryQrcBxMjfuKbq_lvULUhveB97uvZHbUBWadVOFjhnRfMpOAFl4y7vQLe0Ho", 
    "systemMessage": false, 
    "subject": "Re: Did my question get missed, somehow?", 
    "from": "&quot;cypherfox&quot; &lt;cypherfox@...&gt;", 
    "authorName": "cypherfox", 
    "msgSnippet": "Greetings, Hmmm...  This is getting long. ... those ... It s actually just testing that it retrieves the message from the server, and gets the right data,", 
    "msgId": 11550, 
    "rawEmail": "Return-Path: &lt;cypherfox@...&gt;\r\nX-Sender: cypherfox@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (qmail 76747 invoked from network); 16 Jul 2004 21:54:26 -0000\r\nReceived: from unknown (66.218.66.166)\n  by m25.grp.scd.yahoo.com with QMQP; 16 Jul 2004 21:54:26 -0000\r\nReceived: from unknown (HELO n39.grp.scd.yahoo.com) (66.218.66.107)\n  by mta5.grp.scd.yahoo.com with SMTP; 16 Jul 2004 21:54:26 -0000\r\nReceived: from [66.218.67.160] by n39.grp.scd.yahoo.com with NNFMP; 16 Jul 2004 21:54:26 -0000\r\nDate: Fri, 16 Jul 2004 21:54:26 -0000\r\nTo: junit@yahoogroups.com\r\nMessage-ID: &lt;cd9iqi+vm7v@...&gt;\r\nIn-Reply-To: &lt;40F830E4.4010304@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Length: 10873\r\nX-Mailer: Yahoo Groups Message Poster\r\nX-eGroups-Remote-IP: 66.218.66.107\r\nFrom: &quot;cypherfox&quot; &lt;cypherfox@...&gt;\r\nSubject: Re: Did my question get missed, somehow?\r\nX-Yahoo-Group-Post: member; u=174888704\r\nX-Yahoo-Profile: cypherfox\r\n\r\nGreetings,\nHmmm...  This is getting long.\n\n--- In junit@yahoogroups.com, &quot;J. B. Rainsberger&quot; &lt;jbrains@r...&gt;\nwrote:\n&gt; cypherfox wrote:\n&gt; &gt; [...deletia: &#39;read message&#39; talks to a persistent mail server...]\n&gt; \n&gt; That depends: if I&#39;m testing whether I can pull a message from an \n&gt; incoming mail server and display it on a screen, I can fake all\nthose \n&gt; things.\n\nIt&#39;s actually just testing that it retrieves the message from the\nserver, and gets the right data, after it&#39;s converted to XML.\n\nAn example of the kind of bug found, my unit tests discovered\nthat I was losing the final CRLF in the data being converted to\nXML after having been written and re-read, because the data\ncame back in LF-only format.  Killer bug?  No.  Good to know?\nYeah, definitely.\n\n&gt; Of course, if you&#39;re testing end-to-end for concurrency purposes,\nthen I \n&gt; agree, and as we&#39;ve seen, that changes everything.\n\nAnd this is another aspect of my tests, albiet one that is\noutside of JUnit&#39;s scope, but achievable with custom mods.\n\n&gt; &gt; Mock objects don&#39;t test the actual networking code, and\n&gt; &gt; require 1.5x the maintenance anyway.  (Interface changes,\n&gt; &gt; especially for code still under heavy development, need to be\n&gt; &gt; propogated not only to the test, but to the mock objects,\n&gt; &gt; constantly.)\n&gt; \n&gt; Even if it&#39;s 50% more maintenance, the tests would run, test what\nyou \n&gt; needed, and be much faster than trying to test message-reading\nlogic \n&gt; against a real mail server. The overall cost is lower!\n\n...but the value of the tests is less certain, because it&#39;s not\ntesting\nthe real logic, and you have to watch out for bugs in the mock\nobjects.  The key comes later, though, because it&#39;s *all* my code,\neffectively.\n\n&gt; &gt; a bug in the top layer that generates a bad host name can\n&gt; &gt; only be caught by the bottom layer actually trying to do\n&gt; &gt; the work.\n&gt; \n&gt; &quot;caught by&quot; or &quot;thrown by&quot;?\n\nHeh, switching between english and code.  Sorry, &#39;caught by&#39; here\nmeans that the bottom Java layer fails to connect, notes (catches,\nsees) the error, and sends back an XML &#39;error&#39; response.\n\n&gt;  I think you mean to say &quot;I won&#39;t know the \n&gt; hostname is bad until I try to use it.&quot; Perhaps. Perhaps another \n&gt; alternative is to check the hostname at startup and generate a log \n&gt; warning or error saying &quot;Could not reach mail server&quot;. That may or\nmay \n&gt; not be a fatal startup error. That may or may not be something\nuseful. \n&gt; I&#39;m just spinning alternatives, here.\n\nTrue, and while there&#39;s logic (for load balancing on the real site)\nthat generates a list of servers, I can lock it to a subset, but this\ndoesn&#39;t test the real world use, again.  I know I&#39;m conflating the\nunit and functional tests again, but since nobody but me is\ngoing to write the functional tests, and I need to be confident\nthat the code is solid when I hand it off to our small, overworked\nQA group.\n\n&gt; &gt; How would you accelerate that, and still allow the\n&gt; &gt; readMessage test to actually test the networking\n&gt; &gt; code?\n&gt; \n&gt; That you can&#39;t do; but then, to test message-reading logic, there&#39;s\nno \n&gt; need to talk to the network.\n\nI admit, I balk at testing the rough equivalent of\n  &#39;foo() { return bar(); }&#39;\nwith\n  &#39;bar() { return &quot;answer&quot;; }&#39;\nand then\n  &#39;assertEquals(foo(), &quot;answer&quot;);&#39;\nIf my messageRead calls to a storage server to get the message,\nthere&#39;s not much conditional logic (as it should be, and barring\nerrors) between the call and the spot that I&#39;d put a mock object\nto return the answer.\n\n&gt; &gt; Passes a request to a persistent IMAP-client thread which\n&gt; &gt; then queries the IMAP server for the message, and returns\n&gt; &gt; it, then its converted to XML.  That&#39;s a broad overview, it\n&gt; &gt; goes through several layers before that including some\n&gt; &gt; authentication, for example.\n&gt; \n&gt; I suppose you&#39;re threading because you don&#39;t want to block on the \n&gt; request for retrieving mail. Does your user actually do anything\nwhile \n&gt; waiting for mail to be retrieved? (If you have freedom to block,\nyou \n&gt; remove a layer of complexity.)\n\nActually, the problem is that this layer is in the middle of an\noutfacing set of load-balanced no-shared-information servers\neach of which take up to 300 connections from a web front end,\nand filter it to a (theoretically smaller) set of threaded queues\nwhich talk to &#39;n&#39; servers on the back end.  As entries are put into\nthe queue to be run, a thread that talks to the IMAP server wakes\nup and processes it, putting the result into a result queue for\nthe front-facing threads to pick up.  It&#39;s a pretty deep system,\nso for me to feel confidence in it, the testing of all levels is\nintensely crucial before I hand off the code.\n\nEffectively it&#39;s translation of IMAP queries to a more friendly\nprotocol for our front-end facing engineers to code to, as well\nas hiding the load balancing, database activities, and XML\ntranslation from them.\n\n&gt; Sure I&#39;m testing all my code. I&#39;m just choosing not to test JDBC at\nthe \n&gt; same time. JDBC works, for the most part; I don&#39;t need to test it.\nI \n&gt; only need to know whether I use it correctly. Don&#39;t test the\nplatform.\n\nUnfortunately, I *am* the platform.  The IMAP server is customized\nwith my modifications which are used by the IMAP client which is\ncompletely implemented by our own engineers (actually, another\nengineer, and totally refactored by me, as it was a quick hack to\ndemo that we could even do it).\n\n&gt; &gt; [...deletia: I don&#39;t like statics...]\n&gt; &gt; those reasons, among others.\n&gt; \n&gt; Class-level data is not a code smell on its own. With greatest love\nand \n&gt; respect, I find that statement utterly ridiculous.\n\nI understand that you, and many others, feel that way.  The problem\nis that anything class-level is inherently dangerous for\nmulti-threaded\napps.  You have to treat static (mutable!) data as a hand grenade, and\ncarefully check the pin every time you touch it.\n\n&gt; If you are on a team that (rightly so) views any use of class-level\ndata \n&gt; as suspicious, and you want to avoid suspicion, I understand; but I \n&gt; would not routinely use that as a reason not to do what needs to be\ndone.\n\nI understand, and I make very sparing use of class-level data,\nbut I always must have a good reason, as it has always been a\ncode smell to me.  Even disregarding the unpleasantness of\nmultithreaded code, every time I&#39;ve removed excessive statics\nfrom my code, the code has gotten better.  I think of them as\nfile-global variables (C++ism) and that gets my hackles up\nquickly.\n\n&gt; &gt; I&#39;m at a loss, I admit.  I need to test reading a message from a\n&gt; &gt; server.  How do I do that, without writing the message to the\n&gt; &gt; server first?  How do I test that the entire code path is working?\n&gt; \n&gt; Test /your/ code, and not the IMAP implementation--unless, of\ncourse, \n&gt; you wrote the IMAP implementation.\n\nWell, we (as a company) did, and I (embarassed admission) don&#39;t\ntotally trust it, even though I&#39;ve massively re-written it.  If I&#39;d\nwritten it from scratch with the interface I&#39;ve put on it, I&#39;d trust\nit,\nbecause I&#39;d have written unit tests for it as I went.  I&#39;ve had to\nback-build unit tests for it, even as I refactored it, and the\nresult is a LOT better, but I sleep better knowing that my tests do\ngo all the way through the process of manipulating the client\nclass.  (Yes, I do know that the red flag of &#39;write more tests for\nthat class!&#39; has been raised with this.  I do whenever I can, but\ntesting the whole stack does a great job of shaking out the\nissues.)\n\n&gt; Even if you did write it, test /that/ \n&gt; on its own, then trust that it works. Hide the IMAP implementation \n&gt; behind an interface, then pretend it isn&#39;t there. If your fake\nbehaves \n&gt; the same way the actual implementation does, then how does its\nclient \n&gt; tell the difference?\n\nThis gets to my Mock question, because if my fake *behaves*\nthe same way, how is it very much less complex than the\nclient + the server together?  That&#39;s the other thread, though.\n\n&gt; &gt; [...deletia: minor local mods to JUnit will work for me...]\n&gt; \n&gt; Then that sounds good.\n&gt; \n&gt; &gt; Silk Performer, Load Runner, and such, are all good tools,\n&gt; &gt; but they are for later in the process.\n&gt; \n&gt; I don&#39;t understand why, but it&#39;s your decision.\n\nBecause those tools automate user interaction, and potentially\nprotocol interaction, not actual API calls.  QA will probably use\nsomething like that for testing the protocol that I expose,\nbut for this I&#39;m trying to test my code, so I feel confident\nthat QA will be able to test the even larger picture.\n\n&gt; Does IntelliJ not make building plugins easy enough? I&#39;m just\nlearning \n&gt; to write Eclipse plugins, myself. It seems a pretty useful skill.\n\nIt probably is, but to reimplement pretty much everything that was\ndone for the JUnit plugin (which comes with it) would be a lot outside\nthe &#39;core competency&#39; of the company I&#39;m working for, and I don&#39;t\nthink they&#39;d buy off on the time.  Entirely political, corporate and\neconomic issues, not technical.  The whole practical vs. theoretical\nthing.\n\n&gt; &gt; Because statics don&#39;t work on a multi-threaded project, and\n&gt; &gt; in order to re-use test knowledge, I want to reuse the storage\n&gt; &gt; test case.\n&gt; \n&gt; Well, you seem to have a decision, and you seem to be ready to move \n&gt; forward. I have to wonder, though: why does a database work on a \n&gt; multithreaded project, but class-level data does not? I&#39;ve seen\nplenty \n&gt; of projects that use multithreading, but nevertheless talk to a \n&gt; database. Or maybe I got it wrong.\n\nA database provides a point of synchronization.  When you talk to\nthe database, the server itself serializes (to some extent) your\nactivity, and manages the concurrency.  With multi-threading,\nirregardless of a database, you have to carefully manage your own\nsynchronization on static variables.  If at all possible, the best\nanswer is to not use class-level data.\n\nThe difference between an external server and an internal class\nvariable is that the external server behaves as a point of\nsynchronization.\n\n&gt; &gt; However, a good point was made, that doing the tests I&#39;m having\n&gt; &gt; trouble with are in the end, more functional than unit, and so not\n&gt; &gt; in the scope of JUnit.  I need this functionality *in* JUnit\n(because\n&gt; &gt; JUnit is supported by my toolchain), in order to do my testing\n&gt; &gt; quickly and easily before I do checkins, but it&#39;s not in the\nmission\n&gt; &gt; of JUnit to do this, so I shouldn&#39;t expect it from the framework.\n&gt; \n&gt; I don&#39;t think you /need/ to do it in JUnit. I think you could\nprobably \n&gt; do it in Ant (say), then run that before checkins. I admit, it\nwould be \n&gt; /nice/ to do it with JUnit, but you may be making work for yourself\nby \n&gt; deciding that it /must/ be that way.\n\nWell, the problem is I&#39;d have to reimplement all the great stuff\nthat&#39;s gone into the JUnit test suite, and THEN add my own\nstuff.  I&#39;m actually optimizing for the least work by adding a little\nsnippet of code to JUnit.\n\nIt&#39;s just that it&#39;s not in keeping with the intent of the framework.\n\n--  Morgan Schweers\n\n\n", 
    "profile": "cypherfox", 
    "topicId": 11495, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 174888704, 
    "prevInTime": 11549, 
    "contentTrasformed": false, 
    "postDate": "1090014866", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 11543, 
    "headers": {
        "inReplyToHeader": "PDQwRjgzMEU0LjQwMTAzMDRAcm9nZXJzLmNvbT4=", 
        "messageIdInHeader": "PGNkOWlxaSt2bTd2QGVHcm91cHMuY29tPg=="
    }
}