{
    "numMessagesInTopic": 7, 
    "nextInTime": 21601, 
    "senderId": "2nRjzshIHly249t-1eRcxWxO8p5RyDPypJx3ZN2Rd1S6io8EYJHe9DyGWhdSC3E4B9xe1fK8L4A4LzyCCocF2R13I6rF5WUf", 
    "systemMessage": false, 
    "subject": "Re: Non-static inner classes of test classes using enclosing fixtures?", 
    "from": "&quot;Paul Holser&quot; &lt;pholser@...&gt;", 
    "authorName": "Paul Holser", 
    "msgSnippet": "Hi JUnit, Regarding my previous post, about the desire to have non-static inner test classes of a test class instantiated and run with an enclosing instance: I", 
    "msgId": 21600, 
    "profile": "pholser", 
    "topicId": 21578, 
    "spamInfo": {
        "reason": "6", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 66805313, 
    "messageBody": "<div id=\"ygrps-yiv-1475663315\">Hi JUnit,<br/>\n<br/>\nRegarding my previous post, about the desire to have non-static inner<br/>\ntest classes of a test class instantiated and run with an enclosing<br/>\ninstance: I found a solution that seems workable. I used JUnit 4.5. It<br/>\ninvolves the following:<br/>\n<br/>\n-- Mark the enclosing (abstract) class as @RunWith(AllTests.class)<br/>\n-- Have the concrete implementing class declare a suite() method which:<br/>\n     -- Instantiates the concrete<br/>\n     -- Instantiates each of the desired inner classes with the concrete<br/>\nas their enclosing instance<br/>\n     -- Wraps the concrete and each of the inners in a<br/>\nJUnit4TestInstanceAdapter (which I created)<br/>\n     -- Adds all the adapted test instances to the suite<br/>\n     -- Returns the suite.<br/>\n<br/>\nI ended up creating a JUnit4TestInstanceAdapter which hangs onto an<br/>\nObject test instance, and uses a BlockJUnit4InstanceRunner (again, my<br/>\nclass) whose createTest() just gives the test instance already created<br/>\nand whose collectInitializationErrors() validates @BeforeClass,<br/>\n@AfterClass, and the instance methods (@Test, @Before, @After). I also<br/>\nended up creating a JUnit4TestInstanceAdapterCache (basically a clone of<br/>\nJUnit4TestAdapterCache) and a JUnit4TestInstanceFacade.<br/>\n<br/>\nNote that I am not creating new instances of the test class and running<br/>\nits befores + test + afters for each -- I really didn&#39;t need that level<br/>\nof isolation, so I was willing to exchange that isolation for finer<br/>\ncontrol of the inner class instantiation.<br/>\n<br/>\nSo, I was able to leverage existing JUnit extension points to accomplish<br/>\nmy goal. I wonder if this would be useful functionality for JUnit to<br/>\nhave in general: when a test class is detected, and that test class has<br/>\nnon-static inner classes which may themselves be test classes, when<br/>\nbuilding up tests for the enclosing class, also instantiate the inner<br/>\ntest classes and attach to the (an?) enclosing test class instance. I<br/>\nsaw some previous discussion about such fixtures in JDave.<br/>\n<br/>\nWhat do you think? Some code from my solution is below.<br/>\n<br/>\nThanks,<br/>\nPaul Holser<br/>\n<br/>\n<br/>\n======<br/>\n<br/>\npublic abstract class UnmodifiableCollectionTestSupport&lt;T&gt; {<br/>\n     protected Collection&lt;T&gt; items;<br/>\n     private T containedItem;<br/>\n<br/>\n     @Before<br/>\n     public final void initializeHarness() {<br/>\n         this.items = newCollection();<br/>\n         this.containedItem = containedItem();<br/>\n         // ...<br/>\n     }<br/>\n<br/>\n     @Test(expected = UnsupportedOperationException.class) {<br/>\n     public final void<br/>\nshouldPreventOperationThatWouldModifyTheCollection() {<br/>\n         // ...<br/>\n     }<br/>\n<br/>\n     // tests...<br/>\n<br/>\n     protected abstract Collection&lt;T&gt; newCollection();<br/>\n<br/>\n     protected abstract T newItem();<br/>\n<br/>\n     protected abstract T containedItem();<br/>\n}<br/>\n<br/>\npublic abstract class UnmodifiableListTestSupport&lt;T&gt; extends<br/>\nUnmodifiableCollectionTestSupport&lt;T&gt; {<br/>\n     // ...<br/>\n}<br/>\n<br/>\n@RunWith(AllTests.class)<br/>\npublic abstract class UnmodifiableMapTestSupport&lt;K, V&gt; {<br/>\n     private Map&lt;K, V&gt; entries;<br/>\n     private K containedKey;<br/>\n     private V containedValue;<br/>\n<br/>\n     @Before<br/>\n     public final void initializeHarness() {<br/>\n         this.entries = newMap();<br/>\n         this.containedKey = containedKey();<br/>\n         this.containedValue = containedValue();<br/>\n         // ...<br/>\n     }<br/>\n<br/>\n     @Test(expected = UnsupportedOperationException.class) {<br/>\n     public final void shouldPreventOperationThatWouldModifyTheMap() {<br/>\n         // ...<br/>\n     }<br/>\n<br/>\n     // tests...<br/>\n<br/>\n     protected abstract Map&lt;K, V&gt; newMap();<br/>\n<br/>\n     protected abstract K newKey();<br/>\n<br/>\n     protected abstract K containedKey();<br/>\n<br/>\n     protected abstract V containedValue();<br/>\n<br/>\n     protected static junit.framework.Test<br/>\nbuildUnmodifiableMapSuite(UnmodifiableMapTestSupport&lt;?, ?&gt; test) {<br/>\n         TestSuite suite = new TestSuite();<br/>\n         suite.addTest(new JUnit4TestInstanceAdapter(test));<br/>\n         suite.addTest(new JUnit4TestInstanceAdapter(test.new<br/>\nKeySetTest()));<br/>\n         suite.addTest(new JUnit4TestInstanceAdapter(test.new<br/>\nValuesTest()));<br/>\n         suite.addTest(new JUnit4TestInstanceAdapter(test.new<br/>\nEntriesTest()));<br/>\n         return suite;<br/>\n     }<br/>\n<br/>\n     class KeySetTest extends UnmodifiableCollectionTestSupport&lt;K&gt; {<br/>\n         @Override protected K containedItem() {<br/>\n             return containedKey;<br/>\n         }<br/>\n<br/>\n         @Override protected Collection&lt;K&gt; newCollection() {<br/>\n             return entries.keySet();<br/>\n         }<br/>\n<br/>\n         @Override protected K newItem() {<br/>\n             return newKey();<br/>\n         }<br/>\n     }<br/>\n<br/>\n     class ValuesTest extends UnmodifiableCollectionTestSupport&lt;V&gt; {<br/>\n         @Override protected V containedItem() {<br/>\n             return containedValue;<br/>\n         }<br/>\n<br/>\n         @Override protected Collection&lt;V&gt; newCollection() {<br/>\n             return entries.values();<br/>\n         }<br/>\n<br/>\n         @Override protected V newItem() {<br/>\n             return null;<br/>\n         }<br/>\n     }<br/>\n<br/>\n     class EntriesTest extends<br/>\nUnmodifiableCollectionTestSupport&lt;Map.Entry&lt;K, V&gt;&gt; {<br/>\n         @Override protected Entry&lt;K, V&gt; containedItem() {<br/>\n             return /* new Map.Entry impl whose key is containedKey and<br/>\nwhose value is containedValue */;<br/>\n         }<br/>\n<br/>\n         @Override protected Collection&lt;Entry&lt;K, V&gt;&gt; newCollection() {<br/>\n             return entries.entrySet();<br/>\n         }<br/>\n<br/>\n         @Override protected Entry&lt;K, V&gt; newItem() {<br/>\n             return null;<br/>\n         }<br/>\n     }<br/>\n}<br/>\n<br/>\n// sample implementor<br/>\npublic class UnmodifiableMapTest extends<br/>\nUnmodifiableMapTestSupport&lt;String, String&gt; {<br/>\n     public static junit.framework.Test suite() {<br/>\n         return UnmodifiableMapTestSupport.buildUnmodifiableMapSuite(new<br/>\nUnmodifiableMapTest());<br/>\n     }<br/>\n<br/>\n     @Override protected String containedKey() {<br/>\n         return &quot;foo&quot;;<br/>\n     }<br/>\n<br/>\n     @Override protected String containedValue() {<br/>\n         return &quot;value&quot;;<br/>\n     }<br/>\n<br/>\n     @Override protected String newKey() {<br/>\n         return &quot;bar&quot;;<br/>\n     }<br/>\n<br/>\n     @Override protected Map&lt;String, String&gt; newMap() {<br/>\n         return<br/>\nCollections.unmodifiableMap(Collections.singletonMap(&quot;foo&quot;, &quot;value&quot;));<br/>\n     }<br/>\n}<br/>\n<br/>\n<blockquote><span title=\"qreply\"> --- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>, David Saff &lt;david@...&gt; wrote:<br/>\n&gt;<br/>\n&gt; Paul,<br/>\n&gt;<br/>\n&gt; Have you looked at Theory support in JUnit &gt; 4.4?  It may not give you<br/>\n&gt; everything you want, but I&#39;d be curious to know how close it gets.<br/>\n&gt; Thanks,<br/>\n&gt;<br/>\n&gt;    David<br/>\n&gt;<br/>\n&gt; On Sat, May 9, 2009 at 1:37 PM, Paul Holser pholser@... wrote:<br/>\n&gt; &gt; Hello JUnit,<br/>\n&gt; &gt;<br/>\n&gt; &gt; I have some abstract classes that enable a caller to check that<br/>\nclasses which expose collection fields via accessor methods do so via<br/>\nthe java.util.Collections#unmodifiable___() facilities.  Here are some<br/>\nsnippets:<br/>\n&gt; &gt;<br/>\n&gt; &gt; public abstract class UnmodifiableCollectionTestSupport&lt;T&gt; {<br/>\n&gt; &gt;    protected Collection&lt;T&gt; items;<br/>\n&gt; &gt;    private T containedItem;<br/>\n&gt; &gt;<br/>\n&gt; &gt;    @Before<br/>\n&gt; &gt;    public final void initializeHarness() {<br/>\n&gt; &gt;        this.items = newCollection();<br/>\n&gt; &gt;        this.containedItem = containedItem();<br/>\n&gt; &gt;<br/>\n&gt; &gt;        assertFalse(&quot;need a non-empty collection&quot;, items.isEmpty());<br/>\n&gt; &gt;        assertTrue(&quot;need an item that is in the collection&quot;,<br/>\nitems.contains(containedItem));<br/>\n&gt; &gt;    }<br/>\n&gt; &gt;<br/>\n&gt; &gt;    @Test(expected = UnsupportedOperationException.class)<br/>\n&gt; &gt;    public final void shouldPreventAdd() {<br/>\n&gt; &gt;        // ...<br/>\n&gt; &gt;    }<br/>\n&gt; &gt;<br/>\n&gt; &gt;    // etc...<br/>\n&gt; &gt;<br/>\n&gt; &gt;    protected abstract Collection&lt;T&gt; newCollection();<br/>\n&gt; &gt;<br/>\n&gt; &gt;    protected abstract T newItem();<br/>\n&gt; &gt;<br/>\n&gt; &gt;    protected abstract T containedItem();<br/>\n&gt; &gt; }<br/>\n&gt; &gt;<br/>\n&gt; &gt; public abstract class UnmodifiableListTestSupport&lt;T&gt; extends<br/>\nUnmodifiableCollectionTestSupport&lt;T&gt; {<br/>\n&gt; &gt;    @Test(expected = UnsupportedOperationException.class)<br/>\n&gt; &gt;    public final void shouldPreventAddAtIndex() {<br/>\n&gt; &gt;        // ...<br/>\n&gt; &gt;    }<br/>\n&gt; &gt;<br/>\n&gt; &gt;    // etc...<br/>\n&gt; &gt;<br/>\n&gt; &gt;    protected final Collection&lt;T&gt; newCollection() {<br/>\n&gt; &gt;        return newList();<br/>\n&gt; &gt;    }<br/>\n&gt; &gt;<br/>\n&gt; &gt;    protected abstract List&lt;T&gt; newList();<br/>\n&gt; &gt;<br/>\n&gt; &gt;    private List&lt;T&gt; list() {<br/>\n&gt; &gt;        return (List&lt;T&gt;) items;<br/>\n&gt; &gt;    }<br/>\n&gt; &gt; }<br/>\n&gt; &gt;<br/>\n&gt; &gt; public class UnmodifiableListTest extends<br/>\nUnmodifiableListTestSupport&lt;String&gt; {<br/>\n&gt; &gt;    @Override<br/>\n&gt; &gt;    protected List&lt;String&gt; newList() {<br/>\n&gt; &gt;        return unmodifiableList(asList(&quot;foo&quot;));<br/>\n&gt; &gt;    }<br/>\n&gt; &gt;<br/>\n&gt; &gt;    protected String newItem() {<br/>\n&gt; &gt;        return &quot;bar&quot;;<br/>\n&gt; &gt;    }<br/>\n&gt; &gt;<br/>\n&gt; &gt;    protected String containedItem() {<br/>\n&gt; &gt;        return &quot;foo&quot;;<br/>\n&gt; &gt;    }<br/>\n&gt; &gt; }<br/>\n&gt; &gt;<br/>\n&gt; &gt; I am imagining an UnmodifiableMapTestSupport abstract class to do<br/>\nsimilar tests for unmodifiable maps:<br/>\n&gt; &gt;<br/>\n&gt; &gt; public abstract class UnmodifiableMapTestSupport&lt;K, V&gt; {<br/>\n&gt; &gt;    private Map&lt;K, V&gt; entries;<br/>\n&gt; &gt;    private K containedKey;<br/>\n&gt; &gt;    private V containedValue;<br/>\n&gt; &gt;<br/>\n&gt; &gt;    @Before<br/>\n&gt; &gt;    public final void initializeHarness() {<br/>\n&gt; &gt;        this.entries = newMap();<br/>\n&gt; &gt;        this.containedKey = containedKey();<br/>\n&gt; &gt;        this.containedValue = containedValue();<br/>\n&gt; &gt;<br/>\n&gt; &gt;        assertFalse(&quot;need a non-empty map&quot;, entries.isEmpty());<br/>\n&gt; &gt;        assertTrue(&quot;need a key that is in the map&quot;,<br/>\nentries.containsKey(containedKey));<br/>\n&gt; &gt;        assertTrue(&quot;need a value that is in the map&quot;,<br/>\nentries.containsValue(containedValue));<br/>\n&gt; &gt;    }<br/>\n&gt; &gt;<br/>\n&gt; &gt;    @Test(expected = UnsupportedOperationException.class)<br/>\n&gt; &gt;    public final void shouldPreventPut() {<br/>\n&gt; &gt;        // ...<br/>\n&gt; &gt;    }<br/>\n&gt; &gt;<br/>\n&gt; &gt;    protected abstract Map&lt;K, V&gt; newMap();<br/>\n&gt; &gt;<br/>\n&gt; &gt;    protected abstract K newKey();<br/>\n&gt; &gt;<br/>\n&gt; &gt;    protected abstract K containedKey();<br/>\n&gt; &gt;<br/>\n&gt; &gt;    protected abstract V containedValue();<br/>\n&gt; &gt; }<br/>\n&gt; &gt;<br/>\n&gt; &gt; Not just would I like to test that a map cannot be modified via its<br/>\nMap methods, but also I would like to test that the map cannot be<br/>\nmutated via the keySet(), values(), and entrySet() views.  It would be<br/>\nreally nice if, when someone subclasses UnmodifiableMapTestSupport, they<br/>\ncould get an Un modifiableCollectionTestSupport&lt;K&gt;,<br/>\nUnmodifiableCollectionTestSupport&lt;V&gt;, and an<br/>\nUnmodifiableCollectionTestSupport&lt;Map.Entry&lt;K, V&gt;&gt; instantiated, run,<br/>\nand result reported on for the keySet(), values(), and entrySet() views<br/>\nof the newMap() result.  Otherwise, they would have to hand-roll three<br/>\nmore concretes of UnmodifiableCollectionTestSupport for testing the<br/>\nkeySet(), values(), and entrySet() views of a given map. </span></blockquote></div>", 
    "prevInTime": 21599, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1242246345", 
    "canDelete": false, 
    "nextInTopic": 21607, 
    "prevInTopic": 21587, 
    "headers": {
        "inReplyToHeader": "PDRmN2RhNmI5MDkwNTExMDgwNnExNGM4ODFlM3ZiN2UxZGVmZWE4Y2MwYzYyQG1haWwuZ21haWwuY29tPg==", 
        "messageIdInHeader": "PGd1ZmFjOSthYnQxQGVHcm91cHMuY29tPg=="
    }
}