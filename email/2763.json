{
    "numMessagesInTopic": 11, 
    "nextInTime": 2764, 
    "senderId": "095GSIqlhGDnpG8Iuj4wlYmKkq_wTARXRxdbUuDyLSPsBhFcJN-NJvI1vXNrcmmACsIW1rZg-i9KKI3Md--eKe_fjEOXRY8Y", 
    "systemMessage": false, 
    "subject": "Re: [junit] Testing SQL: was Test-first paper", 
    "from": "&quot;Steve Freeman&quot; &lt;steve@...&gt;", 
    "authorName": "Steve Freeman", 
    "msgSnippet": "... but there are two things going on here: checking that the right things go into the generated SQL and checking that the SQL is in sync with the schema. In", 
    "msgId": 2763, 
    "topicId": 2739, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 0, 
    "messageBody": "<div id=\"ygrps-yiv-762919852\"><blockquote><span title=\"ireply\">&gt; Surely the only way to test SQL is to use a database. Imagine testing\r<br/>\n&gt; java code by parsing it rather than running it. Maybe CMP EJBs make this\r<br/>\n&gt; a lot easier.\r<br/>\n\r<br/>\n </span></blockquote>but there are two things going on here: checking that the right things go into the generated SQL and checking that the SQL is in sync with the schema. In fact, code generation is an interesting example because the unit tests for the Big Ben tools (which generate test suites) just does some simple string matching -- there are higher level tests to make sure the thing runs.\r<br/>\n\r<br/>\nIn my experience, most dynamic SQL is some static stuff with values, and maybe an extra clause, stuffed in. It may not be worth testing the static stuff during SQL generation, but it is worth gaining enough confidence that the stuffing is working -- and often the minimum working test can be a substring match. I&#39;ve seen effective unit testing of HTML done with regular expressions. \r<br/>\n\r<br/>\nNow the corollary of this is that at some point you have to be sure that it all hangs together (as against hanging seperately...). My suspicion is that most applications of any size end up with a data model layer, which can be sanity checked by a smaller cross-section of integration (or whatever we&#39;re calling them now) tests. It sounds like your approach is to concentrate on more thorough integration tests.\r<br/>\n\r<br/>\nWhat&#39;s the point of the extra tests? \r<br/>\n- we test everything that can break and some things, like forcing exceptions, are very hard to test against a real server. I find that testing with mocks pushes me towards thinking harder about things like error handling.\r<br/>\n- those of us who use them regularly find that the discipline of writing Mock Objects has a good effect on the shape of our code. I&#39;d be loath to give that up.\r<br/>\n- as we discover new classes and factor them out, we can see the tests that go with them and move them too.\r<br/>\n\r<br/>\nSteve</div>", 
    "prevInTime": 2762, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1001535380", 
    "canDelete": false, 
    "nextInTopic": 2769, 
    "prevInTopic": 2762, 
    "headers": {
        "messageIdInHeader": "PDAxMjEwMWMxNDZjOSQ2Y2RkNTU2MCQwMTAwMDA1YUBnYXRld2F5Pg==", 
        "referencesHeader": "PEZQRU5JRktQTkRQR0xOTlBMUExFT0VMT0RCQUEubmVpbC5zd2luZ2xlckBpbmdlbnRhLmNvbT4="
    }
}