{
    "topicId": 2726, 
    "postDate": "1001602358", 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "from": "Eric Vought &lt;evought@...&gt;", 
    "canDelete": false, 
    "replyTo": "LIST", 
    "senderId": "CqC0mWN2jH3HxCD0jO1nZz89CjQ--ajTd1pLrIOYVdPr121sinGM_TZMgFR5zkprz35B3W0ve1nZOhuBWMsQVdwJuXwa", 
    "nextInTime": 2772, 
    "userId": 0, 
    "prevInTime": 2770, 
    "prevInTopic": 2761, 
    "headers": {
        "inReplyToHeader": "PDcwMEVBMTdBMTQyQUQzMTE4QTFFMDAwOEM3MjRCQ0I0RUI3QTBEQGFnYmdudHMwMy5hZ2JnLmludHJhbmV0Pg==", 
        "messageIdInHeader": "PFBpbmUuTE5YLjQuMzAuMDEwOTI2MTMzMzQxMC4yMjMwNS0xMDAwMDBAYnJhaW4ucWx1ZS1sYW4+"
    }, 
    "authorName": "Eric Vought", 
    "numMessagesInTopic": 10, 
    "msgSnippet": "... Ahh.., I had thought of that, but didn t want to make the example too much more complicated so that the technique was clear. Probably the easiest way to do", 
    "contentTrasformed": false, 
    "msgId": 2771, 
    "nextInTopic": 2787, 
    "systemMessage": false, 
    "rawEmail": "Return-Path: &lt;evought@...&gt;\r\nX-Sender: evought@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (EGP: mail-7_4_1); 27 Sep 2001 14:58:37 -0000\r\nReceived: (qmail 26955 invoked from network); 27 Sep 2001 14:58:36 -0000\r\nReceived: from unknown (10.1.10.142)\n  by 10.1.1.220 with QMQP; 27 Sep 2001 14:58:36 -0000\r\nReceived: from unknown (HELO ral.qlue.com) (65.201.137.7)\n  by mta3 with SMTP; 27 Sep 2001 14:59:56 -0000\r\nReceived: from brain.qlue-lan (brain.qlue-lan [192.168.1.28])\n\tby ral.qlue.com (Postfix) with ESMTP id B3DAC1CE39\n\tfor &lt;junit@yahoogroups.com&gt;; Thu, 27 Sep 2001 10:57:42 -0400 (EDT)\r\nDate: Thu, 27 Sep 2001 10:52:38 -0400 (EDT)\r\nTo: &quot;&#39;junit@yahoogroups.com&#39;&quot; &lt;junit@yahoogroups.com&gt;\r\nSubject: Re: [junit] Re: Multithreaded code\r\nIn-Reply-To: &lt;700EA17A142AD3118A1E0008C724BCB4EB7A0D@...&gt;\r\nMessage-ID: &lt;Pine.LNX.4.30.0109261333410.22305-100000@...-lan&gt;\r\nMIME-Version: 1.0\r\nContent-Type: TEXT/PLAIN; charset=US-ASCII\r\nFrom: Eric Vought &lt;evought@...&gt;\r\n\r\nOn Wed, 26 Sep 2001, Emily Bache wrote:\n\n&gt; Thanks Eric for an enlightening reply! The code example you have given is\n&gt; clearly more robust than what I came up with. I&#39;ve added it to my test\n&gt; suite, and (after minor modification to remove typos) it runs and passes,\n&gt; which is great.\n&gt;\n&gt; There is just one thing I&#39;m unsure of - this test proves that while one\n&gt; thread holds the lock on the record, the other thread can find out that it\n&gt; is locked by calling isRecordLocked(). However, the second thread never\n&gt; requests the lock, so it&#39;s not testing that the second thread blocks in the\n&gt; obtainLock() call until the lock becomes available. That was the requirement\n&gt; I was trying to test :-)\n\nAhh.., I had thought of that, but didn&#39;t want to make the example too much\nmore complicated so that the technique was clear. Probably the easiest way\nto do this would be to obtain the lock in the parent thread before the\nchild starts. It&#39;s tricky to prove that something blocked, much easier to\nprove that it did not. The reason is that it&#39;s hard to tell whether a\nthread really blocked or just wasn&#39;t scheduled to run. You have to make\nsure that the thread really would have run otherwise. JDK 1.4 (beta) has a\nholdsLock() or somesuch method which allows you to tell whether a\nparticular thread has a particular lock or not, which allows you to\nsidestep this issue sometimes.\n\nIf you are running in a green threads environment, then a simple yield()\ncall is enough to cause the next equal priority thread to be\nselected in a round-robin fashion. In native thread environments, threads\nare supposed to be scheduled &quot;fairly&quot;, but there is no particular way to\nguarantee that a particular thread (of equal priority) will be scheduled\nat a particular time. Even so, yield() is usually sufficient. That is, if\nthe parent thread yields, and the child thread has not run, then you can\nassume it won&#39;t. In multiprocessing native thread environments, however,\nprocessor affinity might cause things to become rather weird.\n\nThe safest way to force the child to (try to) run then, is to make sure\nits priority is higher than that of the parent thread\nthread.setPriority(). In a green threads environment, a higher priority\nthread shall immediately pre-empt the parent. In a native threads\nenvironment, you&#39;ve done the best you can.\n\n&gt; You picked up on several points I was unsure of how to tackle, though, such\n&gt; as how to make my test code run in a predictable manner by avoiding timing\n&gt; issues, and making the test run as fast as possible by avoiding sleep()\n&gt; statements. I intend to refactor my other tests to use these approaches as\n&gt; far as possible.\n&gt;\n&gt; The other problem I can see is that the test code is far more complicated\n&gt; than the code being tested! (the implementations for obtainLock() and\n&gt; releaseLock() are about 5 lines each) Is that true in general for threaded\n&gt; code? Does there come a point when it is no longer worth testing that it&#39;s\n&gt; correct, and trying instead to in some way prove that it works by inspection\n&gt; and review?\n\nThis is actually typical in my experience. Testing thread code is\nfairly costly. It becomes more so when you realize that you really should\nrun the tests on a broad selection of platforms if you care about\nportability. This is not only an issue of what platforms your customers\nuse or that you want to support today. Even if, for instance, you will\nonly run your code in an EJB server on Solaris (ever), you have to contend\nwith the fact that OS and VM versions will come and go and may choose a\ndifferent mechanism from the large number of permutations the spec allows.\nRunning on multiple platforms helps you ferret out bad assumptions early.\n\nWe maintain a local portability lab with over thirty platform/VM\ncombinations for just this reason. We don&#39;t run tests on all platforms\nevery time, but do choose different subsets. We have different\narchitectures (e.g.: x86, SPARC32, SPARC64, PA/RISC, PowerPC, etc),\ndifferent numbers of processors (1,2, more than 2), different OSs, and\ndifferent VMs.\n\nWe also try to cut the need for this kind of testing whenever we need to.\nWe often find we can bury most of the thread coordination for even a\ncomplex package in just one class. Often, we can get away with using\nbuiltin classes (e.g. the pipe classes in java.io) to avoid writing our\nown thread control code. Where we have to, we try to make the thread\nclasses general utilities so we can get as much as we can out of the high\ncost.\n\nIn many cases, you can get away with good, visual inspection. We seldom\nwrite unit tests to verify synchronized methods, for instance. We will\nspot check parallel access using soak/stress testing, but will not test\nanywhere near exaustively. We tend to find that exception safety is more\nerror prone and focus effort there first. Save the complex test code for\nthread coordination and control (like a job queue or the example you\nstarted with). In our logging API, for instance, we have a single\nEntryQueue class which handles queueing entries for processing, controls\nconcurrent access, synchronous/asynchronous processing, and throttling.\nThis is what we test. The rest of the code we inspect carefully but more\nor less ignore its threading aspects in regression.\n\n-- \nEric Vought\nChief Technical Officer - QLUE Consulting, Inc.\n\nevought@... toll-free: 888-771-3538  RTP area: 919-816-9901\n\n\n\n\n", 
    "subject": "Re: [junit] Re: Multithreaded code"
}