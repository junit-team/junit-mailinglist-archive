{
    "numMessagesInTopic": 23, 
    "nextInTime": 22544, 
    "senderId": "zwBWIVKuX3yD3IrTpD08XsWXwBpUQUp4kEQd5cVgqUeB_hmYk0e_FPo6K8_xAq5GGfwXAB8dJv0r2G3KkA9REFtA", 
    "systemMessage": false, 
    "subject": "Re: [junit] Re: @DataPoints called several times for Theories", 
    "from": "David Saff &lt;david@...&gt;", 
    "authorName": "David Saff", 
    "msgSnippet": "After further thought, the ParameterSupplier class is even better for this kind of thing: public abstract class ParameterSupplier { public abstract", 
    "msgId": 22543, 
    "profile": "dsaff", 
    "topicId": 22425, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 341876227, 
    "messageBody": "<div id=\"ygrps-yiv-377036157\">After further thought, the ParameterSupplier class is even better for<br/>\nthis kind of thing:<br/>\n<br/>\npublic abstract class ParameterSupplier {<br/>\n\tpublic abstract List&lt;PotentialAssignment&gt;<br/>\ngetValueSources(ParameterSignature sig);<br/>\n}<br/>\n<br/>\nThus:<br/>\n<br/>\n@RunWith(Theories.class)<br/>\n  public class TestMutable {<br/>\n<br/>\n  @DataSupplier public static OneTypeSupplier&lt;Mutable&gt; copyMutable =<br/>\nCopies.of(new Mutable());<br/>\n<br/>\n   //...<br/>\n}<br/>\n<br/>\nThis would allow a supplier to supply zero, one, or many inputs to a<br/>\nparameter signature.  Here&#39;s a supplier for all ints from -10 to 10:<br/>\n<br/>\n@DataSupplier public static OneTypeSupplier&lt;Integer&gt; ints =<br/>\nInts.between(-10, 10);<br/>\n<br/>\nHere&#39;s one that supplies null for any type that can take them:<br/>\n<br/>\n@DataSupplier public static ParameterSupplier nullsEverywhere =<br/>\nNulls.forAllObjectTypes();<br/>\n<br/>\nAnd something crazy and experimental that will keep pumping out values<br/>\nuntil half a second has passed:<br/>\n<br/>\n@DataSupplier public static ParameterSupplier timeLimited =<br/>\nExploreValueSpace.timeLimitedMillis(500);<br/>\n<br/>\n(This one would require the return type from<br/>\nParameterSupplier#getValueSources to be Iterable, which I think would<br/>\nbe a good idea anyway)<br/>\n<br/>\nAnd one that combines many other suppliers, for easy sharing &#39;twixt<br/>\ntest classes:<br/>\n<br/>\n@DataSupplier public static ParameterSupplier combined = new<br/>\nComboSupplier(timeLimited, nullsEverywhere, ints, copyMutable);<br/>\n<br/>\nThus, in another class:<br/>\n<br/>\n@DataSupplier public static ParameterSupplied reused = FirstClass.combined;<br/>\n<br/>\nThis begins to approach the &quot;Rule&quot; threshhold for triggering a lot of<br/>\nvery plausible ideas with only small changes to interface and<br/>\nimplementation.  Shin, Sang, would you like to recast your patch to<br/>\ninclude this interface contribution?<br/>\n<br/>\n   David Saff<br/>\n<br/>\n@RunWith(Theories.class)<br/>\n<blockquote><span title=\"qreply\"> &gt;   public class TestMutable {<br/>\n&gt;<br/>\n&gt;   @DataPointSource public static PotentialAssignment&lt;Mutable&gt; =<br/>\n&gt; Copy.ofMutable(new Mutable());<br/>\nOn Sun, Mar 14, 2010 at 11:29 PM, David Saff &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:david@...\">david@...</a>&gt; wrote:<br/>\n&gt; Brett,<br/>\n&gt;<br/>\n&gt; If developer 1 needs a fresh data point created every time, and<br/>\n&gt; developer 2 needs to re-use an expensive-to-create immutable data<br/>\n&gt; point, I definitely want to make it as easy as possible for both to do<br/>\n&gt; what they need to do.  Just to be clear, do you agree the below would<br/>\n&gt; work with the current implementation of Theories?  It&#39;s four lines<br/>\n&gt; more of boilerplate, but not totally intractable, in my humble<br/>\n&gt; opinion:<br/>\n&gt;<br/>\n&gt;  @RunWith(Theories.class)<br/>\n&gt;   public class TestMutable {<br/>\n&gt;<br/>\n&gt;   private static Mutable createdOnce = new Mutable();<br/>\n&gt;<br/>\n&gt;   @DataPoint<br/>\n&gt;   public static Mutable mutable() {<br/>\n&gt;     return Copy.copy(createdOnce);<br/>\n&gt;   }<br/>\n&gt;<br/>\n&gt;   @Theory<br/>\n&gt;   public static testMutate(Mutable a) {<br/>\n&gt;     a.mutate();<br/>\n&gt;   }<br/>\n&gt;<br/>\n&gt;   @Theory<br/>\n&gt;   public static testNotMutated(Mutable a) {<br/>\n&gt;     assertFalse(a.isMutated());<br/>\n&gt;   }<br/>\n&gt;  }<br/>\n&gt;<br/>\n&gt; I think though, that requiring both the field and the method to be<br/>\n&gt; there in the class could restrict the ability to share data and<br/>\n&gt; concepts.  What would you think of allowing fields or methods to<br/>\n&gt; return PontentialAssignment, the type of named references to data<br/>\n&gt; values used in the Theories runner?  Then we could have:<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;  @RunWith(Theories.class)<br/>\n&gt;   public class TestMutable {<br/>\n&gt;<br/>\n&gt;   @DataPointSource public static PotentialAssignment&lt;Mutable&gt; =<br/>\n&gt; Copy.ofMutable(new Mutable());<br/>\n&gt;<br/>\n&gt;   @Theory<br/>\n&gt;   public static testMutate(Mutable a) {<br/>\n&gt;     a.mutate();<br/>\n&gt;   }<br/>\n&gt;<br/>\n&gt;   @Theory<br/>\n&gt;   public static testNotMutated(Mutable a) {<br/>\n&gt;     assertFalse(a.isMutated());<br/>\n&gt;   }<br/>\n&gt;  }<br/>\n&gt;<br/>\n&gt; Here, I&#39;m guessing about the typing on PotentialAssignment and the<br/>\n&gt; name of the DataPointSource annotation, but perhaps the idea is clear?<br/>\n&gt;<br/>\n&gt;   David Saff<br/>\n&gt;<br/>\n&gt; On Fri, Mar 12, 2010 at 6:44 PM, Brett Daniel &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:brettdaniel@...\">brettdaniel@...</a>&gt; wrote:<br/>\n&gt;&gt; The undergrads I am advising recently pushed a patch that addresses the<br/>\n&gt;&gt; issue of mutable data points.<br/>\n&gt;&gt;<br/>\n&gt;&gt;<br/>\n&gt;&gt; <a rel=\"nofollow\" target=\"_blank\" href=\"http://github.com/stan6/junit/commit/dcfa3c41446c469a4edc7513e9e7a9b610b04020\">http://github.com/stan6/junit/commit/dcfa3c41446c469a4edc7513e9e7a9b610b04020</a><br/>\n&gt;&gt;<br/>\n&gt;&gt; The patch allows developers to define &quot;copy strategies&quot; that duplicate<br/>\n&gt;&gt; marked data points before every theory execution. In this way, every<br/>\n&gt;&gt; execution receives a pristine data point, which removes the problems caused<br/>\n&gt;&gt; when a theory mutates data points. This is orthogonal to datapoint<br/>\n&gt;&gt; (re)creation, but I think copy strategies may help address the bug that<br/>\n&gt;&gt; Berin found.<br/>\n&gt;&gt;<br/>\n&gt;&gt; The patch creates a new, optional &quot;copyStrategy&quot; parameter for the<br/>\n&gt;&gt; @DataPoint and @DataPoints annotations. If the developer wants to copy data<br/>\n&gt;&gt; points, he or she sets the parameter to a class implementing a new<br/>\n&gt;&gt; CopyStrategy interface.<br/>\n&gt;&gt;<br/>\n&gt;&gt; Here is an example:<br/>\n&gt;&gt;<br/>\n&gt;&gt;  @RunWith(Theories.class)<br/>\n&gt;&gt;    public class TestMutable {<br/>\n&gt;&gt;<br/>\n&gt;&gt;    @DataPoint(copyStrategy = MutableWithCopyStrategy.class)<br/>\n&gt;&gt;    public static Mutable mutable = new Mutable();<br/>\n&gt;&gt;<br/>\n&gt;&gt;    @Theory<br/>\n&gt;&gt;    public static testMutate(Mutable a) {<br/>\n&gt;&gt;      a.mutate();<br/>\n&gt;&gt;    }<br/>\n&gt;&gt;<br/>\n&gt;&gt;    @Theory<br/>\n&gt;&gt;    public static testNotMutated(Mutable a) {<br/>\n&gt;&gt;      assertFalse(a.isMutated());<br/>\n&gt;&gt;    }<br/>\n&gt;&gt;  }<br/>\n&gt;&gt;<br/>\n&gt;&gt; In the current implementation of JUnit, the second theory may fail because<br/>\n&gt;&gt; the first theory mutates the datapoint. With a copy strategy enabled, both<br/>\n&gt;&gt; theories receive a new value.<br/>\n&gt;&gt;<br/>\n&gt;&gt; Strategies can do almost anything: clone the data point, call a factory<br/>\n&gt;&gt; method, or--as in the following implementation--instantaiate a new object<br/>\n&gt;&gt; with a copy constructor.<br/>\n&gt;&gt;<br/>\n&gt;&gt;  public class MutableWithCopyStrategy implements CopyStrategy {<br/>\n&gt;&gt;    public Object copyDataPoint(Object toCopy) throws Exception {<br/>\n&gt;&gt;      return new Mutable((Mutable)toCopy);<br/>\n&gt;&gt;    }<br/>\n&gt;&gt;  }<br/>\n&gt;&gt;<br/>\n&gt;&gt; There are several benefits to this implementation. First, the new parameter<br/>\n&gt;&gt; is completely optional; if it is omitted, the theory runner behaves as it<br/>\n&gt;&gt; always has. Second, it doesn&#39;t require modifying the data point&#39;s class (for<br/>\n&gt;&gt; example, to add a copy constructor or clone method). Most importantly, it<br/>\n&gt;&gt; makes it clear to the tester that without a copy strategy one theory<br/>\n&gt;&gt; execution can impact another.<br/>\n&gt;&gt;<br/>\n&gt;&gt; I have CC&#39;d the two students in this email. Please direct any questions to<br/>\n&gt;&gt; them.<br/>\n&gt;&gt;<br/>\n&gt;&gt; Brett<br/>\n&gt;&gt;<br/>\n&gt;&gt; On Thu, Feb 18, 2010 at 5:28 PM, Berin &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:berin.loritsch@...\">berin.loritsch@...</a>&gt; wrote:<br/>\n&gt;&gt;<br/>\n&gt;&gt;&gt;<br/>\n&gt;&gt;&gt;<br/>\n&gt;&gt;&gt; I agree with your prognosis, about fresh data points for testing the<br/>\n&gt;&gt;&gt; theories. That is precisely why I proposed reading them once, and cloning<br/>\n&gt;&gt;&gt; them (making a copy) as needed for each theory. With that approach we even<br/>\n&gt;&gt;&gt; get the protection from mutated data points when you use the @DataPoint to<br/>\n&gt;&gt;&gt; mark a static field.<br/>\n&gt;&gt;&gt;<br/>\n&gt;&gt;&gt; Cloning is a much quicker operation, does not execute any constructors. It<br/>\n&gt;&gt;&gt; merely copies the contents of the object memory verbatim.<br/>\n&gt;&gt;&gt;<br/>\n&gt;&gt;&gt; With the current implementation, if you are not prepared for the<br/>\n&gt;&gt;&gt; combinatorial affect of 60 data points combined with 60 data points for each<br/>\n&gt;&gt;&gt; theory there is a major disconnect. The majority of the overhead in this<br/>\n&gt;&gt;&gt; particular scenario has to do with creating objects (with the additional<br/>\n&gt;&gt;&gt; overhead of doing it by reflection).<br/>\n&gt;&gt;&gt;<br/>\n&gt;&gt;&gt; When I created only one instance of each class instead of two, the<br/>\n&gt;&gt;&gt; performance was twice as fast (i.e. 37 seconds down to about 16 seconds).<br/>\n&gt;&gt;&gt;<br/>\n&gt;&gt;&gt; Essentially the number of times your @DataPoints method is called depends<br/>\n&gt;&gt;&gt; on the number of parameters in your @Theory and how many theories you have.<br/>\n&gt;&gt;&gt; Essentially the formula for my theory (ha, ha) of the execution is like<br/>\n&gt;&gt;&gt; this:<br/>\n&gt;&gt;&gt;<br/>\n&gt;&gt;&gt; N^(p-1) + 1<br/>\n&gt;&gt;&gt;<br/>\n&gt;&gt;&gt; where:<br/>\n&gt;&gt;&gt;<br/>\n&gt;&gt;&gt; N is the number of data points returned by the method<br/>\n&gt;&gt;&gt; p is the number of parameters<br/>\n&gt;&gt;&gt; and the + 1 represents the run where the data point is read the first time<br/>\n&gt;&gt;&gt;<br/>\n&gt;&gt;&gt; So for 60 data points it is run 61 times for two parameters. With three<br/>\n&gt;&gt;&gt; parameters it would be called 3601 times. I have to verify with three<br/>\n&gt;&gt;&gt; parameters. The theory is called N^p times for sure and that is expected.<br/>\n&gt;&gt;&gt;<br/>\n&gt;&gt;&gt; With the above formula, the mapping of number of calls to parameters for 60<br/>\n&gt;&gt;&gt; data points would be:<br/>\n&gt;&gt;&gt;<br/>\n&gt;&gt;&gt; 1 -&gt; 2 (I know this is wrong which gives me doubts on the formula)<br/>\n&gt;&gt;&gt; 2 -&gt; 61<br/>\n&gt;&gt;&gt; 3 -&gt; 3601<br/>\n&gt;&gt;&gt; 3 -&gt; 216001<br/>\n&gt;&gt;&gt;<br/>\n&gt;&gt;&gt; Essentially when the Assignments class needs to make the combinations, it<br/>\n&gt;&gt;&gt; will collect the data points initially for each theory. It then calls the<br/>\n&gt;&gt;&gt; data points again for each existing data point it collected from the first<br/>\n&gt;&gt;&gt; read. With a third parameter it would take all those combinations again, to<br/>\n&gt;&gt;&gt; add all the permutations for the next round.<br/>\n&gt;&gt;&gt;<br/>\n&gt;&gt;&gt; I might be wrong and the real formula would be like this:<br/>\n&gt;&gt;&gt;<br/>\n&gt;&gt;&gt; N^0 + N^1 ... + N^(p-1)<br/>\n&gt;&gt;&gt;<br/>\n&gt;&gt;&gt; If this is the correct formula, then if you have 60 data points the number<br/>\n&gt;&gt;&gt; of times the method is called would map to the number of parameters like<br/>\n&gt;&gt;&gt; this:<br/>\n&gt;&gt;&gt;<br/>\n&gt;&gt;&gt; 1 -&gt; 1<br/>\n&gt;&gt;&gt; 2 -&gt; 61<br/>\n&gt;&gt;&gt; 3 -&gt; 3661<br/>\n&gt;&gt;&gt; 4 -&gt; 219661<br/>\n&gt;&gt;&gt;<br/>\n&gt;&gt;&gt;<br/>\n&gt;&gt;&gt; --- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a> &lt;junit%40yahoogroups.com&gt;, Brett Daniel<br/>\n&gt;&gt;&gt; &lt;brettdaniel@...&gt; wrote:<br/>\n&gt;&gt;&gt; &gt;<br/>\n&gt;&gt;&gt; &gt; Berin,<br/>\n&gt;&gt;&gt; &gt;<br/>\n&gt;&gt;&gt; &gt; When a theory mutates data points, it might be beneficial to recreate<br/>\n&gt;&gt;&gt; &gt; the data point for every theory invocation. Doing so prevents one<br/>\n&gt;&gt;&gt; &gt; theory execution from affecting others. I wrote about this issue in<br/>\n&gt;&gt;&gt; &gt; the following weblog post:<br/>\n&gt;&gt;&gt; &gt;<br/>\n&gt;&gt;&gt; &gt; <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.brettdaniel.com/archives/2009/09/24/200845/\">http://www.brettdaniel.com/archives/2009/09/24/200845/</a><br/>\n&gt;&gt;&gt; &gt;<br/>\n&gt;&gt;&gt; &gt; You are correct, though, that copying would avoid some of the overhead<br/>\n&gt;&gt;&gt; &gt; in calling datapoint methods. It is interesting you mention this idea,<br/>\n&gt;&gt;&gt; &gt; because I am currently overseeing two students who for their senior<br/>\n&gt;&gt;&gt; &gt; thesis project are implementing framework for copying datapoints. I<br/>\n&gt;&gt;&gt; &gt; will post more information to the mailing list as the project<br/>\n&gt;&gt;&gt; &gt; continues.<br/>\n&gt;&gt;&gt; &gt;<br/>\n&gt;&gt;&gt; &gt; Brett<br/>\n&gt;&gt;&gt; &gt;<br/>\n&gt;&gt;&gt;<br/>\n&gt;&gt;&gt;<br/>\n&gt;&gt;&gt;<br/>\n&gt;&gt;<br/>\n&gt;&gt;<br/>\n&gt;&gt; [Non-text portions of this message have been removed]<br/>\n&gt;&gt;<br/>\n&gt;&gt;<br/>\n&gt;&gt;<br/>\n&gt;&gt; ------------------------------------<br/>\n&gt;&gt;<br/>\n&gt;&gt; Yahoo! Groups Links<br/>\n&gt;&gt;<br/>\n&gt;&gt;<br/>\n&gt;&gt;<br/>\n&gt;&gt;<br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 22542, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1268625315", 
    "canDelete": false, 
    "nextInTopic": 22544, 
    "prevInTopic": 22542, 
    "headers": {
        "inReplyToHeader": "PDRmN2RhNmI5MTAwMzE0MjAyOXQ0MzM2MzNkY2kzNDhjN2RhNjM5ZGFkMTBAbWFpbC5nbWFpbC5jb20+", 
        "messageIdInHeader": "PDRmN2RhNmI5MTAwMzE0MjA1NWo4NGEwZmF3NTU5OTQ3NjgwOGY2MTQyNUBtYWlsLmdtYWlsLmNvbT4=", 
        "referencesHeader": "PDU4ZGJhMjI1MTAwMjE4MDk0M3EyMzhkZDhkdjExYWI0ODczNjMyMWUxNzhAbWFpbC5nbWFpbC5jb20+CSA8aGxraWYyKzNtdGVAZUdyb3Vwcy5jb20+CSA8NThkYmEyMjUxMDAzMTIxNTQ0cDNjZDdkZDI4aDFhODk5Y2U2NTdmNjZhZDNAbWFpbC5nbWFpbC5jb20+CSA8NGY3ZGE2YjkxMDAzMTQyMDI5dDQzMzYzM2RjaTM0OGM3ZGE2MzlkYWQxMEBtYWlsLmdtYWlsLmNvbT4="
    }
}