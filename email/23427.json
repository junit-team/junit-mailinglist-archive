{
    "numMessagesInTopic": 3, 
    "nextInTime": 23428, 
    "senderId": "E0KQSRmUe6J1WR6magqQF3ODVloP81ldgi9qLaNpJcrILRwnhhgAV99zheqr5uM6M0kX6v-1Veqp_HjNOaiu-FI8_sTZg8X-v48", 
    "systemMessage": false, 
    "subject": "Re: [junit] Testing for Spring MVC Portlet", 
    "from": "Alistair Israel &lt;aisrael@...&gt;", 
    "authorName": "Alistair Israel", 
    "msgSnippet": "... Whether using Spring 2.x or 3.x, unit testing MVC controllers shouldn t be that hard. This is a testament to the highly decoupled design of the Spring", 
    "msgId": 23427, 
    "profile": "aisrael", 
    "topicId": 23426, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 190140219, 
    "messageBody": "<div id=\"ygrps-yiv-915006734\">On Wed, May 25, 2011 at 7:06 PM, adeithzya &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:adeithzya@...\">adeithzya@...</a>&gt; wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; I&#39;ve setup a project for portlet using Spring MVC Portlet application. Now I need to add testing capabilites using JUnit, my<br/>\n&gt; goal is so I don&#39;t need to deploy every time I make some changes e.g in the Controller.<br/>\n<br/>\n </span></blockquote>Whether using Spring 2.x or 3.x, unit testing MVC controllers<br/>\nshouldn&#39;t be that hard. This is a testament to the highly decoupled<br/>\ndesign of the Spring framework.  In Spring 3.x, they take<br/>\nnon-intrusiveness even further by relying heavily on annotations and<br/>\nletting you use POJOs wherever possible.<br/>\n<br/>\nIn general, you just need to write a JUnit test class that&#39;ll perform<br/>\nthe responsibilities of the Spring container and provide test<br/>\nscaffolding for your controller&#39;s dependencies. Now, if you follow the<br/>\nprinciple of &quot;design by contract&quot; (also evident throughout the Spring<br/>\nframework) then your controller should be depending upon interfaces,<br/>\nnot concrete classes.<br/>\n<br/>\nIf so, then personally I prefer mocking those dependency interfaces at<br/>\ntest time (using a convenient mocking framework such as Mockito). To a<br/>\nlarge extent you can still mock concrete classes but using actual<br/>\ndependencies usually introduces transitive dependencies which just<br/>\nmakes your test scaffolding more complicated or bloated.<br/>\n<br/>\nAs a general example, take a 2.x SimpleFormController that calls an<br/>\nEJB to update an entity.<br/>\n1. Mock the EJB interface<br/>\n2. Instantiate the controller<br/>\n3. Supply the mock to the controller<br/>\n4. Mock the request & response parameters<br/>\n5. Call doSubmitAction()<br/>\n6. Verify that the proper ModelAndView are returned<br/>\n7. Verify that the mock EJB&#39;s update method was called with the proper<br/>\nparameters<br/>\n<br/>\nLike I said, Spring 2.5.x and above simplifies the above greatly by<br/>\nletting you call your controller methods directly with the actual<br/>\nparameters they&#39;ll need (you don&#39;t have to mock the request or<br/>\nresponse interfaces).<br/>\n<br/>\nWithout specifics as to your controllers, forms and views then this is<br/>\nas much as I can give you. Hope this helps!<br/>\n<br/>\n- alistair<br/>\n--<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://alistairisrael.wordpress.com\">http://alistairisrael.wordpress.com</a></div>", 
    "prevInTime": 23426, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1306464459", 
    "canDelete": false, 
    "nextInTopic": 23428, 
    "prevInTopic": 23426, 
    "headers": {
        "inReplyToHeader": "PGlyaW5yZCthbXFqQGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PEJBTkxrVGlreG16bURHPXhwWWdXVXY1dHY4UXR2U2dNX3FnQG1haWwuZ21haWwuY29tPg==", 
        "referencesHeader": "PGlyaW5yZCthbXFqQGVHcm91cHMuY29tPg=="
    }
}