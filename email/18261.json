{
    "numMessagesInTopic": 45, 
    "nextInTime": 18262, 
    "senderId": "ABn5cRCaggPPhRfmQR779KqF7Tf4OwAcSLx1ls-xmGSPysEMhnkp5vA__I-BluG3P4qzAv3paocGK38CqaBSHS-wZOba-0p3nWiXetzg", 
    "systemMessage": true, 
    "subject": "Re: Can anyone help me see how to usefully work with JUnit in a big project, please?", 
    "from": "&quot;Tracey Annison&quot; &lt;TAnnison@...&gt;", 
    "authorName": "Tracey Annison", 
    "msgSnippet": "... that it can ... so small ... is ... each of ... should also ... architecture ... totally miss ... with a ... object ... but I ... general ... Well, this IS", 
    "msgId": 18261, 
    "profile": "traceyannison", 
    "topicId": 18213, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 132563212, 
    "messageBody": "<div id=\"ygrps-yiv-1507593877\">--- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>, &quot;CÃ©dric Beust â&quot; &quot; &lt;cbeust@...&gt; wrote:<br/>\n<blockquote><span title=\"ireply\"> &gt; I have no doubt that TDD works great on such simple problems and <br/>\n </span></blockquote>that it can<br/>\n<blockquote><span title=\"ireply\"> &gt; even lead to a reasonable design.  Then again, the problem space is <br/>\n </span></blockquote>so small<br/>\n<blockquote><span title=\"ireply\"> &gt; that you can argue that no design will really be wrong anyway...<br/>\n&gt; <br/>\n&gt; Now consider a more realistic example, such as an application that <br/>\n </span></blockquote>is<br/>\n<blockquote><span title=\"ireply\"> &gt; dealing with five database tables, each with four to ten columns, <br/>\n </span></blockquote>each of<br/>\n<blockquote><span title=\"ireply\"> &gt; which needs to be mapped to Java objects in a sensible way (i.e. not<br/>\n&gt; necessarily mapping the tables and the objects one-to-one) and <br/>\n </span></blockquote>should also<br/>\n<blockquote><span title=\"ireply\"> &gt; include business methods and objects to make it easier to perform<br/>\n&gt; domain-specific operations.<br/>\n&gt; <br/>\n&gt; Using TDD to drive such a design is guaranteed to lead to an <br/>\n </span></blockquote>architecture<br/>\n<blockquote><span title=\"ireply\"> &gt; that will be focused on solving micro-problems and that will <br/>\n </span></blockquote>totally miss<br/>\n<blockquote><span title=\"ireply\"> &gt; the big picture.  You are much better off spending a few minutes <br/>\n </span></blockquote>with a<br/>\n<blockquote><span title=\"ireply\"> &gt; piece of paper or a white board to design your classes and your <br/>\n </span></blockquote>object<br/>\n<blockquote><span title=\"ireply\"> &gt; diagram.<br/>\n&gt; <br/>\n&gt; If you want to use TDD to implement this model after that, fine, <br/>\n </span></blockquote>but I<br/>\n<blockquote><span title=\"ireply\"> &gt; really dispute the idea that TDD should drive the design in the <br/>\n </span></blockquote>general<br/>\n<blockquote><span title=\"ireply\"> &gt; case, because TDD simply never gives you the big picture.<br/>\n&gt; <br/>\n&gt; Makes sense?<br/>\n&gt; <br/>\n&gt; -- <br/>\n&gt; Cédric<br/>\n&gt; <a rel=\"nofollow\" target=\"_blank\" href=\"http://testng.org\">http://testng.org</a><br/>\n<br/>\n </span></blockquote>Well, this IS the sort of application we&#39;re working on, except that <br/>\nthere&#39;s more like 50 tables, some of which have over 150 columns. And <br/>\nwe did draw out a digram of how the objects were going to be, and how <br/>\nthey&#39;d relate to one another. This IS working, and is comprehensible <br/>\nand proving to be a good structure to build on.<br/>\n<br/>\nNow, we did talk about TDD, as we&#39;d heard that this was an effective <br/>\nway of working. But for the life of me I can&#39;t see how you actually <br/>\ndo it in practice! I can do it on paper - laying down what I expect <br/>\nfrom what I&#39;m building. <br/>\nBut practically, I can&#39;t write such a test as a Java class in Eclipse <br/>\nwithout it failing to compile and thus breaking our automatic build <br/>\nprocedures. The things I want to test don&#39;t exist yet! And to use <br/>\nJMocks then I&#39;d need to define all the ins & outs of the exact method <br/>\nnames & so on, and even then it wouldn&#39;t even run & give me a &quot;real&quot; <br/>\nfailure &#39;cos it&#39;d complain that it&#39;s trying to mock something that <br/>\nisn&#39;t there... <br/>\n<br/>\nSo I don&#39;t see how you can write a test class that has failing tests <br/>\nthat move over to passing tests as you write the code, (as I see TDD <br/>\nasking for) when the thing you&#39;re testing doesn&#39;t exist yet. I guess <br/>\nyou could code in all the skeleton of the class, with the methods & <br/>\nsuch (though this won&#39;t compile unless you really do return what you <br/>\nsay you will), then write the tests, then add the rest of the code. <br/>\nBut I don&#39;t see the great advantage of that, to be honest...<br/>\n<br/>\nCheers<br/>\nTracey</div>", 
    "prevInTime": 18260, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1162202417", 
    "canDelete": false, 
    "nextInTopic": 18262, 
    "prevInTopic": 18260, 
    "headers": {
        "inReplyToHeader": "PGI4NmI2YTljMDYxMDI4MTAzNHA2Y2I2MGViYnFhMGY3MTI1MmNjMjJhOTJhQG1haWwuZ21haWwuY29tPg==", 
        "messageIdInHeader": "PGVpNGlmaCtkcDkyQGVHcm91cHMuY29tPg=="
    }
}