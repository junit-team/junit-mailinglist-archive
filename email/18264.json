{
    "numMessagesInTopic": 45, 
    "nextInTime": 18265, 
    "senderId": "EjB2XdaHZsGGxb5Sej_DYX6MiT9psvpXqdGZis7NDtErtlayCWUdDQX6RWL8xIYSlqQ1I-le8qk5R0VxZVY0QW0bmUvJ-L0fOCwgZ6h7", 
    "systemMessage": true, 
    "subject": "Re: Can anyone help me see how to usefully work with JUnit in a big project, please?", 
    "from": "&quot;Tracey Annison&quot; &lt;TAnnison@...&gt;", 
    "authorName": "Tracey Annison", 
    "msgSnippet": "Well, I ve been discussing all your comments with my colleagues, and I m planning to try changing things in the next piece of work I m now starting. I ll try", 
    "msgId": 18264, 
    "profile": "traceyannison", 
    "topicId": 18213, 
    "spamInfo": {
        "reason": "6", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 132563212, 
    "messageBody": "<div id=\"ygrps-yiv-720934364\">Well, I&#39;ve been discussing all your comments with my colleagues, and <br/>\nI&#39;m planning to try changing things in the next piece of work I&#39;m now <br/>\nstarting. I&#39;ll try extracting out code that &quot;doesn&#39;t belong&quot; into other <br/>\nclasses, and refactoring the big methods into smaller, more testable <br/>\nchunks, and so on. I think that doing this in even one or two classes <br/>\nmay well cut down on a lot of the testing, and a lot of the Mocking, <br/>\ntoo. Thanks everyone for your help on this!<br/>\n<br/>\n<br/>\nBut I was also thinking about how we are using mocks and JMock... <br/>\nUsing this tool demands that you define how each of the methods called <br/>\non a mocked object behave. For a given method, you define what it will <br/>\nreturn, and specify that you expect it to be called once, or twice, or <br/>\nthat you don&#39;t care if it&#39;s called or not, and say what parameters you <br/>\nexpect. <br/>\nSo, from the JUnit point of view, this means that we can test what will <br/>\nhappen if the mock&#39;s method returns null, or an exception, or the thing <br/>\nwe expect, and so on. Whis is good, &#39;cos to get to this result <br/>\notherwise could be hard, especially if it&#39;s a database you&#39;re talking <br/>\nto.<br/>\nBut the other point of this, as I understand it, is to test that the <br/>\nroute you&#39;re taking through your code is the one you expect to take. <br/>\nNow, this is where some of the complexity comes in, because you have to <br/>\ndefine all the mock&#39;s method behaviour to support this, and even <br/>\nrelatively minor changes to the code can hit this hard. The mock&#39;s <br/>\nmethod name has changed, or you moved some code which doesn&#39;t need to <br/>\nget executed in case of an exception, or.... and so on. The result of <br/>\nthe method you&#39;re testing is the same, but how you did it has changed. <br/>\nSo the tests fail, as the methods you were expecting on the mock object <br/>\nnow aren&#39;t called, and other ones are.<br/>\n<br/>\nSo, is this kind of testing important enough to warrant all the effort <br/>\nit takes to write & keep up to date? <br/>\nShould we care what method got called on our mock, or even whether it <br/>\ndid get called at all? Or are we really only interested in the result <br/>\nof the main method we&#39;re testing?<br/>\n<br/>\nCheers, <br/>\nTracey</div>", 
    "prevInTime": 18263, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1162204175", 
    "canDelete": false, 
    "nextInTopic": 18266, 
    "prevInTopic": 18263, 
    "headers": {
        "inReplyToHeader": "PGVobmRhdCtxM2NjQGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PGVpNGs2ZitzaXIxQGVHcm91cHMuY29tPg=="
    }
}