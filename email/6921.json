{
    "numMessagesInTopic": 17, 
    "nextInTime": 6922, 
    "senderId": "CxRtjhHGrO189OGKMBcsNSh--avga44rnjWPy3cu6Ru6ZqKdLGUmxrUtGaG8n5GnkMRWJuw1KQ4CvnyMiluhcGUGIm3Bn6PScKcxFLUe_Q", 
    "systemMessage": false, 
    "subject": "Re: [junit] Testability", 
    "from": "&quot;Scott Stirling&quot; &lt;scottstirling@...&gt;", 
    "authorName": "Scott Stirling", 
    "msgSnippet": "... My point was only that with Beck s TDD methodology, you get 100% statement coverage every time (in theory).  I never said anything to suggest that I ", 
    "msgId": 6921, 
    "profile": "jrun5", 
    "topicId": 6863, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 112036634, 
    "messageBody": "<div id=\"ygrps-yiv-554535304\">--- Curt Sampson &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:yahoo_sucks@...\">yahoo_sucks@...</a>&gt; wrote:<br/>\n<blockquote><span title=\"ireply\"> &gt; Yes, Kent Beck indeed did say, &quot;TDD followed<br/>\n&gt; religiously should result in 100% statement<br/>\n&gt; coverage.&quot; But on the other hand, the sentence<br/>\n&gt; before that in his TDD book is &quot;Statement coverage<br/>\n&gt; is certainly not a sufficient measure of test<br/>\n&gt; quality, but it is a starting place.&quot; If you<br/>\n&gt; look at the chapter on method/class scope testing in<br/>\n&gt; Binder&#39;s _Testing Object Oriented Systems_, you&#39;ll<br/>\n&gt; find that having meerly full statement coverage is<br/>\n&gt; pretty poor test quality indeed.<br/>\n<br/>\n </span></blockquote>My point was only that with Beck&#39;s TDD methodology, you get 100% statement<br/>\ncoverage every time (in theory).  I never said anything to suggest that I<br/>\nthought this was sufficient coverage did I?  I am a great fan of Binder&#39;s<br/>\nbook, and I agree with your point, although in my experience, 100% statement<br/>\ncoverage would be pretty good, because I have yet to work on a project<br/>\nthat&#39;s had it.  I&#39;ve brought code coverage analysis to the last two<br/>\ncompanies I worked for (both multi-million dollar companies producing<br/>\nJ2EE-related products), and the reality in my experience is that unit<br/>\ntesting and code coverage analysis adoption still has a ways to go in the<br/>\nreal world.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; If you&#39;re looking just at a coverage metric, I&#39;d say<br/>\n&gt; you want at least full coverage of branches.<br/>\n<br/>\n </span></blockquote>And I&#39;d say that&#39;d be nice.  But 100% statement coverage would also be nice,<br/>\nand I have yet to see that happen.  Note: sure, I&#39;ve seen packages and lots<br/>\nof classes get 100% statement, method and (mostly in simple cases) branch<br/>\ncoverage, but not whole codebases and applications.  So far I&#39;ve been<br/>\ninvolved in projects of around 200,000 lines of Java code, where I&#39;ve been<br/>\nlucky to get developers to write more than a handful of unit tests.  Do you<br/>\nknow how much code never gets tested because it&#39;s dead, unused code (DUC)?<br/>\nIt&#39;s not easy to root out and remove DUC unless you have cooperative<br/>\ndevelopers willing to investigate based on the coverage reports, and you<br/>\nhave reasonable assurance that your tests are covering all the functional<br/>\nrequirements of the product (thereby making uncovered code DUC, pretty much<br/>\nby definition).<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; But then again, Kent Beck also said, on page 115/6<br/>\n&gt; of _Extreme Programming Explained_, &quot;So you should<br/>\n&gt; write the tests that help get programs working and<br/>\n&gt; keep programs working. Nothing more.&quot;<br/>\n<br/>\n </span></blockquote>Sure, and the corollary is that by doing this, you write just enough code to<br/>\nmake the program work and nothing more.  Again, no DUC because the developer<br/>\nthought this method might be needed someday . . . or because these methods<br/>\nwere copied and pasted from somewhere else.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; In the end, it really depends on the consequences of<br/>\n&gt; failure. In most of the systems I build, the consequence<br/>\n&gt; of failure is a stack exception appearing on the screen<br/>\n&gt; and a slightly troubled user. No big deal if<br/>\n&gt; that happens once in a while; I just find, fix and<br/>\n&gt; roll out a new release.<br/>\n<br/>\n </span></blockquote>But in an expensive commercial product it is a very big deal to roll out a<br/>\nnew release and cannot be done quite so offhandedly.  But I understand your<br/>\nperspective.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; On the other hand, if I had an embedded system that<br/>\n&gt; was going to be mass-produced, where a new release<br/>\n&gt; is extremely expensive, I&#39;d spend a lot more money<br/>\n&gt; and time testing.<br/>\n<br/>\n </span></blockquote>Right.  This is also true of app servers and high-visibility corporate<br/>\napplications.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Actually, I see it as relying on my judgement that<br/>\n&gt; it&#39;s cheaper to deal with the rare failures in that<br/>\n&gt; area when they happen than it is to spend<br/>\n&gt; the money and time for more comprehensive test<br/>\n&gt; coverage.<br/>\n<br/>\n </span></blockquote>Ahh.  Yes, clearly the scope, importance, visibility and nature of the<br/>\napplication has factors important for deciding the risk and worth of<br/>\ntesting.  As do internal process factors such as, do you have to produce a<br/>\ncode coverage report or bug entry/fix statistics to upper management?  We<br/>\nare in different environments, it sounds like.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; &gt; So why are we arguing such different strategies<br/>\n&gt; &gt; for solving the problem of &quot;testability?&quot;<br/>\n&gt;<br/>\n&gt; Because we&#39;re costing it out differently. That&#39;s<br/>\n&gt; all.<br/>\n<br/>\n </span></blockquote>Yes.  Although I think the disagreements have led to interesting theoretical<br/>\npoints about OO design, the underpinnings of TDD, and the meaning of<br/>\n&quot;testability,&quot; which is where I&#39;m glad this discussion has led.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; &gt; Put another way, I wonder the same thing about any<br/>\n&gt; &gt; behavior added to an object.  Testing is not a<br/>\n&gt; &gt; behavior of most objects.<br/>\n&gt;<br/>\n&gt; Well, this perhaps a point of disagreement. I think<br/>\n&gt; that testing is a potential behaviour of every object<br/>\n&gt; I write.<br/>\n<br/>\n </span></blockquote>Interesting.  Some of my thinking has led to a similar thought, and a<br/>\nquestion: like Serializable, Runnable, Cloneable, etc. I have been toying<br/>\nwith what a Testable interface could do.  What would it be like to<br/>\nidiomaticize Testability as a marker interface in Java?<br/>\n<br/>\nOne idea is that &quot;implements Testable&quot; could mean that a runtime flag could<br/>\nbe used to enable/disable a set of test methods (a la JUnit&#39;s test****<br/>\nmethod naming pattern) in classes.  Just a thought.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; &gt; It seems the best way to build and test a<br/>\n&gt; &gt; finite-state machine is to make the inputs<br/>\n&gt; &gt; and outputs explicit, and to make the state<br/>\n&gt; &gt; transitions step-wise and traceable.<br/>\n&gt;<br/>\n&gt; I would consider that to be modifying an object,<br/>\n&gt; beyond its overt function, to make it more testable.<br/>\n<br/>\n </span></blockquote>What I am arguing is that this is exactly what TDD does by only building<br/>\ntestable objects.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; If you didn&#39;t have to test the object, because you<br/>\n&gt; always wrote perfect code, would you bother exposing<br/>\n&gt; the state-wide transitions?<br/>\n<br/>\n </span></blockquote>Good question.  My first thought is that if I could do that, why write code<br/>\nat all?  I would just write binary and dispense with OOP altogether.  Second<br/>\nthought is that &quot;perfect&quot; in the context of OOP must entail more than just<br/>\nfunctional perfection, e.g., things such as ease of understanding and reuse<br/>\nfor other human beings.<br/>\n<br/>\nScott Stirling<br/>\nFramingham, MA</div>", 
    "prevInTime": 6920, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1044830967", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 6913, 
    "headers": {
        "messageIdInHeader": "PEtJRUhJQklPQkFFTEpBSElQTkhETUVBQUNQQUEuc2NvdHRzdGlybGluZ0ByY24uY29tPg=="
    }
}