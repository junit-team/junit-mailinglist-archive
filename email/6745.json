{
    "numMessagesInTopic": 7, 
    "nextInTime": 6746, 
    "senderId": "IBJ_7wiKKlfTzl7suDBlowUrD_VWHjCTUuRuwqMZCqZmjMYtrlHD4t8ZNEMbRpXLILoCvY-A0LV3F8ZWKhbFDqiwAQbOHDlb7cp2QybmllOXYqkw", 
    "systemMessage": false, 
    "subject": "Re: [junit] Tests naming", 
    "from": "&quot;J. B. Rainsberger&quot; &lt;jbr@...&gt;", 
    "authorName": "J. B. Rainsberger", 
    "msgSnippet": "Kirill!  ... be ... Usually there are three kinds of flows: 1. The usual flow 2. Alternate usual flows 3. Error flows I use the term use case", 
    "msgId": 6745, 
    "profile": "nails762", 
    "topicId": 6735, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 89240252, 
    "messageBody": "<div id=\"ygrps-yiv-223382621\">Kirill!<br/>\n<br/>\n&lt;snip /&gt;<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt;&gt; Generally there is one test per use case scenario (different flow<br/>\n&gt;&gt;&gt; through the use case). Choosing to write more or fewer tests should<br/>\n </span></blockquote>be<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt;&gt; done thoughtfully.<br/>\n&gt;&gt;<br/>\n&gt;&gt; In my experience, there are several alternative flows for a ordinary<br/>\n&gt;&gt; use case. And I see reasonable to test at least two of them: basic<br/>\n&gt;&gt; flow and error flow. What do you think?<br/>\n<br/>\n </span></blockquote>Usually there are three kinds of flows:<br/>\n<br/>\n1. The usual flow<br/>\n2. Alternate usual flows<br/>\n3. Error flows<br/>\n<br/>\nI use the term &quot;use case scenario&quot; to mean a path through a use case<br/>\nwith many flows. Each &quot;flow&quot; is a use case scenario. I believe that<br/>\nthis is the standard UML term. When I say &quot;use case scenario&quot;, it is<br/>\nnow clear what I mean.<br/>\n<br/>\nGenerally, the goal is to write one Customer Test per use case<br/>\nscenario. There may even be additional tests, depending on the number<br/>\nof different representative data points along the way.<br/>\n<br/>\nI prioritize as follows:<br/>\n<br/>\n1. Usual flow test<br/>\n2. Fatal error flow tests<br/>\n3. Normal alternative flow tests<br/>\n4. Non-fatal error flow tests<br/>\n5. Others<br/>\n<br/>\nIf there are, for example, 20 scenarios for a use case, then I need to<br/>\nsit down and decide whether the use case is too big.<br/>\n<br/>\n <br/>\n<blockquote><span title=\"ireply\"> &gt;&gt;&gt; &gt; - each test scenario is placed into single class with appropriate<br/>\n&gt;&gt;&gt; name.<br/>\n&gt;&gt;&gt; <br/>\n&gt;&gt;&gt; Each use case scenario is a test. Test classes should almost always<br/>\n&gt;&gt;&gt; evolve based around a fixture, not some other arbitrary<br/>\n </span></blockquote>organization<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt;&gt; mechanism. A given use case may be implemented as its own Customer<br/>\n </span></blockquote>Test<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt;&gt; class, but it is usually better to let the organization of tests<br/>\n </span></blockquote>into<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt;&gt; TestCase implementations depend on shared fixture requirements.<br/>\n&gt;&gt;<br/>\n&gt;&gt; But we can share fixtures using inheritance as well. I have two<br/>\n </span></blockquote>points<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt;here:<br/>\n&gt;&gt;<br/>\n&gt;&gt; - for a complicated test case it may be better to keep it in a<br/>\n </span></blockquote>separate<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt;class.<br/>\n&gt;&gt; - It is easier to get full list of existing functional tests if we<br/>\n </span></blockquote>put<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt; each test case into a single class. Getting the list is quite usual<br/>\n&gt;&gt; task requested by QA department or customer (or I&#39;m wrong here?)<br/>\n<br/>\n </span></blockquote>Certainly this is a good idea. There must be a way to present the list<br/>\nof currently-implemented Customer Tests to groups like QA. Dividing the<br/>\ntests among classes is one way to achieve this. Some kind of xDoclet<br/>\nthing would be another. (Step in, Mr. Gemkow, to provide some<br/>\ninformation here.)<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt;&gt; &gt;2. For Unit tests:<br/>\n&gt;&gt;&gt; &gt; - test package shall be the same as for the production code, <br/>\n&gt;&gt;&gt; &gt; but it is better to use a different source tree.<br/>\n&gt;&gt;&gt; &gt; - for simple classes (such as value objects) it is OK to name<br/>\n&gt;&gt;&gt; &gt; test classes after the name of the class under test <br/>\n&gt;&gt;&gt; &gt; (like UTestFooBar or FooBarTest). Names of test methods,<br/>\n&gt;&gt;&gt; &gt; in its turn, may include the name of the tested method.<br/>\n&gt;&gt;&gt; &gt; - for complex classes, which require a complex fixture to be set,<br/>\n&gt;&gt;&gt; &gt; test case class shall be named using fixture description. <br/>\n&gt;&gt;&gt; &gt; (The issue was discussed previously on this list).<br/>\n&gt;&gt;&gt; &gt; Test method name in this case shall describe the tested<br/>\n </span></blockquote>behaviour.<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt;&gt; <br/>\n&gt;&gt;&gt; The last point is the general case, and the previous points are<br/>\n </span></blockquote>special<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt;&gt; cases when the tests (not the code under test) are very simple.<br/>\n&gt;&gt;<br/>\n&gt;&gt; Agreed. The issue here is to fugure out proper fixture class when<br/>\n </span></blockquote>you <br/>\n<blockquote><span title=\"ireply\"> &gt;&gt; want to add a new test (for instance, when you find a bug). The task<br/>\n<br/>\n&gt;&gt; may become more complicated if you never seen the code before and<br/>\n </span></blockquote>there<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt; are nobody to ask (bad things happen). I see two possible solutions:<br/>\n&gt;&gt;<br/>\n&gt;&gt; - Use IDE features to find usages of tested code (if you have such<br/>\n </span></blockquote>IDE)<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt; - Make a error in the production code and see which test breaks.<br/>\n<br/>\n </span></blockquote>If you cannot figure out where to add the new test, then you can find<br/>\nthe test that breaks by breaking the production code; however, that<br/>\nassumes that you know what production code you need to change in order<br/>\nto add the feature. This may not be the case, and certainly is not<br/>\nalways (often?) the case when test-driving the new feature.<br/>\n<br/>\nIf I am in that situation and I cannot find a test fixture to match my<br/>\ncurrent needs, then I build a new one and let the team refactor it as<br/>\nthey come across it. Eventually, someone will feel the pain of not<br/>\nhaving the right test fixture and will find the problem.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt;&gt; &gt;3. For Integration Tests:<br/>\n&gt;&gt;&gt; &gt; - I suggest, names of Integration tests must differ from Unit<br/>\n&gt;&gt;&gt; tests.<br/>\n&gt;&gt;&gt; &gt; Usually, integration tests run longer, and consequently, more<br/>\n&gt;&gt;&gt; seldom. <br/>\n&gt;&gt;&gt; &gt; That&#39;s why it is convinient to name them differently. One may<br/>\n </span></blockquote>name<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt;&gt; <br/>\n&gt;&gt;&gt; &gt; unit tests using UTest prefix, anf Integration tests using ITest<br/>\n&gt;&gt;&gt; &gt;prefix.<br/>\n&gt;&gt;&gt; <br/>\n&gt;&gt;&gt; On a past project, we used tag interfaces to distinguish Programmer<br/>\n&gt;&gt;&gt; Tests from Customer Tests. This made it easy to write a TestRunner<br/>\n </span></blockquote>that<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt;&gt; picked one or the other or both when building a test suite. You may<br/>\n&gt;&gt;&gt; find this technique useful.<br/>\n&gt;&gt;<br/>\n&gt;&gt; I saw an article where static variable with specific value was used <br/>\n&gt;&gt; to mark a test and TestSuite class used reflection to include only <br/>\n&gt;&gt; tests with specific value of the variable. It is quite close to your<br/>\n&gt;&gt; approach.<br/>\n&gt;&gt;<br/>\n&gt;&gt; What for me, I use ant to build/run my test suites. That&#39;s why I <br/>\n&gt;&gt; suggest class naming approach.<br/>\n<br/>\n </span></blockquote>Certainly a class naming convention works very well with Ant&#39;s<br/>\nJUnit:batchtest task.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt;&gt; Also, place the different kinds of tests in different packages in<br/>\n </span></blockquote>order<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt;&gt; to reduce the number of naming collisions.<br/>\n&gt;&gt;<br/>\n&gt;&gt; Sorry, I don&#39;t see your point clearly. Are you talking about unit<br/>\n </span></blockquote>tests,<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt; functional tests?<br/>\n<br/>\n </span></blockquote>Yes. :)<br/>\n<br/>\nI mean place CTs in one package and PTs in another.<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt;&gt;&gt; I have to say that your list of points is excellent and should be<br/>\n&gt;&gt;&gt; turned into a short article on the subject.<br/>\n&gt;&gt;<br/>\n&gt;&gt; Thank you very much. Actually, I thought about it and I&#39;ll possibly<br/>\n&gt;&gt; try to write one.<br/>\n<br/>\n </span></blockquote>I am more than willing to edit it, if you need some help.<br/>\n<br/>\nTake care.<br/>\n<br/>\n<br/>\nJ. B. Rainsberger,<br/>\nPresident, Diaspar Software Services<br/>\nLet&#39;s write software that people understand.<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.diasparsoftware.com/\">http://www.diasparsoftware.com/</a><br/>\ntelephone: +1 416 791-8603<br/>\nAll correspondence (c) 2002 Diaspar Software Services.<br/>\nIf you want to use it, just ask; don&#39;t steal.</div>", 
    "prevInTime": 6744, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1043611356", 
    "canDelete": false, 
    "nextInTopic": 6753, 
    "prevInTopic": 6741, 
    "headers": {
        "inReplyToHeader": "PDIwMDMwMTI2MTAwMDI4LkdBNjI3OEBxdWVlbi5hY3RpbWluZC5jb20+", 
        "messageIdInHeader": "PDIwMDMwMTI2MTUwMjM2MDIxOS4wMDdEQTM1QkBzbXRwLnltLnBodWIubmV0LmNhYmxlLnJvZ2Vycy5jb20+", 
        "referencesHeader": "PDIwMDMwMTI1MTk0OTAyLkdBMTIzMjlAcXVlZW4uYWN0aW1pbmQuY29tPiA8MjAwMzAxMjUxNTA0NDkwMzMxLjAxMTBBMEIzQHNtdHAueW0ucGh1Yi5uZXQuY2FibGUucm9nZXJzLmNvbT4gPDIwMDMwMTI2MTAwMDI4LkdBNjI3OEBxdWVlbi5hY3RpbWluZC5jb20+"
    }
}