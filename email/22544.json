{
    "numMessagesInTopic": 23, 
    "nextInTime": 22545, 
    "senderId": "YPf-AgngxzOTqd9g6Mk9vZbtusi1Ss01i6FoPegtSvRjJXIhXwPhJygLPgrOFiEJu2NCviY063Rjih8QENFU-FYoG_ht3mMJa9B0Ol7TWYoZf6xwNK4S", 
    "systemMessage": false, 
    "subject": "RE: [junit] Re: @DataPoints called several times for Theories", 
    "from": "&quot;Loritsch, Berin C.&quot; &lt;berin.loritsch@...&gt;", 
    "authorName": "Loritsch, Berin C.", 
    "msgSnippet": "My initial post had to do with performance due to the complexity of collecting the datapoints multiple times.  The solution I suggested was to have the class", 
    "msgId": 22544, 
    "profile": "bloritsch", 
    "topicId": 22425, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 428096731, 
    "messageBody": "<div id=\"ygrps-yiv-1033730472\">My initial post had to do with performance due to the complexity of collecting the datapoints multiple times.  The solution I suggested was to have the class collect the datapoints once, and then copy the datapoints as needed.<br/>\n <br/>\nSo it looks as if the patch may solve that part of the issue.  I&#39;ll have to look into the strategies as they are listed.  I hope we are not introducing an interface or base class that would be required for the data classes to implement.  That would cause problems with using Theories to test interface contracts.<br/>\n<br/>\n________________________________<br/>\n<br/>\nFrom: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a> on behalf of Brett Daniel<br/>\nSent: Fri 3/12/2010 6:44 PM<br/>\nTo: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a><br/>\nCc: Shin Hwei Tan; Sang Y Baik<br/>\nSubject: Re: [junit] Re: @DataPoints called several times for Theories<br/>\n<br/>\n<br/>\n  <br/>\n<br/>\nThe undergrads I am advising recently pushed a patch that addresses the<br/>\nissue of mutable data points.<br/>\n<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://github.com/stan6/junit/commit/dcfa3c41446c469a4edc7513e9e7a9b610b04020\">http://github.com/stan6/junit/commit/dcfa3c41446c469a4edc7513e9e7a9b610b04020</a> &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"http://github.com/stan6/junit/commit/dcfa3c41446c469a4edc7513e9e7a9b610b04020\">http://github.com/stan6/junit/commit/dcfa3c41446c469a4edc7513e9e7a9b610b04020</a>&gt; <br/>\n<br/>\nThe patch allows developers to define &quot;copy strategies&quot; that duplicate<br/>\nmarked data points before every theory execution. In this way, every<br/>\nexecution receives a pristine data point, which removes the problems caused<br/>\nwhen a theory mutates data points. This is orthogonal to datapoint<br/>\n(re)creation, but I think copy strategies may help address the bug that<br/>\nBerin found.<br/>\n<br/>\nThe patch creates a new, optional &quot;copyStrategy&quot; parameter for the<br/>\n@DataPoint and @DataPoints annotations. If the developer wants to copy data<br/>\npoints, he or she sets the parameter to a class implementing a new<br/>\nCopyStrategy interface.<br/>\n<br/>\nHere is an example:<br/>\n<br/>\n@RunWith(Theories.class)<br/>\npublic class TestMutable {<br/>\n<br/>\n@DataPoint(copyStrategy = MutableWithCopyStrategy.class)<br/>\npublic static Mutable mutable = new Mutable();<br/>\n<br/>\n@Theory<br/>\npublic static testMutate(Mutable a) {<br/>\na.mutate();<br/>\n}<br/>\n<br/>\n@Theory<br/>\npublic static testNotMutated(Mutable a) {<br/>\nassertFalse(a.isMutated());<br/>\n}<br/>\n}<br/>\n<br/>\nIn the current implementation of JUnit, the second theory may fail because<br/>\nthe first theory mutates the datapoint. With a copy strategy enabled, both<br/>\ntheories receive a new value.<br/>\n<br/>\nStrategies can do almost anything: clone the data point, call a factory<br/>\nmethod, or--as in the following implementation--instantaiate a new object<br/>\nwith a copy constructor.<br/>\n<br/>\npublic class MutableWithCopyStrategy implements CopyStrategy {<br/>\npublic Object copyDataPoint(Object toCopy) throws Exception {<br/>\nreturn new Mutable((Mutable)toCopy);<br/>\n}<br/>\n}<br/>\n<br/>\nThere are several benefits to this implementation. First, the new parameter<br/>\nis completely optional; if it is omitted, the theory runner behaves as it<br/>\nalways has. Second, it doesn&#39;t require modifying the data point&#39;s class (for<br/>\nexample, to add a copy constructor or clone method). Most importantly, it<br/>\nmakes it clear to the tester that without a copy strategy one theory<br/>\nexecution can impact another.<br/>\n<br/>\nI have CC&#39;d the two students in this email. Please direct any questions to<br/>\nthem.<br/>\n<br/>\nBrett<br/>\n<br/>\n<blockquote><span title=\"qreply\"> On Thu, Feb 18, 2010 at 5:28 PM, Berin &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:berin.loritsch@...\">berin.loritsch@...</a> &lt;mailto:berin.loritsch%40gd-ais.com&gt; &gt; wrote:<br/>\n<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; I agree with your prognosis, about fresh data points for testing the<br/>\n&gt; theories. That is precisely why I proposed reading them once, and cloning<br/>\n&gt; them (making a copy) as needed for each theory. With that approach we even<br/>\n&gt; get the protection from mutated data points when you use the @DataPoint to<br/>\n&gt; mark a static field.<br/>\n&gt;<br/>\n&gt; Cloning is a much quicker operation, does not execute any constructors. It<br/>\n&gt; merely copies the contents of the object memory verbatim.<br/>\n&gt;<br/>\n&gt; With the current implementation, if you are not prepared for the<br/>\n&gt; combinatorial affect of 60 data points combined with 60 data points for each<br/>\n&gt; theory there is a major disconnect. The majority of the overhead in this<br/>\n&gt; particular scenario has to do with creating objects (with the additional<br/>\n&gt; overhead of doing it by reflection).<br/>\n&gt;<br/>\n&gt; When I created only one instance of each class instead of two, the<br/>\n&gt; performance was twice as fast (i.e. 37 seconds down to about 16 seconds).<br/>\n&gt;<br/>\n&gt; Essentially the number of times your @DataPoints method is called depends<br/>\n&gt; on the number of parameters in your @Theory and how many theories you have.<br/>\n&gt; Essentially the formula for my theory (ha, ha) of the execution is like<br/>\n&gt; this:<br/>\n&gt;<br/>\n&gt; N^(p-1) + 1<br/>\n&gt;<br/>\n&gt; where:<br/>\n&gt;<br/>\n&gt; N is the number of data points returned by the method<br/>\n&gt; p is the number of parameters<br/>\n&gt; and the + 1 represents the run where the data point is read the first time<br/>\n&gt;<br/>\n&gt; So for 60 data points it is run 61 times for two parameters. With three<br/>\n&gt; parameters it would be called 3601 times. I have to verify with three<br/>\n&gt; parameters. The theory is called N^p times for sure and that is expected.<br/>\n&gt;<br/>\n&gt; With the above formula, the mapping of number of calls to parameters for 60<br/>\n&gt; data points would be:<br/>\n&gt;<br/>\n&gt; 1 -&gt; 2 (I know this is wrong which gives me doubts on the formula)<br/>\n&gt; 2 -&gt; 61<br/>\n&gt; 3 -&gt; 3601<br/>\n&gt; 3 -&gt; 216001<br/>\n&gt;<br/>\n&gt; Essentially when the Assignments class needs to make the combinations, it<br/>\n&gt; will collect the data points initially for each theory. It then calls the<br/>\n&gt; data points again for each existing data point it collected from the first<br/>\n&gt; read. With a third parameter it would take all those combinations again, to<br/>\n&gt; add all the permutations for the next round.<br/>\n&gt;<br/>\n&gt; I might be wrong and the real formula would be like this:<br/>\n&gt;<br/>\n&gt; N^0 + N^1 ... + N^(p-1)<br/>\n&gt;<br/>\n&gt; If this is the correct formula, then if you have 60 data points the number<br/>\n&gt; of times the method is called would map to the number of parameters like<br/>\n&gt; this:<br/>\n&gt;<br/>\n&gt; 1 -&gt; 1<br/>\n&gt; 2 -&gt; 61<br/>\n&gt; 3 -&gt; 3661<br/>\n&gt; 4 -&gt; 219661<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; --- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a> &lt;mailto:junit%40yahoogroups.com&gt;  &lt;junit%40yahoogroups.com&gt;, Brett Daniel<br/>\n&gt; &lt;brettdaniel@...&gt; wrote:<br/>\n&gt; &gt;<br/>\n&gt; &gt; Berin,<br/>\n&gt; &gt;<br/>\n&gt; &gt; When a theory mutates data points, it might be beneficial to recreate<br/>\n&gt; &gt; the data point for every theory invocation. Doing so prevents one<br/>\n&gt; &gt; theory execution from affecting others. I wrote about this issue in<br/>\n&gt; &gt; the following weblog post:<br/>\n&gt; &gt;<br/>\n&gt; &gt; <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.brettdaniel.com/archives/2009/09/24/200845/\">http://www.brettdaniel.com/archives/2009/09/24/200845/</a> &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.brettdaniel.com/archives/2009/09/24/200845/\">http://www.brettdaniel.com/archives/2009/09/24/200845/</a>&gt; <br/>\n&gt; &gt;<br/>\n&gt; &gt; You are correct, though, that copying would avoid some of the overhead<br/>\n&gt; &gt; in calling datapoint methods. It is interesting you mention this idea,<br/>\n&gt; &gt; because I am currently overseeing two students who for their senior<br/>\n&gt; &gt; thesis project are implementing framework for copying datapoints. I<br/>\n&gt; &gt; will post more information to the mailing list as the project<br/>\n&gt; &gt; continues.<br/>\n&gt; &gt;<br/>\n&gt; &gt; Brett<br/>\n&gt; &gt;<br/>\n&gt;<br/>\n&gt; <br/>\n&gt;<br/>\n<br/>\n[Non-text portions of this message have been removed]<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n[Non-text portions of this message have been removed] </span></blockquote></div>", 
    "prevInTime": 22543, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1268657613", 
    "canDelete": false, 
    "nextInTopic": 22545, 
    "prevInTopic": 22543, 
    "headers": {
        "messageIdInHeader": "PDc1RjVFRDhBNUE1NTM2NDZBNDZFMDBFNkVDODU0RkEzMDM3OEM3RTNAdmFmZjAxLW1haWwwMS5hZC5nZC1haXMuY29tPg==", 
        "referencesHeader": "PDU4ZGJhMjI1MTAwMjE4MDk0M3EyMzhkZDhkdjExYWI0ODczNjMyMWUxNzhAbWFpbC5nbWFpbC5jb20+PGhsa2lmMiszbXRlQGVHcm91cHMuY29tPiA8NThkYmEyMjUxMDAzMTIxNTQ0cDNjZDdkZDI4aDFhODk5Y2U2NTdmNjZhZDNAbWFpbC5nbWFpbC5jb20+"
    }
}