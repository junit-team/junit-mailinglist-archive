{
    "numMessagesInTopic": 2, 
    "nextInTime": 97, 
    "senderId": "o9--mES6laJb2VEVkpv7vdI2BWwGvhnSijWZSFDgYhqSia6a8tj5ESa5nlCj3RY_1kj5aV_kT6BIUKCPj1nbm5U8txJVV1ns_xUinNvR6w", 
    "systemMessage": false, 
    "subject": "RE: [junit] xUnit testing of distributed systems", 
    "from": "&quot;Jim Jackl-Mochel&quot; &lt;jmochel@...&gt;", 
    "authorName": "Jim Jackl-Mochel", 
    "msgSnippet": "There always seems to be one configuration or set of classes that takes up the majority of the test bed work. When I am testing distributed classes there are", 
    "msgId": 96, 
    "topicId": 95, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 0, 
    "messageBody": "<div id=\"ygrps-yiv-2096208579\">There always seems to be one configuration or set of classes that takes<br/>\nup the majority of the test bed work. When I am testing distributed classes<br/>\nthere are few additional things I do beyond the usual testing for regular<br/>\nclasses.<br/>\n<br/>\nMy basic testing regimen for most classes is:<br/>\n(The original ideas for these are stolen from a book on testing Object<br/>\nOriented<br/>\nClasses that I read so long ago I don&#39;t even remember who the author was.)<br/>\n<br/>\nFunctionality to be tested:<br/>\n<br/>\nConstructors<br/>\nDestructors<br/>\nAccessors/Mutators AKA Properties<br/>\nCommon or Core Methods (things like persistence, assignment operators)<br/>\nKey Methods (The reason we wrote the class in the first case...)<br/>\n<br/>\nTypes of tests to be conducted:<br/>\n<br/>\nTests for Basic Functionality<br/>\nTests for Boundary Functionality<br/>\nTests for Beyond Boundary Functionality<br/>\nTests for Destructive Functionality<br/>\n<br/>\n<br/>\n<br/>\nWhen I am testing distributed applications I add the following:<br/>\n<br/>\nTests for Proof of Existence.<br/>\n-----------------------------<br/>\nProof of existence demonstrates that a feature has been minimally<br/>\nimplemented.<br/>\n<br/>\nWith the possibility of mismatches between proxy code, idl, type libraries,<br/>\nand remote servers it makes sense to test for the basic existence<br/>\nof properties and methods. It provides a base test of the connection code as<br/>\nwell.<br/>\n<br/>\n<br/>\nOther kinds of testing:<br/>\n<br/>\nFor the kind of event driven system you are talking about I would<br/>\ntypically produce an event generator that kicks out a series of events and<br/>\nassociated<br/>\ndata in an order than makes sense. It takes some work but it is well worth<br/>\nit.<br/>\n<br/>\nIn addition I would use the event generator to do a specific type of testing<br/>\nfor<br/>\nthe kind of &quot;protocol&quot; you are talking about. It is called short tour<br/>\ntesting<br/>\nand is excellent for pounding on a state retaining protocol (an FSM) so that<br/>\nit correctly recovers from mis-sequenced communications and such.<br/>\n<br/>\nThe basic math for this comes from : &quot;Design and Validation of Computer<br/>\nProtocols&quot;<br/>\nby Holzmann. I first saw it in an article in C++ Journal or JOOPS about 5-6<br/>\nyears ago.<br/>\nThe basic theory is that for any complex sequence of events and data that<br/>\ncause a<br/>\nmisbehaviour you can usually reproduce that problem using a short (~3-5<br/>\nevents) sequence.<br/>\nThe trick is to generate the sequence in a reproducible manner.<br/>\n<br/>\nThe solution is to take the number of events (or methods) to be executed and<br/>\nassign an integer to each.<br/>\nThen for each event assign an integer to each set of data (set of<br/>\nparameters) that  can be sent out.<br/>\nThen the testing looks something like this:<br/>\n<br/>\nint testNumber = 30000; \t// some large number<br/>\nint numberOfEvents = 10; \t// As given by the protocol<br/>\nint numberOfDataSetsPerEvent = 5; // As you desire..<br/>\n<br/>\nint eventToBeSent;<br/>\n<br/>\nwhile (testNumber != 0)<br/>\n{<br/>\n\teventNdx = testNumber % numberOfEvents;<br/>\n\tdataSetNdx = testNumber % numberOfDataSetsPerEvent;<br/>\n<br/>\n\t// Send the event associated with eventNdx with the data associated with<br/>\ndataSetNdx<br/>\n\t// I often use the reflection API for this.<br/>\n<br/>\n\t// Catch any exceptions thrown by the event execution and log them<br/>\n\t// Log the target objects state (if applicable)<br/>\n<br/>\n\ttestNumber = testNumber - 1;<br/>\n}<br/>\n<br/>\nA very old example:<br/>\n<br/>\n    private void executeShortTour(int tour)<br/>\n    {<br/>\n        int            methodNdx;<br/>\n        Method         currMethod;<br/>\n        String         currMethodName;<br/>\n        Vector         currListOfParmLists;<br/>\n        Object[]       currParmList;<br/>\n<br/>\n<br/>\n        int numberOfMethods = _Cfg.getMethodCount();<br/>\n<br/>\n        System.out.println(&quot;Starting Short Tour&quot;);<br/>\n<br/>\n        while ( tour != numberOfMethods )<br/>\n        {<br/>\n            methodNdx = tour % numberOfMethods;<br/>\n<br/>\n            currMethod = (Method) _Cfg.getMethod(methodNdx);<br/>\n<br/>\n            int numberOfParmLists = _Cfg.getParmListCount(currMethod);<br/>\n<br/>\n            int parmListNdx = tour % numberOfParmLists;<br/>\n<br/>\n            Object    returnValue = null;<br/>\n<br/>\n            currParmList = (Object[])<br/>\n_Cfg.getParmList(currMethod,parmListNdx);<br/>\n<br/>\n            if ( currParmList == null )<br/>\n            {<br/>\n                throw (new ProxyInitializationException(new String(&quot;Unable<br/>\nto find parm list for method&quot;)));<br/>\n            }<br/>\n<br/>\n            System.out.println(&quot;Method(&quot; + methodNdx + &quot;) Parm Set(&quot; +<br/>\nparmListNdx + &quot;) tour (&quot; + tour + &quot;)&quot;);<br/>\n<br/>\n            try<br/>\n            {<br/>\n                returnValue = currMethod.invoke(_Instance, currParmList);<br/>\n<br/>\n                invokationSuccessProlog(methodNdx, parmListNdx, returnValue,<br/>\ncurrMethod, currParmList);<br/>\n                invokationSuccessEpilog(currMethod, currParmList);<br/>\n            }<br/>\n            catch(java.lang.reflect.InvocationTargetException<br/>\ninvocationTargetError)<br/>\n            {<br/>\n                invokationFailureProlog(methodNdx, parmListNdx, returnValue,<br/>\ncurrMethod, currParmList, invocationTargetError.getTargetException());<br/>\n                invokationFailureEpilog(currMethod, currParmList,<br/>\ninvocationTargetError.getTargetException());<br/>\n            }<br/>\n            catch(java.lang.IllegalArgumentException illegalArgumentError)<br/>\n            {<br/>\n                invokationFailureProlog(methodNdx, parmListNdx, returnValue,<br/>\ncurrMethod, currParmList, illegalArgumentError);<br/>\n                invokationFailureEpilog(currMethod, currParmList,<br/>\nillegalArgumentError);<br/>\n            }<br/>\n            catch(java.lang.IllegalAccessException illegalAccessError)<br/>\n            {<br/>\n                throw (new ProxyInitializationException(new String(&quot;4&quot;)));<br/>\n            }<br/>\n            finally<br/>\n            {<br/>\n            }<br/>\n<br/>\n            tour--;<br/>\n<br/>\n        }<br/>\n    }<br/>\n<br/>\n<br/>\n<br/>\nThe point here is not to produce something that succeeds in every case. The<br/>\npoint is to execute this<br/>\ntest, check (via by eye review) that it succeeds when it should and fails<br/>\nwhen it should, and use this<br/>\nfor regression and robustness checking.<br/>\n<br/>\nThe review can be a pain, but the effort is well worth it. You can also<br/>\ncreate an Oracle class that<br/>\ntells you what the expected behaviors should be and compares the actual<br/>\nresult to the predicted one.<br/>\nHow far you go depends on how much you want to pay for a given level of<br/>\nrobustness.<br/>\n<br/>\n<br/>\nThus ends my random exposition on how I tested my distribu apps this summer.<br/>\nHave fun.<br/>\n<br/>\nJim JM<br/>\n<br/>\n-----Original Message-----<br/>\nFrom: Jamie Lawrence [mailto:<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:hopeless@...\">hopeless@...</a>]<br/>\nSent: Wednesday, December 06, 2000 2:27 PM<br/>\nTo: <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@egroups.com\">junit@egroups.com</a><br/>\nSubject: [junit] xUnit testing of distributed systems<br/>\n<br/>\n<br/>\nI have finally got around to using JUnit for some of the development work I<br/>\ndo (all in Java).  However, whilst JUnit is fine for testing &quot;normal&quot;<br/>\nclasses I&#39;m really stuck on how to apply it to the application I&#39;m building.<br/>\n<br/>\nThis application is agent-based and is therefore distributed,<br/>\nmulti-threaded, asynchronous and acts in response to incoming messages and<br/>\nuser interactions.  It sits on top of an agent platform which makes it<br/>\nslightly harder to form tests (you must start the platform before any tests<br/>\nwill work).<br/>\n<br/>\nI understand that xUnit tests are normally focused on individual classes but<br/>\nin my case the classes include the agent itself, several behaviours (i.e.<br/>\ntasks), and utility classes.  The utility classes are quite easy to test as<br/>\nthey are usually standard classes devoid of agent complications.  The Agent<br/>\nhas very few methods of interest since it responds to messages placed in a<br/>\nqueue from either the GUI or other agents.  Each behaviour maintains an<br/>\ninternal state which changes in response to messages and can be<br/>\ncharacterised by either WAITING_FOR_USER, WAITING_FOR_MESSAGE,<br/>\nPERFORMING_ACTION, or SENDING_MESSAGE.  So my ideal tests would be to ensure<br/>\nthat the agent makes the correct state transitions in response to<br/>\nvalid/invalid messages and that it does this in each of the concurrent<br/>\nbehaviours.<br/>\n<br/>\nNow that I actually write all this down it does seem kinda difficult!!  But<br/>\nI think many of the problems exist in systems like Jini, etc.<br/>\n<br/>\nGiven the large amount of distributed systems work involved in most<br/>\napplications today I was hoping that someone would have typical patterns for<br/>\ntesting these systems.  Any ideas?<br/>\n<br/>\nMany thanks,<br/>\n<br/>\n<br/>\n\tJamie<br/>\n<br/>\n<br/>\n<br/>\nTo unsubscribe from this group, send an email to:<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit-unsubscribe@egroups.com\">junit-unsubscribe@egroups.com</a></div>", 
    "prevInTime": 95, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "976113249", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 95, 
    "headers": {
        "inReplyToHeader": "PDAwNDQwMWMwNWZiYSQ4NzBiYjBlMCQ3MDZlNmJjMEBwYzEyLmJyb2FkY29tLmllPg==", 
        "messageIdInHeader": "PEJBRVBKSUxMRE1PSEZHRUpNTE5LRUVESENPQUEuam1vY2hlbEBmb2xpYWdlLmNvbT4="
    }
}