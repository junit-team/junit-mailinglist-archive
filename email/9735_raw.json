{
    "topicId": 9699, 
    "postDate": "1066760723", 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "from": "&quot;Michael Silverstein&quot; &lt;msilverstein@...&gt;", 
    "canDelete": false, 
    "replyTo": "LIST", 
    "senderId": "mTJ9Wh7tQaXO0pD4Mkn2pFo9OtApGj0A9lvUkPaapL4S5p92I8rY4MJEX501G_bfWLWBcJRaiPieDZ6OT-7a852pKrRY8ACZWeBsTyk1EX4rk9KTYJd12kOV", 
    "nextInTime": 9736, 
    "userId": 62742148, 
    "prevInTime": 9734, 
    "prevInTopic": 9734, 
    "headers": {
        "inReplyToHeader": "PDNDNjc4RERGOTIyMTIzNERBNEYyOTAwRjkzQzZGNjMzMDFFQkFEOTFAYWx0ZWMwMDUuYWx0ZWMubG9jYWw+", 
        "messageIdInHeader": "PDAwMzAwMWMzOTgwMCRiMTRlYTg5MCQ2OTAxYThjMEBsYXRpdHVkZTAxPg=="
    }, 
    "authorName": "Michael Silverstein", 
    "numMessagesInTopic": 23, 
    "msgSnippet": "Agile methodologies suggest that we accept and plan for the fact that we don t always know all requirements. If I accept that I as a framework provider will in", 
    "contentTrasformed": false, 
    "msgId": 9735, 
    "nextInTopic": 0, 
    "systemMessage": false, 
    "rawEmail": "Return-Path: &lt;msilverstein@...&gt;\r\nX-Sender: msilverstein@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (qmail 61329 invoked from network); 21 Oct 2003 18:25:50 -0000\r\nReceived: from unknown (66.218.66.172)\n  by m8.grp.scd.yahoo.com with QMQP; 21 Oct 2003 18:25:50 -0000\r\nReceived: from unknown (HELO ms-smtp-03-eri0.southeast.rr.com) (24.25.9.102)\n  by mta4.grp.scd.yahoo.com with SMTP; 21 Oct 2003 18:25:50 -0000\r\nReceived: from latitude01 (cpe-024-211-140-157.nc.rr.com [24.211.140.157])\n\tby ms-smtp-03-eri0.southeast.rr.com (8.12.10/8.12.7) with ESMTP id h9LIPlhf001495\n\tfor &lt;junit@yahoogroups.com&gt;; Tue, 21 Oct 2003 14:25:47 -0400 (EDT)\r\nTo: &lt;junit@yahoogroups.com&gt;\r\nSubject: RE: [junit] Re: How to test private methods, its urgent\r\nDate: Tue, 21 Oct 2003 14:25:23 -0400\r\nMessage-ID: &lt;003001c39800$b14ea890$6901a8c0@latitude01&gt;\r\nMIME-Version: 1.0\r\nContent-Type: text/plain;\n\tcharset=&quot;Windows-1252&quot;\r\nContent-Transfer-Encoding: 7bit\r\nX-Priority: 3 (Normal)\r\nX-MSMail-Priority: Normal\r\nX-Mailer: Microsoft Outlook, Build 10.0.3416\r\nX-MimeOLE: Produced By Microsoft MimeOLE V6.00.2727.1300\r\nIn-Reply-To: &lt;3C678DDF9221234DA4F2900F93C6F63301EBAD91@...&gt;\r\nImportance: Normal\r\nX-Virus-Scanned: Symantec AntiVirus Scan Engine\r\nFrom: &quot;Michael Silverstein&quot; &lt;msilverstein@...&gt;\r\nX-Yahoo-Group-Post: member; u=62742148\r\n\r\nAgile methodologies suggest that we accept and plan for the fact that we\ndon&#39;t always know all requirements. If I accept that I as a framework\nprovider will in all likelihood not be able to anticipate the myriad\nways someone might want to extend my framework then I will hesitate to\nrestrict visibility to methods, except in circumstances where I\nintentionally want to prevent use or extension.\n\nSo you either protect people from themselves or you tell them what the\nrisks are and let them make their own decisions. Remember that we are\ntalking about the ability to *extend* a framework as opposed to *using*\nit. I favor using Java Interfaces to publish real APIs, so this isn&#39;t\nreally an issue for the case of *using* a framework.\n\nOne place this ties in to testing is that you expose internal supporting\nmethods that have not been tested outside of the context of their use in\nsupport of real APIs. This is another reason to approach use of these\nmethods with caution. On the other hand, I&#39;ve often been so grateful to\nbe able to access internal methods that I&#39;m willing to accept the risks.\n\nAnyway, I realize this is straying from the topic of testing and would\nbe happy to bury this dead horse.\n\n-----------------------------\nMike Silverstein\nSilverMark, Inc.\nThe Object Testing Company\nwww.javatesting.com\n\n&gt; -----Original Message-----\n&gt; From: Danijel Arsenovski [mailto:darsenovski@...] \n&gt; Sent: Tuesday, October 21, 2003 10:09 AM\n&gt; To: junit@yahoogroups.com\n&gt; Subject: RE: [junit] Re: How to test private methods, its urgent\n&gt; \n&gt; \n&gt; OK, let&#39;s go a few steps back...\n&gt; First of all, in a well written framework, you will not \n&gt; modify or even see original source. (I will not consider \n&gt; badly written, since majority I have expirience with are fine \n&gt; in this rescpect). So, when you say only interfaces are \n&gt; visible (and I mean visibillity in software programming \n&gt; sence) I understand all classes are not, so there is no way \n&gt; to extend them (inherit). On the other hand, if classes are \n&gt; visible, there is nothing preventing a client programmer \n&gt; instantiating these classes directly (not through interface). \n&gt; Generally, you will want to permit extending only certain \n&gt; classes. The same thing happens on the method - field level, \n&gt; if you don&#39;t make method private, client programmer will \n&gt; consider it wasn&#39;t ment to be private. OO. Rule No 1: \n&gt; encapsulate! Only contract two programmers have to obey is \n&gt; code. What makes you think other programmer will read your \n&gt; docs or comments? But, if he tries to override private \n&gt; method, compiler will not permit it. (Actually, he will not \n&gt; even know the method exist.) \n&gt; If you can ENFORCE something, you will not leave it to \n&gt; chance. Making method private or public is a design decision \n&gt; , not something arbitrary. Leaving important information to \n&gt; comments, docs etc is extremely dangerous! I suggest you \n&gt; check out refactoring catalogue www.refactoring.com \n&gt; (&quot;Comments lie, code does not&quot;) and how refactoring community \n&gt; treats comments: either you don&#39;t need them  so you eliminate \n&gt; them or you make code out of them. Similar thing goes for \n&gt; documentation that is trying to explain code. Making testing \n&gt; influence your design decision is an example of very \n&gt; testing-biased paradigm, but this should not conflict with \n&gt; basic premises of OO, like most of new usefull paradigms \n&gt; don&#39;t (for example AOP does not make you change OO \n&gt; principles, it builds on them).\n&gt;  \n&gt; &gt;&gt; \n&gt; &gt;&gt; Hello Michael,\n&gt; &gt;&gt; \n&gt; &gt;&gt; \n&gt; &gt;&gt; &gt;Private methods are difficult to test because, after all, they&#39;re\n&gt; &gt;&gt; &gt;private. If you adopt a convention that API methods are only \n&gt; &gt;&gt; presented\n&gt; &gt;&gt; &gt;via Java Interfaces instead of concrete classes then you \n&gt; don&#39;t care\n&gt; &gt;&gt; &gt;about the way the implementers of the Interfaces are \n&gt; &gt;&gt; written. You can\n&gt; &gt;&gt; &gt;then make non-API methods within the concrete \n&gt; implementation public\n&gt; &gt;&gt; &gt;without implying that they are themselves API methods.\n&gt; &gt;&gt; \n&gt; &gt;&gt; I am not sure I follow, but as I can see this only works if\n&gt; &gt;&gt; you never plan to extend your clases, or leave them to be \n&gt; &gt;&gt; extended. I guess that in your case only thing visible from \n&gt; &gt;&gt; the outside are interfaces. If you write frameworks, it is \n&gt; &gt;&gt; difficult to get by without inheritance. Inheritance breaks \n&gt; &gt;&gt; encapsulation, keeping methods private helps encapsulate things. \n&gt; &gt;&gt; Also, I am not shure what you mean by &quot;without implying&quot;, \n&gt; &gt;&gt; generally you &quot;make statement&quot; with your code, any other \n&gt; &gt;&gt; method yo imply something (comments, documentation etc...) is \n&gt; &gt;&gt; superfluous.\n&gt; &gt;&gt; \n&gt; &gt;&gt; Regards,\n&gt; &gt;&gt; \n&gt; &gt;&gt; Danijel Arsenovski\n&gt; &gt;\n&gt; &gt;On the contrary, I think this approach makes it easier to extend \n&gt; &gt;frameworks. I believe that in the general case, there is no \n&gt; reason to \n&gt; &gt;make methods in classes private if their API methods are \n&gt; only accessed \n&gt; &gt;by clients via Interface methods.\n&gt; &gt;\n&gt; &gt;Here&#39;s an example of what I mean:\n&gt; &gt;\n&gt; &gt;Let&#39;s assume we have class MyClass that implements interface \n&gt; &gt;MyInterface, with methods: public int x(){\n&gt; &gt;  // return an answer based on y() and z() \n&gt; &gt;}\n&gt; &gt;private int y() {...}\n&gt; &gt;private int z() {...}\n&gt; &gt;\n&gt; &gt;And Interface MyInterface with method:\n&gt; &gt;public int x()\n&gt; &gt;\n&gt; &gt;We observe that:\n&gt; &gt;\n&gt; &gt;- MyInterface serves to &#39;publish&#39; the API method x().\n&gt; &gt;\n&gt; &gt;- Any client of MyClass will only see it in terms of\n&gt; &gt;\n&gt; &gt;- We have the choice of testing public method x() by constructing a \n&gt; &gt;test that &#39;talks&#39; to either MyClass or MyInterface.\n&gt; &gt;\n&gt; &gt;- If we have other concrete implementors of MyInterface it \n&gt; makes sense \n&gt; &gt;to write the test to talk to MyInterface rather than directly to \n&gt; &gt;implementors to they can be swapped in and tested.\n&gt; &gt;\n&gt; &gt;- x() returns a value based on values returned by private \n&gt; methods y() \n&gt; &gt;and z().\n&gt; &gt;\n&gt; &gt;- Methods y() and z() may be private for no other reason \n&gt; than that they \n&gt; &gt;are not part of the public API interface of MyClass and that the \n&gt; &gt;developer did not anticipate that anyone would ever need to \n&gt; use them in \n&gt; &gt;extending the framework.\n&gt; \n&gt; &gt;Continuing:\n&gt; &gt;Let&#39;s say\n&gt; &gt; - we want to extend MyClass with MyClass2 that implements method int\n&gt; &gt;q().\n&gt; &gt; - we want to override x() so that it uses methods y(),  \n&gt; z(), and q() to\n&gt; &gt;calculate its return value. \n&gt; &gt;\n&gt; &gt;We have a problem: MyClass2 does not have visibility to \n&gt; private methods\n&gt; &gt;y() and z().\n&gt; &gt;\n&gt; &gt;If private methods y() and z() were made public there would be no \n&gt; &gt;adverse effect on the publication of API methods because \n&gt; users of the \n&gt; &gt;class would only see those methods published via MyInterface.\n&gt; &gt;\n&gt; &gt;We have the question of whether it is *safe* to use y() and \n&gt; z(). Since \n&gt; &gt;they are not published as part of the API via MyInterface it may be \n&gt; &gt;considered too risky to use them. This can be solved with \n&gt; some notes in \n&gt; &gt;the javadoc.\n&gt; &gt;\n&gt; &gt;Methods that really are too risky to use outside of the class itself \n&gt; &gt;can always be made private but I would hope that this is the \n&gt; exception \n&gt; &gt;and not the rule.\n&gt; &gt;\n&gt; &gt;The developer creating the extension can make the decision based on \n&gt; &gt;those notes whether they are willing to accept fhe risk of using \n&gt; &gt;methods that may not continue to behave the same way or even \n&gt; exist in \n&gt; &gt;the future. At least they have that choice. If they have a \n&gt; good set of \n&gt; &gt;tests then changes to those methods in the future will be exposed \n&gt; &gt;readily enough.\n&gt; &gt;\n&gt; &gt;Conclusion\n&gt; &gt;----------\n&gt; &gt;If the purpose of making methods private is to indicate that \n&gt; they are \n&gt; &gt;not part of a class&#39;s API a better way is to encourage users of the \n&gt; &gt;class to program to a Java Interface instead. When you make methods \n&gt; &gt;private it makes the class more difficult to test and short-circuits \n&gt; &gt;the efforts of people who might need to extend the framework in \n&gt; &gt;unanticipated ways.\n&gt; \n&gt; -----------------------------\n&gt; Mike Silverstein\n&gt; SilverMark, Inc.\n&gt; The Object Testing Company\n&gt; www.javatesting.com\n\n---\nOutgoing mail is certified Virus Free.\nChecked by AVG anti-virus system (http://www.grisoft.com).\nVersion: 6.0.528 / Virus Database: 324 - Release Date: 10/16/2003\n \n\n\n", 
    "subject": "RE: [junit] Re: How to test private methods, its urgent"
}