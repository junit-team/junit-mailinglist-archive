{
    "numMessagesInTopic": 41, 
    "nextInTime": 6816, 
    "senderId": "F89IWeBOvNRCw5zgdY0eXUyKIQKe8tmVeLcKI7f0NN_pP55FZ_MkB_h9xCY9rHigMmQKZWRbOUn4NlcpCa_g0MPsSWCdF1xArVIKgKHvCw", 
    "systemMessage": false, 
    "subject": "RE: [junit] Websphere Connection Pool", 
    "from": "&quot;Scott Stirling&quot; &lt;scottstirling@...&gt;", 
    "authorName": "Scott Stirling", 
    "msgSnippet": "... [...] ... Well, it *was* your example, and I thought it was an intentional simplification, not an example of production code.  It was supposed to be ", 
    "msgId": 6815, 
    "rawEmail": "Return-Path: &lt;scottstirling@...&gt;\r\nX-Sender: scottstirling@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (EGP: mail-8_2_3_4); 31 Jan 2003 04:12:31 -0000\r\nReceived: (qmail 80974 invoked from network); 31 Jan 2003 04:12:31 -0000\r\nReceived: from unknown (66.218.66.218)\n  by m2.grp.scd.yahoo.com with QMQP; 31 Jan 2003 04:12:31 -0000\r\nReceived: from unknown (HELO smtp-hub2.mrf.mail.rcn.net) (207.172.4.76)\n  by mta3.grp.scd.yahoo.com with SMTP; 31 Jan 2003 04:12:30 -0000\r\nReceived: from smtp01.mrf.mail.rcn.net ([207.172.4.60])\n\tby smtp-hub2.mrf.mail.rcn.net with esmtp (Exim 3.35 #4)\n\tid 18eSXW-00072o-00\n\tfor junit@yahoogroups.com; Thu, 30 Jan 2003 23:12:30 -0500\r\nReceived: from 207-172-67-6.c3-0.frm-ubr1.sbo-frm.ma.cable.rcn.com ([207.172.67.6] helo=javalaptop)\n\tby smtp01.mrf.mail.rcn.net with smtp (Exim 3.35 #4)\n\tid 18eSXW-0005cJ-00\n\tfor junit@yahoogroups.com; Thu, 30 Jan 2003 23:12:30 -0500\r\nTo: &lt;junit@yahoogroups.com&gt;\r\nSubject: RE: [junit] Websphere Connection Pool\r\nDate: Thu, 30 Jan 2003 23:12:08 -0500\r\nMessage-ID: &lt;KIEHIBIOBAELJAHIPNHDGEKBCOAA.scottstirling@...&gt;\r\nMIME-Version: 1.0\r\nContent-Type: text/plain;\n\tcharset=&quot;US-ASCII&quot;\r\nContent-Transfer-Encoding: 7bit\r\nX-Priority: 3 (Normal)\r\nX-MSMail-Priority: Normal\r\nX-Mailer: Microsoft Outlook IMO, Build 9.0.2416 (9.0.2911.0)\r\nIn-Reply-To: &lt;Pine.NEB.4.51.0301270822220.596@...&gt;\r\nX-MIMEOLE: Produced By Microsoft MimeOLE V6.00.2800.1106\r\nImportance: Normal\r\nFrom: &quot;Scott Stirling&quot; &lt;scottstirling@...&gt;\r\nReply-To: &lt;scottstirling@...&gt;\r\nX-Yahoo-Group-Post: member; u=112036634\r\nX-Yahoo-Profile: jrun5\r\n\r\n&gt; -----Original Message-----\n&gt; From: Curt Sampson [mailto:yahoo_sucks@...]\n[...]\n&gt; True. The above code is easily testable by simply passing in a mock\n&gt; connection factory, and asserting that getConnection() was invoked with\n&gt; whatever information was necessary, and that close() was called on the\n&gt; connection. I don&#39;t generally find this worth the effort because this\n&gt; routine is so simple.\n\nWell, it *was* your example, and I thought it was an intentional\nsimplification, not an example of production code.  It was supposed to be\nsimple, but that doesn&#39;t invalidate the principles we&#39;re debating.\n\n&gt; &gt; The whole doMyThing method is very general, but we can work with it.  I\n&gt; &gt; would argue that rather than modify the class and adding code that,\n&gt; &gt; ironically, is added for unit level testability but can&#39;t be\n&gt; &gt; unit tested, one should use 2 mock objects here.\n&gt;\n&gt; Err...if you&#39;re creating new classes for the mock objects, aren&#39;t you\n&gt; adding extra code just for testability?\n\nSort of -- but test code that doesn&#39;t have to ship with the product, and\nwhich is completely decoupled from the design and implementation of the\nproduct, unlike test code added to the class itself.\n\n&gt; &gt; You&#39;d need a ConnectionFactory mock object that could return a\n&gt; &gt; Connection mock object. You create the mock object in the TestCase,\n&gt; &gt; and you pass it to doMyThing.\n&gt;\n&gt; Right. But if you don&#39;t already have such mock objects, you&#39;d have to\n&gt; create them, which is a lot more work that just doing what I did above.\n\nIt doesn&#39;t have to much work at all if you use an IDE like Eclipse and/or a\ntool like Mockmaker (http://www.mockmaker.org/).  Even without Mockmaker in\nplain old Eclipse I can define a class that implements any existing\ninterface and then choose &quot;add unimplemented methods&quot; from the task pop-up.\n\n&gt; What does all the extra code buy you? Just saving one method declaration\n&gt; and one extra line of code to invoke a second method?\n\nI know, but again, the method under discussion was originally just an\nintentionally simplified example of a situation that can arise.  In a real\napplication you&#39;re right, there would be a lot of other things to take into\naccount.  I am debating the general principle of whether one should modify\nimplementation code to make it testable, and you&#39;re talking about particular\ncases *when* it might be better.  I can&#39;t argue with that.  Would we both\nagree that the best possible solution would be to avoid the problem\naltogether by doing test driven development?\n\nScott Stirling\n\n\n\n", 
    "profile": "jrun5", 
    "topicId": 6711, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 112036634, 
    "prevInTime": 6814, 
    "contentTrasformed": false, 
    "postDate": "1043986328", 
    "canDelete": false, 
    "nextInTopic": 6825, 
    "prevInTopic": 6789, 
    "headers": {
        "inReplyToHeader": "PFBpbmUuTkVCLjQuNTEuMDMwMTI3MDgyMjIyMC41OTZAYW5nZWxpYy5jeW5pYy5uZXQ+", 
        "messageIdInHeader": "PEtJRUhJQklPQkFFTEpBSElQTkhER0VLQkNPQUEuc2NvdHRzdGlybGluZ0ByY24uY29tPg=="
    }
}