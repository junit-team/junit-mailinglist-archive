{
    "numMessagesInTopic": 13, 
    "nextInTime": 16300, 
    "senderId": "mRjAb7JIlnRzsbAoNNVypNVwFwbA8oS1KR4uFA1uFJprRqpxb5tvsp7I-tTEcsHzd7_3TrFh6RnrIDwi4W_v5Rd-cByVhOEdvPhAB1ylFg", 
    "systemMessage": false, 
    "subject": "Re: [junit] Testing Abstract Classes", 
    "from": "&quot;J. B. Rainsberger&quot; &lt;jbrains@...&gt;", 
    "authorName": "J. B. Rainsberger", 
    "msgSnippet": "... They are similar. They also point to an observation I ve made about abstract classes, explaining why I prefer not to use them. Every abstract class", 
    "msgId": 16299, 
    "profile": "nails762", 
    "topicId": 16293, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 127224993, 
    "messageBody": "<div id=\"ygrps-yiv-822530071\">Kamal Ahmed wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; Since I did not follow completely what the recipe was, are these two<br/>\n&gt; approaches same?<br/>\n<br/>\n </span></blockquote>They are similar. They also point to an observation I&#39;ve made about <br/>\nabstract classes, explaining why I prefer not to use them.<br/>\n<br/>\nEvery abstract class consists of two parts: the abstract part and the <br/>\nconcrete part. The concrete part consists of all the fields and methods <br/>\nwith implementations (bodies). The abstract part consists of all the <br/>\ndeclarations of abstract methods.<br/>\n<br/>\nI recommend splitting (most) abstract classes into a concrete class and <br/>\nan interface. Test the interface using the recipe you cited. Test the <br/>\nconcrete class with interaction-style tests faking and mocking the <br/>\ninterface, as needed.<br/>\n<br/>\nThe concrete class will probably take an instance of the interface <br/>\nthrough its constructor.<br/>\n<br/>\nI know you probably can&#39;t change the design of the code you&#39;re testing, <br/>\nbut if you can, consider giving this technique a go.<br/>\n<br/>\nTake care.<br/>\n----<br/>\nThis is the first time I can see value in the test case class not <br/>\nextending a JUnit framework class. We could use the Self-Shunt pattern <br/>\nwhere the test case class provides implementations for the abstract <br/>\nmethods, extending the abstract class. There would probably be one class <br/>\nper different way to fake the abstract methods. This corresponds pretty <br/>\nwell to different test case classes for different fixtures, in general. <br/>\nIf I had a good, concrete example for this, I could write an article.<br/>\n-- <br/>\nJ. B. (Joe) Rainsberger :: <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.jbrains.info\">http://www.jbrains.info</a><br/>\nYour guide to software craftsmanship<br/>\nJUnit Recipes: Practical Methods for Programmer Testing<br/>\n2005 Gordon Pask Award for contribution Agile Software Practice</div>", 
    "prevInTime": 16298, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1142040121", 
    "canDelete": false, 
    "nextInTopic": 16300, 
    "prevInTopic": 16294, 
    "headers": {
        "inReplyToHeader": "PDVCMTBFNTBFMTRBNDU5NEVCMUI1NTY2QjY5QUQ5NDA3MEQyRTI4QkNAbWFpbGVhc3Q+", 
        "messageIdInHeader": "PDQ0MTIyNjM5LjMwODA0MDFAcm9nZXJzLmNvbT4=", 
        "referencesHeader": "PDVCMTBFNTBFMTRBNDU5NEVCMUI1NTY2QjY5QUQ5NDA3MEQyRTI4QkNAbWFpbGVhc3Q+"
    }
}