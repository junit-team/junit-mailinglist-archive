{
    "numMessagesInTopic": 9, 
    "nextInTime": 3230, 
    "senderId": "G2xzw8Ktzy-041_mRMRmjgziTYJ3qokzriHpux3JTspWNhAhSJcMgAvbBc-dhyuLTRkz3S7Zt2fgILOJRpiHF4SM_-76", 
    "systemMessage": false, 
    "subject": "Re: [junit] Inner Class, Even Driven Classes", 
    "from": "Eric Vought &lt;evought@...&gt;", 
    "authorName": "Eric Vought", 
    "msgSnippet": "The short answer is that they are usually tested in the same testcase as the enclosing class. Where the testcase are complex enough for a sepearte testcase", 
    "msgId": 3229, 
    "profile": "eric_vought", 
    "topicId": 3227, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 0, 
    "messageBody": "<div id=\"ygrps-yiv-1073910943\">The short answer is that they are usually tested in the same testcase as<br/>\nthe enclosing class. Where the testcase are complex enough for a<br/>\nsepearte testcase class to make sense, refactoring the inner class to<br/>\nthe top level will also typically make sense. For the long answer, I&#39;ll<br/>\nlay out a few cases for you and how they are handled in my experience.<br/>\n<br/>\nIf the class is a tightly coupled private utility, like an iterator or an<br/>\nevent adapter, these are typically tested in the test case for the class.<br/>\nIn the case of an event listener, whether the listener is implemented by<br/>\nan adapter or the class itself is a minor organizational detail. The<br/>\nimportant question is whether the event is dispatched correctly. With<br/>\niterators, they tend to be very minor in functionality and extremely<br/>\ntightly coupled. Iterators are therefore more of a special reference or<br/>\npsuedopod of the class-under-test than a separate entity and are also<br/>\ntested in the same testcase.<br/>\n<br/>\nSometimes, you use an inner class to define an interface that goes along<br/>\nwith it, such as defining static inner  classes to represent listeners for<br/>\nevents which only that class will generate. The example I have in front of<br/>\nme right now is a class called LogListener.MaskChangeListener. LogListener<br/>\naccepts logging events from a Logger for dispatch. A particular<br/>\nLogListener, however, only accepts events of a particular set of<br/>\npriorities (e.g. WARNING or above). A Logger wishes to avoid instantiating<br/>\nmessages that will never be processed, so it monitors the priority masks<br/>\nof its Listeners. It should be obvious that MaskChangeListener is very<br/>\nspecific to LogListener and therefore may as well be a part of it.<br/>\n<br/>\nIn these cases, you have a base class or interface which will be<br/>\nimplemented or extended by some other class. The general practice here is<br/>\nto create a testcase for that base class (using a stub implementation) and<br/>\nthen the testcases for actual implementations can inherit your abstract<br/>\ntestcase to ensure that invariants are maintained. With the inner class<br/>\nsituation, however, most of the eventual implementations will themselves<br/>\nbe inner classes (adapters) and therefore will not be tested as separate<br/>\nentities. Further, there really aren&#39;t any invariants to be maintained<br/>\nbeyond what the compiler will verify for you- namely, that a method exists<br/>\nwith that signature in the implementing class. So, in this case, too,<br/>\nthere isn&#39;t any special testing to be done.<br/>\n<br/>\nAs your inner class gets more complex- perhaps it is an abstract class<br/>\nwith some fields or concrete code- the case for doing a seperate testcase<br/>\ngets stronger, but so does the case for refactoring. Even if the inner<br/>\nclass needs access to private state which you don&#39;t wish to expose, the<br/>\ndependency can probably be reduced through refactoring to the point where<br/>\nyou can use simple listeners and adapters to connect two top-level<br/>\nclasses.<br/>\n<br/>\nThe borderline case I sometimes run into is an inner class representing a<br/>\nsouped up type-safe enumeration. The enumeration has methods to produce or<br/>\nparse a human-readable representation of a value and has some special code<br/>\nto handle serialization safely. If the enumeration is conceptually coupled<br/>\nto the enclosing class, it makes sense to leave it as an inner class.<br/>\nThere is *some* significant functionality to test (mostly looking for<br/>\nsimple typing errors), which is conceptually different from the<br/>\nfunctionality of the top-level class and tends to clutter the testcase a<br/>\nlittle if included. I could see a case for breaking this out into multiple<br/>\ntestcase if there were a number of similar inner classes in the top-level<br/>\nclass. Otherwise, I still tend to keep all the tests in one container.<br/>\n<br/>\n<blockquote><span title=\"qreply\"> On Fri, 9 Nov 2001 <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:sowmya.srinivasan@...\">sowmya.srinivasan@...</a> wrote:<br/>\n<br/>\n&gt; Hello<br/>\n&gt; I have just started using JUnit.<br/>\n&gt; I have a few queries.<br/>\n&gt;<br/>\n&gt; 1. How do I handle inner classes ?<br/>\n&gt; \tIf I have a class A and this has three inner classes A1, A2, A3 ;<br/>\n&gt; \t\tShould I write separate test classes for each of these inner<br/>\n&gt; classes ? (Atest, A1test, A2test, A3test)<br/>\n&gt; \t\tOR should I write just write one test class( TestA) that<br/>\n&gt; will handle the functions in the inner classes also ?<br/>\n&gt;<br/>\n&gt; 2. I am trying to write test classes for an event driven program. How<br/>\n&gt; feasible is this ?<br/>\n&gt;<br/>\n&gt; Thanks<br/>\n&gt;<br/>\n&gt; Sowmya<br/>\n&gt;<br/>\n&gt; To unsubscribe from this group, send an email to:<br/>\n&gt; <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit-unsubscribe@yahoogroups.com\">junit-unsubscribe@yahoogroups.com</a><br/>\n&gt;<br/>\n&gt;<br/>\n&gt; Your use of Yahoo! Groups is subject to <a rel=\"nofollow\" target=\"_blank\" href=\"http://docs.yahoo.com/info/terms/\">http://docs.yahoo.com/info/terms/</a><br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n<br/>\n-- <br/>\nEric Vought<br/>\nChief Technical Officer - QLUE Consulting, Inc.<br/>\n<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:evought@...\">evought@...</a> toll-free: 888-771-3538  RTP area: 919-816-9901 </span></blockquote></div>", 
    "prevInTime": 3228, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1005326083", 
    "canDelete": false, 
    "nextInTopic": 3274, 
    "prevInTopic": 3227, 
    "headers": {
        "inReplyToHeader": "PDQ4ODE1QUYzQ0E1RkQ1MTFBMjVBMDA1MDhCRTE2RUZGMDFFQzQzNTdAZm1nLW9wLmlmbGV4c29sdXRpb25zLmNvbT4=", 
        "messageIdInHeader": "PFBpbmUuTE5YLjQuMzAuMDExMTA5MTEyNTIxMC4yNTcxNy0xMDAwMDBAYnJhaW4ucWx1ZS1sYW4+"
    }
}