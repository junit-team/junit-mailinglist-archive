{
    "numMessagesInTopic": 7, 
    "nextInTime": 20702, 
    "senderId": "B8MHD24T1neQLBGWTMGNALjnvKIrF-529dC0u9cEPEVeUiqsrUHyH1FhmKf_WtRTRxFccFXSsDrUW9LB8CZPQIrs_rnGz98Agyg51Dwvj568cQ", 
    "systemMessage": true, 
    "subject": "Re: Newbie wants to take some JUnit group. Some basic questions.", 
    "from": "&quot;robinjay33&quot; &lt;robin.desilva@...&gt;", 
    "authorName": "robinjay33", 
    "msgSnippet": "Hi! Looking at your email-address I assume that you are german. ;-) So, if you are motivated to read more about JUnit and TDD check out the just released 2nd", 
    "msgId": 20701, 
    "profile": "robinjay33", 
    "topicId": 20700, 
    "spamInfo": {
        "reason": "6", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 348617342, 
    "messageBody": "<div id=\"ygrps-yiv-1719890058\">Hi!<br/>\n<br/>\nLooking at your email-address I assume that you are german. ;-) So, if you are motivated <br/>\nto read more about JUnit and TDD check out the just released 2nd edition of &quot;Softwaretests <br/>\nmit JUnit&quot; by Johannes Link. It cotains a larger chapter about mocking and working <br/>\ndistributed systems.<br/>\n<br/>\nRegarding your SQL queries it might be a trade-off to use a slim in memory-database to <br/>\nvalidate whether your SQL queries are correct. However you might not be able to simulate <br/>\nyour production-database since it might interpret your SQL slightly different..  <br/>\n<br/>\nBest Regards,<br/>\nRobin<br/>\n<br/>\n<blockquote><span title=\"qreply\"> --- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>, &quot;serethos_0&quot; &lt;Serethos@...&gt; wrote:<br/>\n&gt;<br/>\n&gt; Hello!<br/>\n&gt; <br/>\n&gt; I am an quite experienced programmer but new to the philosophy of unit<br/>\n&gt; testing. An issue I want to change.<br/>\n&gt; I read some articles and took some orientation on Frank Westphal&#39;s<br/>\n&gt; very good book about that topic. But in practice, I always run into<br/>\n&gt; similar problems, which seem to disturb my view of unit testing. So<br/>\n&gt; some thought and questions I would like to discuss.<br/>\n&gt; <br/>\n&gt; 1. Recently I read that a unit test is no one if you have to touch<br/>\n&gt; network, db or filesystem. I understand the point that these accesses<br/>\n&gt; really can slow the tests down and usually need extra work of<br/>\n&gt; configuration, but how to avoid this?<br/>\n&gt; An example of my daily work. I have quite a common task: Fetch some<br/>\n&gt; xmls from an ftp server, parse the content and map it into db and vice<br/>\n&gt; versa. So the business logic is quite thin. More important is good<br/>\n&gt; exception handling and the transport of all data in the right structures. <br/>\n&gt; <br/>\n&gt; Actually the slowdown of a real ftp transport and the configuration<br/>\n&gt; and injection overhead of the db-connection is a major drawback. But<br/>\n&gt; on the other hand I see no good way to mock the behaviour of these<br/>\n&gt; endpoints. <br/>\n&gt; I could try to mock a database, but how to test, if an sql-statement<br/>\n&gt; is correct (especially for a wider range of queries)?<br/>\n&gt; It also is a very hard work to write stubs or mocks, which can answer<br/>\n&gt; with all error-states an ftp-server/network can generate (timeout,<br/>\n&gt; access denied, authentication etc) to test the correct error handling<br/>\n&gt; of my code.<br/>\n&gt; <br/>\n&gt; 2. Another question points to a basic principle of unit testing: the<br/>\n&gt; opening of a class in small and public methods. I see an advantage in<br/>\n&gt; the possibility to inject every aspect of a class (manually or e.g.<br/>\n&gt; via spring) and the code can benefit from a better readability through<br/>\n&gt; a chain of self-explanatory method calls.<br/>\n&gt; But in some cases I want to hide implementation details from the user.<br/>\n&gt; Taking my Importer/Exporter example a second time, it is more a cron<br/>\n&gt; script than an application: Doing a defined job in a robust and<br/>\n&gt; understandable manner but neither designed as a basis for wide<br/>\n&gt; enhancements nor for ultimate flexibility. <br/>\n&gt; So there are methods which start the whole work of an importer over<br/>\n&gt; the whole lifecycle (connect, fetch data, map data etc). Methods,<br/>\n&gt; which are necessary for getting the object in a usable state (e.g.<br/>\n&gt; connection established) are hidden away. To ensure that there must be<br/>\n&gt; the correct state before executing the main task I can lead the user<br/>\n&gt; with parameterized constructors (e.g. MyImporter(host, port)).<br/>\n&gt; To say it more generally I think that it is a common way to restrict<br/>\n&gt; the use of classes which need to be handled in correct order because<br/>\n&gt; of their state. This saves a lot of additional exception handling<br/>\n&gt; (e.g. executing before connecting). <br/>\n&gt; But following this thought it gets very hard to isolate testing units.<br/>\n&gt; Even when I separate the tasks within the class to units (connecting,<br/>\n&gt; disconnecting etc) they would be not accessible and would need to be<br/>\n&gt; tested from within.<br/>\n&gt; <br/>\n&gt; This is only a very simple and not a perfect example but I think my<br/>\n&gt; point should be clear. I hope that some of you take some time to read<br/>\n&gt; it. I really would appreciate some thoughts!<br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 20700, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1216705103", 
    "canDelete": false, 
    "nextInTopic": 20702, 
    "prevInTopic": 20700, 
    "headers": {
        "inReplyToHeader": "PGc2Mm5lYis1NWl0QGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PGc2M3JvZitlNnQ2QGVHcm91cHMuY29tPg=="
    }
}