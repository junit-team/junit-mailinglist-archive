{
    "numMessagesInTopic": 16, 
    "nextInTime": 8378, 
    "senderId": "qeZbhaQTOvH20mQ0sKSnwsvRSeoKJQLoXHlzlRb0AW1LeyVuv5fRmxyNU4uCoXnmxoZ_6vzkgeOVRviRwvrxJkEvN93jygVlGU3v4j13vQ", 
    "systemMessage": false, 
    "subject": "RE: [junit] Re: Fork each test method?", 
    "from": "&quot;J. B. Rainsberger&quot; &lt;jbrains@...&gt;", 
    "authorName": "J. B. Rainsberger", 
    "msgSnippet": "... I don t understand how what you said is different from what I said. How is create a new runtime instance different from create a new object , since an", 
    "msgId": 8377, 
    "rawEmail": "Return-Path: &lt;jbrains@...&gt;\r\nX-Sender: jbrains@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (qmail 27142 invoked from network); 17 Jun 2003 23:56:16 -0000\r\nReceived: from unknown (66.218.66.218)\n  by m6.grp.scd.yahoo.com with QMQP; 17 Jun 2003 23:56:16 -0000\r\nReceived: from unknown (HELO fep03-mail.bloor.is.net.cable.rogers.com) (66.185.86.73)\n  by mta3.grp.scd.yahoo.com with SMTP; 17 Jun 2003 23:56:16 -0000\r\nReceived: from quincy ([24.156.43.226])\n          by fep03-mail.bloor.is.net.cable.rogers.com\n          (InterMail vM.5.01.05.12 201-253-122-126-112-20020820) with ESMTP\n          id &lt;20030617235614.XXAO487659.fep03-mail.bloor.is.net.cable.rogers.com@quincy&gt;\n          for &lt;junit@yahoogroups.com&gt;; Tue, 17 Jun 2003 19:56:14 -0400\r\nMessage-ID: &lt;200306171956110590.00B7E6DE@...&gt;\r\nIn-Reply-To: &lt;CFDDEB3B870EE346BB583D2B0420F5AC3B9491@...&gt;\r\nReferences: &lt;CFDDEB3B870EE346BB583D2B0420F5AC3B9491@...&gt;\r\nX-Mailer: Calypso Version 3.30.00.00 (4)\r\nDate: Tue, 17 Jun 2003 19:56:11 -0400\r\nTo: junit@yahoogroups.com\r\nSubject: RE: [junit] Re: Fork each test method?\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=&quot;us-ascii&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\nX-Authentication-Info: Submitted using SMTP AUTH LOGIN at fep03-mail.bloor.is.net.cable.rogers.com from [24.156.43.226] using ID &lt;jbrains@...&gt; at Tue, 17 Jun 2003 19:56:14 -0400\r\nFrom: &quot;J. B. Rainsberger&quot; &lt;jbrains@...&gt;\r\nReply-To: jbr@...\r\nX-Yahoo-Group-Post: member; u=127224993\r\nX-Yahoo-Profile: nails762\r\n\r\n&gt;So said Robert DiFalco on 2003-06-17 --------------------\n&gt;&gt;&gt; I would thin=\r\nk that the easiest way to zero out all the\n&gt;&gt;&gt; caches is to create new cach=\r\ne objects. \n&gt;\n&gt;No, not really. I don&#39;t expect to be able to convince you bu=\r\nt if you\n&gt;have caches, or thread pools, or whatever that &quot;are scoped to the=\r\n\n&gt;runtime instance they were created in&quot;, the easiest and in fact the most\n=\r\n&gt;correct way to reinitialize them is to create a new runtime instance.\n\nI d=\r\non&#39;t understand how what you said is different from what I said.\n\nHow is &quot;c=\r\nreate a new runtime instance&quot; different from &quot;create a new object&quot;, since a=\r\nn object is just a runtime instance of a class? There is some nuance in wha=\r\nt you&#39;re saying that I can&#39;t see. If you have the energy, help me understan=\r\nd what that is.\n\n&gt;The saddest thing is that there is no reason in productio=\r\nn to &quot;zero out\n&gt;all caches&quot;. Even having such a method indicates (to me) a =\r\ndesign flaw.\n&gt;After all, I don&#39;t expect the value of an immutable object (s=\r\nay an\n&gt;Integer) to suddenly change during the life of that object. \n\nI&#39;m no=\r\nt sure what the former has to do with the latter. I agree with your stateme=\r\nnt. This is one motivation for keeping from my objects the details of wheth=\r\ner they are collaborating with caches. In J2EE we may want to cache the res=\r\nult of a JNDI lookup. One way to do this is abstract away the lookup into a=\r\n generic object factory. At test time, we use an in-memory object factory; =\r\nat production time, we use an object factory backed by JNDI. Everyone wins.=\r\n\n\n&gt;&gt;&gt; If a class uses a cache, then that class should either\n&gt;&gt;&gt; accept the=\r\n cache from the outside world or be unaware\n&gt;&gt;&gt; that it&#39;s using a cache at =\r\nall.\n&gt;\n&gt;You are working too hard at this. \n\nI appreciate your concern. (Not=\r\n sarcasm: it&#39;s nice to know that your goal is to help, and not just puff yo=\r\nur chest. Many others are guilty of the latter.)\n\n&gt;Things seem simpler to m=\r\ne. For\n&gt;example, from what you say I am going to assume that you never use\n=\r\n&gt;string constants in your code. \n\nWell, I never do anything the same way al=\r\nl the time. Everything depends. In particular, I externalize strings when i=\r\nt makes sense, and I don&#39;t when it doesn&#39;t. I first have to see the pattern=\r\n or be told by a customer that the data in question is volatile.\n\n&gt;There is=\r\nn&#39;t that much of a difference. I\n&gt;suppose you use a decorator that caches s=\r\ntrings and then you make a call\n&gt;on each access of the string (possibly loo=\r\nking in a map?) instead of\n&gt;simply caching the constant string reference as=\r\n a static final? \n\nI don&#39;t see a need for that right now. It depends whethe=\r\nr the string needs to change. If the string doesn&#39;t need to change, then I =\r\nput it in the code until I see evidence that it needs to change.\n\n&gt; Really,=\r\n\n&gt;there is no difference between that and this:\n&gt;\n&gt;class Something\n&gt;{\n&gt;    =\r\n private static final Identity FOO_CLASS_ID =3D\n&gt;ClassRegistry.identify( Fo=\r\no.class );\n&gt;\n&gt;     ...\n&gt;}\n&gt;\n&gt;FOO_CLASS_ID is scoped to the runtime instance=\r\n it was created in. \n\nI think this is the big difference. I have the tenden=\r\ncy to build classes and interfaces that collaborate with one another and le=\r\nt the application context (or component runtime context, whatever it is) de=\r\ncide how to bind runtime objects to one another. So in my code there are re=\r\nlatively few cases where an object manages the lifecycle of other objects.\n=\r\n\nIn particular, FOO_CLASS_ID would be a parameter to Something&#39;s constructo=\r\nr. If the production code wants to use a ClassRegistry to get FOO_CLASS_ID,=\r\n then that&#39;s cool; but if Something only depends on having a FOO_CLASS_ID, =\r\nthen why should it care where the FOO_CLASS_ID came from? I don&#39;t see the b=\r\nenefit there.\n\nYou are saying, &quot;This is the simplest place to put that code=\r\n.&quot; I disagree. It&#39;s the easiest, but not necessarily the simplest. What if =\r\nthe application doesn&#39;t want Something to identify Foo.class as the means o=\r\nf getting a FOO_CLASS_ID? What if the application needs to provide that dat=\r\na?\n\nOf course, I can take my own advice and deal with that when it happens,=\r\n but I practice TDD, and in so doing, would tend not to write the code you&#39;=\r\nve written there. No value judgment: just a difference in approach.\n\n&gt;It is=\r\n\n&gt;immutable for the life of the runtime. These may be generated by a\n&gt;datab=\r\nase, created by a synchronized static int, GUID generator or\n&gt;whatever. It =\r\ndoesn&#39;t really matter. The contract is that they are good\n&gt;for the life of =\r\nthe Runtime. So it makes sense to hide them just as you\n&gt;would any other im=\r\nmutable constant -- say a string. The only reason to\n&gt;impose a hash look up=\r\n on every access is, well, I dunno. For testing?\n\nFirst, don&#39;t underestimat=\r\ne the importance of testing. Testing is damn important.\n\nYou want to Someth=\r\ning to hide the way it gets a FOO_CLASS_ID because all that matters is the =\r\nvalue: once Something gets the FOO_CLASS_ID, it doesn&#39;t matter how it did t=\r\nhat. I can&#39;t argue with that. If the system only says this once, then it ma=\r\ntters less where the system says it.\n\nHowever, I claim that by splitting So=\r\nmething into Something and FooClassIdFactory, I can add only a little compl=\r\nexity but gain the real benefit of making Something easier to test. Here is=\r\n how I would do it.\n\nclass Something\n    Something()\n        this(ClassRegi=\r\nstry.identify(Foo.class))\n\n    Something(identity)\n        // store in inst=\r\nance-level variable\n\nThe default behavior of Something is to use the ClassR=\r\negistry to create FOO_CLASS_ID, but in my tests, I can just provide whateve=\r\nr data is easiest for the tests to provide.\n\nThis is an extremely small amo=\r\nunt of complexity to add to gain the benefit of testing. Of course, if you =\r\ndon&#39;t value testing the same way I do, then you won&#39;t be moved by this. Tha=\r\nt&#39;s fine: do as you find best, as will I.\n\n&gt;Now, if you suddenly invalidate=\r\n those identities or flush the\n&gt;ClassRegistry, you are in deep trouble. Wha=\r\nt is the simplest solution?\n&gt;&quot;Don&#39;t do that.&quot; What is the most complicated =\r\nsolution? &quot;Create a bunch\n&gt;of rigging that has no value save for unit tests=\r\n that are unable to\n&gt;create new runtime instances on each run.&quot; Think about=\r\n it. Details and\n&gt;Abstraction are one thing, this is another.\n\nYou&#39;re right=\r\n. This is another. This is straightforward separation of responsibilities. =\r\nSomething just needs an Identity. It shouldn&#39;t much matter where the Identi=\r\nty comes from. For that reason, Something should be willing to take whateve=\r\nr Identity I give it, if I want to give it one; otherwise, it can use the o=\r\nne it wants to use.\n\n&gt;For me, there is nothing\n&gt;worse than seeing designs t=\r\nhat are overly complicated (obfuscated in\n&gt;fact) for no other reason than t=\r\no serve a principle. Liskov\n&gt;Substitution, Law of Demeter, Coupling and Coh=\r\nesion, Shunts, Mock\n&gt;Objects, Decorators....these are all good and wonderfu=\r\nl things.  All\n&gt;important tools. However, they are capable of improving cod=\r\ne or making\n&gt;code horribly obfuscated and ugly. At this point in its evolut=\r\nion,\n&gt;programming is much more like music than science. You can kill the fe=\r\nel\n&gt;of the code by being too pedantic.\n\nNo argument here: I am guilty of us=\r\ning good tools to build bad ashtrays. We all are. We have to take care, tho=\r\nugh, not to become neo-Luddites, deciding that the tools are the reason we =\r\nbuilt bad ashtrays. That was us. We should practise with the tools.\n\n&gt;Googl=\r\ne &quot;Simplicity&quot;.\n\nSometimes people mistake simplicitly and ease. I&#39;m not say=\r\ning that you&#39;re doing it, but it happens. Here is how my code tends to evol=\r\nve.\n\n1. Implement a few hardcoded concrete cases.\n2. Identify the abstracti=\r\nons by looking at common code.\n3. Extract the abstractions into behavioral =\r\nclasses; push the difference into data classes.\n4. Decide whether to move t=\r\nhe values of the data classes outside the system into data files of some so=\r\nrt.\nRinse and repeat, as needed.\n\nThe result is a bunch of collaborating en=\r\ngines and, surprisingly, less code. Also increased flexibility without obsc=\r\nene complexity. (Some complexity, yes; but then a system without complexity=\r\n may not do much of anything useful.) I don&#39;t think that&#39;s being &quot;pedantic&quot;=\r\n. When I feel that the code is becoming too complex, I have to step back aw=\r\nay from the keyboard and think a little. I have to throw away what I&#39;ve don=\r\ne and try again. The result is usually better. Sometimes banging out a sill=\r\ny solution is a good tool to finding a better one.\n\nTake care.\n\n\nJ. B. Rain=\r\nsberger,\nPresident, Diaspar Software Services\nLet&#39;s write software that peo=\r\nple understand.\nhttp://www.diasparsoftware.com/\ntelephone: +1 416 791-8603\n=\r\n\n\n", 
    "profile": "nails762", 
    "topicId": 8358, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 127224993, 
    "prevInTime": 8376, 
    "contentTrasformed": false, 
    "postDate": "1055894171", 
    "canDelete": false, 
    "nextInTopic": 8378, 
    "prevInTopic": 8376, 
    "headers": {
        "inReplyToHeader": "PENGRERFQjNCODcwRUUzNDZCQjU4M0QyQjA0MjBGNUFDM0I5NDkxQHNlYWJhc3MudHJpcHdpcmUuY29tPg==", 
        "messageIdInHeader": "PDIwMDMwNjE3MTk1NjExMDU5MC4wMEI3RTZERUBzc210cC5ibG9vci5pcy5uZXQuY2FibGUucm9nZXJzLmNvbT4=", 
        "referencesHeader": "PENGRERFQjNCODcwRUUzNDZCQjU4M0QyQjA0MjBGNUFDM0I5NDkxQHNlYWJhc3MudHJpcHdpcmUuY29tPg=="
    }
}