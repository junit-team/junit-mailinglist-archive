{
    "numMessagesInTopic": 48, 
    "nextInTime": 19848, 
    "senderId": "OOMXb68az6Bj8kALjwfqy67zB4UavmwyzG1g_eFRQruaQnMFIAScJDxBP37Fb5y3Gd6g6hdVrYbQ5PuAgLHPSYClm_kiiA", 
    "systemMessage": false, 
    "subject": "Re: [junit] Help,what&#39;s wrong with my TDD practice in my daily\tlife?", 
    "from": "Jeff Langr &lt;jeff@...&gt;", 
    "authorName": "Jeff Langr", 
    "msgSnippet": "... It seems like there is a large jump in the amount of code in this refactoring step. If it were just removing the duplicate space, you could do that with", 
    "msgId": 19847, 
    "profile": "jlangr", 
    "topicId": 19846, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 238525042, 
    "messageBody": "<div id=\"ygrps-yiv-621974096\">Quoting hyysguyang &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:hyysguyang@...\">hyysguyang@...</a>&gt;:<br/>\n<blockquote><span title=\"ireply\"> &gt; The final step is to refactor to remove duplicate code.<br/>\n&gt;<br/>\n&gt; a) Remove the duplicate string in the test case and product code.<br/>\n&gt;<br/>\n&gt;    public class StringReverser {<br/>\n&gt;        public String reverse(String str) {<br/>\n&gt;            String[] words=str.split(&quot; &quot;);<br/>\n&gt;            StringBuilder result=new StringBuilder();<br/>\n&gt;            for (int i = words.length-1; i &gt;=0; i--) {<br/>\n&gt;                result.append(words[i]).append(&quot; &quot;);<br/>\n&gt;            }<br/>\n&gt;            return result.toString().trim();<br/>\n&gt;        }<br/>\n&gt;    }<br/>\n<br/>\n </span></blockquote>It seems like there is a large jump in the amount of code in this  <br/>\nrefactoring step. If it were just removing the duplicate space, you  <br/>\ncould do that with something like a hardcoded array:<br/>\n<br/>\nString[] reversedSentence = { &quot;technology&quot;, &quot;devolopment&quot;, &quot;software&quot;,  <br/>\n&quot;a&quot;, &quot;is&quot;, &quot;Tdd&quot; };<br/>\nfor (String word: reversedSentence) {<br/>\n\tresult.append(word, &quot; &quot;);<br/>\n}<br/>\n<br/>\nThat is certainly one possible route.<br/>\n<br/>\nYou might try to instead think in terms of moving from the simplest  <br/>\npossible case and adding complexity incrementally to the test cases.  <br/>\nThe simplest possible test case here? Empty string, do nothing. Write  <br/>\nthe code to get this to pass. This gets your interface in place.<br/>\n<br/>\nThen consider the next most simple case: one word. Reversal is the  <br/>\nsame as the input. You have to check for the existence of the  <br/>\nseparator character (indexOf is probably sufficient).<br/>\n<br/>\nThen move to the next case, which would probably be two words. You  <br/>\ndon&#39;t need a loop to implement this case.<br/>\n<br/>\nThen write a case for multiple words. A loop is probably prudent at  <br/>\nthis point.<br/>\n<br/>\nFinally, oddball/edge cases: Does your algorithm work for multiple  <br/>\nspaces inbetween words? Should it retain the same input spacing (or  <br/>\nnot?). Write a test.<br/>\n<br/>\nYou&#39;ll end up with a more comprehensive set of test cases, and more  <br/>\nimportantly, you&#39;ll have arrived at the solution more incrementally.<br/>\n<br/>\nJeff</div>", 
    "prevInTime": 19846, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1189453987", 
    "canDelete": false, 
    "nextInTopic": 19848, 
    "prevInTopic": 19846, 
    "headers": {
        "inReplyToHeader": "PGZjM3U3dCttZzg5QGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PDIwMDcwOTEwMTI1MzA3LmJ4N200Y3Y0emlnNGtvNHNAbG9naW4uc2lyaXVzLmx1bmFycGFnZXMuY29tPg==", 
        "referencesHeader": "PGZjM3U3dCttZzg5QGVHcm91cHMuY29tPg=="
    }
}