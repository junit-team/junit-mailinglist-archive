{
    "numMessagesInTopic": 17, 
    "nextInTime": 6922, 
    "senderId": "MHiyqiumz_zsXoBt5Vbh3YUZzbgI5xHBM174WxKfR60jhXbfNf7pu-7fv3aZ3p0lajgXzg_T7qsZgLKIHKwDssZhlDPsrzdbuMXbO8aQIw", 
    "systemMessage": false, 
    "subject": "Re: [junit] Testability", 
    "from": "&quot;Scott Stirling&quot; &lt;scottstirling@...&gt;", 
    "authorName": "Scott Stirling", 
    "msgSnippet": "... My point was only that with Beck s TDD methodology, you get 100% statement coverage every time (in theory).  I never said anything to suggest that I ", 
    "msgId": 6921, 
    "rawEmail": "Return-Path: &lt;scottstirling@...&gt;\r\nX-Sender: scottstirling@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (EGP: mail-8_2_3_4); 9 Feb 2003 22:50:07 -0000\r\nReceived: (qmail 33776 invoked from network); 9 Feb 2003 22:50:07 -0000\r\nReceived: from unknown (66.218.66.216)\n  by m10.grp.scd.yahoo.com with QMQP; 9 Feb 2003 22:50:07 -0000\r\nReceived: from unknown (HELO smtp-hub.mrf.mail.rcn.net) (207.172.4.107)\n  by mta1.grp.scd.yahoo.com with SMTP; 9 Feb 2003 22:50:07 -0000\r\nReceived: from smtp01.mrf.mail.rcn.net ([207.172.4.60])\n\tby smtp-hub.mrf.mail.rcn.net with esmtp (Exim 3.35 #4)\n\tid 18i0H0-0005Qf-00\n\tfor junit@yahoogroups.com; Sun, 09 Feb 2003 17:50:06 -0500\r\nReceived: from 207-172-67-6.c3-0.frm-ubr1.sbo-frm.ma.cable.rcn.com ([207.172.67.6] helo=javalaptop)\n\tby smtp01.mrf.mail.rcn.net with smtp (Exim 3.35 #4)\n\tid 18i0H0-00045n-00\n\tfor junit@yahoogroups.com; Sun, 09 Feb 2003 17:50:06 -0500\r\nTo: &quot;Junit@Yahoogroups. Com&quot; &lt;junit@yahoogroups.com&gt;\r\nSubject: Re: [junit] Testability\r\nDate: Sun, 9 Feb 2003 17:49:27 -0500\r\nMessage-ID: &lt;KIEHIBIOBAELJAHIPNHDMEAACPAA.scottstirling@...&gt;\r\nMIME-Version: 1.0\r\nContent-Type: text/plain;\n\tcharset=&quot;iso-8859-1&quot;\r\nContent-Transfer-Encoding: 7bit\r\nX-Priority: 3 (Normal)\r\nX-MSMail-Priority: Normal\r\nX-Mailer: Microsoft Outlook IMO, Build 9.0.2416 (9.0.2911.0)\r\nImportance: Normal\r\nX-MimeOLE: Produced By Microsoft MimeOLE V6.00.2800.1106\r\nFrom: &quot;Scott Stirling&quot; &lt;scottstirling@...&gt;\r\nReply-To: &lt;scottstirling@...&gt;\r\nX-Yahoo-Group-Post: member; u=112036634\r\nX-Yahoo-Profile: jrun5\r\n\r\n--- Curt Sampson &lt;yahoo_sucks@...&gt; wrote:\n&gt; Yes, Kent Beck indeed did say, &quot;TDD followed\n&gt; religiously should result in 100% statement\n&gt; coverage.&quot; But on the other hand, the sentence\n&gt; before that in his TDD book is &quot;Statement coverage\n&gt; is certainly not a sufficient measure of test\n&gt; quality, but it is a starting place.&quot; If you\n&gt; look at the chapter on method/class scope testing in\n&gt; Binder&#39;s _Testing Object Oriented Systems_, you&#39;ll\n&gt; find that having meerly full statement coverage is\n&gt; pretty poor test quality indeed.\n\nMy point was only that with Beck&#39;s TDD methodology, you get 100% statement\ncoverage every time (in theory).  I never said anything to suggest that I\nthought this was sufficient coverage did I?  I am a great fan of Binder&#39;s\nbook, and I agree with your point, although in my experience, 100% statement\ncoverage would be pretty good, because I have yet to work on a project\nthat&#39;s had it.  I&#39;ve brought code coverage analysis to the last two\ncompanies I worked for (both multi-million dollar companies producing\nJ2EE-related products), and the reality in my experience is that unit\ntesting and code coverage analysis adoption still has a ways to go in the\nreal world.\n\n&gt; If you&#39;re looking just at a coverage metric, I&#39;d say\n&gt; you want at least full coverage of branches.\n\nAnd I&#39;d say that&#39;d be nice.  But 100% statement coverage would also be nice,\nand I have yet to see that happen.  Note: sure, I&#39;ve seen packages and lots\nof classes get 100% statement, method and (mostly in simple cases) branch\ncoverage, but not whole codebases and applications.  So far I&#39;ve been\ninvolved in projects of around 200,000 lines of Java code, where I&#39;ve been\nlucky to get developers to write more than a handful of unit tests.  Do you\nknow how much code never gets tested because it&#39;s dead, unused code (DUC)?\nIt&#39;s not easy to root out and remove DUC unless you have cooperative\ndevelopers willing to investigate based on the coverage reports, and you\nhave reasonable assurance that your tests are covering all the functional\nrequirements of the product (thereby making uncovered code DUC, pretty much\nby definition).\n\n&gt; But then again, Kent Beck also said, on page 115/6\n&gt; of _Extreme Programming Explained_, &quot;So you should\n&gt; write the tests that help get programs working and\n&gt; keep programs working. Nothing more.&quot;\n\nSure, and the corollary is that by doing this, you write just enough code to\nmake the program work and nothing more.  Again, no DUC because the developer\nthought this method might be needed someday . . . or because these methods\nwere copied and pasted from somewhere else.\n\n&gt; In the end, it really depends on the consequences of\n&gt; failure. In most of the systems I build, the consequence\n&gt; of failure is a stack exception appearing on the screen\n&gt; and a slightly troubled user. No big deal if\n&gt; that happens once in a while; I just find, fix and\n&gt; roll out a new release.\n\nBut in an expensive commercial product it is a very big deal to roll out a\nnew release and cannot be done quite so offhandedly.  But I understand your\nperspective.\n\n&gt; On the other hand, if I had an embedded system that\n&gt; was going to be mass-produced, where a new release\n&gt; is extremely expensive, I&#39;d spend a lot more money\n&gt; and time testing.\n\nRight.  This is also true of app servers and high-visibility corporate\napplications.\n\n&gt; Actually, I see it as relying on my judgement that\n&gt; it&#39;s cheaper to deal with the rare failures in that\n&gt; area when they happen than it is to spend\n&gt; the money and time for more comprehensive test\n&gt; coverage.\n\nAhh.  Yes, clearly the scope, importance, visibility and nature of the\napplication has factors important for deciding the risk and worth of\ntesting.  As do internal process factors such as, do you have to produce a\ncode coverage report or bug entry/fix statistics to upper management?  We\nare in different environments, it sounds like.\n\n&gt; &gt; So why are we arguing such different strategies\n&gt; &gt; for solving the problem of &quot;testability?&quot;\n&gt;\n&gt; Because we&#39;re costing it out differently. That&#39;s\n&gt; all.\n\nYes.  Although I think the disagreements have led to interesting theoretical\npoints about OO design, the underpinnings of TDD, and the meaning of\n&quot;testability,&quot; which is where I&#39;m glad this discussion has led.\n\n&gt; &gt; Put another way, I wonder the same thing about any\n&gt; &gt; behavior added to an object.  Testing is not a\n&gt; &gt; behavior of most objects.\n&gt;\n&gt; Well, this perhaps a point of disagreement. I think\n&gt; that testing is a potential behaviour of every object\n&gt; I write.\n\nInteresting.  Some of my thinking has led to a similar thought, and a\nquestion: like Serializable, Runnable, Cloneable, etc. I have been toying\nwith what a Testable interface could do.  What would it be like to\nidiomaticize Testability as a marker interface in Java?\n\nOne idea is that &quot;implements Testable&quot; could mean that a runtime flag could\nbe used to enable/disable a set of test methods (a la JUnit&#39;s test****\nmethod naming pattern) in classes.  Just a thought.\n\n&gt; &gt; It seems the best way to build and test a\n&gt; &gt; finite-state machine is to make the inputs\n&gt; &gt; and outputs explicit, and to make the state\n&gt; &gt; transitions step-wise and traceable.\n&gt;\n&gt; I would consider that to be modifying an object,\n&gt; beyond its overt function, to make it more testable.\n\nWhat I am arguing is that this is exactly what TDD does by only building\ntestable objects.\n\n&gt; If you didn&#39;t have to test the object, because you\n&gt; always wrote perfect code, would you bother exposing\n&gt; the state-wide transitions?\n\nGood question.  My first thought is that if I could do that, why write code\nat all?  I would just write binary and dispense with OOP altogether.  Second\nthought is that &quot;perfect&quot; in the context of OOP must entail more than just\nfunctional perfection, e.g., things such as ease of understanding and reuse\nfor other human beings.\n\nScott Stirling\nFramingham, MA\n\n\n\n", 
    "profile": "jrun5", 
    "topicId": 6863, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 112036634, 
    "prevInTime": 6920, 
    "contentTrasformed": false, 
    "postDate": "1044830967", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 6913, 
    "headers": {
        "messageIdInHeader": "PEtJRUhJQklPQkFFTEpBSElQTkhETUVBQUNQQUEuc2NvdHRzdGlybGluZ0ByY24uY29tPg=="
    }
}