{
    "numMessagesInTopic": 23, 
    "nextInTime": 22542, 
    "senderId": "Z5uJvvYutZ2C-7rBG9GRQO2JcF6oA04FZW2ClbT2dohDEkjTee1-eUsHrQU04uCatJEVvqoqosdiIpPC-243slx50POnIkTboi8", 
    "systemMessage": true, 
    "subject": "Re: [junit] Re: @DataPoints called several times for Theories", 
    "from": "Mike Forsberg &lt;bigmike.f@...&gt;", 
    "authorName": "Mike Forsberg", 
    "msgSnippet": "Please feel free to join the mailing list.  I would find the discussion interesting and wish it would not run offline. Big Mike ... [Non-text portions of this", 
    "msgId": 22541, 
    "profile": "bigmike_f", 
    "topicId": 22425, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 421392598, 
    "messageBody": "<div id=\"ygrps-yiv-381163616\">Please feel free to join the mailing list.  I would find the discussion<br/>\ninteresting and wish it would not run offline.<br/>\n<br/>\nBig Mike<br/>\n<br/>\n<blockquote><span title=\"qreply\"> On Fri, Mar 12, 2010 at 6:44 PM, Brett Daniel &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:brettdaniel@...\">brettdaniel@...</a>&gt; wrote:<br/>\n<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; The undergrads I am advising recently pushed a patch that addresses the<br/>\n&gt; issue of mutable data points.<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; <a rel=\"nofollow\" target=\"_blank\" href=\"http://github.com/stan6/junit/commit/dcfa3c41446c469a4edc7513e9e7a9b610b04020\">http://github.com/stan6/junit/commit/dcfa3c41446c469a4edc7513e9e7a9b610b04020</a><br/>\n&gt;<br/>\n&gt; The patch allows developers to define &quot;copy strategies&quot; that duplicate<br/>\n&gt; marked data points before every theory execution. In this way, every<br/>\n&gt; execution receives a pristine data point, which removes the problems caused<br/>\n&gt; when a theory mutates data points. This is orthogonal to datapoint<br/>\n&gt; (re)creation, but I think copy strategies may help address the bug that<br/>\n&gt; Berin found.<br/>\n&gt;<br/>\n&gt; The patch creates a new, optional &quot;copyStrategy&quot; parameter for the<br/>\n&gt; @DataPoint and @DataPoints annotations. If the developer wants to copy data<br/>\n&gt; points, he or she sets the parameter to a class implementing a new<br/>\n&gt; CopyStrategy interface.<br/>\n&gt;<br/>\n&gt; Here is an example:<br/>\n&gt;<br/>\n&gt; @RunWith(Theories.class)<br/>\n&gt; public class TestMutable {<br/>\n&gt;<br/>\n&gt; @DataPoint(copyStrategy = MutableWithCopyStrategy.class)<br/>\n&gt; public static Mutable mutable = new Mutable();<br/>\n&gt;<br/>\n&gt; @Theory<br/>\n&gt; public static testMutate(Mutable a) {<br/>\n&gt; a.mutate();<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; @Theory<br/>\n&gt; public static testNotMutated(Mutable a) {<br/>\n&gt; assertFalse(a.isMutated());<br/>\n&gt; }<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; In the current implementation of JUnit, the second theory may fail because<br/>\n&gt; the first theory mutates the datapoint. With a copy strategy enabled, both<br/>\n&gt; theories receive a new value.<br/>\n&gt;<br/>\n&gt; Strategies can do almost anything: clone the data point, call a factory<br/>\n&gt; method, or--as in the following implementation--instantaiate a new object<br/>\n&gt; with a copy constructor.<br/>\n&gt;<br/>\n&gt; public class MutableWithCopyStrategy implements CopyStrategy {<br/>\n&gt; public Object copyDataPoint(Object toCopy) throws Exception {<br/>\n&gt; return new Mutable((Mutable)toCopy);<br/>\n&gt; }<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; There are several benefits to this implementation. First, the new parameter<br/>\n&gt; is completely optional; if it is omitted, the theory runner behaves as it<br/>\n&gt; always has. Second, it doesn&#39;t require modifying the data point&#39;s class<br/>\n&gt; (for<br/>\n&gt; example, to add a copy constructor or clone method). Most importantly, it<br/>\n&gt; makes it clear to the tester that without a copy strategy one theory<br/>\n&gt; execution can impact another.<br/>\n&gt;<br/>\n&gt; I have CC&#39;d the two students in this email. Please direct any questions to<br/>\n&gt; them.<br/>\n&gt;<br/>\n&gt; Brett<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; On Thu, Feb 18, 2010 at 5:28 PM, Berin &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:berin.loritsch@...\">berin.loritsch@...</a>&lt;berin.loritsch%40gd-ais.com&gt;&gt;<br/>\n&gt; wrote:<br/>\n&gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt; I agree with your prognosis, about fresh data points for testing the<br/>\n&gt; &gt; theories. That is precisely why I proposed reading them once, and cloning<br/>\n&gt; &gt; them (making a copy) as needed for each theory. With that approach we<br/>\n&gt; even<br/>\n&gt; &gt; get the protection from mutated data points when you use the @DataPoint<br/>\n&gt; to<br/>\n&gt; &gt; mark a static field.<br/>\n&gt; &gt;<br/>\n&gt; &gt; Cloning is a much quicker operation, does not execute any constructors.<br/>\n&gt; It<br/>\n&gt; &gt; merely copies the contents of the object memory verbatim.<br/>\n&gt; &gt;<br/>\n&gt; &gt; With the current implementation, if you are not prepared for the<br/>\n&gt; &gt; combinatorial affect of 60 data points combined with 60 data points for<br/>\n&gt; each<br/>\n&gt; &gt; theory there is a major disconnect. The majority of the overhead in this<br/>\n&gt; &gt; particular scenario has to do with creating objects (with the additional<br/>\n&gt; &gt; overhead of doing it by reflection).<br/>\n&gt; &gt;<br/>\n&gt; &gt; When I created only one instance of each class instead of two, the<br/>\n&gt; &gt; performance was twice as fast (i.e. 37 seconds down to about 16 seconds).<br/>\n&gt; &gt;<br/>\n&gt; &gt; Essentially the number of times your @DataPoints method is called depends<br/>\n&gt; &gt; on the number of parameters in your @Theory and how many theories you<br/>\n&gt; have.<br/>\n&gt; &gt; Essentially the formula for my theory (ha, ha) of the execution is like<br/>\n&gt; &gt; this:<br/>\n&gt; &gt;<br/>\n&gt; &gt; N^(p-1) + 1<br/>\n&gt; &gt;<br/>\n&gt; &gt; where:<br/>\n&gt; &gt;<br/>\n&gt; &gt; N is the number of data points returned by the method<br/>\n&gt; &gt; p is the number of parameters<br/>\n&gt; &gt; and the + 1 represents the run where the data point is read the first<br/>\n&gt; time<br/>\n&gt; &gt;<br/>\n&gt; &gt; So for 60 data points it is run 61 times for two parameters. With three<br/>\n&gt; &gt; parameters it would be called 3601 times. I have to verify with three<br/>\n&gt; &gt; parameters. The theory is called N^p times for sure and that is expected.<br/>\n&gt; &gt;<br/>\n&gt; &gt; With the above formula, the mapping of number of calls to parameters for<br/>\n&gt; 60<br/>\n&gt; &gt; data points would be:<br/>\n&gt; &gt;<br/>\n&gt; &gt; 1 -&gt; 2 (I know this is wrong which gives me doubts on the formula)<br/>\n&gt; &gt; 2 -&gt; 61<br/>\n&gt; &gt; 3 -&gt; 3601<br/>\n&gt; &gt; 3 -&gt; 216001<br/>\n&gt; &gt;<br/>\n&gt; &gt; Essentially when the Assignments class needs to make the combinations, it<br/>\n&gt; &gt; will collect the data points initially for each theory. It then calls the<br/>\n&gt; &gt; data points again for each existing data point it collected from the<br/>\n&gt; first<br/>\n&gt; &gt; read. With a third parameter it would take all those combinations again,<br/>\n&gt; to<br/>\n&gt; &gt; add all the permutations for the next round.<br/>\n&gt; &gt;<br/>\n&gt; &gt; I might be wrong and the real formula would be like this:<br/>\n&gt; &gt;<br/>\n&gt; &gt; N^0 + N^1 ... + N^(p-1)<br/>\n&gt; &gt;<br/>\n&gt; &gt; If this is the correct formula, then if you have 60 data points the<br/>\n&gt; number<br/>\n&gt; &gt; of times the method is called would map to the number of parameters like<br/>\n&gt; &gt; this:<br/>\n&gt; &gt;<br/>\n&gt; &gt; 1 -&gt; 1<br/>\n&gt; &gt; 2 -&gt; 61<br/>\n&gt; &gt; 3 -&gt; 3661<br/>\n&gt; &gt; 4 -&gt; 219661<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt; --- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a> &lt;junit%40yahoogroups.com&gt; &lt;junit%<br/>\n&gt; 40yahoogroups.com&gt;, Brett Daniel<br/>\n&gt;<br/>\n&gt; &gt; &lt;brettdaniel@...&gt; wrote:<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; Berin,<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; When a theory mutates data points, it might be beneficial to recreate<br/>\n&gt; &gt; &gt; the data point for every theory invocation. Doing so prevents one<br/>\n&gt; &gt; &gt; theory execution from affecting others. I wrote about this issue in<br/>\n&gt; &gt; &gt; the following weblog post:<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.brettdaniel.com/archives/2009/09/24/200845/\">http://www.brettdaniel.com/archives/2009/09/24/200845/</a><br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; You are correct, though, that copying would avoid some of the overhead<br/>\n&gt; &gt; &gt; in calling datapoint methods. It is interesting you mention this idea,<br/>\n&gt; &gt; &gt; because I am currently overseeing two students who for their senior<br/>\n&gt; &gt; &gt; thesis project are implementing framework for copying datapoints. I<br/>\n&gt; &gt; &gt; will post more information to the mailing list as the project<br/>\n&gt; &gt; &gt; continues.<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt; &gt; Brett<br/>\n&gt; &gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt;<br/>\n&gt; [Non-text portions of this message have been removed]<br/>\n&gt;<br/>\n&gt;  <br/>\n&gt;<br/>\n<br/>\n<br/>\n[Non-text portions of this message have been removed] </span></blockquote></div>", 
    "prevInTime": 22540, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1268583322", 
    "canDelete": false, 
    "nextInTopic": 22542, 
    "prevInTopic": 22540, 
    "headers": {
        "inReplyToHeader": "PDU4ZGJhMjI1MTAwMzEyMTU0NHAzY2Q3ZGQyOGgxYTg5OWNlNjU3ZjY2YWQzQG1haWwuZ21haWwuY29tPg==", 
        "messageIdInHeader": "PGE1MjdmZGRmMTAwMzE0MDkxNWw3Mzc2MWVlMXI3ODFiYTIwZmM3NjhlNDJlQG1haWwuZ21haWwuY29tPg==", 
        "referencesHeader": "PDU4ZGJhMjI1MTAwMjE4MDk0M3EyMzhkZDhkdjExYWI0ODczNjMyMWUxNzhAbWFpbC5nbWFpbC5jb20+CSA8aGxraWYyKzNtdGVAZUdyb3Vwcy5jb20+CSA8NThkYmEyMjUxMDAzMTIxNTQ0cDNjZDdkZDI4aDFhODk5Y2U2NTdmNjZhZDNAbWFpbC5nbWFpbC5jb20+"
    }
}