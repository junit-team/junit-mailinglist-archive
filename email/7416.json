{
    "numMessagesInTopic": 7, 
    "nextInTime": 7417, 
    "senderId": "aHtIa2TS8V-JjjaPUrMTIGXFhMLblKITqnMxsbFnVwRy3YiXYgg2YFN4Re4gJjQ8Jjyh4w5ZozSG0QaQ9a_Lliq_UcCXwdc6Aa2kcicNI4-z-ObSOg", 
    "systemMessage": false, 
    "subject": "Re: [junit] Factory adaptor approach", 
    "from": "&quot;Jeff Nielsen&quot; &lt;jeff.nielsen@...&gt;", 
    "authorName": "Jeff Nielsen", 
    "msgSnippet": "Why all of the use of static methods?  Statics are globals, as far as the VM is concerned, and you can run into problems not knowing what code last set the", 
    "msgId": 7416, 
    "profile": "jeffreymads", 
    "topicId": 7358, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 65487161, 
    "messageBody": "<div id=\"ygrps-yiv-1222756627\">Why all of the use of static methods?  Statics are globals, as far as the VM<br/>\nis concerned, and you can run into problems not knowing what code last set<br/>\nthe state.  Unless every client that uses the factory explicitly configures<br/>\nthe factory before using it, you don&#39;t know what you&#39;re getting.<br/>\n<br/>\nIt seems like a cleaner, better OO design to use Factory objects (i.e.,<br/>\ninstances).  Much of what you have written remains the same, but all of the<br/>\nmethods can become instance methods.  Then you &quot;configure&quot; the factory at<br/>\nconstruction time.<br/>\n<br/>\nFor example, &quot;production&quot; code can use the default factory constructor.<br/>\n<br/>\n    myFactory = new Factory()<br/>\n    thing = myFactory.createThing()<br/>\n<br/>\nTest code can pass in arguments to the constructor.<br/>\n<br/>\n    new Factory(false)    OR<br/>\n    new Factory(overrideThing)    OR<br/>\n    new Factory().setOverrideThing(overrideThing)<br/>\n<br/>\nYou can even subclass a factory to behave in a different way, which is<br/>\nsomething else you can&#39;t do with statics.  As far as how to get a factory to<br/>\nthe class that needs to use it, you can pass it in at construction time, or<br/>\nset it as an argument, or override the factory creation method in the class<br/>\nunder test<br/>\n<br/>\nJust some ideas that have worked well for me.<br/>\n<br/>\nJeff Nielsen<br/>\nDigital Focus<br/>\nwww.digitalfocus.com<br/>\n<br/>\n<br/>\n<blockquote><span title=\"qreply\"> ----- Original Message -----<br/>\nFrom: &quot;Kevin Klinemeier&quot; &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:zipwow@...\">zipwow@...</a>&gt;<br/>\nTo: &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit@yahoogroups.com\">junit@yahoogroups.com</a>&gt;<br/>\nSent: Tuesday, April 01, 2003 1:43 PM<br/>\nSubject: [junit] Factory adaptor approach<br/>\n<br/>\n<br/>\n&gt; In response to my own problems and an earlier question, I&#39;ve been<br/>\n&gt; thinking about how to test classes that retrieve things from static<br/>\n&gt; factories.<br/>\n&gt;<br/>\n&gt; I don&#39;t want to give up being able to make these factories, but they<br/>\n&gt; typically are for things that I&#39;d want to use mock objects for<br/>\n&gt; (persistence, logging, etc).<br/>\n&gt;<br/>\n&gt; The requirements I started with were:<br/>\n&gt;<br/>\n&gt; 1. The public interface to the factory cannot change.<br/>\n&gt; 2. The factory&#39;s outputs must be editable at runtime by test classes.<br/>\n&gt; 3. The factory&#39;s outputs must be editable by classes not in the<br/>\n&gt; factory&#39;s package.<br/>\n&gt;<br/>\n&gt; What I came up with was the regular factory, with some extra logic for<br/>\n&gt; replacement.  That satisfied #2.  I made the methods protected in order<br/>\n&gt; to fulfill requirement #1.  Lastly, in order to get around the<br/>\n&gt; protected restriction for #3, I made a &#39;FactoryAdaptor&#39; that basically<br/>\n&gt; provided pass-through for those protected methods.<br/>\n&gt;<br/>\n&gt; Here&#39;s some quick example code:<br/>\n&gt;<br/>\n&gt; public class Factory {<br/>\n&gt;<br/>\n&gt;   private static overrideThing=null;<br/>\n&gt;<br/>\n&gt;   public static Thing createThing(String thingName) {<br/>\n&gt;     Thing returnThing;<br/>\n&gt;     if (overrideThing != null) {<br/>\n&gt;       returnThing=overrideThing;<br/>\n&gt;     } else {<br/>\n&gt;       do what you&#39;d normally do..<br/>\n&gt;     }<br/>\n&gt;     return returnThing;<br/>\n&gt;   }<br/>\n&gt;<br/>\n&gt;   protected static void ut_setOverrideThing(Thing overrideThing) {<br/>\n&gt;     this.overrideThing= overrideThing;<br/>\n&gt;   }<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; public class FactoryAdaptor extends Factory {<br/>\n&gt;   public static setOverrideThing(Thing overrideThing) {<br/>\n&gt;     ut_setOverrideTHing(overrideThing);<br/>\n&gt;   }<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; In the real implementation, I provided methods to &#39;clear&#39; the override,<br/>\n&gt; which is more straightforward than setting it to null.  I also provided<br/>\n&gt; methods for recording the thingNames that were requested.  In the<br/>\n&gt; future, if I need it, I may change it to specify a list of things to<br/>\n&gt; return over several requests, but I didn&#39;t need it this time around.<br/>\n&gt;<br/>\n&gt; I like this because it doesn&#39;t change the public interface, and the<br/>\n&gt; test interface can reside in the test source folder.  Those parts of<br/>\n&gt; the code that exist for unit test functionality are marked that way,<br/>\n&gt; though I may have gone too far in modifying the method naming<br/>\n&gt; convention for this.<br/>\n&gt;<br/>\n&gt; Usage is pretty straightforward, calls go to the FactoryAdaptor.<br/>\n&gt;<br/>\n&gt; Have other folks used this approach, or something similar?  What do you<br/>\n&gt; all think of this approach to the problem?<br/>\n&gt;<br/>\n&gt; Kevin Klinemeier<br/>\n&gt;<br/>\n&gt; PS:  It occurs to me now that if the factory were a little different,<br/>\n&gt; with a single static getCurrent() method and otherwise instance<br/>\n&gt; methods, this would reduce the nefarious intermingling of the &#39;mocking&#39;<br/>\n&gt; code, because the current method could return a completely different<br/>\n&gt; (mock) factory altogether.<br/>\n&gt;<br/>\n&gt; __________________________________________________<br/>\n&gt; Do you Yahoo!?<br/>\n&gt; Yahoo! Tax Center - File online, calculators, forms, and more<br/>\n&gt; <a rel=\"nofollow\" target=\"_blank\" href=\"http://platinum.yahoo.com\">http://platinum.yahoo.com</a><br/>\n&gt;<br/>\n&gt;<br/>\n&gt;       Yahoo! Groups Sponsor<br/>\n&gt;             ADVERTISEMENT<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; To unsubscribe from this group, send an email to:<br/>\n&gt; <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit-unsubscribe@yahoogroups.com\">junit-unsubscribe@yahoogroups.com</a><br/>\n&gt;<br/>\n&gt;<br/>\n&gt; Your use of Yahoo! Groups is subject to the Yahoo! Terms of Service.<br/>\n&gt;<br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 7415, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1049292221", 
    "canDelete": false, 
    "nextInTopic": 7441, 
    "prevInTopic": 7411, 
    "headers": {
        "messageIdInHeader": "PDA2MTEwMWMyZjkyMCRhYjVjMmU1MCRlNzA1MDAwYUBqbmllbHNlbjI+", 
        "referencesHeader": "PDIwMDMwNDAxMTg0MzEzLjM2Mzc5LnFtYWlsQHdlYjgwNDAyLm1haWwueWFob28uY29tPg=="
    }
}