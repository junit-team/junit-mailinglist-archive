{
    "numMessagesInTopic": 17, 
    "nextInTime": 24053, 
    "senderId": "NaY2FXEPP0YYtR3FmrftDRfGncBjRmWzz5hrx1G6p5pd_SXIEX19dfEzGb8dm7grGSsR9x8rB8STuCA9LgSGVfNk_EZQjADkn1E", 
    "systemMessage": false, 
    "subject": "JUnit 4.11-beta-1 is released", 
    "from": "Marc Philipp &lt;mphilipp82@...&gt;", 
    "authorName": "Marc Philipp", 
    "msgSnippet": "All, I am happy to announce the release of JUnit 4.11-beta-1. There have been a lot of contributions by a full cast of contributors. Thanks to everyone who", 
    "msgId": 24052, 
    "profile": "mphilipp1982", 
    "topicId": 24052, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 466871638, 
    "messageBody": "<div id=\"ygrps-yiv-1972497829\">All,<br/>\n<br/>\nI am happy to announce the release of JUnit 4.11-beta-1. There have been a lot of contributions by a full cast of contributors. Thanks to everyone who took part by reporting an issue, offering his/her opinion, or even submitting a pull request!<br/>\n<br/>\nToday, we are releasing a first beta version of 4.11. The reason is simple: We want to make sure the upgrade from Hamcrest 1.1 to 1.3 goes smoothly. Therefore, we are kindly asking you to give it a try. If you find anything we should consider, please let us know, either via this mailing list or directly on GitHub: <a rel=\"nofollow\" target=\"_blank\" href=\"https://github.com/KentBeck/junit/issues/512\">https://github.com/KentBeck/junit/issues/512</a><br/>\n<br/>\nAs usual, you can download the JARs or the complete ZIP file directly from <a rel=\"nofollow\" target=\"_blank\" href=\"https://github.com/KentBeck/junit/downloads.\">https://github.com/KentBeck/junit/downloads.</a> In addition, the jars<br/>\nhave been submitted to Maven Central and should appear there within one or two hours.<br/>\n<br/>\nYou can find the preliminary release notes on GitHub and copied below:<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"https://github.com/KentBeck/junit/blob/master/doc/ReleaseNotes4.11.txt\">https://github.com/KentBeck/junit/blob/master/doc/ReleaseNotes4.11.txt</a><br/>\n<br/>\nCheers,<br/>\n<br/>\nMarc Philipp<br/>\n<br/>\n<br/>\nSummary of changes in version 4.11 [unreleased!]<br/>\n<br/>\nMatchers: Upgrade to Hamcrest 1.3<br/>\n<br/>\nJUnit now uses the latest version of Hamcrest. Thus, you can use all the available matchers and benefit from an improved assertThat which will now print the mismatch description from the matcher when an assertion fails.<br/>\n<br/>\nExample<br/>\n<br/>\nassertThat(Long.valueOf(1), instanceOf(Integer.class));<br/>\nOld error message:<br/>\n<br/>\nExpected: an instance of java.lang.Integer<br/>\n     got: &lt;1L&gt;<br/>\nNew error message:<br/>\n<br/>\nExpected: an instance of java.lang.Integer<br/>\n     but: &lt;1L&gt; is a java.lang.Long<br/>\nHamcrest�s new FeatureMatcher makes writing custom matchers that make use of custom mismatch descriptions quite easy:<br/>\n<br/>\n@Test<br/>\npublic void featureMatcher() throws Exception {<br/>\n    assertThat(&quot;Hello World!&quot;, length(is(0)));<br/>\n}<br/>\n<br/>\nprivate Matcher&lt;String&gt; length(Matcher&lt;? super Integer&gt; matcher) {<br/>\n    return new FeatureMatcher&lt;String, Integer&gt;(matcher, &quot;a String of length that&quot;, &quot;length&quot;) {<br/>\n        @Override<br/>\n        protected Integer featureValueOf(String actual) {<br/>\n            return actual.length();<br/>\n        }<br/>\n    };<br/>\n}<br/>\nRunning this test will return the following failure message:<br/>\n<br/>\nExpected: a String of length that is &lt;0&gt;<br/>\n     but: length was &lt;12&gt;<br/>\nMost of the matchers in JUnitMatchers have been deprecated. Please use org.hamcrest.CoreMatchers directly.<br/>\n<br/>\nParameterized Tests<br/>\n<br/>\nIn order to easily identify the individual test cases in a Parameterized test, you may provide a name using the @Parameters annotation. This name is allowed to contain placeholders that are replaced at runtime:<br/>\n<br/>\n{index}: the current parameter index<br/>\n{0}, {1}, �: the first, second, and so on, parameter value<br/>\nExample<br/>\n<br/>\n@RunWith(Parameterized.class)<br/>\npublic class FibonacciTest {<br/>\n<br/>\n    @Parameters(name = &quot;{index}: fib({0})={1}&quot;)<br/>\n    public static Iterable&lt;Object[]&gt; data() {<br/>\n        return Arrays.asList(new Object[][] { { 0, 0 }, { 1, 1 }, { 2, 1 },<br/>\n                { 3, 2 }, { 4, 3 }, { 5, 5 }, { 6, 8 } });<br/>\n    }<br/>\n<br/>\n    private int input;<br/>\n    private int expected;<br/>\n<br/>\n    public FibonacciTest(int input, int expected) {<br/>\n        this.input = input;<br/>\n        this.expected = expected;<br/>\n    }<br/>\n<br/>\n    @Test<br/>\n    public void test() {<br/>\n        assertEquals(expected, Fibonacci.compute(input));<br/>\n    }<br/>\n}<br/>\nIn the example given above, the Parameterized runner creates names like [1: fib(3)=2]. If you don�t specify a name, the current parameter index will be used by default.<br/>\n<br/>\nTest execution order<br/>\n<br/>\nBy design, JUnit does not specify the execution order of test method invocations. Until now, the methods were simply invoked in the order returned by the reflection API. However, using the JVM order is unwise since the Java platform does not specify any particular order, and in fact JDK 7 returns a more or less random order. Of course, well-written test code would not assume any order, but some does, and a predictable failure is better than a random failure on certain platforms.<br/>\n<br/>\nFrom now on, JUnit will by default use a deterministic, but not predictable, order (MethodSorters.DEFAULT). To change the test execution order simply annotate your test class using @FixMethodOrder and specify one of the available MethodSorters:<br/>\n<br/>\n@FixMethodOrder(MethodSorters.JVM): Leaves the test methods in the order returned by the JVM. This order may vary from run to run.<br/>\n<br/>\n@FixMethodOrder(MethodSorters.NAME_ASCENDING): Sorts the test methods by method name, in lexicographic order.<br/>\n<br/>\nMaven artifacts<br/>\n<br/>\nUp until now there were two Maven artifacts for JUnit: junit:junit-dep and junit:junit. From a Maven point-of-view only the former made sense because it did not contain the Hamcrest classes but declared a dependency to the Hamcrest Maven artifact. The latter included the Hamcrest classes which was very un-Maven-like.<br/>\n<br/>\nFrom this release on, you should use junit:junit which will be what junit:junit-dep used to. If you still reference junit:junit-dep, Maven will automatically relocate you to the new junit:junit and issue a warning for you to fix.<br/>\n<br/>\nRules<br/>\n<br/>\nA number of improvements have been made to Rules:<br/>\n<br/>\nBoth @Rule and @ClassRule can now be used on methods that return a TestRule.<br/>\nExpectedException now always prints the stacktrace of the actual exception in case of failure.<br/>\nA parent folder can be specified for TemporaryFolder. In addition, the newFile/newFolder methods will now fail when the file or folder could not be created.<br/>\nTestWatcher has a new template method called skipped that is invoked when a test is skipped due to a failed assumption.<br/>\nImprovements to Assert and Assume<br/>\n<br/>\nassertNotEquals has been added to Assert.<br/>\nassertEquals has been overloaded in order to check whether two floats are equal given a certain float delta.<br/>\nMost methods in Assume now allow to pass a custom message.<br/>\n<br/>\n<br/>\n<br/>\n[Non-text portions of this message have been removed]</div>", 
    "prevInTime": 24051, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1350333278", 
    "canDelete": true, 
    "nextInTopic": 24053, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PEUzQjBGMzYxLUMzMEEtNDgxNC04MjdCLTJCNzE2OTkyRThBMUBtYXJjcGhpbGlwcC5kZT4="
    }
}