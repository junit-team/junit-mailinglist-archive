{
    "numMessagesInTopic": 7, 
    "nextInTime": 21586, 
    "senderId": "OHumFbvq7cqrTSNUaag2Dh8UJKqi0EQX8wBfHpdxQNPGT_t1yoBuVkktR2or8qgVvFk7zWSErO_611A_ewhw-s7U", 
    "systemMessage": false, 
    "subject": "Re: [junit] Non-static inner classes of test classes using enclosing \tfixtures?", 
    "from": "David Saff &lt;david@...&gt;", 
    "authorName": "David Saff", 
    "msgSnippet": "Paul, Have you looked at Theory support in JUnit  4.4?  It may not give you everything you want, but I d be curious to know how close it gets. Thanks, David", 
    "msgId": 21585, 
    "profile": "dsaff", 
    "topicId": 21578, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 341876227, 
    "messageBody": "<div id=\"ygrps-yiv-931565110\">Paul,<br/>\n<br/>\nHave you looked at Theory support in JUnit &gt; 4.4?  It may not give you<br/>\neverything you want, but I&#39;d be curious to know how close it gets.<br/>\nThanks,<br/>\n<br/>\n   David<br/>\n<br/>\n<blockquote><span title=\"qreply\"> On Sat, May 9, 2009 at 1:37 PM, Paul Holser &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:pholser@...\">pholser@...</a>&gt; wrote:<br/>\n&gt; Hello JUnit,<br/>\n&gt;<br/>\n&gt; I have some abstract classes that enable a caller to check that classes which expose collection fields via accessor methods do so via the java.util.Collections#unmodifiable___() facilities.  Here are some snippets:<br/>\n&gt;<br/>\n&gt; public abstract class UnmodifiableCollectionTestSupport&lt;T&gt; {<br/>\n&gt;    protected Collection&lt;T&gt; items;<br/>\n&gt;    private T containedItem;<br/>\n&gt;<br/>\n&gt;    @Before<br/>\n&gt;    public final void initializeHarness() {<br/>\n&gt;        this.items = newCollection();<br/>\n&gt;        this.containedItem = containedItem();<br/>\n&gt;<br/>\n&gt;        assertFalse(&quot;need a non-empty collection&quot;, items.isEmpty());<br/>\n&gt;        assertTrue(&quot;need an item that is in the collection&quot;, items.contains(containedItem));<br/>\n&gt;    }<br/>\n&gt;<br/>\n&gt;    @Test(expected = UnsupportedOperationException.class)<br/>\n&gt;    public final void shouldPreventAdd() {<br/>\n&gt;        // ...<br/>\n&gt;    }<br/>\n&gt;<br/>\n&gt;    // etc...<br/>\n&gt;<br/>\n&gt;    protected abstract Collection&lt;T&gt; newCollection();<br/>\n&gt;<br/>\n&gt;    protected abstract T newItem();<br/>\n&gt;<br/>\n&gt;    protected abstract T containedItem();<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; public abstract class UnmodifiableListTestSupport&lt;T&gt; extends UnmodifiableCollectionTestSupport&lt;T&gt; {<br/>\n&gt;    @Test(expected = UnsupportedOperationException.class)<br/>\n&gt;    public final void shouldPreventAddAtIndex() {<br/>\n&gt;        // ...<br/>\n&gt;    }<br/>\n&gt;<br/>\n&gt;    // etc...<br/>\n&gt;<br/>\n&gt;    protected final Collection&lt;T&gt; newCollection() {<br/>\n&gt;        return newList();<br/>\n&gt;    }<br/>\n&gt;<br/>\n&gt;    protected abstract List&lt;T&gt; newList();<br/>\n&gt;<br/>\n&gt;    private List&lt;T&gt; list() {<br/>\n&gt;        return (List&lt;T&gt;) items;<br/>\n&gt;    }<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; public class UnmodifiableListTest extends UnmodifiableListTestSupport&lt;String&gt; {<br/>\n&gt;    @Override<br/>\n&gt;    protected List&lt;String&gt; newList() {<br/>\n&gt;        return unmodifiableList(asList(&quot;foo&quot;));<br/>\n&gt;    }<br/>\n&gt;<br/>\n&gt;    protected String newItem() {<br/>\n&gt;        return &quot;bar&quot;;<br/>\n&gt;    }<br/>\n&gt;<br/>\n&gt;    protected String containedItem() {<br/>\n&gt;        return &quot;foo&quot;;<br/>\n&gt;    }<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; I am imagining an UnmodifiableMapTestSupport abstract class to do similar tests for unmodifiable maps:<br/>\n&gt;<br/>\n&gt; public abstract class UnmodifiableMapTestSupport&lt;K, V&gt; {<br/>\n&gt;    private Map&lt;K, V&gt; entries;<br/>\n&gt;    private K containedKey;<br/>\n&gt;    private V containedValue;<br/>\n&gt;<br/>\n&gt;    @Before<br/>\n&gt;    public final void initializeHarness() {<br/>\n&gt;        this.entries = newMap();<br/>\n&gt;        this.containedKey = containedKey();<br/>\n&gt;        this.containedValue = containedValue();<br/>\n&gt;<br/>\n&gt;        assertFalse(&quot;need a non-empty map&quot;, entries.isEmpty());<br/>\n&gt;        assertTrue(&quot;need a key that is in the map&quot;, entries.containsKey(containedKey));<br/>\n&gt;        assertTrue(&quot;need a value that is in the map&quot;, entries.containsValue(containedValue));<br/>\n&gt;    }<br/>\n&gt;<br/>\n&gt;    @Test(expected = UnsupportedOperationException.class)<br/>\n&gt;    public final void shouldPreventPut() {<br/>\n&gt;        // ...<br/>\n&gt;    }<br/>\n&gt;<br/>\n&gt;    protected abstract Map&lt;K, V&gt; newMap();<br/>\n&gt;<br/>\n&gt;    protected abstract K newKey();<br/>\n&gt;<br/>\n&gt;    protected abstract K containedKey();<br/>\n&gt;<br/>\n&gt;    protected abstract V containedValue();<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; Not just would I like to test that a map cannot be modified via its Map methods, but also I would like to test that the map cannot be mutated via the keySet(), values(), and entrySet() views.  It would be really nice if, when someone subclasses UnmodifiableMapTestSupport, they could get an Un modifiableCollectionTestSupport&lt;K&gt;, UnmodifiableCollectionTestSupport&lt;V&gt;, and an UnmodifiableCollectionTestSupport&lt;Map.Entry&lt;K, V&gt;&gt; instantiated, run, and result reported on for the keySet(), values(), and entrySet() views of the newMap() result.  Otherwise, they would have to hand-roll three more concretes of UnmodifiableCollectionTestSupport for testing the keySet(), values(), and entrySet() views of a given map.<br/>\n&gt;<br/>\n&gt; It occurred to me that inner classes of UnmodifiableMapTestSupport would be handy:<br/>\n&gt;<br/>\n&gt; public abstract class UnmodifiableMapTestSupport&lt;K, V&gt; {<br/>\n&gt;    // ...<br/>\n&gt;<br/>\n&gt;    @Ignore<br/>\n&gt;    class KeySetTest extends UnmodifiableCollectionTestSupport&lt;K&gt; {<br/>\n&gt;        protected K containedItem() {<br/>\n&gt;            return containedKey;<br/>\n&gt;        }<br/>\n&gt;<br/>\n&gt;        protected Collection&lt;K&gt; newCollection() {<br/>\n&gt;            return entries.keySet();<br/>\n&gt;        }<br/>\n&gt;<br/>\n&gt;        protected K newItem() {<br/>\n&gt;            return newKey();<br/>\n&gt;        }<br/>\n&gt;    }<br/>\n&gt;<br/>\n&gt;    @Ignore<br/>\n&gt;    class ValuesTest extends UnmodifiableCollectionTestSupport&lt;V&gt; {<br/>\n&gt;        protected V containedItem() {<br/>\n&gt;            return containedValue;<br/>\n&gt;        }<br/>\n&gt;<br/>\n&gt;        protected Collection&lt;V&gt; newCollection() {<br/>\n&gt;            return entries.values();<br/>\n&gt;        }<br/>\n&gt;<br/>\n&gt;        protected V newItem() {<br/>\n&gt;            return null;<br/>\n&gt;        }<br/>\n&gt;    }<br/>\n&gt;<br/>\n&gt;    @Ignore<br/>\n&gt;    class EntriesTest extends UnmodifiableCollectionTestSupport&lt;Map.Entry&lt;K, V&gt;&gt; {<br/>\n&gt;        protected Entry&lt;K, V&gt; containedItem() {<br/>\n&gt;            return new Map.Entry&lt;K, V&gt;() {<br/>\n&gt;                public K getKey() {<br/>\n&gt;                    return containedKey;<br/>\n&gt;                }<br/>\n&gt;<br/>\n&gt;                public V getValue() {<br/>\n&gt;                    return containedValue;<br/>\n&gt;                }<br/>\n&gt;<br/>\n&gt;                public V setValue(V value) {<br/>\n&gt;                    throw new UnsupportedOperationException();<br/>\n&gt;                }<br/>\n&gt;<br/>\n&gt;                public boolean equals(Object that) {<br/>\n&gt;                    if (!(that instanceof Map.Entry&lt;?, ?&gt;))<br/>\n&gt;                        return false;<br/>\n&gt;<br/>\n&gt;                    Map.Entry&lt;?, ?&gt; other = (Map.Entry) that;<br/>\n&gt;                    return ObjectUtils.equals(getKey(), other.getKey())<br/>\n&gt;                        && ObjectUtils.equals(getValue(), other.getValue());<br/>\n&gt;                }<br/>\n&gt;<br/>\n&gt;                public int hashCode() {<br/>\n&gt;                    return ObjectUtils.hashCode(getKey()) ^ ObjectUtils.hashCode(getValue());<br/>\n&gt;                }<br/>\n&gt;            };<br/>\n&gt;        }<br/>\n&gt;<br/>\n&gt;        protected Collection&lt;Entry&lt;K, V&gt;&gt; newCollection() {<br/>\n&gt;            return entries.entrySet();<br/>\n&gt;        }<br/>\n&gt;<br/>\n&gt;        protected Entry&lt;K, V&gt; newItem() {<br/>\n&gt;            return null;<br/>\n&gt;        }<br/>\n&gt;    }<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; The inner classes are not static, and are @Ignore&#39;d so that the runner doesn&#39;t report instantiation problems (non-static inner classes don&#39;t get a zero-arg ctor, which the default runner requires).  I could have, say, runAll() methods on each of these inner classes, and then have @Test methods on UnmodifiableMapTestSupport that instantiate one of the inner classes and call any @Befores followed by runAll() followed by any @After on them.  But then, runAll() would have to be smart enough to run all the tests, including not bailing out at the first UnsupportedOperationException.  Also, the results of running those tests would not get reported along with the @Test methods of UnmodifiableMapTestSupport.<br/>\n&gt;<br/>\n&gt; Is there a cleaner way to accomplish my goal?  Maybe using a special kind of Runner?  Am I missing a more obvious solution?<br/>\n&gt;<br/>\n&gt; Thanks much.<br/>\n&gt;<br/>\n&gt; Paul Holser<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; ------------------------------------<br/>\n&gt;<br/>\n&gt; Yahoo! Groups Links<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 21584, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1242054360", 
    "canDelete": false, 
    "nextInTopic": 21587, 
    "prevInTopic": 21578, 
    "headers": {
        "inReplyToHeader": "PGd1NGYxbStrYnBmQGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PDRmN2RhNmI5MDkwNTExMDgwNnExNGM4ODFlM3ZiN2UxZGVmZWE4Y2MwYzYyQG1haWwuZ21haWwuY29tPg==", 
        "referencesHeader": "PGd1NGYxbStrYnBmQGVHcm91cHMuY29tPg=="
    }
}