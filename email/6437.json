{
    "numMessagesInTopic": 108, 
    "nextInTime": 6438, 
    "senderId": "br_oiQ874IK7JjpLWGnlgVujeSqg5waPxJUrdFetKmczuWolY5JiVQT2EahBsRwY5OBFomiAGr0NWC-_6WCdgSqHgQmzNsnRyl_8UUGaRWry", 
    "systemMessage": false, 
    "subject": "Re: [junit] Re: Testing Private Methods", 
    "from": "&quot;Lauren Bish&quot; &lt;developerdude@...&gt;", 
    "authorName": "Lauren Bish", 
    "msgSnippet": "Excuse me if I weigh in on this subject with a few thoughts: 1) I agree with the sentiment that testing behaviors is the desired methodology for writing tests", 
    "msgId": 6437, 
    "profile": "gs_nomad", 
    "topicId": 1696, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 117292773, 
    "messageBody": "<div id=\"ygrps-yiv-1941084983\">Excuse me if I weigh in on this subject with a few thoughts:<br/>\n<br/>\n1) I agree with the sentiment that testing behaviors is the desired<br/>\nmethodology for writing tests rather than explcitily testing methods<br/>\nthemselves. You eventually wind up testing methods, but since the purpose is<br/>\nto find bugs, and find them as early as possible, behavioral testing should<br/>\nbe the focus. This may seem to conflict with how some people do or view TDD,<br/>\nand it does require viewing the Code Under Test in a more abstract manner,<br/>\nbut that is generally a &quot;good thing&quot;.<br/>\n<br/>\nBehavioral testing is good because it helps the code writer/tester keep the<br/>\n&quot;big picture&quot; in mind rather than getting lost in the code, and because<br/>\nwhile the code itself may go through several iterations, behavior changes<br/>\nless often - this results in more flexible tests, test code that needs to<br/>\nchange less often, and it keeps a high degree of separation between the code<br/>\nexecuting the tests and the CUT. Closely bound code is a bad thing, whether<br/>\nit is in testing code or the CUT, or between the two.<br/>\n<br/>\n2) Behavioral testing results in higher reuse of the test code. It may also<br/>\nresult in higher reuse of the CUT since it may help reusable patterns<br/>\nemerge.<br/>\n<br/>\n3) Being both a developer and a SQA engineer, I often write unit tests for<br/>\nother people&#39;s code. TDD is relatively new and unused by much of the<br/>\nindustry, unit-testing in general having been in use much longer. I usually<br/>\ntest at a more abstract level. I don&#39;t use the terms &quot;white-box&quot; and<br/>\n&quot;black-box&quot; for testing as much as unit-testing, module testing, sub-system<br/>\nand system testing, integration and acceptance testing.<br/>\n<br/>\nAlmost anything at any level can be thought of as a black box, and to<br/>\ninitially test a unit I don&#39;t really need to have a white-box knowledge<br/>\nlevel of the code - just the interface, method signatures and preferably the<br/>\nJavaDocs. Indeed, I prefer not to look at the internal code of a unit at<br/>\nfirst - I find I am more productive, more generalized and less biased in how<br/>\nI test if I treat the unit as a black box first, then drill down into the<br/>\nactual code later. This way my testing code tends to be less tied to the<br/>\nCUT; e.g., I don&#39;t know or at this point care whether the CUT uses a Vector<br/>\nor an Array to store items.<br/>\n<br/>\n4) To make sure that non-visable methods are properly tested, code coverage<br/>\ntools should be used in lieu of explicitly writing tests for these<br/>\nnon-visible methods or code. This results in making explicitly sure that all<br/>\ncode is actually tested (more so than writing tests that access private<br/>\nmethods directly) - which is the purpose, it is more productive, and it may<br/>\npoint out unused code or logic errors missed by just assuming that because<br/>\nthe test passed the code has been completely tested. Testing code is only as<br/>\ngood the measured results. Pass/fails are one type of result, code coverage<br/>\nmetrics are another - the latter more qualitative than the former - and they<br/>\nshould be used together.<br/>\n<br/>\nGranted the above observations and opinions come more from my viewpoint as a<br/>\ntester of other people&#39;s code, but I believe they are valid. I have noticed<br/>\nthat much of the test code written during TDD tends to be skimpy in coverage<br/>\n(both code and test conditions), and because it is usually highly bound to<br/>\nthe CUT it is often not maintained well when the code is changed. Few<br/>\ndevelopers write good tests, even fewer can test their own code well. As<br/>\nsuch, while I encourage TDD since it is productive in its own right - I also<br/>\nmandate that more extensive unit tests be written from a more abstract view<br/>\noutside of the code. This usually entails a person, other than the original<br/>\ncoder, writing more extensive unit tests. Almost invariably, these tests are<br/>\nbest maintained separate from the original code.<br/>\n<br/>\nFWIW,<br/>\nLauren<br/>\n<br/>\n=====<br/>\nLooking for an experienced Java/C++ Software Engineer?<br/>\nSee: <a rel=\"nofollow\" target=\"_blank\" href=\"http://developerdude.mystarband.net/resume.html\">http://developerdude.mystarband.net/resume.html</a></div>", 
    "prevInTime": 6436, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1039889594", 
    "canDelete": false, 
    "nextInTopic": 6438, 
    "prevInTopic": 6436, 
    "headers": {
        "messageIdInHeader": "PDAyMzEwMWMyYTM5YyRhODcyNjQ5MCQwMzlhNDA5NEBHb3J0Pg==", 
        "referencesHeader": "PGF0ZWNiMit2MW05QGVHcm91cHMuY29tPg=="
    }
}