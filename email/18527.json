{
    "numMessagesInTopic": 23, 
    "nextInTime": 18528, 
    "senderId": "RLv4IEUq8OK8mVaXJICDqUCNV1GPPCZFmCX1IuPP0KtzXsb1e4UIAzb7DeKRLdbEFPQKlGyULCzTbEJ8cafJ-Wtz_mR6vs-7uMH-hmfVIxlGtq3AB3mXTiE8", 
    "systemMessage": false, 
    "subject": "Re: Essay: The Trouble With JUnit", 
    "from": "&quot;Jan Theodore Galkowski&quot; &lt;jtgalkowski@...&gt;", 
    "authorName": "Jan Theodore Galkowski", 
    "msgSnippet": "Hi David, Well, it s from the work of Tony Hoare and others that if programs are annotated with a rich enough (minimally complete) set of pre- and post- ", 
    "msgId": 18527, 
    "profile": "ekzept", 
    "topicId": 18392, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 280430, 
    "messageBody": "<div id=\"ygrps-yiv-62863601\">Hi David,<br/>\n<br/>\nWell, it&#39;s from the work of Tony Hoare and others that if programs are<br/>\nannotated with a rich enough (minimally complete) set of pre- and post-<br/>\nconditions describing state changes using predicate assertions, it&#39;s<br/>\npossible to delete the intervening program (or state transformation)<br/>\nsteps and &quot;execute&quot; the program using just the stated pre- and post-<br/>\nconditions.  This is part of the motivation behind Bertrand Meyer&#39;s work<br/>\nwith Eiffel and Design By Contract.<br/>\n<br/>\nThis is not, at present, a part of the test-driven methodology, as far<br/>\nas I know, but it is implicit in the sense that by writing tests first,<br/>\nthe requirements for the code under test are supposed to be expressed in<br/>\nthe tests.  Then, one invests in the &quot;throw anything at it&quot; cycle where<br/>\ncode is written, tested using an xUnit, if it&#39;s red, add another<br/>\nassertion to cover the case missed. If it&#39;s green, extend the scope of<br/>\nthe requirements to better approximate what&#39;s wanted.  There&#39;s cleanup<br/>\nvia refactoring needed for code.<br/>\n<br/>\nAs mentioned, refactoring should probably be applied to the tests as<br/>\nwell, assuming they are complicated enough.  And, what I&#39;m getting at is<br/>\nthat perhaps the language of predicates, as well known and studied as it<br/>\nis, isn&#39;t quite enough to make truly requirements-level test<br/>\nprescriptions easy.<br/>\n<br/>\nLet&#39;s get narrow and specific for a moment.  Suppose you have a Python-<br/>\nlike language and want to assert that the head of a list L is &#39;foo&#39;:<br/>\n<br/>\n  &#39;foo&#39; == L[0]<br/>\n<br/>\nSure, but you&#39;re obligated also to test first that L has at least one<br/>\nelement, lest the assertion itself fail.  Yes, you can check first<br/>\n<br/>\n  1 &lt;= L.count(&#39;foo&#39;)<br/>\n<br/>\nthen<br/>\n<br/>\n   &#39;foo&#39; == L[0]<br/>\n<br/>\nor even<br/>\n<br/>\n   1 &lt;= L.count(&#39;foo&#39;) and &#39;foo&#39; == L[0]<br/>\n<br/>\nrelying upon short-circuiting evaluation, but wouldn&#39;t it be easier to<br/>\nuse some kind of Prolog-like matching notation<br/>\n<br/>\n    L == [: &#39;foo&#39; . % :]<br/>\n<br/>\nwhere I&#39;ve arbitrarily co-opted special brackets &quot;[:&quot; and &quot;:]&quot; to<br/>\nindicate the (LISP) CONS-like pairing?  If actually realized in Python<br/>\nthe notation could be built into a tuple, but the idea would be if the<br/>\nmatch fails, the assertion fails.<br/>\n<br/>\nIf requirements are the focus of a test-driven approach, then the (a)<br/>\nlanguage for expressing tests ought to not tie up the hands of the<br/>\nprogrammer with worries about ancillary conditions, (b) it ought to be<br/>\nperspicacious, and (c) it should allow an economy of expression which<br/>\npredicates and the base language don&#39;t.  The problems of writing &quot;bigger<br/>\nrequirements&quot; get, well, bigger if the conditions tested rely upon<br/>\nexogenous factors, like status of external resources or the execution of<br/>\nother whole subsystems.  At present, I suppose try-except-else could be<br/>\nput into the tests, but I think that&#39;s really a distraction.  I&#39;d<br/>\nprobably encapsulate it in a function and then call the function in the<br/>\nassertion.  All I&#39;m asking is why? and can&#39;t we do better?<br/>\n<br/>\nI&#39;m sure once such a natural patterns sublanguage was decided, it could<br/>\nbe built with present facilities in something like Python, Smalltalk,<br/>\nSCHEME, LISP, probably Java and C#.  As for jsunit,  phpunit,  other<br/>\nsuch,  I have my doubts.  There&#39;s a point of separation here: xUnit is a<br/>\nubiquitous metapattern for testing.  Here, when seeing &quot;tests&quot; as a<br/>\nmeans of stating program requirements, we&#39;re leaving ubiquity aside and<br/>\nreaching for bigger things.<br/>\n<br/>\nLeaving the narrow and specific, don&#39;t we really want to separate tests<br/>\nof a program fragment into two different kinds?  One kind tests whether<br/>\nthe conditions we expect to be established for the fragment to execute<br/>\nare actually there, the precondition.  The other kind tests whether the<br/>\nfragment actually achieved what we expect it to, the postcondition.<br/>\nPreconditions are in part a check that our tests themselves are properly<br/>\nformed.  In fact, although there&#39;s value in the unit-testing emphasis of<br/>\ntest-driven, we might carry these new kinds of test assertions over to<br/>\n&quot;string testing&quot;, where each program fragment brings its precondition<br/>\nwith it preceding it, and a postcondition with it succeeding it, and we<br/>\ncan then test a series of fragments at once.<br/>\n<br/>\nThis is a small step away from Meyer&#39;s ultimate world.  I&#39;ve often<br/>\nthought how nice it would be if the methods of a class could be<br/>\ndiscriminated among not only by their signature (argument numbers and<br/>\ntypes), but by an Eiffel-like &quot;require&quot; precondition that needs to be<br/>\nsatisfied before the method is picked.  This would further suppress the<br/>\nneed for case analysis in nested if-then-else structures.<br/>\n<br/>\nThere&#39;s more opportunity for innovation in notation with postconditions,<br/>\ntoo.  How often have *you* wanted to readily express a test relating the<br/>\nvalue of a variable after a fragment to that before it?  Sure, you can<br/>\ndo this by introducing new variables in the test fixture, declaring them<br/>\nappropriately where that&#39;s needed, but wouldn&#39;t it be nice to have a<br/>\nsimple notation for it, like for a list L, checking that &#39;foo&#39; was<br/>\nproperly appended (using Python terminology again):<br/>\n<br/>\n    +L == -L.append(&#39;foo&#39;)<br/>\n<br/>\nif the prefix operators &quot;+&quot; and &quot;-&quot; were used to denote &quot;after&quot; and<br/>\n&quot;before&quot;, respectively.<br/>\n<br/>\nWhether there should also be a special class of tests for loop or<br/>\nrecursion invariants is something that needs further thought.<br/>\n<br/>\nDavid, does this help?<br/>\n<br/>\n -- Jan</div>", 
    "prevInTime": 18526, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1165856942", 
    "canDelete": false, 
    "nextInTopic": 18528, 
    "prevInTopic": 18525, 
    "headers": {
        "messageIdInHeader": "PDExNjU4NTY5NDIuMTAwMjUuMjc5OTA0MDIzQHdlYm1haWwubWVzc2FnaW5nZW5naW5lLmNvbT4="
    }
}