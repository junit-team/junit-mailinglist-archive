{
    "numMessagesInTopic": 27, 
    "nextInTime": 17857, 
    "senderId": "RjHU_j_rIGLebvoJtVbDz2UFrkqqXY4VPSlFsSym30Bk_yFwYC86G-5R6wno-3WbaUan-4mFNdY0EUcwIYORJ8cxCg0eDEgEc34X04Bq9Q-r2mzA6MuIlEKngA", 
    "systemMessage": false, 
    "subject": "Re: [junit] JUnit Testing Code That Has System.exit(n);", 
    "from": "Andrew McDonagh &lt;yahoogroups@...&gt;", 
    "authorName": "Andrew McDonagh", 
    "msgSnippet": "Hi Bob, I ll comment on the / ...developer had implemented System.exit(n) throughout the application whenever there was a trapped exception... /later, but for", 
    "msgId": 17856, 
    "profile": "andy_ipaccess", 
    "topicId": 17851, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 234174584, 
    "messageBody": "<div id=\"ygrps-yiv-1865761450\">Hi Bob,<br/>\n<br/>\nI&#39;ll comment on the /&#39;...developer had implemented System.exit(n) <br/>\nthroughout the application whenever there was a trapped exception...&#39; <br/>\n/later, but for now here&#39;s how to write your tests...<br/>\n<br/>\n<br/>\nGiven this kind of class......<br/>\n<br/>\n<br/>\n<br/>\npublic class SomethingThatCallsExit {<br/>\n<br/>\n    public int add(int num1, int num2) {<br/>\n         if( num1 &lt; 0) {<br/>\n           System.exit(2);<br/>\n        }<br/>\n<br/>\n       return num1 + num2;<br/>\n    }<br/>\n<br/>\n}<br/>\n<br/>\n<br/>\nWhen trying to test it we need to provide a substitute  (delegate) for <br/>\nit to call System.exit(); on, instead of doing it itself, so that we <br/>\ndont call System.exit during our test runs.<br/>\n<br/>\n<br/>\nLets create the Interface that our delegate will need to implement....<br/>\n<br/>\npublic interface SystemExiter {<br/>\n  void exit(int reason);<br/>\n}<br/>\n<br/>\n<br/>\nNow lets create a Fake implementation of the interface for use within <br/>\nour tests.<br/>\n<br/>\npublic class FakeSystemExiter implements SystemExiter {<br/>\n<br/>\n   public boolean   wasExitCalled;<br/>\n   public int exitReason = -999;  // number not used by our app so other <br/>\ntests know if it was set<br/>\n<br/>\n   public void exit(int reason) {<br/>\n      wasExitCalled = true;<br/>\n      exitReason = reason;<br/>\n   }<br/>\n}<br/>\n<br/>\n<br/>\nNow lets create the real implementation....<br/>\n<br/>\n<br/>\npublic class RealSystemExiter implements SystemExiter {<br/>\n<br/>\n   public void exit(int reason) {<br/>\n      System.exit(reason);<br/>\n   }<br/>\n}<br/>\n<br/>\n<br/>\nSo now we have the necessary interface and classes to test, we have a <br/>\nchoice on how to use them.<br/>\n<br/>\nFirst. we could simply pass the delegate (the real and the fake) to the <br/>\nclass....<br/>\n<br/>\nSo we need to change our class by adding a new constructor parameter and <br/>\nchanging how it calls exit.<br/>\n<br/>\npublic class SomethingThatCallsExit {<br/>\n<br/>\n   private SystemExiter systemExiter;<br/>\n<br/>\n   public SomethingThatCallsExit( SystemExiter exiter) {<br/>\n       systemExiter = exiter;<br/>\n   }<br/>\n<br/>\n   public int add(int num1, int num2) {<br/>\n       if( num1 &lt; 0) {<br/>\n          //System.exit(2);<br/>\n         exiter.exit(2);<br/>\n      }<br/>\n      return num1 + num2;<br/>\n   }<br/>\n<br/>\n}<br/>\n<br/>\nNow we can test it like so...<br/>\n<br/>\npublic class SomethingThatCallsExitTests extends Testcase {<br/>\n<br/>\n  public void testTryingToAddNegativeNumberStopsApp () {<br/>\n      FakeSystemExiter exiter = new FakeSystemExiter();<br/>\n      SomethingThatCallsExit calc = new SomethingThatCallsExit ( exiter  );<br/>\n<br/>\n      calc.add( -1 , 1);<br/>\n<br/>\n     assertTrue(&quot;Exit not called!&quot;, exiter.wasExitCalled );    <br/>\n  }<br/>\n}<br/>\n<br/>\nThis does mean that the application code that creates and uses the class <br/>\nunder test (not shown here) would need to be modified to pass the <br/>\nconstructor parameter.<br/>\n<br/>\nThis is a nice and clean way of setting the delegate though.<br/>\n<br/>\n<br/>\nThe second approach is useful if we can&#39;t (don&#39;t want to) change the <br/>\ncode that creates and uses our class under test. This means our class <br/>\nunder test has to create the real exiter itself and during testing we <br/>\nneed to use a hook into this creation, so we can over ride it and <br/>\nprovide our fake.<br/>\n<br/>\nFirst lets rewrite the class so it creates the exiter....<br/>\n<br/>\npublic class SomethingThatCallsExit {<br/>\n<br/>\n   public int add(int num1, int num2) {<br/>\n       if( num1 &lt; 0) {<br/>\n          //System.exit(2);<br/>\n          SystemExiter systemExiter = createExiter();<br/>\n         exiter.exit(2);<br/>\n      }<br/>\n      return num1 + num2;<br/>\n   }<br/>\n<br/>\n  // real implementation<br/>\n   protected SystemExiter createExiter() {<br/>\n      return new RealSystemExiter();<br/>\n   }<br/>\n<br/>\n}<br/>\n<br/>\n<br/>\nNow lets write the test to over ride the &#39;createExiter()&#39; method to <br/>\nreturn our fake.<br/>\n<br/>\npublic class SomethingThatCallsExitTests extends Testcase {<br/>\n<br/>\n    public class TestableSomethingThatCallsExit extends  <br/>\nSomethingThatCallsExit{<br/>\n     <br/>\n         protected SystemExiter createExiter() {<br/>\n             return systemExiter;<br/>\n         }<br/>\n<br/>\n    }<br/>\n<br/>\n  <br/>\n<br/>\n  public void testTryingToAddNegativeNumberStopsApp () {<br/>\n      systemExiter = new FakeSystemExiter();<br/>\n      TestableSomethingThatCallsExit calc = new <br/>\nTestableSomethingThatCallsExit ();<br/>\n<br/>\n      calc.add( -1 , 1);<br/>\n<br/>\n     assertTrue(&quot;Exit not called!&quot;, exiter.wasExitCalled );    <br/>\n  }<br/>\n}<br/>\n<br/>\n<br/>\n<br/>\nSo there you go....two ways of injecting a fake exiter into the class <br/>\nunder test, so that we can test it without the real System.exit() being <br/>\ncalled.<br/>\n<br/>\nHTH<br/>\n<br/>\nAndrew<br/>\n<br/>\n<br/>\nBob Russell wrote:<br/>\n<blockquote><span title=\"qreply\"> &gt;<br/>\n&gt;<br/>\n&gt; I&#39;m involved on a project as the QA. To improve my development<br/>\n&gt; skills and my JUnit skills, I am writing some JUnit tests. Today, I<br/>\n&gt; found that the developer had implemented System.exit(n) throughout<br/>\n&gt; the application whenever there was a trapped exception.<br/>\n&gt;<br/>\n&gt; Now, the requirements call for the application to return some exit<br/>\n&gt; code telling any downstream processes whether this application was<br/>\n&gt; 100% successful with no warnings (rc=0), 100% successful with<br/>\n&gt; warnings (rc=4), not successful at all (rc=8). However, the only<br/>\n&gt; java mechanism for reporting return codes is System.exit(n), based on<br/>\n&gt; my use of Google.<br/>\n&gt;<br/>\n&gt; My JUnit dilemma then, is that System.exit(n) gives the required<br/>\n&gt; application behavior but doesn&#39;t seem to be good for running JUnit<br/>\n&gt; tests from a test suite since System.exit(n) ends the JVM.<br/>\n&gt;<br/>\n&gt; Does anyone have any insights they can share? Since this is my first<br/>\n&gt; post to this forum, I&#39;m happy to Google some more if you&#39;ll only give<br/>\n&gt; me some keyword hint(s) beyond what I&#39;ve already tried: &quot;java exit<br/>\n&gt; code&quot;.<br/>\n&gt;<br/>\n&gt; Thanks!<br/>\n&gt;<br/>\n&gt; <br/>\n&gt; ------------------------------------------------------------------------<br/>\n&gt;<br/>\n&gt; No virus found in this incoming message.<br/>\n&gt; Checked by AVG Free Edition.<br/>\n&gt; Version: 7.1.405 / Virus Database: 268.12.2/441 - Release Date: 07/09/2006<br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 17855, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1157669458", 
    "canDelete": false, 
    "nextInTopic": 17857, 
    "prevInTopic": 17855, 
    "headers": {
        "inReplyToHeader": "PGVkcTJzOStvZGVrQGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PDQ1MDBBMjUyLjUwNzA3MDlAYW5kcmV3bWNkb25hZ2guZjJzLmNvbT4=", 
        "referencesHeader": "PGVkcTJzOStvZGVrQGVHcm91cHMuY29tPg=="
    }
}