{
    "topicId": 24565, 
    "postDate": "1406321798", 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "from": "Stefan Penndorf &lt;stefan@...&gt;", 
    "canDelete": false, 
    "replyTo": "LIST", 
    "senderId": "lTPHs7z5kK6gICfMsx3h4_1sOlF6uT7JdObv29dktUWjTY5xLZlBtUDHZ5cQsBDlg9oGmbFfO2mrk9CnduFe3vhWKM9tYy_XwpOuGw", 
    "nextInTime": 24570, 
    "userId": 515214438, 
    "prevInTime": 24568, 
    "prevInTopic": 24568, 
    "headers": {
        "inReplyToHeader": "PDIwMTQwNzI0MjA0OTMyLkdDMjMwOTZAZmF1aTIwZS5pbmZvcm1hdGlrLnVuaS1lcmxhbmdlbi5kZT4=", 
        "messageIdInHeader": "PDUzRDJDNDg2LjMwNjA1MDRAY3lwaG9yaWEubmV0Pg==", 
        "referencesHeader": "PDIwMTQwNzI0MjA0OTMyLkdDMjMwOTZAZmF1aTIwZS5pbmZvcm1hdGlrLnVuaS1lcmxhbmdlbi5kZT4="
    }, 
    "authorName": "Stefan Penndorf", 
    "numMessagesInTopic": 7, 
    "msgSnippet": "Hi Tobi, I think it s really hard to address those things. I agree with Esko that those concerns are rare in every-day projects. If you re using timeouts in", 
    "contentTrasformed": false, 
    "msgId": 24569, 
    "nextInTopic": 24570, 
    "systemMessage": false, 
    "rawEmail": "Return-Path: &lt;stefan@...&gt;\r\nReceived: (qmail 17664 invoked by uid 7800); 25 Jul 2014 21:12:32 -0000\r\nX-Sender: stefan@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nX-Received: (qmail 15848 invoked by uid 102); 25 Jul 2014 20:56:49 -0000\r\nX-Received: from unknown (HELO mtaq1.grp.bf1.yahoo.com) (10.193.84.32)\n  by m13.grp.bf1.yahoo.com with SMTP; 25 Jul 2014 20:56:49 -0000\r\nX-Received: (qmail 6650 invoked from network); 25 Jul 2014 20:56:48 -0000\r\nX-Received: from unknown (HELO mail.worldserver.net) (98.139.170.166)\n  by mtaq1.grp.bf1.yahoo.com with SMTP; 25 Jul 2014 20:56:48 -0000\r\nX-Received: from [192.168.178.27] (95-91-18-244-dynip.superkabel.de [95.91.18.244])\n\t(Authenticated sender: stefan@...)\n\tby mail.worldserver.net (Postfix) with ESMTPSA id ECEFB30051F\n\tfor &lt;junit@yahoogroups.com&gt;; Fri, 25 Jul 2014 22:56:43 +0200 (CEST)\r\nMessage-ID: &lt;53D2C486.3060504@...&gt;\r\nDate: Fri, 25 Jul 2014 22:56:38 +0200\r\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:24.0) Gecko/20100101 Thunderbird/24.6.0\r\nMIME-Version: 1.0\r\nTo: junit@yahoogroups.com\r\nReferences: &lt;20140724204932.GC23096@...-erlangen.de&gt;\r\nIn-Reply-To: &lt;20140724204932.GC23096@...-erlangen.de&gt;\r\nContent-Type: multipart/alternative;\n boundary=&quot;------------010404020009040501050705&quot;\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nSubject: Re: [junit] Side effects between test cases\r\nX-Yahoo-Group-Post: member; u=515214438\r\nX-Original-From: Stefan Penndorf &lt;stefan@...&gt;\r\nX-eGroups-Approved-By: dsaff &lt;david@...&gt; via email; 25 Jul 2014 21:12:32 -0000\r\nFrom: Stefan Penndorf &lt;stefan@...&gt;\r\n\r\n\r\n--------------010404020009040501050705\r\nContent-Type: text/plain; charset=ISO-8859-1; format=flowed\r\nContent-Transfer-Encoding: 7bit\r\n\r\nHi Tobi,\n\nI think it&#39;s really hard to address those things. I agree with Esko that \nthose concerns are rare in &quot;every-day&quot; projects.\n\nIf you&#39;re using timeouts in tests those might not be _unit_ tests but \n_integration_ tests. That said you should consider separating them from \nthe &quot;real&quot; unit tests. If you&#39;re a maven user you could use failsafe to \nrun those. With failsafe you could use multiple JVMs or a JVM per \ntest(class) if memory is an issue. I always configure a larger heap for \nintegration tests than for unit tests which will reduce the likelyhood \nof OutOfMemoryErrors. I would avoid that but you could trigger garbage \ncollection in @Before or @BeforeClass or @After methods.\n\nIf you&#39;re having long running code you should check \nThread.isInterrupted() and exit the computation or throw an \nInterruptedException(). This applies to long running test code and will \nalso be good practice for long running production code. For example you \ncould insert the check between line 40 and 41 of your example [1] and \nthrow InterruptedException or return &quot;silently&quot;. See also [2] for more \ndetails.\nNevertheless if I experienced long running production code in the wild \nthere was always I/O involved - most I/O operations do throw \nInterruptedExceptions themselfes. And - additionally - if I/O is \ninvolved those tests are no longer unit tests.\n\n------\nBut that won&#39;t safe you from infinite loops in production code tested by \nreal unit tests. If your team executes all unit tests before checking \nin, those infinite loops will only occur once on developer machines and \nshould be fixed before checking code in. If there&#39;s an infinite loop and \nno timeout configured the developer will see the test causing the \ninfinite loop and fix it.\n\n\nMaybe you could explain further why timing is an issue for you. And \nmaybe you can also describe the code and project that causes the issue.\n\nStefan\n\n[2] Java Concurrency in Practice by Brian Goetz et al.\n\nAm 24.07.2014 22:49, schrieb Tobias Werth Tobias.Werth@... [junit]:\n&gt;\n&gt; Hi,\n&gt;\n&gt; I wanted to discuss two side effects between multiple JUnit test\n&gt; methods:\n&gt;\n&gt; a) timing issues\n&gt; If a test method runs into a timeout, the executing thread is\n&gt; interrupted (but not stopped). Hence, if it executes an infinite loop,\n&gt; it will still occupy some of your resources after this test failed.\n&gt;\n&gt; For an example, see [1]. The helper method is executed either once or\n&gt; infinite often in a loop. If executed once, it runs approx. 100ms on my\n&gt; machine. If executed in a loop, JUnit&#39;s runtime is approx. 600ms times\n&gt; for a single parameterized run.\n&gt; Executing 10 infinite loops first and then 10 single helper calls\n&gt; results in more than 10 timeouts (which is set to 500ms). You may have\n&gt; to increase NUM_RUNS on your machine to reproduce.\n&gt;\n&gt; b) memory issues\n&gt; It&#39;s easy to construct cases from the above insight (threads may keep\n&gt; running in case of a timeout) with side effects on memory which lead to\n&gt; an OutOfMemoryError.\n&gt; Even when threads do not keep running, and one test allocates many\n&gt; objects, the garbage collector may kick in during the execution of the\n&gt; next test method. This may result in an timeout that is not caused by\n&gt; the code under test but by the previous massive object allocation.\n&gt;\n&gt; I know that&#39;s almost impossible to stop Java threads. I also assume that\n&gt; both side effects are well known.\n&gt;\n&gt; So what&#39;s the best practice to reduce or even avoid these side effects\n&gt; when writing JUnit test methods?\n&gt;\n&gt; Cheers,\n&gt; Tobi\n&gt;\n&gt; --\n&gt; 1: https://gist.github.com/meisterT/97db378abea366036f36\n&gt;\n&gt; \n\n\r\n--------------010404020009040501050705\r\nContent-Type: text/html; charset=ISO-8859-1\r\nContent-Transfer-Encoding: 7bit\r\n\r\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta content=&quot;text/html; charset=ISO-8859-1&quot;\n      http-equiv=&quot;Content-Type&quot;&gt;\n  &lt;/head&gt;\n  &lt;body text=&quot;#000000&quot; bgcolor=&quot;#FFFFFF&quot;&gt;\n    &lt;div class=&quot;moz-cite-prefix&quot;&gt;Hi Tobi,&lt;br&gt;\n      &lt;br&gt;\n      I think it&#39;s really hard to address those things. I agree with\n      Esko that those concerns are rare in &quot;every-day&quot; projects.&lt;br&gt;\n      &lt;br&gt;\n      If you&#39;re using timeouts in tests those might not be _unit_ tests\n      but _integration_ tests. That said you should consider separating\n      them from the &quot;real&quot; unit tests. If you&#39;re a maven user you could\n      use failsafe to run those. With failsafe you could use multiple\n      JVMs or a JVM per test(class) if memory is an issue. I always\n      configure a larger heap for integration tests than for unit tests\n      which will reduce the likelyhood of OutOfMemoryErrors. I would\n      avoid that but you could trigger garbage collection in @Before or\n      @BeforeClass or @After methods.&lt;br&gt;\n      &lt;br&gt;\n      If you&#39;re having long running code you should check\n      Thread.isInterrupted() and exit the computation or throw an\n      InterruptedException(). This applies to long running test code and\n      will also be good practice for long running production code. For\n      example you could insert the check between line 40 and 41 of your\n      example [1] and throw InterruptedException or return &quot;silently&quot;.\n      See also [2] for more details.&lt;br&gt;\n      Nevertheless if I experienced long running production code in the\n      wild there was always I/O involved - most I/O operations do throw\n      InterruptedExceptions themselfes. And - additionally - if I/O is\n      involved those tests are no longer unit tests.&lt;br&gt;\n      &lt;br&gt;\n      ------&lt;br&gt;\n      But that won&#39;t safe you from infinite loops in production code\n      tested by real unit tests. If your team executes all unit tests\n      before checking in, those infinite loops will only occur once on\n      developer machines and should be fixed before checking code in. If\n      there&#39;s an infinite loop and no timeout configured the developer\n      will see the test causing the infinite loop and fix it. &lt;br&gt;\n      &lt;br&gt;\n      &lt;br&gt;\n      Maybe you could explain further why timing is an issue for you.\n      And maybe you can also describe the code and project that causes\n      the issue.&lt;br&gt;\n      &lt;br&gt;\n      Stefan&lt;br&gt;\n      &lt;br&gt;\n      [2] Java Concurrency in Practice by Brian Goetz et al.&lt;br&gt;\n      &lt;br&gt;\n      Am 24.07.2014 22:49, schrieb Tobias Werth &lt;a class=&quot;moz-txt-link-abbreviated&quot; href=&quot;mailto:Tobias.Werth@...&quot;&gt;Tobias.Werth@...&lt;/a&gt;\n      [junit]:&lt;br&gt;\n    &lt;/div&gt;\n    &lt;blockquote\n      cite=&quot;mid:20140724204932.GC23096@...-erlangen.de&quot;\n      type=&quot;cite&quot;&gt; &lt;span style=&quot;display:none&quot;&gt;&nbsp;&lt;/span&gt;\n      \n          &lt;div id=&quot;ygrp-text&quot;&gt;\n            &lt;p&gt;Hi,&lt;br&gt;\n              &lt;br&gt;\n              I wanted to discuss two side effects between multiple\n              JUnit test&lt;br&gt;\n              methods:&lt;br&gt;\n              &lt;br&gt;\n              a) timing issues&lt;br&gt;\n              If a test method runs into a timeout, the executing thread\n              is&lt;br&gt;\n              interrupted (but not stopped). Hence, if it executes an\n              infinite loop,&lt;br&gt;\n              it will still occupy some of your resources after this\n              test failed.&lt;br&gt;\n              &lt;br&gt;\n              For an example, see [1]. The helper method is executed\n              either once or&lt;br&gt;\n              infinite often in a loop. If executed once, it runs\n              approx. 100ms on my&lt;br&gt;\n              machine. If executed in a loop, JUnit&#39;s runtime is approx.\n              600ms times&lt;br&gt;\n              for a single parameterized run.&lt;br&gt;\n              Executing 10 infinite loops first and then 10 single\n              helper calls&lt;br&gt;\n              results in more than 10 timeouts (which is set to 500ms).\n              You may have&lt;br&gt;\n              to increase NUM_RUNS on your machine to reproduce.&lt;br&gt;\n              &lt;br&gt;\n              b) memory issues&lt;br&gt;\n              It&#39;s easy to construct cases from the above insight\n              (threads may keep&lt;br&gt;\n              running in case of a timeout) with side effects on memory\n              which lead to&lt;br&gt;\n              an OutOfMemoryError.&lt;br&gt;\n              Even when threads do not keep running, and one test\n              allocates many&lt;br&gt;\n              objects, the garbage collector may kick in during the\n              execution of the&lt;br&gt;\n              next test method. This may result in an timeout that is\n              not caused by&lt;br&gt;\n              the code under test but by the previous massive object\n              allocation.&lt;br&gt;\n              &lt;br&gt;\n              I know that&#39;s almost impossible to stop Java threads. I\n              also assume that&lt;br&gt;\n              both side effects are well known.&lt;br&gt;\n              &lt;br&gt;\n              So what&#39;s the best practice to reduce or even avoid these\n              side effects&lt;br&gt;\n              when writing JUnit test methods?&lt;br&gt;\n              &lt;br&gt;\n              Cheers,&lt;br&gt;\n              Tobi&lt;br&gt;\n              &lt;br&gt;\n              --&lt;br&gt;\n              1: &lt;a class=&quot;moz-txt-link-freetext&quot; href=&quot;https://gist.github.com/meisterT/97db378abea366036f36&quot;&gt;https://gist.github.com/meisterT/97db378abea366036f36&lt;/a&gt;&lt;br&gt;\n              &lt;br&gt;\n            &lt;/p&gt;\n          &lt;/div&gt;\n          \n      \n      &lt;!-- end group email --&gt;\n    &lt;/blockquote&gt;\n    &lt;br&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\r\n--------------010404020009040501050705--\r\n\n", 
    "subject": "Re: [junit] Side effects between test cases"
}