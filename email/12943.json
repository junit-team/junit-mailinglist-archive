{
    "numMessagesInTopic": 13, 
    "nextInTime": 12944, 
    "senderId": "JzmJDI3zTokiE2xYA1T3IBHAjxgIKQhkREbh2XdU7YS-cbrRw_Nr8YDEAly5XaGG35sur-8USQkXN7QGMI7a9h_NISeji3LUKgOSbMJzTQ", 
    "systemMessage": false, 
    "subject": "Re: [junit] Junit and mock objects", 
    "from": "&quot;J. B. Rainsberger&quot; &lt;jbrains@...&gt;", 
    "authorName": "J. B. Rainsberger", 
    "msgSnippet": "... I call this Mock one level of abstraction higher . Example: When I mock/fake JDBC, I end up with a bunch of tests that make the same checks about", 
    "msgId": 12943, 
    "profile": "nails762", 
    "topicId": 12911, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 127224993, 
    "messageBody": "<div id=\"ygrps-yiv-1368991295\">Pico Geyer wrote:<br/>\n<blockquote><span title=\"ireply\"> &gt; Hi all.<br/>\n&gt; <br/>\n&gt; As suggested earlier my members of this list, I&#39;m trying to implement<br/>\n&gt; mock objects to test my code.<br/>\n&gt; <br/>\n&gt; I&#39;m coming across a couple of problems though, and would like some<br/>\n&gt; advice if possible.<br/>\n&gt; <br/>\n&gt; I&#39;m not sure what to do when I need to mock 3rd party code. Most of the<br/>\n&gt; documentation about mock objects says: &quot;don&#39;t mock 3rd party code&quot;, but<br/>\n&gt; if I don&#39;t, then how am I expected to test my code that uses these 3rd<br/>\n&gt; party libraries.<br/>\n&gt; <br/>\n&gt; In particular I found this statement from<br/>\n&gt; <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.mockobjects.com/DynaMock.html:\">http://www.mockobjects.com/DynaMock.html:</a><br/>\n&gt; &quot;We have found that mocking third party classes (and interfaces) over<br/>\n&gt; which we have no control causes problems in the long run. It is better<br/>\n&gt; to define an interfaces for your objects in terms of concepts in your<br/>\n&gt; application, and then implement them as wafer-thin adapters to the third<br/>\n&gt; party libraries. That has two benefits: (a) your objects are easier to<br/>\n&gt; understand, and (b) your application is not polluted with references to<br/>\n&gt; third party packages that might have to be replaced for non-technical<br/>\n&gt; reasons. You do not need to have full control over the entire codebase<br/>\n&gt; to follow this approach.&quot;<br/>\n&gt; <br/>\n&gt; I don&#39;t really understand what is meant by this. I&#39;ll return to the<br/>\n&gt; example that I&#39;ve been struggling with, one of my classes takes a<br/>\n&gt; NetworkInterface object as a parameter to the constructor. Now in order<br/>\n&gt; for me to test that all is well in the constructor I need to mock<br/>\n&gt; NetworkInterface.<br/>\n&gt; <br/>\n&gt; If somebody could please give me an example of what to do. If possible<br/>\n&gt; please use a class that takes NetorkInterface as an argument to the<br/>\n&gt; constructor as an example, as I&#39;m struggling to understand this.<br/>\n&gt; <br/>\n&gt; Btw I would post this on the easyMock mailing list, but I&#39;m having<br/>\n&gt; problems joining this list.<br/>\n<br/>\n </span></blockquote>I call this &quot;Mock one level of abstraction higher&quot;.<br/>\n<br/>\nExample: When I mock/fake JDBC, I end up with a bunch of tests that make <br/>\nthe same checks about connections, statements, and so on.<br/>\n<br/>\nTHEREFORE,<br/>\n<br/>\nCreate an interface Repository on which my (current) JDBC client <br/>\ndepends, then implement Repository with JdbcRepository that talks JDBC <br/>\nto the database. Now:<br/>\n<br/>\n1. I can test the (former) JDBC client using a fake or mock Repository, <br/>\nwhich has domain-oriented methods and is therefore a less verbose and <br/>\nmore useful API.<br/>\n<br/>\n2. I can test the methods in JdbcRepository /outside the context of the <br/>\napplication/ with a real database (possibly in memory). If 3 business <br/>\nlogic methods use a certain Repository method, I don&#39;t have to test that <br/>\nmethod /as part of/ all 3 of those business logic tests -- I only test <br/>\nthat Repository method once.<br/>\n<br/>\nConclusion: Fewer, faster tests. Clear win.<br/>\n-- <br/>\nJ. B. (Joe) Rainsberger<br/>\nDiaspar Software Services<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.diasparsoftware.com\">http://www.diasparsoftware.com</a><br/>\nAuthor, JUnit Recipes: Practical Methods for Programmer Testing</div>", 
    "prevInTime": 12942, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1109122493", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 12928, 
    "headers": {
        "inReplyToHeader": "PEFEREYzRkUxOUQ2NDIxNDJBQjBGMDk4NzYxQUEwQ0U5MDhFNzhDQHNzbWFpbi5zb2Z0c3RhcnQuY28uemE+", 
        "messageIdInHeader": "PDQyMUJEREJELjgwNzA0MDNAcm9nZXJzLmNvbT4=", 
        "referencesHeader": "PEFEREYzRkUxOUQ2NDIxNDJBQjBGMDk4NzYxQUEwQ0U5MDhFNzhDQHNzbWFpbi5zb2Z0c3RhcnQuY28uemE+"
    }
}