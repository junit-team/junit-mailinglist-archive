{
    "numMessagesInTopic": 1, 
    "nextInTime": 18488, 
    "senderId": "xyHEeAbRuWIgCo_QgSpnlso1nd3ByeH0XiiFmLZVPGtb1FRyt9TBmCtBZFx186T_vTwzkyEmAcADxSZqK52b4pwi", 
    "systemMessage": false, 
    "subject": "assertThat (was: Re: [junit] Re: Literate assertions)", 
    "from": "&quot;David Saff&quot; &lt;saff@...&gt;", 
    "authorName": "David Saff", 
    "msgSnippet": "... Perhaps separate.  I ve been going on a lot about this, because a recent project I ve been working on (about which, hopefully, more in a week or two) is", 
    "msgId": 18487, 
    "profile": "dsaff", 
    "topicId": 18487, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 139771899, 
    "messageBody": "<div id=\"ygrps-yiv-1638130330\">On 11/30/06, Cédric Beust ♔ &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:cbeust@...\">cbeust@...</a>&gt; wrote:<br/>\n<blockquote><span title=\"ireply\"> &gt; On 11/30/06, David Saff &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:saff@...\">saff@...</a>&gt; wrote:<br/>\n&gt; &gt;<br/>\n&gt; &gt;<br/>\n&gt; &gt; But it means something completely different.  This is what I get for<br/>\n&gt; &gt; trying to be clever and concise at the same time. [1]<br/>\n&gt; &gt;<br/>\n&gt; &gt; assertThat(valueOf(button).isEnabled(), eventually(eq(true)));<br/>\n&gt; &gt;<br/>\n&gt; &gt; ...only is useful in a multi-threaded situation, in which the button<br/>\n&gt; &gt; may not be enabled the first time you check, but if you wait a while,<br/>\n&gt; &gt; it should soon become enabled.  The great thing is that this idea of<br/>\n&gt; &gt; repeatedly evaluating an expression, checking against a desired<br/>\n&gt; &gt; result, and then waiting before evaluating again is all encapsulated<br/>\n&gt; &gt; within the &quot;valueOf&quot; and &quot;eventually&quot; methods.  Once I figured this<br/>\n&gt; &gt; out, my asynchronous UI tests actually became readable.<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; Oh, ok, so there is a lot more at work than assertions here, and this is a<br/>\n&gt; separate (albeit very interesting) topic from literate assertions.<br/>\n<br/>\n </span></blockquote>Perhaps separate.  I&#39;ve been going on a lot about this, because a<br/>\nrecent project I&#39;ve been working on (about which, hopefully, more in a<br/>\nweek or two) is made _much_ easier by the use of the functional style<br/>\nof assertion which I&#39;ve been code-naming by the method name<br/>\n&quot;assertThat&quot;.  This functional style does happen to allow some<br/>\nliterate-sounding code, but there&#39;s no reason it has to:<br/>\n<br/>\nassert(equals(5), x);<br/>\n<br/>\nworks just as well for the purposes of the kind of extension I want to<br/>\ndo.  Though Java stole the assert keyword, which I&#39;ve been very<br/>\nunhappy about over the last week, again.<br/>\n<br/>\nIn summary, for me, it&#39;s more about functional assertions than<br/>\nliterate programming, although it&#39;s nice that the two do work together<br/>\n(sometimes).<br/>\n<br/>\nI would<br/>\n<blockquote><span title=\"ireply\"> &gt; definitely hide this kind of complexity (such as invokeLater(), join(),<br/>\n&gt; etc...) in utility functions.<br/>\n&gt;<br/>\n&gt; FYI, here are a few ways you can test asynchronous code (e.g. UI or JMS)<br/>\n&gt; with TestNG &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"http://beust.com/weblog/archives/000236.html\">http://beust.com/weblog/archives/000236.html</a>&gt;.<br/>\n&gt;<br/>\n&gt; The literacy is actually secondary here, which is why I&#39;m willing to<br/>\n&gt; &gt; live with and(greaterThan(10), lessThan(20)) when I have to [2].  The<br/>\n&gt; &gt; primary win is that the thing you&#39;re trying to assert is separated<br/>\n&gt; &gt; from the act of asserting<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; I&#39;m a bit confused by this, which sounds interesting, but which I can&#39;t<br/>\n&gt; connect to your following examples:<br/>\n&gt;<br/>\n&gt; , so that you can write:<br/>\n&gt; &gt; assertThat(button, eventually(isEnabled()));  // will become enabled<br/>\n&gt; &gt; or<br/>\n&gt; &gt; assertThat(button, isEnabled());  // is now enabled<br/>\n&gt; &gt; or<br/>\n&gt; &gt; assertThat(button, not(isEnabled()));  // is disabled<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; In all these cases, it looks like both the assert and the evaluation of the<br/>\n&gt; assert are executed at the same time, can you clarify?  (maybe by explaining<br/>\n&gt; what eventually() really does?)<br/>\n<br/>\n </span></blockquote>Off the top of my head, here&#39;s a definition of eventually() that would<br/>\nmeet the top examples (it&#39;s slightly different, though not importantly<br/>\nso, from the one I actually wrote):<br/>\n<br/>\npublic &lt;T&gt; Matcher&lt;T&gt; eventually(final Matcher&lt;T&gt; matcher) {<br/>\n  return new Matcher&lt;T&gt;() {<br/>\n    public String describe() {<br/>\n      return &quot;eventually &quot; + matcher.describe();<br/>\n    }<br/>\n<br/>\n    public String matches(T value) {<br/>\n      Stopwatch stopwatch = Stopwatch.start(MAXIMUM_TIME_TO_WAIT);<br/>\n      while (stopwatch.timeLeft()) {<br/>\n         if (matcher.matches(value))<br/>\n           return true;<br/>\n         JobQueue.advanceOtherThreads();<br/>\n      }<br/>\n      return matcher.matches(value);<br/>\n    }<br/>\n  }<br/>\n}<br/>\n<br/>\nDoes that help?<br/>\n<br/>\n   David Saff</div>", 
    "prevInTime": 18486, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1164941586", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 0, 
    "headers": {
        "messageIdInHeader": "PDRmN2RhNmI5MDYxMTMwMTg1M2k5YjJiNzJibmEzOGIzMjAxOGQyMTVkNzJAbWFpbC5nbWFpbC5jb20+"
    }
}