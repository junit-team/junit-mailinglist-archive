{
    "numMessagesInTopic": 80, 
    "nextInTime": 18665, 
    "senderId": "EFV1I5p4X13wb0dxdYq_-nNVnxuhXAflUa5HT9fIPY7TSNxeh4jwCZyxBJ6Ru_t3eojt--dTX_EWPYNMJlzoQSomrk1nYA", 
    "systemMessage": false, 
    "subject": "Re: [junit] 100%% Method Testing and Generating Unit Tests", 
    "from": "Ole Ersoy &lt;ole_ersoy@...&gt;", 
    "authorName": "Ole Ersoy", 
    "msgSnippet": "Wow - Dud - You Da Man!! (And judging by the name - quite possibly Norwegian, which explains why u so da Man :-)  ) This actually looks a lot like what I ve", 
    "msgId": 18664, 
    "profile": "ole_ersoy", 
    "topicId": 18605, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 98908154, 
    "messageBody": "<div id=\"ygrps-yiv-1326918342\">Wow - Dud - You Da Man!!<br/>\n<br/>\n(And judging by the name - quite possibly Norwegian, which explains why <br/>\nu so da Man :-)  )<br/>\n<br/>\nThis actually looks a lot like<br/>\nwhat I&#39;ve been trying to describe,<br/>\nwith the possible exception that I don&#39;t think<br/>\nit generates tests like Jimm wants to do,<br/>\nbut hey this is real ;-).  HooohHahhh!<br/>\n<br/>\nJimm in order for this to work the way it says it<br/>\nworks it has to parse source and store it in some<br/>\nmodel.  Then analyze it...looks like using rule sets.<br/>\n<br/>\nI&#39;m sure you could use the same model and rule sets<br/>\nto generate tests (Just shooting from the hip.  I&#39;d have to look at it a <br/>\nlittle more<br/>\nto see whether I could come up with a concrete example. )<br/>\n<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"http://pmd.sourceforge.net/\">http://pmd.sourceforge.net/</a><br/>\n<br/>\nThanks for letting me us Joakim.  Can&#39;t wait to<br/>\nto hook it up to my maven projects.<br/>\n<br/>\nCheers,<br/>\n- Ole<br/>\n<br/>\n<br/>\n<br/>\n<br/>\nJoakim Ohlrogge wrote:<br/>\n<blockquote><span title=\"qreply\"> &gt;<br/>\n&gt; &gt; As a matter of fact...it would be nice to have<br/>\n&gt; &gt; something that enumerates the branches and generates a<br/>\n&gt; &gt; report on which methods has a number of branches over<br/>\n&gt; &gt; a certain limit...for code refactoring and maintenance<br/>\n&gt; &gt; purposes.<br/>\n&gt;<br/>\n&gt; Hi Ole,<br/>\n&gt;<br/>\n&gt; I have not read the whole thread yet so if this has already been<br/>\n&gt; suggested I&#39;m sorry.<br/>\n&gt; PMD actually reports methods with a cyclomatic complexity that is<br/>\n&gt; larger than 10. If I&#39;m not mistaken that is what you&#39;re looking for.<br/>\n&gt;<br/>\n&gt; I find this helpful to find targets to refactor in legacy code. When<br/>\n&gt; TDD:ing the PLP (my abbreviation for path of least pain) keeps the<br/>\n&gt; cyclomatic complexity down (Like Jeff Langr suggested earlier in the<br/>\n&gt; threat).<br/>\n&gt;<br/>\n&gt; Cheers!<br/>\n&gt; /J<br/>\n&gt;<br/>\n&gt; </span></blockquote></div>", 
    "prevInTime": 18663, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1168205007", 
    "canDelete": false, 
    "nextInTopic": 18665, 
    "prevInTopic": 18663, 
    "headers": {
        "inReplyToHeader": "PGI5ZWU1ZTQxMDcwMTA3MTE1N3A3MTcwY2Q3Zm1iOTEyOWQ4MzE5ZDI4OWE2QG1haWwuZ21haWwuY29tPg==", 
        "messageIdInHeader": "PDQ1QTE2NENGLjgwODAwMDdAeWFob28uY29tPg==", 
        "referencesHeader": "PGI4NmI2YTljMDcwMTAzMTEzMW8xM2QyNGYxZXFjNzQ3ZWVlODRhNTI0N2NlQG1haWwuZ21haWwuY29tPgkgPDkzMDQ4OC43MTIwLnFtQHdlYjYwNzE1Lm1haWwueWFob28uY29tPiA8YjllZTVlNDEwNzAxMDcxMTU3cDcxNzBjZDdmbWI5MTI5ZDgzMTlkMjg5YTZAbWFpbC5nbWFpbC5jb20+"
    }
}