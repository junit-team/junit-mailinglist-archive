{
    "numMessagesInTopic": 31, 
    "nextInTime": 24169, 
    "senderId": "jfL9M7BI5q9OY6vEH0MCuefUqzROJvEzneubt_ODSf-6jhw_FwbdAlNd76j-5vJjGW45jLJh_qU7RNJk2eHTkIU4Ww", 
    "systemMessage": false, 
    "subject": "Re: [junit] Is it Time for JUnit 5", 
    "from": "David Saff &lt;saff@...&gt;", 
    "authorName": "David Saff", 
    "msgSnippet": "There s a lot of interesting stuff to chat about in your mail.  I m swamped at work until mid-next-week, so please don t take a couple days of silence as lack", 
    "msgId": 24168, 
    "profile": "saffatgoogle", 
    "topicId": 24156, 
    "spamInfo": {
        "reason": "12", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 525765722, 
    "messageBody": "<div id=\"ygrps-yiv-839753921\">There&#39;s a lot of interesting stuff to chat about in your mail.  I&#39;m swamped<br/>\nat work until mid-next-week, so please don&#39;t take a couple days of silence<br/>\nas lack of interest.<br/>\n<br/>\n   David<br/>\n<br/>\n<br/>\n<blockquote><span title=\"qreply\"> On Thu, Dec 13, 2012 at 7:32 PM, Esko Luontola &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:esko.luontola@...\">esko.luontola@...</a>&gt;wrote:<br/>\n<br/>\n&gt; **<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; David Saff wrote on 13.12.2012 17:47:<br/>\n&gt;<br/>\n&gt; &gt; There&#39;s been a lot of things we&#39;ve wanted to do<br/>\n&gt; &gt; all along with JUnit that I&#39;ve designed first in my head the way they<br/>\n&gt; would<br/>\n&gt; &gt; have worked in a language with lambdas, and then redesigned to fit the<br/>\n&gt; &gt; grain of a lambda-less language. Assertions (and mocks) have especially<br/>\n&gt; &gt; contorted themselves in ways that they might finally now be able to<br/>\n&gt; relax.<br/>\n&gt;<br/>\n&gt; Yes, assertions could probably get much benefit from lambdas.<br/>\n&gt;<br/>\n&gt; I support the idea of having assertions as a separate library which is<br/>\n&gt; decoupled from the testing framework (the same way as Hamcrest,<br/>\n&gt; FEST-Assert and probably others). The testing framework would then focus<br/>\n&gt; fully on the test execution model (e.g. test isolation, execution order,<br/>\n&gt; rules and other metaprogramming).<br/>\n&gt;<br/>\n&gt; There is wide variablity in how assertions can be done (especially in<br/>\n&gt; different languages). I don&#39;t have strong opinions about what an assert<br/>\n&gt; should be like, and seems that there are as many kinds of asserts as<br/>\n&gt; there are testing frameworks.<br/>\n&gt;<br/>\n&gt; There is less variablity in testing frameworks&#39; execution model, but<br/>\n&gt; those differences are often at a more fundamental level (e.g. test<br/>\n&gt; isolation vs. shared state). I and others hold strong opinions about them.<br/>\n&gt;<br/>\n&gt; Thus I would like to be able to mix and match the frameworks and<br/>\n&gt; assertions separately, sometimes even using multiple assertion libraries<br/>\n&gt; in the same test.<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; &gt; - The fact that a Description is both the immutable single name of a test<br/>\n&gt; &gt; node, and a mutable builder for the test structure, and then later an<br/>\n&gt; &gt; immutable reference for the test structure, is exasperating.<br/>\n&gt; &gt; - The reliance on reflectively-discovered constructors for extensibility<br/>\n&gt; &gt; causes some awkwardness.<br/>\n&gt; &gt; - The IDE-centric idea that one should be enable to enumerate all tests<br/>\n&gt; &gt; before any is run places some binding constraints, and should be at most<br/>\n&gt; &gt; optional in a world in which tests are often run by daemons many more<br/>\n&gt; times<br/>\n&gt; &gt; a day than by humans.<br/>\n&gt;<br/>\n&gt; I&#39;ve noticed those as well. I&#39;ve already addressed each of those in Jumi:<br/>\n&gt;<br/>\n&gt; - A testing framework must assign a unique immutable TestId for each<br/>\n&gt; test in a test class, which is then used to send events of when the test<br/>\n&gt; was started, finished, failed etc. The TestId implies a tree structure<br/>\n&gt; of tests (to be used in test result reports). Everything is expressed as<br/>\n&gt; immutable events (Jumi relies heavily on Event Sourcing). See details at<br/>\n&gt; <a rel=\"nofollow\" target=\"_blank\" href=\"http://jumi.fi/api/jumi-api/fi/jumi/api/drivers/SuiteNotifier.html\">http://jumi.fi/api/jumi-api/fi/jumi/api/drivers/SuiteNotifier.html</a><br/>\n&gt;<br/>\n&gt; - The fi.jumi.api.drivers.Driver which corresponds<br/>\n&gt; org.junit.runner.Runner requires a zero-argument constructor. The test<br/>\n&gt; class et al is passed as method argument to<br/>\n&gt; <a rel=\"nofollow\" target=\"_blank\" href=\"http://jumi.fi/api/jumi-api/fi/jumi/api/drivers/Driver.html#findTests\">http://jumi.fi/api/jumi-api/fi/jumi/api/drivers/Driver.html#findTests</a><br/>\n&gt;<br/>\n&gt; - Jumi starts executing tests as soon as possible, at both the suite and<br/>\n&gt; test class levels. At suite level, test class execution starts<br/>\n&gt; asynchronously before all test classes are discovered (i.e. before Jumi<br/>\n&gt; has finished traversing the directories containing test classes). At<br/>\n&gt; test class level, more tests can be found during test execution (for<br/>\n&gt; example Specsy requires this) and the new test executions can be started<br/>\n&gt; asynchronously in parallel (depending on the testing framework and<br/>\n&gt; whether the user has disabled parallelism for that test class or the<br/>\n&gt; whole suite).<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; &gt; - There are as many perfect models of test status possibilities as there<br/>\n&gt; &gt; are developers. Passed/Failed? Passed/Failed/Skipped?<br/>\n&gt; &gt; Passed/Failed/Ignored, etc. The current design bakes one required system<br/>\n&gt; &gt; pretty deep into the internals, unnecessarily.<br/>\n&gt;<br/>\n&gt; That&#39;s been on my mind for a long time, but I haven&#39;t yet figured out a<br/>\n&gt; good way to support all the variations, so I&#39;m deferring the decision. I<br/>\n&gt; would love to hear your ideas.<br/>\n&gt;<br/>\n&gt; A very flexible way would be to allow tagging tests with arbitrary<br/>\n&gt; keywords, but then the problem will be that how each of those keywords<br/>\n&gt; should affect the user interface. There would have to be at least some<br/>\n&gt; keywords with specific meaning, which brings us back to the original<br/>\n&gt; question of which states to support.<br/>\n&gt;<br/>\n&gt; To get started we could list all the variations in use today and the use<br/>\n&gt; cases for using each of them (e.g. it&#39;s an acceptance tests for a<br/>\n&gt; feature which has not yet been implemented). I&#39;m hoping there to be 5 or<br/>\n&gt; less different reasons that are served by test statuses.<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; &gt; Now, should the framework to which I&#39;d contribute time to fix these<br/>\n&gt; &gt; problems be called JUnit 5, or something entirely different? That&#39;s<br/>\n&gt; &gt; another kettle of fish, with some interesting options to consider. Looks<br/>\n&gt; &gt; like we have at least 9 months to consider them at length.<br/>\n&gt;<br/>\n&gt; 9 months, like giving birth to a baby. I suppose the names of quite many<br/>\n&gt; people have been pondered for that long. :)<br/>\n&gt;<br/>\n&gt; JUnit&#39;s name is well known, so it&#39;s a marketing bonus. On the other<br/>\n&gt; hand, the software industry moves quickly and good technology can get<br/>\n&gt; popular regardless of its name.<br/>\n&gt;<br/>\n&gt; --<br/>\n&gt; Esko Luontola<br/>\n&gt; www.orfjackal.net<br/>\n&gt;<br/>\n&gt;  <br/>\n&gt;<br/>\n<br/>\n<br/>\n[Non-text portions of this message have been removed] </span></blockquote></div>", 
    "prevInTime": 24167, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1355501863", 
    "canDelete": false, 
    "nextInTopic": 24172, 
    "prevInTopic": 24167, 
    "headers": {
        "inReplyToHeader": "PDUwQ0E3MzkwLjYwMzA4MDdAZ21haWwuY29tPg==", 
        "messageIdInHeader": "PENBTHJ3LVB3UWhVckNZczlRU2hTZUFjMEpPZDJUOV9fX2dXb2IzK0NqaVNUalZTMmtGQUBtYWlsLmdtYWlsLmNvbT4=", 
        "referencesHeader": "PGthNms0ays1NHBiQGVHcm91cHMuY29tPiA8Q0FMcnctUHhwN1VUb2g1TlEwY3ZHZkxuNjI3bmMtK2tUM1JoQWFtcnlvRl9xRVYyRVR3QG1haWwuZ21haWwuY29tPiA8NTBDOTA3RjAuNjAzMDEwN0BnbWFpbC5jb20+IDxDQUxydy1QeFBkOEJ0ZFk9RlVNU1NLWmJyMzI5RTdaTTJuSGdwZEVQR1J1MjFORnNjUEFAbWFpbC5nbWFpbC5jb20+IDw1MENBNzM5MC42MDMwODA3QGdtYWlsLmNvbT4="
    }
}