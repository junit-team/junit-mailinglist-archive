{
    "topicId": 2000, 
    "postDate": "1000504834", 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "from": "&quot;Kirby Angell&quot; &lt;kirbyangell@...&gt;", 
    "canDelete": false, 
    "replyTo": "LIST", 
    "senderId": "0VdBe1gwC3KDd1LaxJSCI6e6p2UZXYhGV1akU3pOmXULNcvGeLrb0ra1n8qeBrxg2KQZNgeQ4DBQ2sgvDR8hRe14bAbWl670Q4T1jHI", 
    "nextInTime": 2666, 
    "userId": 0, 
    "prevInTime": 2664, 
    "prevInTopic": 2664, 
    "headers": {
        "inReplyToHeader": "PDlrNmdtMys5MmJmQGVHcm91cHMuY29tPg==", 
        "messageIdInHeader": "PDludHVtMis2ZWR1QGVHcm91cHMuY29tPg=="
    }, 
    "authorName": "Kirby Angell", 
    "numMessagesInTopic": 8, 
    "msgSnippet": "With a little more snooping around the Ant code, it seems that JUnitTestRunner will use Ant s class loader if run from within Ant, but if you fork each JUnit", 
    "contentTrasformed": false, 
    "msgId": 2665, 
    "nextInTopic": 0, 
    "systemMessage": false, 
    "rawEmail": "Return-Path: &lt;kirbyangell@...&gt;\r\nX-Sender: kirbyangell@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (EGP: mail-7_3_2_2); 14 Sep 2001 23:22:56 -0000\r\nReceived: (qmail 29254 invoked from network); 14 Sep 2001 22:00:35 -0000\r\nReceived: from unknown (10.1.10.26)\n  by m8.onelist.org with QMQP; 14 Sep 2001 22:00:35 -0000\r\nReceived: from unknown (HELO n30.groups.yahoo.com) (10.1.2.219)\n  by mta1 with SMTP; 14 Sep 2001 22:00:35 -0000\r\nX-eGroups-Return: kirbyangell@...\r\nReceived: from [10.1.2.230] by ho.egroups.com with NNFMP; 14 Sep 2001 22:00:35 -0000\r\nDate: Fri, 14 Sep 2001 22:00:34 -0000\r\nTo: junit@yahoogroups.com\r\nSubject: Re: SwingUI and AWTUI don&#39;t work with PROJECTX?\r\nMessage-ID: &lt;9ntum2+6edu@...&gt;\r\nIn-Reply-To: &lt;9k6gm3+92bf@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Length: 7046\r\nX-Mailer: eGroups Message Poster\r\nFrom: &quot;Kirby Angell&quot; &lt;kirbyangell@...&gt;\r\n\r\nWith a little more snooping around the Ant code, it seems that \nJUnitTestRunner will use Ant&#39;s class loader if run from within Ant, \nbut if you fork each JUnit test into its own JVM it apparently uses \nthe JVM&#39;s default class loader. \n\nThis change to my JUnit task in build.xml forked JUnit into its own \nJVM:\n\n    &lt;junit fork=&quot;true&quot;&gt;\n\nWith that, my tests run as I would expect (still have errors, but at \nleast they are my errors :-).\n\n--- In junit@y..., tooleojim@y... wrote:\n&gt; Hello,\n&gt; \n&gt; I&#39;ve been following the various threads to do with the JUnit\n&gt; TestCaseClassLoader on the JUnit mailing list because I&#39;ve\n&gt; been having a similar sort of problem.\n&gt; \n&gt; I&#39;m using Ant 1.3 to run JUnit 3.7 tests for an application\n&gt; that uses Xerces 1.4.1 and Xalan 2.1. However, my tests fail on \ntrying\n&gt; to parse a DOM document because of a problem with a class loader \n(I&#39;m not sure which loader).\n&gt; \n&gt; java.lang.LinkageError\n&gt; &quot;loader constraints violated when linking org/xml/sax/InputSource \nclass&quot;\n&gt; \n&gt; I&#39;ve had the same problem when running the same tests on the same \napplication using the Swing or AWT JUnit test runner (and NOT using \nAnt). I managed to fix  this problem thanks to a suggestion on the \nJUnit mailing list from Scott Stirling. He suggests a change to the \nexclude.properties file in the JUnit jar. This file tells the JUnit \nTestCaseClassLoader which classes it should not try to load. Instead \nthese classes should be left to the JVM class loader. His suggestion \nwas to supplement the list of excluded classes to exclude all\n&gt; org.w3c.dom.* and or.xml.sax.* classes.\n&gt; \n&gt; However, this workaround does not fix the problem of running JUnit \ntests from Ant where the tests (or the application being tested) \ninvolve org.xml.sax.* classes. \n&gt; \n&gt; Has anyone else experienced this problem? Does anyone know of any \nother fix that could solve this problem? Perhaps, it&#39;s a flaw in the \nAntClassLoader but as I don&#39;t know much about class loading matters I \nneed some assistance in pin pointing the problem. Does anyone have \nany  suggestions?\n&gt; \n&gt; Incidentally, I tried removing the JAXP jars (jaxp.jar and \nparser.jar) that come with Ant and replacing them with the Xalan and \nXerces jars that my application uses. Ant continues to work fine but \nthe tests still won&#39;t run. The reason I made this change was that I \nwas under the impression (from reading the Java Spec \nhttp://java.sun.com/docs/books/vmspec/2nd-\nedition/html/ConstantPool.doc.html) that there would be no problem \nhaving two class loaders loading the same class.\n&gt; \n&gt; I also tried adding org.* to the excluded.properties file (so that \njunit wouldn&#39;t try loading Ant/Xerces/Xalan/etc classes!) but \nalthough Ant continues to work, the JUnit tests still won&#39;t.\n&gt; \n&gt; Thanks,\n&gt; Jim.\n&gt; \n&gt; P.S. This is what Scott Stirling had to say about the matter:\n&gt; \n&gt; The JUnit TestCaseClassLoader (the reloadable one) has a \nfundamental problem that results in frequent LinkageErrors under the \nfollowing conditions:\n&gt; \n&gt; 1.  You use the JUnit Swing UI.\n&gt; 2.  You use JAXP in your test cases or any classes referenced in \nyour test cases, or even any &quot;instanceof&quot; expressions that reference \nJAXP classes. (By JAXP I mean the whole set of javax.* classes plus \nthe org.w3c.dom.* and org.xml.sax.* classes)\n&gt; \n&gt; I can go into this in depth, but the bottom line problems are that \nJUnit loads classes from the same place as the JVM&#39;s system loader; \nthe classpath. This necessitates the use of an exclusion list to \nfilter out certain class names that either must be loaded by the \nsystem loader, or you would like to have loaded by the system \nloader.  The JUnit loader does not always delegate to the system \nloader when it should, particularly in the case of JAXP, which is a \nweird mix of classes whose names begin with the filtered &quot;javax.*&quot; and\n&gt; the unfiltered &quot;org.w3c.*&quot; and org.xml.*&quot;.\n&gt; \n&gt; JAXP is a special case because it is based on a set of javax.* \nclasses.  All javax.* classes are excluded from the JUnit loader by \ndefault (in the default excluded.properties file) in junit.jar.  But \nJAXP, as shipped from Sun, comes with a bunch of other classes in \norg.w3c.* and org.xml.*.  The interesting thing is a direct \ndependency between javax.* classes and some other classes not in the \nusual exclusion list of com.sun.*, javax.*, etc.\n&gt; \n&gt; So what can happen, and frequently does when using the JUnit Swing \nUI with test cases or other classes, such as Log4J, that use JAXP, is \nthat the JUnit class loader (properly) delegates javax.xml.* classes \nit &quot;sees&quot; to the system loader.  But then the system loader loads up \na bunch of org.w3c.dom and/or org.xml.sax classes as the result of \ninitializing and loading that JAXP class.  Later, if the JUnit loader \ncomes across some org.w3c/xml class that it&#39;s never seen before, it \ntries to load it because the classname doesn&#39;t match one of the \npatterns in the exclude list.\n&gt; \n&gt; But it&#39;s already been loaded through the &quot;backdoor&quot; as the result \nof some other class loaded by the system loader (remember, the JVM \nkeeps classes in their own namespace by identifying them by their \nfully qualified name plus the instance of their _defining_ (not \ninitiating) loader, AND, the JVM will attempt to assign all unloaded \nclasses referenced by a defined class to that defining class&#39;s \nloader).  The JVM&#39;s classresolver routine keeps track of all these \nclass loading events and &quot;sees&quot; that the JUnit loader is attempting \nto define a class that has already been defined by the system \nloader.  That&#39;s wrong because according to the rules of loader \nconstraints, JUnit should delegate this load to the system loader.\n&gt; \n&gt; You can hack around this (I did) by catching the LinkageError in\n&gt; TestCaseClassLoader&#39;s loadClass() method and then making a recovery \ncall to findSystemClass() -- thereby delegating to the system loader \nafter the fact (which is OK).  This hack only works some of the time, \nthough, because now you can have the reverse problem where the JUnit \nloader loads a host of org.*.* classes, and then the system loader \nviolates the loader constraints at some point when it tries to do \nexactly what I described above with JAXP because it doesn&#39;t ever \ndelegate to its child (the JUnit loader). Inevitably, if your test \ncases use many JAXP and related XML classes, one or the other \nClassLoader will end violating the constraints whatever you do.\n&gt; \n&gt; So the solution in the existing JUnit is to definitely add \norg.w3c.dom.* and org.xml.sax.* to your excluded.properties if you&#39;re \nusing any JAXP stuff.\n&gt; \n&gt; What can we learn from this?  Well, one thing is that it&#39;s a good \nidea to have your custom class loaders load classes from repositories \nother than the system classpath.  Note that the JVM&#39;s built-in \nclassloaders work that way (one for the jre/ext dirs, another for the \njava.class.path).\n&gt; \n&gt; Anyway, the excluded.properties fix is just a matter of time before \nit\n&gt; becomes standard in JUnit, since JAXP will be a standard part of \nthe 1.4 JDK.  It&#39;ll be just like having org.omg.* excluded.\n\n\n", 
    "subject": "Re: SwingUI and AWTUI don&#39;t work with PROJECTX?"
}