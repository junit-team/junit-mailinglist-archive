{
    "numMessagesInTopic": 80, 
    "nextInTime": 18631, 
    "senderId": "ItDA1W9-0AMQ3v8_pxxkb0sJx4BmT0r323Mzgi16V0gMbcBIr5cx60B98FHXXf4DPXk-xPikbVDq3Oh6pzpGglH-bu9NLw", 
    "systemMessage": false, 
    "subject": "Re: [junit] 100%% Method Testing and Generating Unit Tests", 
    "from": "Jeff Langr &lt;jeff@...&gt;", 
    "authorName": "Jeff Langr", 
    "msgSnippet": "... Greetings Cedric, I prefer not to use coverage tools (in fact, I strongly resist characterizing the quality of unit testing with coverage numbers), but ", 
    "msgId": 18630, 
    "profile": "jlangr", 
    "topicId": 18605, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 238525042, 
    "messageBody": "<div id=\"ygrps-yiv-1354350202\">Quoting CÃ©dric Beust ?  &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:cbeust@...\">cbeust@...</a>&gt;:<br/>\n<blockquote><span title=\"ireply\"> &gt; public URL createUrl(int a, int b) {<br/>\n&gt; try {<br/>\n&gt;   if (a == 0 || b == 0) {<br/>\n&gt;   }<br/>\n&gt;   if (c == 0 && d == 0) {<br/>\n&gt;   }<br/>\n&gt; }<br/>\n&gt; catch(IOException ex) {<br/>\n&gt; }<br/>\n&gt; catch(MalformedURLException ex) {<br/>\n&gt; }<br/>\n&gt;<br/>\n&gt; 100% coverage for this code means something like 2*2*2*2 = 16 test cases<br/>\n&gt; (I&#39;m approximating, but you get the idea).<br/>\n&gt;<br/>\n&gt; Do you really feel it&#39;s useful to write 16 test cases for these 6 lines of<br/>\n&gt; code?<br/>\n<br/>\n </span></blockquote>Greetings Cedric,<br/>\n<br/>\nI prefer not to use coverage tools (in fact, I strongly resist  <br/>\ncharacterizing the quality of unit testing with coverage numbers), but  <br/>\ninstead test-drive as much as possible in the code. In other words,  <br/>\nthe complex conditionals don&#39;t get complex until I have a second test  <br/>\nthat drives out the &quot;or&quot; part of the clause. So in theory I&#39;d end up  <br/>\nwith the combinatorial explosion you&#39;re suggesting.<br/>\n<br/>\nHowever, in practice that doesn&#39;t happen often.<br/>\n<br/>\nSometimes these complex conditionals end up as method calls:<br/>\n   if (a == null || b == null)<br/>\nbecomes:<br/>\n   if (areAnyNull(a, b)) // yes this is a trivial example, but it&#39;s  <br/>\nnot atypical<br/>\n<br/>\nI end up with comprehensive tests against areAnyNull; that&#39;s easy to  <br/>\ntest (it often becomes a public method on another class). Then I only  <br/>\nconcern myself with two cases to cover the &quot;if&quot; block in the enclosing  <br/>\nmethod (createUrl in this example). I often find that encapsulating  <br/>\nthe complex conditionals within separate methods (a) helps make the  <br/>\ncode easier to follow,  (b) often helps reduce the overall code size  <br/>\n(it makes some duplication more obvious), and (c) makes some defects  <br/>\nvery apparent.<br/>\n<br/>\nEven if I need to explode the tests, they end up extremely short,  <br/>\nsometimes a single line, by virtue of test refactoring.<br/>\n<br/>\nIn general, it&#39;s the refactoring that keeps the tests in TDD sane. I  <br/>\ndon&#39;t end up with a lot of methods that have more than a couple of  <br/>\nbranch statements, so I don&#39;t usually have a problem with covering all  <br/>\nthe combinations.<br/>\n<br/>\nRegardless, I&#39;d rather have the test that demonstrates that the rhs of  <br/>\nthe conditional really works, and that all of the combinations thus  <br/>\nreally work. Particularly given short circuit evaluation, I&#39;ve  <br/>\nencountered many cases where not completely testing this allowed  <br/>\ndefects that weren&#39;t found until much later.<br/>\n<br/>\nRegards,<br/>\nJeff</div>", 
    "prevInTime": 18629, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1167860690", 
    "canDelete": false, 
    "nextInTopic": 18631, 
    "prevInTopic": 18629, 
    "headers": {
        "inReplyToHeader": "PGI4NmI2YTljMDcwMTAzMTEzMW8xM2QyNGYxZXFjNzQ3ZWVlODRhNTI0N2NlQG1haWwuZ21haWwuY29tPg==", 
        "messageIdInHeader": "PDIwMDcwMTAzMTM0NDUwLjRvM2Uzc2Q0cXB3a2t3dzRAbG9naW4uc2lyaXVzLmx1bmFycGFnZXMuY29tPg==", 
        "referencesHeader": "PGI4NmI2YTljMDcwMTAzMDkwNWgyMmVkOThlNnFiMjM3MTA1OTI1Mzc1NjhmQG1haWwuZ21haWwuY29tPgk8MjAwNzAxMDMxNzU2MDkuODM5NzYucW1haWxAd2ViNjA3MjIubWFpbC55YWhvby5jb20+CTxiODZiNmE5YzA3MDEwMzExMzFvMTNkMjRmMWVxYzc0N2VlZTg0YTUyNDdjZUBtYWlsLmdtYWlsLmNvbT4="
    }
}