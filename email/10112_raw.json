{
    "numMessagesInTopic": 5, 
    "nextInTime": 10113, 
    "senderId": "llhF4xyoEAiCOcXGS2gYZ9jinKdBgrjGuB5Nk85BDByh5boXUGnTLKdvBeDcN-22MdkVviiR1aVlRUN2YAX2w7zjf96bNwdkhA0", 
    "systemMessage": false, 
    "subject": "Re: [junit] newbie - how to test clases persisting to DB, mock objects in .net", 
    "from": "Kevin Klinemeier &lt;zipwow@...&gt;", 
    "authorName": "Kevin Klinemeier", 
    "msgSnippet": "... Ayup, I love this part of the mock approach. ... Not quite.  Since my jdbc (or whatever) level is a mock object rather than the real connection, I can", 
    "msgId": 10112, 
    "rawEmail": "Return-Path: &lt;zipwow@...&gt;\r\nReceived: (qmail 32239 invoked by uid 7800); 17 Dec 2003 21:36:52 -0000\r\nX-Sender: zipwow@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (qmail 9224 invoked from network); 17 Dec 2003 21:26:56 -0000\r\nReceived: from unknown (66.218.66.217)\n  by m3.grp.scd.yahoo.com with QMQP; 17 Dec 2003 21:26:56 -0000\r\nReceived: from unknown (HELO web60303.mail.yahoo.com) (216.109.118.114)\n  by mta2.grp.scd.yahoo.com with SMTP; 17 Dec 2003 21:26:56 -0000\r\nMessage-ID: &lt;20031217212655.35211.qmail@...&gt;\r\nReceived: from [207.14.29.3] by web60303.mail.yahoo.com via HTTP; Wed, 17 Dec 2003 13:26:55 PST\r\nDate: Wed, 17 Dec 2003 13:26:55 -0800 (PST)\r\nTo: junit@yahoogroups.com\r\nIn-Reply-To: &lt;3FE0B628.50108@...&gt;\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=us-ascii\r\nX-eGroups-Remote-IP: 216.109.118.114\r\nFrom: Kevin Klinemeier &lt;zipwow@...&gt;\r\nSubject: Re: [junit] newbie - how to test clases persisting to DB, mock objects in .net\r\nX-Yahoo-Group-Post: member; u=82914509\r\nX-Yahoo-Profile: zipwow\r\nX-eGroups-Approved-By: nails762 &lt;jbrains@...&gt; via email; 17 Dec 2003 21:36:52 -0000\r\n\r\n\n--- &quot;J. B. Rainsberger&quot; &lt;jbrains@...&gt; wrote:\n&gt; &gt; 2:  Test speed - This sounds minor, but its a bigger deal than you\n&gt; &gt; might think.  No database startup or connection times makes for\n&gt; much\n&gt; &gt; faster execution of unit tests.  This makes me much more likely to\n&gt; add\n&gt; &gt; a unit test, or to run old ones.\n&gt; \n&gt; In memory, these tests take 0.25 seconds less time each.\nAyup, I love this part of the mock approach.\n\n&gt; &gt; 3:  Test failure cases - This is a big one.  The mock object\n&gt; approach\n&gt; &gt; can test the way your code behaves when the database fails.  I can\n&gt; have\n&gt; &gt; my mock object accept the Person query, but when it asks for\n&gt; Salary, it\n&gt; &gt; throws an exception.  This can&#39;t be done with the\n&gt; database-connected\n&gt; &gt; approach.\n&gt; \n&gt; Tell me more about this. I don&#39;t understand it.\n&gt; \n&gt; I think you mean that the tests detect problems before your JDBC\n&gt; driver \n&gt; tries to execute an obviously erroneous query. Is that right?\n\nNot quite.  Since my jdbc (or whatever) level is a mock object rather\nthan the real connection, I can write a test that checks how a piece of\ncode handles failure.  Pseudocode is probably the clearest explanation:\n\n/**\n * Tests that the in-memory transaction is properly backed out if the  \n\n * database fails during the update.  (Bug #41833)\n */\npublic void testSalaryQueryFailure() {\n\n    //create a query object that throws an exception just like a\n    //database failure\n    MockResult brokenQuery = new MockResult {\n        public getResult() {\n            throw new MyDatabaseIsDyingException();\n        }\n    };\n\n    someFramework.setResult(brokenQuery);\n    objectUnderTest.updateSalary();  //the method whose behavior \n                                     //we&#39;re testing\n    \n    testFailureState();  //checks the specifics described in test docs\n}\n\n\n&gt; \n&gt; How often does it happen that data magically disappears from another \n&gt; table? I suppose it happens when someone silently adds a new foreign\n&gt; key \n&gt; constraint with &quot;cascade delete&quot;. Perhaps this shouldn&#39;t happen.\n&gt; Perhaps \n&gt; that&#39;s a different problem.\n\nInterestingly, the mock objects wouldn&#39;t catch changes to the database\nsetup that you describe.  This could be a criticism of the mock\napproach.  I lump all that in with configuration, and try very hard to\nignore it.  I&#39;ll probably carry on like that until it bites me very\nhard.\n\nThe problem I&#39;m worried about is that my code under test makes use of\nsome other code (okay, obviously).  Say I call person.removeAccount(). \nWhen I write it, removeAccount doesn&#39;t delete the person in any case. \nSometime after I&#39;ve written my test, removeAccount() is changed to\nremove the person record if it has no more accounts.  \n\nThis would certainly break my test, however, because the\nremoveAccount() method is now sending some SQL about person removal\nthat I&#39;m not expecting.\n\n&gt; Disagree. More mock objects means more complex object construction\n&gt; (more \n&gt; parameters to constructors). This means your setUp() code is more \n&gt; complex. (I use EasyMock, so two lines of code per interface to\n&gt; mock.) \n&gt; What&#39;s neat, though, is that you spend more lines of code setting up \n&gt; objects, but verifying them is a snap. The less cohesive your objects\n&gt; \n&gt; (common with a direct-to-database design), the more hoops to jump \n&gt; through to verify a particular condition.\n&gt; \n&gt; Complex object construction is much less brittle, in general, than \n&gt; complex assertions.\n\nMaybe I should have said that the code as a whole is about the same\nsize?  I didn&#39;t do any kind of quantitative analysis, but kind of\nlooked over the code and said, &quot;Yeah, this is all doing the same\nthing.&quot;  I probably counted some of the mock setup as the same as the\nnon-mock verification.  I like your observation about verification\nbeing simple.  That alone is a strong argument in favor of the mock\napproach, as the easier things are to verify, the more likely I am to\ntest them.\n\nI want to say, too, that I&#39;ve written some of the comments as a\n&quot;connected database&quot; vs &quot;mock database objects&quot; battle.  What I think\nis closer to the truth is to mock everything you can mock, and if what\nyou have left must be tested, then and only then should you go the\nconnected database route.   Connected db is a pain, especially if you\ndon&#39;t have a database instance per developer.\n\nAnd yeah, JB, you&#39;re not alone out there.  I&#39;m hoping to write some of\nthese impressions up either as an internal document, so I&#39;ve been\nthinking a lot about this lately.\n\n-Kevin\n\n__________________________________\nDo you Yahoo!?\nProtect your identity with Yahoo! Mail AddressGuard\nhttp://antispam.yahoo.com/whatsnewfree\n\n", 
    "profile": "zipwow", 
    "topicId": 10094, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 82914509, 
    "prevInTime": 10111, 
    "contentTrasformed": false, 
    "postDate": "1071696415", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 10109, 
    "headers": {
        "inReplyToHeader": "PDNGRTBCNjI4LjUwMTA4QHJvZ2Vycy5jb20+", 
        "messageIdInHeader": "PDIwMDMxMjE3MjEyNjU1LjM1MjExLnFtYWlsQHdlYjYwMzAzLm1haWwueWFob28uY29tPg=="
    }
}