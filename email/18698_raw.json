{
    "numMessagesInTopic": 80, 
    "nextInTime": 18699, 
    "senderId": "1g3rgz4Qr3qKwg0JrF4dOGNmC-TA97fsq-pDF6dOBPwMouuu2B-Sdv0FE8lYwAQf_2FW_fYoRN2LiLxZDQ06VeEwl-6IRg", 
    "systemMessage": false, 
    "subject": "Re: [junit] 100%% Method Testing and Generating Unit Tests", 
    "from": "Ole Ersoy &lt;ole_ersoy@...&gt;", 
    "authorName": "Ole Ersoy", 
    "msgSnippet": "... Suppose a,b,c are int s. Further, this is a triangle so 0 ", 
    "msgId": 18698, 
    "rawEmail": "Return-Path: &lt;ole_ersoy@...&gt;\r\nX-Sender: ole_ersoy@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (qmail 54063 invoked from network); 10 Jan 2007 20:28:56 -0000\r\nReceived: from unknown (66.218.67.35)\n  by m25.grp.scd.yahoo.com with QMQP; 10 Jan 2007 20:28:56 -0000\r\nReceived: from unknown (HELO web60715.mail.yahoo.com) (209.73.178.218)\n  by mta9.grp.scd.yahoo.com with SMTP; 10 Jan 2007 20:28:56 -0000\r\nReceived: (qmail 32218 invoked by uid 60001); 10 Jan 2007 20:18:44 -0000\r\nX-YMail-OSG: SGaPtQsVM1mnolh9vQjFHu6YeVPUPTht7aaKiwrWZlQ7kkbG3c..yYK7GR4DyqCNtkkEHVc.cUzdueJfcNvom6mjLDnYPwyfVHnMTYIX3iY2D2uTjFBoGvooe.DK1BXytnlSlm8PTXzvGpfzEjyqSyKmnqeQKHQ1GpeEaOI_zFqO..59ZoHNpiF5_uS9MibOZVXNatMc\r\nReceived: from [24.13.179.233] by web60715.mail.yahoo.com via HTTP; Wed, 10 Jan 2007 12:18:44 PST\r\nDate: Wed, 10 Jan 2007 12:18:44 -0800 (PST)\r\nTo: junit@yahoogroups.com\r\nIn-Reply-To: &lt;51d1b2de0701100947i4dc77510p42191906cd51af0a@...&gt;\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=iso-8859-1\r\nContent-Transfer-Encoding: 8bit\r\nMessage-ID: &lt;417416.30208.qm@...&gt;\r\nX-eGroups-Msg-Info: 1:0:0:0\r\nFrom: Ole Ersoy &lt;ole_ersoy@...&gt;\r\nSubject: Re: [junit] 100%% Method Testing and Generating Unit Tests\r\nX-Yahoo-Group-Post: member; u=98908154; y=4lphQDb7ucQ1Qb3rEwkW4rUQRMnt_cGWq6ZGD18NZCFxteLu\r\nX-Yahoo-Profile: ole_ersoy\r\n\r\nJust a comment on this part:\n\n\n&gt;This one is not\n&gt;even theoretically\n&gt;possible for a machine to do. \n \n&gt;For example, consider this method on a Triangle\n&gt;class:\n \n&gt; public boolean isIsosceles() {\n&gt;     return a == b || a == c || b == c;\n&gt; }\n&gt; \n\nSuppose a,b,c are int&#39;s.\n\nFurther, this is a triangle so \n\n0 &lt; [a,b,c]\n\nis always true.\n\nThis is an invarient constraint of the model for the\ntriangle.\n\nA good design tool should ask questions like that with\n\nrespect to the defined parameters.\n\nThen to complete enumerate the test, we define the\nfollowing points:\n\naMax bMax cMax\naMin bMin cMin\n\naMin-1 bMin-1 cMin-1\naMax+1 bMax+1 cMax+1\n\nIn range means a legal java int that respects the \nthe invarient constraint.\n\naInRange bInRange cInRange ExpectedReturnValue\n   2        2        2          true\n   2        2        3          true\n   2        3        3          true\n   3        2        2          true\n   3        3        2          true\n   3        3        3          true\n   1        2        3          false\n   3        2        1          false\n   2        3        1          false \n\n\nThen you could do the same process using\naMin, aMin=1, bMin...etc.\nfinally forming the picture of all the points\nthat are interesting.\n\nWith respect to this, \n\nif we were to add aMin bMin cMin to the \ntable above, we would be adding \n\n   1        1        1\n\nThis falls in the same pattern as the above\npoints, but the tester might find it interesting/\ncomforting just to check that point.\n\nSam goes for aMax, bMax, cMax\n\nThen for aMin-1 and aMax+1...these should\nnever be allowed to enter the test...an exception\nshould be thrown.  Thus for the enumerated set of\nthese\npossibilities, an exception is always thrown, so\nthat&#39;s what the test tests for.\n\n\nSo these points represent the 100% test.\n\nIt&#39;s possible to create tests using different\ndatapoints, but they&#39;ll follow the same pattern.\n\nSo if these tests pass, everything should pass.\n\nCheers,\n- Ole\n\n\n\n\n\n\n\n\n\n\n\n--- Kevin Lawrence &lt;kev.lawrence@...&gt; wrote:\n\n&gt; On 1/9/07, Greg Irvine &lt;greg.irvine@...&gt;\n&gt; wrote:\n&gt; &gt; Kevin, I think you&#39;ve missed James&#39; point, at\n&gt; least in the snippet of his\n&gt; &gt; email you&#39;ve quoted.\n&gt; \n&gt; I think I understood his point and agreed with it. I\n&gt; was trying to\n&gt; make an additional point.\n&gt; \n&gt; &gt;\n&gt; &gt; He&#39;s saying that generating tests from existing\n&gt; code has the risk that the\n&gt; &gt; code doesn&#39;t do what it was intended but a test is\n&gt; generated to pass based\n&gt; &gt; on the incorrect code.  So you would have 100%\n&gt; test passes, which is\n&gt; &gt; incorrect against the actual expected results\n&gt; against the requirements.\n&gt; &gt;\n&gt; \n&gt; I am trying to separate the various goals of testing\n&gt; and investigate\n&gt; distinct strategies that would achieve each goal.\n&gt; \n&gt; One goal is to prevent regressions: show that, after\n&gt; a change, the\n&gt; code still does what it did before or at least show\n&gt; what behaviors\n&gt; changed (regardless of whether the code was\n&gt; previously &#39;correct&#39;). I\n&gt; think we are agreed that a machine could do this in\n&gt; principle even if\n&gt; it is difficult in practice. It still requires a\n&gt; reviewer, though, to\n&gt; decide which changes were intended and which were\n&gt; not .\n&gt; \n&gt; \n&gt; Another goal is to demonstrate correctness:\n&gt; demonstrate that the code\n&gt; behaves correctly for all inputs. This one is not\n&gt; even theoretically\n&gt; possible for a machine to do. But a machine can make\n&gt; the job of a\n&gt; human reviewer easier by showing combinations of\n&gt; inputs and outputs\n&gt; that are &#39;likely&#39; to represent special or border\n&gt; cases.\n&gt; \n&gt; For example, consider this method on a Triangle\n&gt; class:\n&gt; \n&gt; public boolean isIsosceles() {\n&gt;     return a == b || a == c || b == c;\n&gt; }\n&gt; \n&gt; A machine might generate tests:\n&gt; \n&gt;     public void testIsIsosceles() throws Throwable {\n&gt;         boolean result = new Triangle(59, 100,\n&gt; 59).isIsosceles();\n&gt;         assertTrue(&quot;result&quot;, result);\n&gt;     }\n&gt; \n&gt;     public void testIsIsosceles1() throws Throwable\n&gt; {\n&gt;         boolean result = new Triangle(100, 59,\n&gt; 59).isIsosceles();\n&gt;         assertTrue(&quot;result&quot;, result);\n&gt;     }\n&gt; \n&gt;     public void testIsIsosceles2() throws Throwable\n&gt; {\n&gt;         boolean result = new Triangle(30, 30,\n&gt; 30).isIsosceles();\n&gt;         assertTrue(&quot;result&quot;, result);\n&gt;     }\n&gt; \n&gt; A reviewer might look at these tests and exclaim\n&gt; &quot;That&#39;s not correct!\n&gt; The last one is equilateral&quot; and amend the spec to\n&gt; exclude equilateral\n&gt; triangles from the definition of isosceles.\n&gt; \n&gt; A second attempt might amend the code to,\n&gt; \n&gt;   public boolean isIsosceles() {\n&gt;     return a == b || a == c || b == c;\n&gt;   }\n&gt; \n&gt; The existing tests would then serve as a regression\n&gt; suite. After the\n&gt; change, one of the tests (the previously incorrect\n&gt; one) would now fail\n&gt; and (we hope) the others would still pass.\n&gt; \n&gt; Assuming the tests are essentially &#39;free&#39; and that\n&gt; we can trust the\n&gt; machine to generate tests that are at least as good\n&gt; as they were\n&gt; before, we can throw all the existing tests away and\n&gt; generate new\n&gt; ones.\n&gt; \n&gt; Then we might get a test like this,\n&gt; \n&gt;     public void testIsIsosceles2() throws Throwable\n&gt; {\n&gt;         boolean result = new Triangle(36, 36,\n&gt; 36).isIsosceles();\n&gt;         assertFalse(&quot;result&quot;, result);\n&gt;     }\n&gt; \n&gt; and be happy that our method now behaves correctly.\n&gt; \n&gt; There are a lot of &#39;if&#39;s and &#39;assuming&#39;s in all that\n&gt; but, with a\n&gt; machine that could generate perfect regression tests\n&gt; in zero time, we\n&gt; might think quite differently about the value of\n&gt; tests and how we use\n&gt; them.\n&gt; \n&gt; As JB suggested, it is impossible for a program to\n&gt; prove the\n&gt; correctness of another program. Even with a\n&gt; human/machine combo it is\n&gt; difficult and tedious which is why I still write all\n&gt; of my code test\n&gt; first with TDD.\n&gt; \n&gt; TDD provides excellent regression coverage too but,\n&gt; if it&#39;s\n&gt; essentially free to generate tests to fill the gaps\n&gt; in my TDD\n&gt; coverage, why wouldn&#39;t I?\n&gt; \n&gt; The more astute reader will have guessed that the\n&gt; examples above were\n&gt; lifted directly from the demo page at\n&gt; http://www.junitfactory.com/demo/   The service is\n&gt; still experimental\n&gt; and somewhat less than perfect, but I&#39;d be\n&gt; interested in getting\n&gt; feedback from the kind of people who think a lot\n&gt; about these kinds of\n&gt; things. I can send an invitation to anyone who wants\n&gt; one.\n&gt; \n&gt; Kevin\n&gt; \n&gt; http://www.junitfactory.com\n&gt; You send us code. We send you tests. For free.\n&gt; \n\n\n\n \n____________________________________________________________________________________\nNeed a quick answer? Get one in minutes from people who know.\nAsk your question on www.Answers.yahoo.com\n\n", 
    "profile": "ole_ersoy", 
    "topicId": 18605, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 98908154, 
    "prevInTime": 18697, 
    "contentTrasformed": false, 
    "postDate": "1168460324", 
    "canDelete": false, 
    "nextInTopic": 18699, 
    "prevInTopic": 18697, 
    "headers": {
        "inReplyToHeader": "PDUxZDFiMmRlMDcwMTEwMDk0N2k0ZGM3NzUxMHA0MjE5MTkwNmNkNTFhZjBhQG1haWwuZ21haWwuY29tPg==", 
        "messageIdInHeader": "PDQxNzQxNi4zMDIwOC5xbUB3ZWI2MDcxNS5tYWlsLnlhaG9vLmNvbT4="
    }
}