{
    "numMessagesInTopic": 8, 
    "nextInTime": 22937, 
    "senderId": "KN2boxKUrgFcKXYfrnvwtIfYiufnoXQRVM1caVLxDdolfQZvzFB6Nm7pt7EBhdghT-rUkqzpRb0sWefYtugZKaP7Fz6M2QOV3n_TV0MV", 
    "systemMessage": false, 
    "subject": "Re: [junit] Common Test Runner for JVM", 
    "from": "Esko Luontola &lt;esko.luontola@...&gt;", 
    "authorName": "Esko Luontola", 
    "msgSnippet": "... Yes. In addition to programming I do also interaction design, and usability is very important to me. My development process is to first design the UI and", 
    "msgId": 22936, 
    "rawEmail": "Return-Path: &lt;esko.luontola@...&gt;\r\nX-Sender: esko.luontola@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nX-Received: (qmail 99414 invoked from network); 13 Sep 2010 19:18:59 -0000\r\nX-Received: from unknown (66.196.94.107)\n  by m12.grp.re1.yahoo.com with QMQP; 13 Sep 2010 19:18:59 -0000\r\nX-Received: from unknown (HELO mail-ey0-f172.google.com) (209.85.215.172)\n  by mta3.grp.re1.yahoo.com with SMTP; 13 Sep 2010 19:18:59 -0000\r\nX-Received: by eyd10 with SMTP id 10so3350260eyd.31\n        for &lt;junit@yahoogroups.com&gt;; Mon, 13 Sep 2010 12:18:58 -0700 (PDT)\r\nX-Received: by 10.213.34.137 with SMTP id l9mr2121403ebd.16.1284405538708;\n        Mon, 13 Sep 2010 12:18:58 -0700 (PDT)\r\nReturn-Path: &lt;esko.luontola@...&gt;\r\nX-Received: from [127.0.0.1] (dsl-hkibrasgw2-ff75c300-100.dhcp.inet.fi [88.195.117.100])\n        by mx.google.com with ESMTPS id u9sm9717604eeh.11.2010.09.13.12.18.57\n        (version=SSLv3 cipher=RC4-MD5);\n        Mon, 13 Sep 2010 12:18:57 -0700 (PDT)\r\nMessage-ID: &lt;4C8E791D.5040704@...&gt;\r\nDate: Mon, 13 Sep 2010 22:18:53 +0300\r\nUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.2.9) Gecko/20100825 Thunderbird/3.1.3\r\nMIME-Version: 1.0\r\nTo: junit@yahoogroups.com\r\nReferences: &lt;4C8BFDE7.3010603@...&gt;\t&lt;AANLkTin4AXk8BGcbXGfm68KQFzLqbVzk+m22CrcUgRt1@...&gt; &lt;AANLkTim11ORO68irFhHrVCBvqH8vK9BQG26wiUxWd9Zd@...&gt;\r\nIn-Reply-To: &lt;AANLkTim11ORO68irFhHrVCBvqH8vK9BQG26wiUxWd9Zd@...&gt;\r\nContent-Type: text/plain; charset=windows-1252; format=flowed\r\nContent-Transfer-Encoding: 7bit\r\nFrom: Esko Luontola &lt;esko.luontola@...&gt;\r\nSubject: Re: [junit] Common Test Runner for JVM\r\nX-Yahoo-Group-Post: member; u=395435659; y=ARtBk555S2L0DbSw3joLQu5PGEZ9bu8PLzDmjfz83y7SYtHgzjk\r\nX-Yahoo-Profile: egeluontola\r\n\r\n&gt;  &gt; I notice that a\n&gt;  &gt; number of the issues you&#39;re tackling are mostly about IDE\n&gt;  &gt; integration\n\nYes. In addition to programming I do also interaction design, and \nusability is very important to me. My development process is to first \ndesign the UI and after that think about what is needed to implement it. \nQuite many times a good user interface affects all levels of the \nimplementation.\n\n\n&gt;  &gt; I wonder if thinking about the interface you wish IDEs\n&gt;  &gt; would talk to, and then getting at least one IDE to agree to it, would\n&gt;  &gt; be a good approach.\n\nYes, that&#39;s what I&#39;m planning. As Linus Torvalds says, &quot;Talk is cheap. \nShow me the code.&quot;\n\nMy current plan is to implement a minimal set of features, create a UI \nand integrate it with IntelliJ IDEA. Then people can better see what \nthis is all about, and can better decide whether it&#39;s something that \nthey like. I will setup a dedicated mailing list and contact the major \ntool vendors after I have something working to show (right now I&#39;m only \ngauging some interest on JUnit, scala-tools and simple-build-tool \nmailing lists).\n\n\n&gt; I think the main advantage to being able to count the tests before\n&gt; you run\n&gt; them is that is that you can make a progress bar that gives feedback to the\n&gt; user as the tests run. That&#39;s a really nice feature in GUI test runners that\n&gt; is lost if you can&#39;t count tests in advance. It would be possible to make\n&gt; the advance test count an optional feature, but then when tests can&#39;t be\n&gt; counted, you couldn&#39;t show a progress bar. And I think that would be a\n&gt; pretty big loss.\n\nI&#39;ve thought about that. It&#39;s possible to measure progress at least on \nthe class level. And within a class, the completion of a class can be \napproximated as more tests are discovered.\n\nI&#39;m also planning on making the tool remember statistics from previous \ntest runs (and do some classloader caching of external libraries, to \nspeed up the test runs), so after the first test run the tool will know \nquite accurately that how many tests there are and how long each of them \ntakes to execute.\n\nI&#39;ve also thought about some ways to detect which classes are covered by \na test, which information can be used to run first the tests for the \nrecently modified classes. So there might be some features similar to \nJUnit Max (I haven&#39;t used Max because it&#39;s not available on IntelliJ IDEA).\n\n\n&gt;  &gt; In terms of IDE integration, JUnit just reports a tree of\n&gt;  &gt; Descriptions, and results against them. Runners are free to structure\n&gt;  &gt; these trees however they wish. Have you run into IDE limitations for\n&gt;  &gt; displaying/interacting with these trees?\n&gt;  &gt;\n&gt; I would question the need for nesting tests. I can easily see the benefit\n&gt; of nesting closures in test code. Several traits in ScalaTest do that, but\n&gt; the model I use in ScalaTest is that each leaf node is one test. The\n&gt; closures surrounding the leaf nodes are descriptions, not tests themselves.\n&gt; I would think you and Eric could adopt that approach in Specs and Specsy\n&gt; without much trouble.\n\nIt would be possible for me to detect the leaf nodes after the tests \nhave been run, but I prefer the UI to show the correct mental model of \nwhat is happening during test runs.\n\nTo illustrate, here is a partial version of one of Specsy&#39;s example \nspecs with some println() debug statements.\n\n@RunWith(classOf[Specsy])\nclass StackSpec extends Spec {\n   val stack = new scala.collection.mutable.Stack[String]\n   println(stack)\n\n   &quot;When objects have been pushed onto a stack&quot; &gt;&gt; {\n     stack.push(&quot;pushed first&quot;)\n     stack.push(&quot;pushed last&quot;)\n     println(stack)\n\n     &quot;the object pushed last is popped first&quot; &gt;&gt; {\n       val poppedFirst = stack.pop()\n       assertThat(poppedFirst, is(&quot;pushed last&quot;))\n       println(stack)\n     }\n     &quot;the object pushed first is popped last&quot; &gt;&gt; {\n       stack.pop()\n       val poppedLast = stack.pop()\n       assertThat(poppedLast, is(&quot;pushed first&quot;))\n       println(stack)\n     }\n   }\n}\n\nTo execute that, Specsy needs to instantiate and run the class two \ntimes. The first test run will print:\n\nStack()\nStack(pushed last, pushed first)\nStack(pushed first)\n\nThe second test run will print:\n\nStack()\nStack(pushed last, pushed first)\nStack()\n\nMy vision is that the UI would visualize where one test ends and another \nbegins. It would provide the same information as the following examples \n(but better visualized ;).\n\nTest run 1:\n\n-- &lt;net.orfjackal.specsy.examples.StackSpec&gt;\nStack()\n--     &lt;When objects have been pushed onto a stack&gt;\nStack(pushed last, pushed first)\n--         &lt;the object pushed last is popped first&gt;\nStack(pushed first)\n--         &lt;/the object pushed last is popped first&gt;\n--     &lt;/When objects have been pushed onto a stack&gt;\n-- &lt;/net.orfjackal.specsy.examples.StackSpec&gt;\n\nTest run 2:\n\n-- &lt;net.orfjackal.specsy.examples.StackSpec&gt;\nStack()\n--     &lt;When objects have been pushed onto a stack&gt;\nStack(pushed last, pushed first)\n--         &lt;the object pushed first is popped last&gt;\nStack()\n--         &lt;/the object pushed first is popped last&gt;\n--     &lt;/When objects have been pushed onto a stack&gt;\n-- &lt;/net.orfjackal.specsy.examples.StackSpec&gt;\n\nThen when I select &quot;StackSpec&quot; or &quot;When objects have been pushed onto a \nstack&quot; in the tree of tests shown by the UI, it would show both of those \ntest runs, because those tests were included in both of them. But if I \nselect &quot;the object pushed last is popped first&quot; then it will show only \ntest run 1, and if I select &quot;the object pushed first is popped last&quot; it \nwill show only test run 2.\n\n\n&gt;  &gt; That assumption is in the IDE&#39;s. It&#39;s a useful one, but it&#39;s neither\n&gt;  &gt; required nor assumed by JUnit itself.\n\nTrue. I would like to make that concept explicit, so that the testing \nframework could help the IDE with code navigation.\n\n\n&gt;  &gt; We&#39;ve taken several stabs at this. The biggest hurdle is how to\n&gt;  &gt; extend the test-definition language: while many tests can be\n&gt;  &gt; parallelized without cost, and test writers should not depend on\n&gt;  &gt; order, they currently might depend on only test being written at the\n&gt;  &gt; time.\n\nI&#39;ve been thinking whether to make parallelization enabled by default. \n From a usability point of view, I would prefer to &quot;design for one user&quot; \n(as advocated for example by Alan Cooper) and as such I&#39;m tempted to \nwrite the test runner for programmers who write tests which don&#39;t depend \non any global state (i.e. I would design it for myself :).\n\nFor tests which cannot be executed safely in parallel, my plan is to \nmake it possible to annotate the class with @LocallySequential or \n@GloballySequential. The first annotation would still allow running \ntests from other classes in parallel, but the second annotation would \nexecute this one test class all alone.\n\n\n&gt;  &gt; Test discovery seems to be yet another feature of a common IDE interface.\n\nAnd build tools.\n\nOne thing that I&#39;m also trying to solve, is minor differences between \nrunning tests in the IDE vs. running them through a build tool. For \nexample IntelliJ IDEA executes all tests in the project using the same \nclasspath, but Maven uses the classpath of the module which contains the \ntests. If two modules use different versions of a library (I have one \nsuch project), then this difference might be important.\n\nAlso I want to get rid of bugs such as \nhttp://youtrack.jetbrains.net/issue/IDEA-57696 &quot;IDEA&#39;s JUnit test runner \ndoes not run Scala classes which are annotated with \norg.junit.runner.RunWith&quot;. Running tests is such an important feature, \nthat I don&#39;t want it to have any bugs.\n\n-- \nEsko Luontola\nwww.orfjackal.net\n\n", 
    "profile": "egeluontola", 
    "topicId": 22933, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 395435659, 
    "prevInTime": 22935, 
    "contentTrasformed": false, 
    "postDate": "1284405533", 
    "canDelete": false, 
    "nextInTopic": 22937, 
    "prevInTopic": 22935, 
    "headers": {
        "inReplyToHeader": "PEFBTkxrVGltMTFPUk82OGlyRmhIclZDQnZxSDh2SzlCUUcyNndpVXhXZDlaZEBtYWlsLmdtYWlsLmNvbT4=", 
        "messageIdInHeader": "PDRDOEU3OTFELjUwNDA3MDRAZ21haWwuY29tPg==", 
        "referencesHeader": "PDRDOEJGREU3LjMwMTA2MDNAZ21haWwuY29tPgk8QUFOTGtUaW40QVhrOEJHY2JYR2ZtNjhLUUZ6THFiVnprK20yMkNyY1VnUnQxQG1haWwuZ21haWwuY29tPiA8QUFOTGtUaW0xMU9STzY4aXJGaEhyVkNCdnFIOHZLOUJRRzI2d2lVeFdkOVpkQG1haWwuZ21haWwuY29tPg=="
    }
}