{
    "numMessagesInTopic": 10, 
    "nextInTime": 2251, 
    "senderId": "LZfYZyGLw6q6AGYQx-iPhVyxXsX5ZPA3fCZMH6BcMYexp1FmqDORiwmT4MA1OH3DnXVzxRfoDvHgfp8L8KnwJXiev0qM", 
    "systemMessage": false, 
    "subject": "Re: [junit] Re: False warnings? (Re: re - assert counting)", 
    "from": "Eric Vought &lt;evought@...&gt;", 
    "authorName": "Eric Vought", 
    "msgSnippet": "One of the distinctions I have often found useful is whether a failure is a test precondition or postcondition failure. This is especially true where there is", 
    "msgId": 2250, 
    "topicId": 2171, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 0, 
    "messageBody": "<div id=\"ygrps-yiv-374644343\">One of the distinctions I have often found useful is whether a failure<br/>\nis a test precondition or postcondition failure. This is especially<br/>\ntrue where there is a deep tree of dependencies in the testcases (which is<br/>\noften the case). A single bug can cause hundreds of failures; Only one<br/>\nfailure is probably significant. We had an in-house test harness at some<br/>\npoint that had assertions which would return different result codes on<br/>\nfailure. One of them was INCOMPLETE. A test would be INCOMPLETE if<br/>\nsomething failed in setting up the test indicating a problem with a<br/>\ndependency which is not the direct purpose of the test. Semi-contrived<br/>\nexample:<br/>\n<br/>\nvoid testConnectLogger()<br/>\n{<br/>\n\tprecondition(d_logger.isOpen());<br/>\n\tprecondition(d_logger.queue().isEmpty());<br/>\n<br/>\n\td_service.connectLogger(d_logger);<br/>\n<br/>\n\tpostcondition(d_service.getLogger() == d_logger);<br/>\n\tpostcondition(d_logger.queue().size() == 1);<br/>\n} // testConnectLogger()<br/>\n<br/>\nIf the preconditions fail, it means that the test couldn&#39;t run, not that<br/>\nit &quot;fails&quot; per se. Precondition failure were enough to fail an entire<br/>\nrun, but they were tallied separately. If you see:<br/>\n<br/>\nRUN: 45<br/>\nFAILED: 1<br/>\nINCOMPLETE: 33<br/>\n<br/>\n[Test testSomeDependencyOrOther FAILED]<br/>\n<br/>\n...<br/>\n<br/>\nIt&#39;s very obvious what the culprit is. Exceptions in setUp()<br/>\nmethods should also cause tests in that unit to be INCOMPLETE.<br/>\nAnother useful thing is to be able to write code like:<br/>\n<br/>\nvoid testSpecialCall()<br/>\n{<br/>\n\tif (!HAVE_SPECIAL_LIB) cancel();<br/>\n<br/>\n\tpostcondition(specialCall() == 5);<br/>\n} // testSpecialCall()<br/>\n<br/>\nCertain tests may be inappropriate in certain environs. You don&#39;t want<br/>\nthese tests to pass, since that&#39;s misleading. You certainly don&#39;t want<br/>\nthem to fail though, because determining whether or not a test run was<br/>\nsuccessful overall becomes error-prone. It&#39;s nice to have a count of the<br/>\ntests that ended up being inappropriate for a particular setup.<br/>\n<br/>\n<blockquote><span title=\"qreply\"> On Fri, 3 Aug 2001, David Avraamides wrote:<br/>\n<br/>\n&gt; &gt; Agreed; however, I find it nice to go on the<br/>\n&gt; &gt; assumption that a failure means<br/>\n&gt; &gt; my code is broken and an error means my test is<br/>\n&gt; &gt; broken. I wonder if not many<br/>\n&gt; &gt; people find this useful or if I&#39;m overstating how<br/>\n&gt; &gt; useful it can be.<br/>\n&gt;<br/>\n&gt; In the past I tried to make this same distinction, but<br/>\n&gt; I found in practice that it was often arbitrary.<br/>\n&gt; Often, I&#39;ll change code that invalidates existing test<br/>\n&gt; cases so they start throwing assertions. The code<br/>\n&gt; isn&#39;t broken, the problem is that the test cases are<br/>\n&gt; out of sync with the code since the assumptions have<br/>\n&gt; changed. To me, it doesn&#39;t really matter what&#39;s broken<br/>\n&gt; (testing code or tested code) or how I&#39;m notified of<br/>\n&gt; the problem (assertion or error). The point is that I<br/>\n&gt; need to investigate the problem and fix it.<br/>\n&gt;<br/>\n&gt; For me, the path of least resistance is the most<br/>\n&gt; effective: make my test cases simple to write and<br/>\n&gt; simple to understand. Thus, I prefer letting JUnit<br/>\n&gt; handle uncaught exceptions as errors since this:<br/>\n&gt;<br/>\n&gt;   public void testFoo() throws Exception {<br/>\n&gt;     code;<br/>\n&gt;   }<br/>\n&gt;<br/>\n&gt; is simpler than:<br/>\n&gt;<br/>\n&gt;   public void testFoo() {<br/>\n&gt;     try {<br/>\n&gt;       code;<br/>\n&gt;     catch (ErrorException e) {<br/>\n&gt;       fail(...);<br/>\n&gt;     }<br/>\n&gt;   }<br/>\n&gt;<br/>\n&gt; Both versions say the same thing to me: I expect<br/>\n&gt; &quot;code&quot; to work, and if it doesn&#39;t something is wrong.<br/>\n&gt; I just find the latter case less clear.<br/>\n&gt;<br/>\n&gt; My two cents...<br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n&gt; __________________________________________________<br/>\n&gt; Do You Yahoo!?<br/>\n&gt; Make international calls for as low as $.04/minute with Yahoo! Messenger<br/>\n&gt; <a rel=\"nofollow\" target=\"_blank\" href=\"http://phonecard.yahoo.com/\">http://phonecard.yahoo.com/</a><br/>\n&gt;<br/>\n&gt;<br/>\n&gt; To unsubscribe from this group, send an email to:<br/>\n&gt; <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:junit-unsubscribe@yahoogroups.com\">junit-unsubscribe@yahoogroups.com</a><br/>\n&gt;<br/>\n&gt;<br/>\n&gt; Your use of Yahoo! Groups is subject to <a rel=\"nofollow\" target=\"_blank\" href=\"http://docs.yahoo.com/info/terms/\">http://docs.yahoo.com/info/terms/</a><br/>\n&gt;<br/>\n&gt;<br/>\n&gt;<br/>\n<br/>\n-- <br/>\nEric Vought<br/>\nChief Technical Officer - QLUE Consulting, Inc.<br/>\n<br/>\n<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:evought@...\">evought@...</a> toll-free: 888-771-3538  RTP area: 919-816-9901 </span></blockquote></div>", 
    "prevInTime": 2249, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "996989116", 
    "canDelete": false, 
    "nextInTopic": 2263, 
    "prevInTopic": 2246, 
    "headers": {
        "inReplyToHeader": "PDIwMDEwODA0MDUxMTAyLjMyMDk3LnFtYWlsQHdlYjEzOTA1Lm1haWwueWFob28uY29tPg==", 
        "messageIdInHeader": "PFBpbmUuTE5YLjQuMzAuMDEwODA1MDEwMzI1MC4zMTg0MC0xMDAwMDBAYnJhaW4ucWx1ZS1sYW4+"
    }
}