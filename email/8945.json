{
    "numMessagesInTopic": 106, 
    "nextInTime": 8946, 
    "senderId": "j-wVRaza0OPf1VclEiOXEt_pKsuVKa1shXjPqmuScS-qdc30KDUFA35rDw7TITU1cyP0rS9JP2XbFq56gp-MPyMF4y7YWKnJb67p", 
    "systemMessage": false, 
    "subject": "RE: [junit] TestCase Dependency Hierarchy", 
    "from": "David Boyer &lt;mangr3n@...&gt;", 
    "authorName": "David Boyer", 
    "msgSnippet": "... I think what everyone s trying to tell you is that this issue of dependencies in your tests is a code smell, and though you may be used to doing it this", 
    "msgId": 8945, 
    "profile": "mangr3n", 
    "topicId": 8807, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 138345974, 
    "messageBody": "<div id=\"ygrps-yiv-1468359262\">On Thu, 2003-07-31 at 09:47, Adam Jack wrote:<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; You guys all seem very caught up on decoupling, and I&#39;ll acknowledge I am<br/>\n&gt; far from an OO purist, I have a job to do & I write code. I attempt to write<br/>\n&gt; standalone (decoupled) classes, I attempt to make them have well structed<br/>\n&gt; &quot;APIs&quot; but at the end of the day, if A uses B (however implemented, and<br/>\n&gt; however used -- aggregation, subclassing, command/messaging paradigms,<br/>\n&gt; whatever) *for whatever reason* then surely for A to work, B ought work? If<br/>\n&gt; B fail a test then it has broken the contracts the tests assert, so it&#39;s<br/>\n&gt; behaviours must be deemed unknown. I B is unknown, I could argue (a user<br/>\n&gt; choice, on a per case basis) that it isn&#39;t worth knowing what the outcome of<br/>\n&gt; A&#39;s results test are. If they pass, then perhaps those tests don&#39;t cover<br/>\n&gt; enough. If they fail, isn&#39;t quite likely because B failed and what A relied<br/>\n&gt; upon is bogus?<br/>\n<br/>\n </span></blockquote>I think what everyone&#39;s trying to tell you is that this issue of<br/>\ndependencies in your tests is a code smell, and though you may be used<br/>\nto doing it this way, there MIGHT be a healthy way to decouple your code<br/>\nso that this issue doesn&#39;t persist.<br/>\n<br/>\n<br/>\n<blockquote><span title=\"ireply\"> &gt; &gt;\tMaybe the direct dependency on the collection object is the problem in the<br/>\n&gt; &gt;\tfirst place. You could take your problem with many test cases failing at<br/>\n&gt; once<br/>\n&gt; &gt;\tas a strong hint to remove this direct dependency. If your collection<br/>\n&gt; object,<br/>\n&gt; &gt;\thowever, is so low level that a direct dependency does not hurt then it<br/>\n&gt; &gt;\tshould be very very stable; the probability that it fails in a fundamental<br/>\n&gt; way,<br/>\n&gt; &gt;\twhich makes lots of other tests fail too, is very low.<br/>\n&gt; <br/>\n&gt; There might be gold in that statement. You are saying that failures can<br/>\n&gt; propagate (as I say) but that as you go up the stack the chance for<br/>\n&gt; catastrophic failure ought not be there. I wonder if the result I am looking<br/>\n&gt; for is better suited in the case of catastrophic failure, not just &quot;some<br/>\n&gt; obscure failure&quot;. That is possible.<br/>\n&gt; <br/>\n&gt; With this observation, maybe what I am asking for is too fuzzy. I think that<br/>\n&gt; code uses code (however you structure it) and much as there ought not be<br/>\n&gt; dependency on internal, if code breaks is &quot;API agreement&quot; then anything that<br/>\n&gt; uses that API is in doubt, and not worth testing. Trouble is, I&#39;d not want<br/>\n&gt; to do this on a &quot;method by method&quot; or &quot;test by test&quot; basics, so I was<br/>\n&gt; proposing doing it on TestCases. At this level, I can see how it is not fine<br/>\n&gt; grained enough, and perhaps too fuzzy.<br/>\n<br/>\n </span></blockquote>OK Here I can talk about this.   <br/>\n<br/>\nIn my code, if an object I&#39;m working on wants to offer behavior to<br/>\nothers, he first gets an Interface and then I create an interface for<br/>\npeople he works with.  Next I implement those two interfaces.  In order<br/>\nto test each Implementation, I run a MockObject of the interface not<br/>\nbeing tested.  MockObjects don&#39;t fail and don&#39;t need to be tested.  Each<br/>\nobject can be tested in isolation from the other.  I don&#39;t have to worry<br/>\nabout some other class failing, and thus making my test on The other<br/>\nclass suspect. (Psst... Use EasyMock)<br/>\n<br/>\nMy biggest pet peeve in my current job, is a Monster Singleton that&#39;s<br/>\nreferred to by static reference EVERYWHERE IN OUR GUI!!!!<br/>\n<br/>\nCan&#39;t test anything, because that singleton is so tightly coupled with<br/>\nall of the code, and he takes a lot, including a Tomcat server address<br/>\n(working) in order to do even the slightest thing.  So, my major task at<br/>\nmy work is to slowly but surely reduce the dependencies on this monster,<br/>\nas I go.  I do it very slowly and by forcing people to work through an<br/>\ninterface instead of directly through him.  I&#39;m still plugging away at<br/>\nit.   I shall overcome!<br/>\n<br/>\nCheers,<br/>\n<br/>\n-- <br/>\nDavid Boyer &lt;<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:mangr3n@...\">mangr3n@...</a>&gt;</div>", 
    "prevInTime": 8944, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1059742284", 
    "canDelete": false, 
    "nextInTopic": 8946, 
    "prevInTopic": 8944, 
    "headers": {
        "inReplyToHeader": "PDAwMDAwMWMzNTc4OCQ2ZDVjOWE2MCQyODc4MTYwYUBzeWJhc2UuY29tPg==", 
        "messageIdInHeader": "PDEwNTk3NDIyODQuMjE2My44MS5jYW1lbEBsb2NhbGhvc3Q+", 
        "referencesHeader": "PDAwMDAwMWMzNTc4OCQ2ZDVjOWE2MCQyODc4MTYwYUBzeWJhc2UuY29tPg=="
    }
}