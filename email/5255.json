{
    "numMessagesInTopic": 67, 
    "nextInTime": 5256, 
    "senderId": "juhWpYR8ZYbCUWR5HtcJ5mEOVn0HP86OKLtlv0U-hm4Wg5tTTiZk3jDirdUdT76zYDX1Js0wIyvX48xreDBH9YjQID9YasdevkGMmFI", 
    "systemMessage": false, 
    "subject": "RE: [junit] Re: distinguishing between failures and errors", 
    "from": "Daniel Barclay &lt;dbarclay@...&gt;", 
    "authorName": "Daniel Barclay", 
    "msgSnippet": "... Because tests aren t specifications. (How can a test show that the caller is responsible for not passing in a null pointer? You can t test for any", 
    "msgId": 5255, 
    "topicId": 5186, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 111812165, 
    "messageBody": "<div id=\"ygrps-yiv-510607297\"><blockquote><span title=\"ireply\">&gt; From: J. B. Rainsberger [mailto:<a rel=\"nofollow\" target=\"_blank\" href=\"mailto:jbr@...\">jbr@...</a>]<br/>\n&gt;...<br/>\n&gt; &gt; Isn&#39;t documentation the thing that should be used to tell the<br/>\n&gt; &gt; writer of code that calls yours what your code is supposed to<br/>\n&gt; &gt; do, or what the caller is supposed to do (or not do)?  (At<br/>\n&gt; &gt; least for code meant to be re-used, such as that implementing<br/>\n&gt; &gt; an API?)<br/>\n&gt; <br/>\n&gt; Yes, it is. Please explain to me why unit tests are not <br/>\n&gt; documentation. :)<br/>\n<br/>\n<br/>\n </span></blockquote>Because tests aren&#39;t specifications. <br/>\n<br/>\n(How can a test show that the caller is responsible for not <br/>\npassing in a null pointer?<br/>\n<br/>\nYou can&#39;t test for any particular behavior from the callee<br/>\nif the callee&#39;s behavior in the face of a null pointer is <br/>\nintentially left undefined (e.g., for flexibility in <br/>\nimplementing an interface).)<br/>\n<br/>\n(How can a test show that a caller is responsible for not<br/>\ndepending on certain current behavior of an implementation<br/>\nthat is not part of the interface contract?)<br/>\n<br/>\n<br/>\nBecause tests are code.  <br/>\n<br/>\n(They have syntactic clutter that is necessary for use as tests <br/>\nbut which is just clutter relative to the information useful to a <br/>\nclient programmer.)<br/>\n<br/>\n<br/>\nBecause tests, being code, can&#39;t relate code to external concepts.  <br/>\n<br/>\n(A specification can say that a function f returns the mathematical<br/>\nsum of two given integers subject to the limitations of 32-bit<br/>\nsigned binary arithmetic.  How can a test say something like that?)<br/>\n<br/>\n<br/>\nTests are great, but don&#39;t forget the documentation.<br/>\n<br/>\n<br/>\nIt seems that some people who write tests waste one advantage of it:  <br/>\n<br/>\nI agree that testing, especially writing tests even before you implement, <br/>\nis good because it forces you to think about what your code is supposed <br/>\nto do and how it&#39;s supposed to be used.  <br/>\n<br/>\nWell, if you&#39;re already thinking about the contract, then that&#39;s a<br/>\ngood time to document the contract.  <br/>\n<br/>\n<br/>\nYes, I know this has to be modulated by what kind of code we&#39;re<br/>\ntalking about (e.g., intra-program calls versus trans-API calls) <br/>\nand by how stable the interface contract is.  I just wouldn&#39;t<br/>\nwant to have to read test cases instead of Javadoc to figure <br/>\nout how, say, Sun&#39;s Servlet API worked and was supposed to be <br/>\nused. <br/>\n<br/>\n<br/>\n<br/>\nDaniel</div>", 
    "prevInTime": 5254, 
    "specialLinks": [], 
    "contentTrasformed": false, 
    "postDate": "1025024763", 
    "canDelete": false, 
    "nextInTopic": 5256, 
    "prevInTopic": 5254, 
    "headers": {
        "messageIdInHeader": "PEQ1Nzc2RDA5RDA4NEE3NDBCNUQ3RjI5MjY2ODBGQ0YzMDExRkUyMjhAbXVzMDAxbXVsbGV0Lm1lcmNhdG9yLmNvbT4="
    }
}