{
    "topicId": 5875, 
    "postDate": "1033411504", 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "from": "&quot;Michael Silverstein&quot; &lt;msilverstein@...&gt;", 
    "canDelete": false, 
    "replyTo": "LIST", 
    "senderId": "yCD656PgAVRf5VWqQK8hHKRuOiAYX16N9u0JAw6LULEvhu363RMqibf4N1YeI6VarfAb1PmsOGrL2kAN96Ah9ztXQ4frmXZF9gJEpkdosNt5AM-ntBywdI8s", 
    "nextInTime": 5886, 
    "userId": 62742148, 
    "prevInTime": 5884, 
    "prevInTopic": 5882, 
    "headers": {
        "inReplyToHeader": "PDIwMDIwOTMwMDk1NzI2LjkzMTMuaDAwMS5jMDAzLndtQG1haWwudGVsb2NpdHkuY29tLmNyaXRpY2FscGF0aC5uZXQ+", 
        "messageIdInHeader": "PE5EQkJKRUZLTURHRklCRUtLRUxFR0VHQ0VEQUEubXNpbHZlcnN0ZWluQHNpbHZlcm1hcmsuY29tPg=="
    }, 
    "authorName": "Michael Silverstein", 
    "numMessagesInTopic": 38, 
    "msgSnippet": "To add to what Vladimir was saying, I ve needed to override the way tests are launched and managed. Because of the way the test runners are implemented (in the", 
    "contentTrasformed": false, 
    "msgId": 5885, 
    "nextInTopic": 5886, 
    "systemMessage": false, 
    "rawEmail": "Return-Path: &lt;msilverstein@...&gt;\r\nX-Sender: msilverstein@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (EGP: mail-8_1_1_4); 30 Sep 2002 18:47:48 -0000\r\nReceived: (qmail 18737 invoked from network); 30 Sep 2002 18:47:48 -0000\r\nReceived: from unknown (66.218.66.217)\n  by m3.grp.scd.yahoo.com with QMQP; 30 Sep 2002 18:47:48 -0000\r\nReceived: from unknown (HELO mr2.ash.ops.us.uu.net) (198.5.241.87)\n  by mta2.grp.scd.yahoo.com with SMTP; 30 Sep 2002 18:47:48 -0000\r\nReceived: from dell7500 by mr2.ash.ops.us.uu.net with SMTP \n\t(peer crosschecked as: [63.86.212.130])\n\tid QQniox27300\n\tfor &lt;junit@yahoogroups.com&gt;; Mon, 30 Sep 2002 18:47:47 GMT\r\nTo: &lt;junit@yahoogroups.com&gt;\r\nSubject: RE: [junit] Do JUnit internals suck?!?\r\nDate: Mon, 30 Sep 2002 14:45:04 -0400\r\nMessage-ID: &lt;NDBBJEFKMDGFIBEKKELEGEGCEDAA.msilverstein@...&gt;\r\nMIME-Version: 1.0\r\nContent-Type: text/plain;\n\tcharset=&quot;US-ASCII&quot;\r\nContent-Transfer-Encoding: 7bit\r\nX-Priority: 3 (Normal)\r\nX-MSMail-Priority: Normal\r\nX-Mailer: Microsoft Outlook IMO, Build 9.0.2416 (9.0.2910.0)\r\nImportance: Normal\r\nX-MimeOLE: Produced By Microsoft MimeOLE V5.00.3018.1300\r\nIn-Reply-To: &lt;20020930095726.9313.h001.c003.wm@...&gt;\r\nFrom: &quot;Michael Silverstein&quot; &lt;msilverstein@...&gt;\r\nReply-To: &lt;msilverstein@...&gt;\r\nX-Yahoo-Group-Post: member; u=62742148\r\n\r\n\nTo add to what Vladimir was saying, I&#39;ve needed to override the way tests\nare launched and managed. Because of the way the test runners are\nimplemented (in the junit.framework.BaseTestRunner hierarchy), we ended up\nduplicating code in subclasses of the runner views. I agree that there&#39;s way\ntoo much replication in functionality between the different flavors of test\nrunners. It bit me several times. Note: by view, I mean whatever is\nresponsible for the presentation and control behavior.\n\nFor me, it would be advantageous to be able to provide arbitrary test\nrunners that implement a test runner interface (whatever that turns out to\nbe) to the views. If done right, it can live in parallel with the current\nimplementation for a couple of iterations.\n\nHere&#39;s a very simple test case off the top of my head that shows what I\nmean:\n\nimport junit.framework.*;\npublic class TestRunner extends junit.framework.TestCase implements\nTestListener {\n\tint errorCount;\n\tint failureCount;\n\tITestRunner runner;\n\tString testClassName= &quot;junit.samples.money.MoneyTest&quot;;\n\npublic void synchronousTestRunnerTest() {\n\trunner= new SynchronousTestRunner(testClassName);\n\n\t// Perhaps needing to instantiate the runner under a try/catch block for\n\t// ClassNotFoundException, etc. would be better than this. Thoughts?\n\tassertTrue(runner.testClassIsValid());\n\n\t// In my case, the count of test cases was derived from\n\t// the actual count and other parameters, so going through\n\t// the runner for the count would be preferred\n\tassertEquals(runner.countTestCases(),21);\n\n\trunner.addListener(this);\n\trunner.start();\n\n\t// With the synchronous test runner here, you can assume it is done after\n\t// returning from start(). With an asynchronous test runner, you would\n\t// need to be notified of completion, which implies extending the\n\t// listener interface.\n\tvalidateResult(result);\n\npublic void validateResult(ITestResult result) {\n\t// Simple result assertions. If I knew that the runner returned\n\t// results that included other arbitrary information, I\n\t// would cast and assert appropriately.\n\tITestResult result= runner.getResult();\n\tassertTrue(result.getExecutionTime() &gt; 0);\n\tassertEquals(result.getTestsRun(),21);\n\tassertEquals(result.getFailureCount(),0);\n\tassertEquals(result.getErrorCount(),0);\n\n\t// Simple listener assertions\n\tassertEquals(result.getFailureCount(),failureCount);\n\tassertEquals(result.getErrorCount(),errorCount);\n}\n\npublic void addError(Test test, Throwable t) {\n\terrorCount++;\n}\n\npublic void addFailure(Test test, Throwable t) {\n\tfailureCount++;\n}\n\n\nLet&#39;s say we add the following to TestListener:\n/**\n * The entire test has completed\n */\npublic void testComplete(Test test);\n\nThen we can do the following to test an asynchronous test runner, if one\nwere ever needed. I&#39;ve eliminated some of the stuff that would have been\nrepetitions of the above. Note: To do this right, we would add a timer to\nfail the test if it does not complete within a reasonable time.\n\npublic void asynchronousTestRunnerTest() {\n\trunner= new AsynchronousTestRunner(testClassName);\n\trunner.addListener(this);\n\n\t// Asynchronously spawn test\n\trunner.start();\n}\n\npublic void testComplete(Test test) {\n\tvalidateResult(runner.getResult());\n}\n\n^^^^^^^^^^^^^^^^^^^^^^^^^\nMike Silverstein\nSilverMark, Inc.\nThe object testing company\nhttp://www.javatesting.com\n\n\n&gt; -----Original Message-----\n&gt; From: Vladimir Bossicard [mailto:vbossica@...]\n&gt; Sent: Monday, September 30, 2002 12:57 PM\n&gt; To: junit@yahoogroups.com\n&gt; Subject: RE: [junit] Do JUnit internals suck?!?\n&gt;\n&gt;\n&gt; &gt; Could he define the code smell &quot;the code sucks&quot; ?\n&gt;\n&gt; One refactoring could improve the internal API: the rerun method\n&gt; is duplicated\n&gt; in the AWT and Swing runners. Move this method to the BaseTestRunner.\n&gt;\n&gt; The following refactorings are a natural consequence of the first one:\n&gt;\n&gt; - move all run methods into the BaseTestRunner (so that every\n&gt; runners can run a\n&gt; Test or a Class or a TestSuite)\n&gt; - replace all the abstract methods (used to communicate with the\n&gt; AWT, Swing and\n&gt; Text runners by a listener.\n&gt; - hide the TestResult completely and only let clients communicate with the\n&gt; listener.\n&gt;\n&gt; And it looks very nice :-)  Hopefully a future release will look\n&gt; nice too.  I&#39;m\n&gt; working on it.\n&gt;\n&gt; -Vladimir\n&gt;\n&gt; --\n&gt; Vladimir Bossicard\n&gt; www.bossicard.com\n&gt;\n\n\n", 
    "subject": "RE: [junit] Do JUnit internals suck?!?"
}