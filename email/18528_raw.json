{
    "numMessagesInTopic": 23, 
    "nextInTime": 18529, 
    "senderId": "9TyEE3vCymD8U8E6TSz-UbS0Sv0lBH1wTnt42IRiWZPolD217U73p2_G8zZLmrzLeySEAeO8y-mhwjpmqHH9ZIcJqUSpLib7HpEvz38HepzrGDvo01T6fhe8vQDRYfO9wzN3c3A", 
    "systemMessage": false, 
    "subject": "Re: [junit] Re: Essay: The Trouble With JUnit", 
    "from": "&quot;=?UTF-8?Q?C=C3=A9dric_Beust_=E2=99=94_?=&quot; &lt;cbeust@...&gt;", 
    "authorName": "Cédric Beust ♔", 
    "msgSnippet": "As much as I like the idea, I really don t think Design by Contract scales anywhere beyond collections and toy projects. Either your test is very simple and", 
    "msgId": 18528, 
    "rawEmail": "Return-Path: &lt;cbeust@...&gt;\r\nX-Sender: cbeust@...\r\nX-Apparently-To: junit@yahoogroups.com\r\nReceived: (qmail 1976 invoked from network); 11 Dec 2006 20:32:37 -0000\r\nReceived: from unknown (66.218.66.167)\n  by m28.grp.scd.yahoo.com with QMQP; 11 Dec 2006 20:32:37 -0000\r\nReceived: from unknown (HELO smtp-out.google.com) (216.239.33.17)\n  by mta6.grp.scd.yahoo.com with SMTP; 11 Dec 2006 20:32:36 -0000\r\nReceived: from spaceape8.eur.corp.google.com (spaceape8.eur.corp.google.com [172.28.16.142])\n\tby smtp-out.google.com with ESMTP id kBBKTK9u011173\n\tfor &lt;junit@yahoogroups.com&gt;; Mon, 11 Dec 2006 20:29:20 GMT\r\nReceived: from nz-out-0102.google.com (nzar28.prod.google.com [10.36.69.28])\n\tby spaceape8.eur.corp.google.com with ESMTP id kBBKSqlD004268\n\tfor &lt;junit@yahoogroups.com&gt;; Mon, 11 Dec 2006 20:29:18 GMT\r\nReceived: by nz-out-0102.google.com with SMTP id r28so873982nza\n        for &lt;junit@yahoogroups.com&gt;; Mon, 11 Dec 2006 12:29:18 -0800 (PST)\r\nReceived: by 10.65.59.20 with SMTP id m20mr5461840qbk.1165868958443;\n        Mon, 11 Dec 2006 12:29:18 -0800 (PST)\r\nReceived: by 10.64.84.16 with HTTP; Mon, 11 Dec 2006 12:29:18 -0800 (PST)\r\nMessage-ID: &lt;b86b6a9c0612111229m6417f5a9o3ffe58140bf8be0f@...&gt;\r\nDate: Mon, 11 Dec 2006 12:29:18 -0800\r\nTo: junit@yahoogroups.com\r\nIn-Reply-To: &lt;1165856942.10025.279904023@...&gt;\r\nMIME-Version: 1.0\r\nReferences: &lt;1165856942.10025.279904023@...&gt;\r\nX-eGroups-Msg-Info: 1:0:0:0\r\nFrom: &quot;=?UTF-8?Q?C=C3=A9dric_Beust_=E2=99=94_?=&quot; &lt;cbeust@...&gt;\r\nSubject: Re: [junit] Re: Essay: The Trouble With JUnit\r\nX-Yahoo-Group-Post: member; u=199443513; y=hj_lXAgD-fug-rDjx1x5bA4VEaLMDTLLojl-eWXOEiTE\r\nX-Yahoo-Profile: cbeust\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Transfer-Encoding: quoted-printable\r\n\r\nAs much as I like the idea, I really don&#39;t think Design by Contract scales\n=\r\nanywhere beyond collections and toy projects.\n\nEither your test is very sim=\r\nple and you are better off capturing it as an\nassert, or it&#39;s complex enoug=\r\nh to require an entire test in itself, and the\nvalue of completely tying it=\r\n to the class doesn&#39;t seem to add much compared\nto simply having a tests fo=\r\nr it.\n\nAnd in general, I still believe that pre/post conditions and invaria=\r\nnts are\nextremely hard to express to the point where spending time coming u=\r\np with\nthem is wasted time compared to writing a series of functional tests=\r\n.  If\nsomebody disagrees, I&#39;ll be happy to post some of the code I deal wit=\r\nh on a\nregular basis and see if they can come up with reasonable invariants=\r\n and\nconditions :-)\n\nDesign by Contract:  nice idea, great for education pu=\r\nrposes, but outclassed\nby functional testing in the real world.\n\n-- \nCedric=\r\n\nhttp://testng.org\n\n\n\nOn 12/11/06, Jan Theodore Galkowski &lt;jtgalkowski@alum=\r\n.mit.edu&gt; wrote:\n&gt;\n&gt; Hi David,\n&gt;\n&gt; Well, it&#39;s from the work of Tony Hoare a=\r\nnd others that if programs are\n&gt; annotated with a rich enough (minimally co=\r\nmplete) set of pre- and post-\n&gt; conditions describing state changes using p=\r\nredicate assertions, it&#39;s\n&gt; possible to delete the intervening program (or =\r\nstate transformation)\n&gt; steps and &quot;execute&quot; the program using just the stat=\r\ned pre- and post-\n&gt; conditions.  This is part of the motivation behind Bert=\r\nrand Meyer&#39;s work\n&gt; with Eiffel and Design By Contract.\n&gt;\n&gt; This is not, at=\r\n present, a part of the test-driven methodology, as far\n&gt; as I know, but it=\r\n is implicit in the sense that by writing tests first,\n&gt; the requirements f=\r\nor the code under test are supposed to be expressed in\n&gt; the tests.  Then, =\r\none invests in the &quot;throw anything at it&quot; cycle where\n&gt; code is written, te=\r\nsted using an xUnit, if it&#39;s red, add another\n&gt; assertion to cover the case=\r\n missed. If it&#39;s green, extend the scope of\n&gt; the requirements to better ap=\r\nproximate what&#39;s wanted.  There&#39;s cleanup\n&gt; via refactoring needed for code=\r\n.\n&gt;\n&gt; As mentioned, refactoring should probably be applied to the tests as\n=\r\n&gt; well, assuming they are complicated enough.  And, what I&#39;m getting at is\n=\r\n&gt; that perhaps the language of predicates, as well known and studied as it\n=\r\n&gt; is, isn&#39;t quite enough to make truly requirements-level test\n&gt; prescripti=\r\nons easy.\n&gt;\n&gt; Let&#39;s get narrow and specific for a moment.  Suppose you have=\r\n a Python-\n&gt; like language and want to assert that the head of a list L is =\r\n&#39;foo&#39;:\n&gt;\n&gt;   &#39;foo&#39; =3D=3D L[0]\n&gt;\n&gt; Sure, but you&#39;re obligated also to test =\r\nfirst that L has at least one\n&gt; element, lest the assertion itself fail.  Y=\r\nes, you can check first\n&gt;\n&gt;   1 &lt;=3D L.count(&#39;foo&#39;)\n&gt;\n&gt; then\n&gt;\n&gt;    &#39;foo&#39; =\r\n=3D=3D L[0]\n&gt;\n&gt; or even\n&gt;\n&gt;    1 &lt;=3D L.count(&#39;foo&#39;) and &#39;foo&#39; =3D=3D L[0]\n=\r\n&gt;\n&gt; relying upon short-circuiting evaluation, but wouldn&#39;t it be easier to\n=\r\n&gt; use some kind of Prolog-like matching notation\n&gt;\n&gt;     L =3D=3D [: &#39;foo&#39; =\r\n. % :]\n&gt;\n&gt; where I&#39;ve arbitrarily co-opted special brackets &quot;[:&quot; and &quot;:]&quot; t=\r\no\n&gt; indicate the (LISP) CONS-like pairing?  If actually realized in Python\n=\r\n&gt; the notation could be built into a tuple, but the idea would be if the\n&gt; =\r\nmatch fails, the assertion fails.\n&gt;\n&gt; If requirements are the focus of a te=\r\nst-driven approach, then the (a)\n&gt; language for expressing tests ought to n=\r\not tie up the hands of the\n&gt; programmer with worries about ancillary condit=\r\nions, (b) it ought to be\n&gt; perspicacious, and (c) it should allow an econom=\r\ny of expression which\n&gt; predicates and the base language don&#39;t.  The proble=\r\nms of writing &quot;bigger\n&gt; requirements&quot; get, well, bigger if the conditions t=\r\nested rely upon\n&gt; exogenous factors, like status of external resources or t=\r\nhe execution of\n&gt; other whole subsystems.  At present, I suppose try-except=\r\n-else could be\n&gt; put into the tests, but I think that&#39;s really a distractio=\r\nn.  I&#39;d\n&gt; probably encapsulate it in a function and then call the function =\r\nin the\n&gt; assertion.  All I&#39;m asking is why? and can&#39;t we do better?\n&gt;\n&gt; I&#39;m=\r\n sure once such a natural patterns sublanguage was decided, it could\n&gt; be b=\r\nuilt with present facilities in something like Python, Smalltalk,\n&gt; SCHEME,=\r\n LISP, probably Java and C#.  As for jsunit,  phpunit,  other\n&gt; such,  I ha=\r\nve my doubts.  There&#39;s a point of separation here: xUnit is a\n&gt; ubiquitous =\r\nmetapattern for testing.  Here, when seeing &quot;tests&quot; as a\n&gt; means of stating=\r\n program requirements, we&#39;re leaving ubiquity aside and\n&gt; reaching for bigg=\r\ner things.\n&gt;\n&gt; Leaving the narrow and specific, don&#39;t we really want to sep=\r\narate tests\n&gt; of a program fragment into two different kinds?  One kind tes=\r\nts whether\n&gt; the conditions we expect to be established for the fragment to=\r\n execute\n&gt; are actually there, the precondition.  The other kind tests whet=\r\nher the\n&gt; fragment actually achieved what we expect it to, the postconditio=\r\nn.\n&gt; Preconditions are in part a check that our tests themselves are proper=\r\nly\n&gt; formed.  In fact, although there&#39;s value in the unit-testing emphasis =\r\nof\n&gt; test-driven, we might carry these new kinds of test assertions over to=\r\n\n&gt; &quot;string testing&quot;, where each program fragment brings its precondition\n&gt; =\r\nwith it preceding it, and a postcondition with it succeeding it, and we\n&gt; c=\r\nan then test a series of fragments at once.\n&gt;\n&gt; This is a small step away f=\r\nrom Meyer&#39;s ultimate world.  I&#39;ve often\n&gt; thought how nice it would be if t=\r\nhe methods of a class could be\n&gt; discriminated among not only by their sign=\r\nature (argument numbers and\n&gt; types), but by an Eiffel-like &quot;require&quot; preco=\r\nndition that needs to be\n&gt; satisfied before the method is picked.  This wou=\r\nld further suppress the\n&gt; need for case analysis in nested if-then-else str=\r\nuctures.\n&gt;\n&gt; There&#39;s more opportunity for innovation in notation with postc=\r\nonditions,\n&gt; too.  How often have *you* wanted to readily express a test re=\r\nlating the\n&gt; value of a variable after a fragment to that before it?  Sure,=\r\n you can\n&gt; do this by introducing new variables in the test fixture, declar=\r\ning them\n&gt; appropriately where that&#39;s needed, but wouldn&#39;t it be nice to ha=\r\nve a\n&gt; simple notation for it, like for a list L, checking that &#39;foo&#39; was\n&gt;=\r\n properly appended (using Python terminology again):\n&gt;\n&gt;     +L =3D=3D -L.a=\r\nppend(&#39;foo&#39;)\n&gt;\n&gt; if the prefix operators &quot;+&quot; and &quot;-&quot; were used to denote &quot;a=\r\nfter&quot; and\n&gt; &quot;before&quot;, respectively.\n&gt;\n&gt; Whether there should also be a spec=\r\nial class of tests for loop or\n&gt; recursion invariants is something that nee=\r\nds further thought.\n&gt;\n&gt; David, does this help?\n&gt;\n&gt; -- Jan\n&gt;\n&gt;\n&gt;\n&gt; Yahoo! Gr=\r\noups Links\n&gt;\n&gt;\n&gt;\n&gt;\n\n\n-- \nC=E9dric\n\n\n[Non-text portions of this message have=\r\n been removed]\n\n\n", 
    "profile": "cbeust", 
    "topicId": 18392, 
    "spamInfo": {
        "reason": "0", 
        "isSpam": false
    }, 
    "replyTo": "LIST", 
    "userId": 199443513, 
    "prevInTime": 18527, 
    "contentTrasformed": false, 
    "postDate": "1165868958", 
    "canDelete": false, 
    "nextInTopic": 0, 
    "prevInTopic": 18527, 
    "headers": {
        "inReplyToHeader": "PDExNjU4NTY5NDIuMTAwMjUuMjc5OTA0MDIzQHdlYm1haWwubWVzc2FnaW5nZW5naW5lLmNvbT4=", 
        "messageIdInHeader": "PGI4NmI2YTljMDYxMjExMTIyOW02NDE3ZjVhOW8zZmZlNTgxNDBiZjhiZTBmQG1haWwuZ21haWwuY29tPg==", 
        "referencesHeader": "PDExNjU4NTY5NDIuMTAwMjUuMjc5OTA0MDIzQHdlYm1haWwubWVzc2FnaW5nZW5naW5lLmNvbT4="
    }
}